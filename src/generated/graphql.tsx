import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Duration: any;
  MosaicData: any;
  Time: any;
};

/** Amazon Digital Ad Service Properties. */
export type AdasProperties = {
  __typename?: 'ADASProperties';
  /**
   * The media partner that should be used for the ad break.
   * @deprecated No longer needed.
   */
  partner?: Maybe<Scalars['String']>;
  /**
   * The id for selecting the amazon ad campaign or program.
   * @deprecated No longer needed.
   */
  programID?: Maybe<Scalars['ID']>;
};

/** AVC profiles for streams. */
export enum AvcProfile {
  /** Low level. */
  Baseline = 'BASELINE',
  /** High level. */
  High = 'HIGH',
  /** Regular level. */
  Main = 'MAIN'
}

export type AcceptFriendRequestInput = {
  /** The authenticated user will accept the friend request sent by the user with an ID equal to targetID. */
  targetID: Scalars['ID'];
};

export type AcceptFriendRequestPayload = {
  __typename?: 'AcceptFriendRequestPayload';
  /** The user whose friend request was just accepted. */
  user?: Maybe<User>;
};

/** Error associated with mutation AcceptOrganizationInvite. */
export type AcceptOrganizationInviteError = {
  __typename?: 'AcceptOrganizationInviteError';
  /** Error code. */
  code: AcceptOrganizationInviteErrorCode;
};

/** Client error code. */
export enum AcceptOrganizationInviteErrorCode {
  /** Organization Member already exists. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** User is exceeds the the limit of organization they can be a member for. */
  ExceedsMembershipLimit = 'EXCEEDS_MEMBERSHIP_LIMIT',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /**
   * The user doesn't meet the requirements to have this role. For example, when trying to assign the
   * "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
   */
  MemberIneligible = 'MEMBER_INELIGIBLE',
  /** Invitation not found. */
  NotFound = 'NOT_FOUND',
  /** The requesting user does not permission to accept invite. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Input to the AcceptOrganiztaionInvite mutation. */
export type AcceptOrganizationInviteInput = {
  /** First name to the user accepting the invite. */
  firstName: Scalars['String'];
  /** Last name of the user accepting the invite. */
  lastName: Scalars['String'];
  /** ID of the invite to accept. */
  organizationInviteID: Scalars['ID'];
  /** Job title the user has in the inviting organization. */
  title: Scalars['String'];
};

/** Output from the AcceptOrganizationInvite mutation. */
export type AcceptOrganizationInvitePayload = {
  __typename?: 'AcceptOrganizationInvitePayload';
  /** The possible error returned from service. */
  error?: Maybe<AcceptOrganizationInviteError>;
};

/** Enumerates possible errors when accepting a program agreement. */
export enum AcceptProgramAgreementError {
  /** User does not have permission to agree to the program agreement for the targeted user. */
  Forbidden = 'FORBIDDEN',
  /** An internal error has occurred. */
  InternalError = 'INTERNAL_ERROR',
  /** Version of the agreement provided in the input is not valid. */
  InvalidAgreementVersion = 'INVALID_AGREEMENT_VERSION',
  /** Must have auth credentials to agree to a program agreement. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** AcceptProgramAgreementInput is the input required when accepting a program agreement. */
export type AcceptProgramAgreementInput = {
  /** TargetUserID is the ID of the user whose program agreement will be accepted. */
  targetUserID: Scalars['ID'];
  /** Agreement type being accepted for payout onboarding. */
  type: PayoutOnboardingCategory;
  /** Version of agreement (e.g. "v1"). */
  version: Scalars['String'];
};

/** AcceptProgramAgreementPayload is the payload returned after accepting a program agreement. */
export type AcceptProgramAgreementPayload = {
  __typename?: 'AcceptProgramAgreementPayload';
  /** Describes error that occured while accepting a program agreement. */
  error?: Maybe<AcceptProgramAgreementError>;
  /** New workflow state. */
  workflow?: Maybe<PayoutOnboardingWorkflow>;
};

/** Errors from acceptSquadStreamInvitation mutation. */
export type AcceptSquadStreamInvitationError = {
  __typename?: 'AcceptSquadStreamInvitationError';
  /** Error from request to accept invitation. */
  code: AcceptSquadStreamInvitationErrorCode;
};

/** Possible errors from this mutation. */
export enum AcceptSquadStreamInvitationErrorCode {
  /** Invitation not in pending state cannot be accepted. */
  InvitationCannotBeAccepted = 'INVITATION_CANNOT_BE_ACCEPTED',
  /** Invitation to be accepted does not exist. */
  InvitationNotFound = 'INVITATION_NOT_FOUND',
  /** Squad associated with the invitation does not exist. */
  SquadNotFound = 'SQUAD_NOT_FOUND',
  /** User does not have permissions to accept invitation. */
  Unauthorized = 'UNAUTHORIZED',
  /** The recipient does not have access to squad streams. */
  UserCannotAccessSquads = 'USER_CANNOT_ACCESS_SQUADS'
}

/** Inputs to the acceptSquadStreamInvitation mutation. */
export type AcceptSquadStreamInvitationInput = {
  /** ID of the invitation to be accepted. */
  invitationID: Scalars['ID'];
};

/** Outputs from the acceptSquadStreamInvitation mutation. */
export type AcceptSquadStreamInvitationPayload = {
  __typename?: 'AcceptSquadStreamInvitationPayload';
  /** Error from mutation if exists. */
  error?: Maybe<AcceptSquadStreamInvitationError>;
  /** The accepted invitation. */
  invitation?: Maybe<SquadStreamInvitation>;
};

/** The information about all of a user's connected accounts. */
export type AccountConnectionSet = {
  __typename?: 'AccountConnectionSet';
  /** Connection information about a user's Blizzard account. */
  blizzard?: Maybe<UserBlizzardConnectionLink>;
  /** Connection infromation about a user's Facebook account. */
  facebook?: Maybe<UserFacebookConnectionLink>;
  /** Whether or not the user has a linked amazon account. */
  hasConnectedAmazon?: Maybe<Scalars['Boolean']>;
  /** Connection information about a user's Riot account. */
  riot?: Maybe<UserRiotConnectionLink>;
  /** Connection information about a user's Steam account. */
  steam?: Maybe<UserSteamConnectionLink>;
  /** Connection information about a user's Twitter account. */
  twitter?: Maybe<UserTwitterConnectionLink>;
  /** Connection information about a user's Youtube account. */
  youtube?: Maybe<UserYoutubeConnectionLink>;
};

/** An error returned from the acknowledgePredictionResult mutation. */
export type AcknowledgePredictionResultError = {
  __typename?: 'AcknowledgePredictionResultError';
  /** Code describing the error. */
  code: AcknowledgePredictionResultErrorCode;
};

/** Possible error codes from the acknowledgePredictionResult mutation. */
export enum AcknowledgePredictionResultErrorCode {
  /** The authorized user is forbidden from acknowledging this Prediction result. */
  Forbidden = 'FORBIDDEN',
  /** The specified Prediction ID was not found. */
  NotFound = 'NOT_FOUND',
  /** The specified Prediction ID has not been resolved yet. */
  NotResolved = 'NOT_RESOLVED',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Acknowledge the results of a Prediction. */
export type AcknowledgePredictionResultInput = {
  /** The Prediction ID. */
  id: Scalars['ID'];
};

/** Payload for acknowledging the results of a Prediction. */
export type AcknowledgePredictionResultPayload = {
  __typename?: 'AcknowledgePredictionResultPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<AcknowledgePredictionResultError>;
  /** The acknowledgged Prediction. */
  prediction?: Maybe<Prediction>;
};

/** AcknowledgeSubscriptionStateInput updates the state of the given subscription to aknowledged. */
export type AcknowledgeSubscriptionStateInput = {
  /** ID of the subscription being updated. */
  subscriptionID: Scalars['ID'];
};

/** AcknowledgeSubscriptionStatePayload returns the state of the subscription. */
export type AcknowledgeSubscriptionStatePayload = {
  __typename?: 'AcknowledgeSubscriptionStatePayload';
  /** The current state of the subscription. One of "active", "will_not_renew", or "canceled". */
  state?: Maybe<UnacknowledgedSubscriptionEventState>;
};

/** Required input to acknowledge an unban request on a channel. */
export type AcknowledgeUnbanRequestInput = {
  /** ID of the unban request to be acknowledged. */
  id: Scalars['ID'];
};

/** Result of acknowledging an unban request. */
export type AcknowledgeUnbanRequestPayload = {
  __typename?: 'AcknowledgeUnbanRequestPayload';
  /** Used for errors arising from acknowledging the unban request. */
  error?: Maybe<UnbanRequestError>;
  /** The acknowledged unban request. */
  unbanRequest?: Maybe<UnbanRequest>;
};

/** The input to be provided to the activateExtension mutation. */
export type ActivateExtensionInput = {
  /** The anchor the extension is getting activated into. */
  anchor: ExtensionAnchor;
  /** The composite ID of an extension installation <extensionID:version:channelID>. */
  extensionInstallationID: Scalars['ID'];
  /** The slot the extension is getting activated into. */
  slot: Scalars['String'];
};

/** The result of an activateExtension mutation. */
export type ActivateExtensionPayload = {
  __typename?: 'ActivateExtensionPayload';
  /** The resulting list of installed extensions after the activation. */
  installedExtensions: Array<ExtensionInstallation>;
};

/** ActivationState contains possible activation states found in the ActivationConfig. */
export enum ActivationState {
  /** The extension is activated into a slot on the channel. */
  Active = 'ACTIVE',
  /**
   * The extension has not been activated into a slot or required permsissions/config
   * is not set up yet.
   */
  Inactive = 'INACTIVE',
  /** The user rejected the permissions required for the extension to be activated. */
  RejectedPermissions = 'REJECTED_PERMISSIONS'
}

/** An action (and metadata about the action) which a user or session is performing. */
export type Activity = {
  /** The type of activity. */
  type?: Maybe<ActivityType>;
};

/**
 * ActivityInput represents what the user is doing right now.
 *
 * If type is WATCHING, userID must be supplied.
 *
 * If type is PLAYING, gameID must be supplied.
 */
export type ActivityInput = {
  gameID?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<ActivityType>;
  userID?: InputMaybe<Scalars['String']>;
};

/** The categories of activities which users can engage in. */
export enum ActivityType {
  Playing = 'PLAYING',
  Streaming = 'STREAMING',
  Watching = 'WATCHING'
}

/** The context returned for the current ad request. */
export type AdContext = {
  __typename?: 'AdContext';
  /** The decline status for this ad request. */
  declineState: AdContextDeclineState;
  /** The id of the ad session this context applies to. */
  id: Scalars['ID'];
  /** The RAd service token used to validate subsequent ad event mutations. */
  radToken: Scalars['String'];
};

/** The decline state for the context. */
export type AdContextDeclineState = {
  __typename?: 'AdContextDeclineState';
  /** The reason the ad request was declined if it was declined. */
  reason?: Maybe<Scalars['String']>;
  /** Whether or not the client will request an ad. */
  shouldDecline: Scalars['Boolean'];
};

/** Advertising creative. */
export type AdCreative = {
  __typename?: 'AdCreative';
  /** The AdCreative's unique identifier. */
  id: Scalars['ID'];
  /** Integrated loudness value for this AdCreative. */
  integratedLoudness?: Maybe<Scalars['Float']>;
};

/** AdPlatform describes the type of device. */
export enum AdPlatform {
  /** Android phone app. */
  AndroidPhone = 'ANDROID_PHONE',
  /** Android tablet app. */
  AndroidTablet = 'ANDROID_TABLET',
  /** Ios iphone app. */
  IosPhone = 'IOS_PHONE',
  /** Ios tablet app. */
  IosTablet = 'IOS_TABLET'
}

/** A vote an ad poll and associated information. */
export type AdPollVote = {
  __typename?: 'AdPollVote';
  /** Id of the choice that was voted for. */
  choiceID: Scalars['ID'];
  /** id of the vote in the poll. */
  id: Scalars['ID'];
  /** Id of the poll this voter voted in. */
  pollID: Scalars['ID'];
  /** Id of the voter in the poll. */
  userID: Scalars['ID'];
};

/** Ad Properties is an object that defines ad properties for a channel. */
export type AdProperties = {
  __typename?: 'AdProperties';
  /**
   * Deprecated.
   * @deprecated Should use adServerDefault instead
   */
  adServer?: Maybe<Scalars['String']>;
  /** Which adserver to send requests to. */
  adServerDefault?: Maybe<Scalars['String']>;
  /** Amazon Digital Ad Service (ADAS) specific Properties for this channel. Properties should only be nested if it is ADAS specific. */
  adasProperties?: Maybe<AdasProperties>;
  /** Which ids are costreamers for this channel. */
  costreamers?: Maybe<Array<Maybe<User>>>;
  /** Contains ad density information for channel ads management. */
  density?: Maybe<Density>;
  /** Contains properties used by channel's disable prerolls feature. */
  disablePrerollsAbility?: Maybe<DisablePrerollsAbility>;
  /** Get the ad experiment treatment group for a specified experiment bucket. */
  experimentTreatment?: Maybe<Scalars['String']>;
  /** How often ad breaks can be run on this channel. */
  frequency?: Maybe<Scalars['Int']>;
  /** If postrolls are disabled on this channel. */
  hasPostrollsDisabled?: Maybe<Scalars['Boolean']>;
  /** If prerolls are disabled on this channel. */
  hasPrerollsDisabled?: Maybe<Scalars['Boolean']>;
  /** If Turbo benefit is disabled on this channel. */
  hasTurboDisabled?: Maybe<Scalars['Boolean']>;
  /** If vod ads are enabled on this channel. */
  hasVodAdsEnabled?: Maybe<Scalars['Boolean']>;
  /** If multiplayer ads are enabled for subscribers on this channel. */
  isMultiplayerAdsForSubsEnabled?: Maybe<Scalars['Boolean']>;
  /** A bool that represents a streamer's eligibility to run a picture by picture ad. */
  isPictureByPictureAdEligible?: Maybe<Scalars['Boolean']>;
  /** Maximum length for an ad break on this channel. */
  maxAdBreakLength?: Maybe<Scalars['Int']>;
  /** Current multiplayer ad offers on the channel. */
  multiplayerAdOffers?: Maybe<Array<MultiplayerAdOffer>>;
  /** The stream has the required age gate enabled if greater than 0. */
  requiredAge?: Maybe<Scalars['Int']>;
  /** Tracking pixels that channel pages should fire at certain intervals. */
  trackingPixels?: Maybe<Array<TrackingPixel>>;
  /** Setting for vod archive midrolls on this channel. Can be 'broadcaster', 'inserted', or 'off'. */
  vodArchiveMidrolls?: Maybe<Scalars['String']>;
  /** Ad break length for VOD archive midrolls on this channel. */
  vodArchiveMidrollsBreakLength?: Maybe<Scalars['Int']>;
  /** Frequency for VOD archive midrolls on this channel. */
  vodArchiveMidrollsFrequency?: Maybe<Scalars['Int']>;
};


/** Ad Properties is an object that defines ad properties for a channel. */
export type AdPropertiesExperimentTreatmentArgs = {
  bucket: Scalars['String'];
};


/** Ad Properties is an object that defines ad properties for a channel. */
export type AdPropertiesTrackingPixelsArgs = {
  consent?: InputMaybe<GdprConsent>;
};

/** The context of the Client when the ad request is about to be made. */
export type AdRequestClientContext = {
  /** Version of the app. */
  appVersion?: InputMaybe<Scalars['String']>;
  /** App that the client is using. */
  clientApp?: InputMaybe<Scalars['String']>;
  /** If the client is in audio only mode. */
  isAudioOnly: Scalars['Boolean'];
  /** If the client is in mini theater mode. */
  isMiniTheater: Scalars['Boolean'];
  /** If the client is in Picture in Picture mode. */
  isPIP: Scalars['Boolean'];
  /** If the client is broadcasting to an external device (i.e. Chromecast, Airplay). */
  isUsingExternalPlayback: Scalars['Boolean'];
};

/** The type of content playing when the ad was requested. */
export enum AdRequestContentType {
  /** Live streams. */
  Live = 'LIVE',
  /** VOD playback. */
  Vod = 'VOD'
}

/** The context of an upcoming ad request. */
export type AdRequestContext = {
  /** Format of the Ad being requested. */
  adFormat?: InputMaybe<Scalars['String']>;
  /** The ID generated for the ad Session. */
  adSessionID: Scalars['ID'];
  /** The context of the client at the time the ad is requested. */
  clientContext: AdRequestClientContext;
  /** The commercial break ID of a channel wide midroll. */
  commercialID?: InputMaybe<Scalars['ID']>;
  /** The duration of the ad break in seconds. */
  duration: Scalars['Int'];
  /** The game played on the channel. */
  game?: InputMaybe<Scalars['String']>;
  /** If the requested ad is a viewer level midroll. */
  isVLM?: InputMaybe<Scalars['Boolean']>;
  /** The context of the player at the time the ad is requested. */
  playerContext: AdRequestPlayerContext;
  /** The type of ad request being made. */
  rollType: AdrollType;
  /** The twitch correlator. */
  twitchCorrelator?: InputMaybe<Scalars['String']>;
};

/** The context of the Player when the ad request is about to be made. */
export type AdRequestPlayerContext = {
  /** The type of content being watched. */
  contentType: AdRequestContentType;
  /** If the session was initiated by playing automatically. */
  isAutoPlay: Scalars['Boolean'];
  /** The signature for the access token for the current video session. */
  nauthSig: Scalars['String'];
  /** The access token for the current video session. */
  nauthToken: Scalars['String'];
  /** PlayerSizeMode of the incoming request. */
  playerSizeMode?: InputMaybe<Scalars['String']>;
  /** The ID for the current video session. */
  videoSessionID?: InputMaybe<Scalars['ID']>;
};

/** AdSession is the response object from an Ad Request. */
export type AdSession = {
  __typename?: 'AdSession';
  /** id is the id of the ad. */
  id: Scalars['ID'];
  /** lengthSeconds is the length of the ad being requested in seconds. */
  lengthSeconds: Scalars['Int'];
  /** retryAfterSeconds is the amount of time in seconds remaining for a user to run another ad. */
  retryAfterSeconds: Scalars['Int'];
};

/** Defines ads management attributes for channel. */
export type AdSlot = {
  __typename?: 'AdSlot';
  /** Duration of Ads that will run. */
  durationSeconds: Scalars['Int'];
  /** Time when Ad will run. */
  runAtTime: Scalars['Time'];
};

/** AddAutohostChannelsInput append channelIDs to a user's list to autohost. */
export type AddAutohostChannelsInput = {
  /** ChannelIDs that will be added to the list to autohost. */
  channelIDs: Array<Scalars['ID']>;
  /** UserID to update autohost list for. */
  userID: Scalars['ID'];
};

/** AddAutohostChannelsPayload returns the user whose autohostChannels field had been updated. */
export type AddAutohostChannelsPayload = {
  __typename?: 'AddAutohostChannelsPayload';
  /** User whose autohostChannels field had been updated. */
  user?: Maybe<User>;
};

export type AddBrowserPushSubscriptionInput = {
  /** An authentication secret. It must be a non-blank string. */
  auth: Scalars['String'];
  /**
   * A custom URL pointing to a push server, which can be used to send a push message to the
   * particular service worker instance that subscribed to the push service. It must be a
   * non-blank string.
   */
  endpoint: Scalars['String'];
  /** An Elliptic curve Diffie–Hellman public key on the P-256 curve. It must be a non-blank string. */
  p256DH: Scalars['String'];
};

export type AddBrowserPushSubscriptionPayload = {
  __typename?: 'AddBrowserPushSubscriptionPayload';
  /**
   * The opaque ID of the push subscription. The entire push subscription is not returned because
   * there is no product use for it. Also, there is no existing query or mutation that can use this ID,
   * but it could be used for future functionality.
   */
  browserPushSubscriptionID?: Maybe<Scalars['ID']>;
};

/** Possible errors that this resolver returns. */
export enum AddChannelBlockedTermError {
  /** Duration provided was invalid. */
  DurationInvalid = 'DURATION_INVALID',
  /** User does not have permission to add blocked term in channel. */
  NoPermissions = 'NO_PERMISSIONS'
}

/** AddChannelBlockedTermInput takes in the channel, phrases, and if the term should be editable by mods. */
export type AddChannelBlockedTermInput = {
  /** channelID is the channelID owner of terms. */
  channelID: Scalars['ID'];
  /** isModEditable is if the term is viewable or editable by mods. */
  isModEditable: Scalars['Boolean'];
  /** phrase defines the string that is to be blocked. */
  phrase?: InputMaybe<Scalars['String']>;
  /** phrases is the strings that are blocked. */
  phrases: Array<Scalars['String']>;
};

/** The returned data from the mutation. */
export type AddChannelBlockedTermPayload = {
  __typename?: 'AddChannelBlockedTermPayload';
  /** The time term was added. */
  addedAt?: Maybe<Scalars['Time']>;
  /** Mutation error caused by the user input. */
  error?: Maybe<AddChannelBlockedTermError>;
  /** The phrases that were added. */
  phrases: Array<Scalars['String']>;
};

/** Possible errors that this resolver returns. */
export enum AddChannelPermittedTermError {
  /** Duration provided was invalid. */
  DurationInvalid = 'DURATION_INVALID',
  /** User does not have permission to add Permitted term in channel. */
  NoPermissions = 'NO_PERMISSIONS'
}

/** AddChannelPermittedTermInput takes in the channel, phrases, and if the term should be editable by mods. */
export type AddChannelPermittedTermInput = {
  /** channelID is the owner of the permitted terms. */
  channelID: Scalars['ID'];
  /** phrase defines the string that is to be permitted. */
  phrase?: InputMaybe<Scalars['String']>;
  /** phrases are the strings that are permitted in a channel. */
  phrases: Array<Scalars['String']>;
};

/** The returned payload from the mutation. */
export type AddChannelPermittedTermPayload = {
  __typename?: 'AddChannelPermittedTermPayload';
  /** The time term was added. */
  addedAt?: Maybe<Scalars['Time']>;
  /** Mutation error caused by the user input. */
  error?: Maybe<AddChannelPermittedTermError>;
  /** The phrases that were added. */
  phrases: Array<Scalars['String']>;
};

/** AddCollectionItemInput accepts a collectionID and item ID and parameters to add the item to a collection. */
export type AddCollectionItemInput = {
  /** The id of the collection. */
  collectionID: Scalars['ID'];
  /** The id of the item of which will be added to the collection. */
  itemID: Scalars['ID'];
  /** The type of item ie. video. */
  itemType: Scalars['String'];
};

/** The response from adding an item to a collection. */
export type AddCollectionItemPayload = {
  __typename?: 'AddCollectionItemPayload';
  /** The newly updated collection. */
  collection?: Maybe<Collection>;
};

/** Add a Phase to a Competition. */
export type AddCompetitionPhaseInput = {
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
};

/** Data that was mutated after the Phase was created. */
export type AddCompetitionPhasePayload = {
  __typename?: 'AddCompetitionPhasePayload';
  /** The competition is returned with any side effects adding a phase has caused. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Add a User as a player to a Competition. */
export type AddCompetitionPlayerInput = {
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
  /** The player's Discord username. */
  discordUsername?: InputMaybe<Scalars['String']>;
  /** The player's in-game username. */
  inGameUsername?: InputMaybe<Scalars['String']>;
  /** The state the player in. Defaults to INVITED if not specified. */
  state?: InputMaybe<CompetitionPlayerState>;
  /** Twitch user id of the player. */
  userID: Scalars['ID'];
};

/** Data that was mutated after the player was created. */
export type AddCompetitionPlayerPayload = {
  __typename?: 'AddCompetitionPlayerPayload';
  /** The new state of competition after adding a competition player to the competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Inputs adding a competition team to a competition. */
export type AddCompetitionTeamInput = {
  /** ID of the competition team captain. */
  captainID?: InputMaybe<Scalars['ID']>;
  /** ID of the competition. */
  competitionID: Scalars['ID'];
  /** The user ids of the team members. */
  members?: InputMaybe<Array<Scalars['ID']>>;
  /** The name of the team. */
  name: Scalars['String'];
};

/** AddCompetitionTeamPayload is the success response adding a competition team to the competition. */
export type AddCompetitionTeamPayload = {
  __typename?: 'AddCompetitionTeamPayload';
  /** The new state of competition after adding a competition team to the competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** AddDeviceTokenInput accepts a token and other parameters to add a device token to a given user. */
export type AddDeviceTokenInput = {
  /** App build number of the current device. */
  appBuild?: InputMaybe<Scalars['String']>;
  /**
   * Unique identifier of the current device.
   * Note: deprecated field -- the deviceID now comess of the X-Device-Id header...
   */
  deviceID?: InputMaybe<Scalars['ID']>;
  /** Arbitrary name associated with the device. */
  deviceName?: InputMaybe<Scalars['String']>;
  /** The ID of the new token. */
  deviceToken: Scalars['ID'];
  /** Notification capabilities of the current device. */
  notificationCapabilitiesTypes?: InputMaybe<Array<Scalars['String']>>;
  /** Onsite notification capabilities of the current device. */
  onsiteCapabilitiesTypes?: InputMaybe<Array<Scalars['String']>>;
  /** The platform the token is associated with, i.e. 'android' or 'ios'. */
  platform: Scalars['String'];
  /**
   * ID for the user associated with the new device token.
   * Note: deprecated field -- the userID now comes off the authenticated user.
   */
  userID?: InputMaybe<Scalars['ID']>;
};

/** The response from adding a push notification token to a user. */
export type AddDeviceTokenPayload = {
  __typename?: 'AddDeviceTokenPayload';
  /** The ID of the new token. */
  deviceToken: Scalars['ID'];
};

/** AddDropToCampaignInput has fields required to create a drop within a campaign. */
export type AddDropToCampaignInput = {
  /** The campaign this drop belongs to. */
  campaignID: Scalars['ID'];
  /** The type of rule defining what needs to happen to trigger this drop. */
  dropRuleType: DropRuleType;
  /** The date at which this drop can no longer occur. Default to campaign endDate if not provided. */
  endAt?: InputMaybe<Scalars['Time']>;
  /** The friendly name of this drop. */
  name: Scalars['String'];
  /** The date at which this drop can start to occur. Default to campaign startDate if not provided. */
  startAt?: InputMaybe<Scalars['Time']>;
};

/** AddDropToCampaignPayload returns the result of the creation. */
export type AddDropToCampaignPayload = {
  __typename?: 'AddDropToCampaignPayload';
  /** Returns the newly created drop. */
  drop?: Maybe<DropType>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** AddEditorError contains details about a client error that occurred. */
export type AddEditorError = {
  __typename?: 'AddEditorError';
  /** The type of error that occurred when adding an editor. */
  code: AddEditorErrorCode;
};

/** AddEditorErrorCode defines a client error that occurred while adding an editor. */
export enum AddEditorErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The user who is to become an editor is already an editor. */
  TargetUserAlreadyEditor = 'TARGET_USER_ALREADY_EDITOR',
  /** The user who is to become an editor does not exist. */
  TargetUserNotFound = 'TARGET_USER_NOT_FOUND'
}

/** AddEditorInput contains the parameters to add an editor. */
export type AddEditorInput = {
  /** The channel for which the target user will become an editor. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user who will become an editor.
   * Either targetUserID or targetUserLogin must be provided.
   */
  targetUserID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user who will become an editor.
   * Either targetUserID or targetUserLogin must be provided.
   */
  targetUserLogin?: InputMaybe<Scalars['String']>;
};

/** AddEditorPayload is the response after attemping to add an editor. */
export type AddEditorPayload = {
  __typename?: 'AddEditorPayload';
  /** The channel for which the target user will become an editor. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<AddEditorError>;
  /** The user who became an editor. */
  targetUser?: Maybe<User>;
};

/** Error from a failed recent play mutation. */
export type AddRadioRecentlyPlayedError = {
  __typename?: 'AddRadioRecentlyPlayedError';
  /** Mutation error code. */
  code: AddRadioRecentlyPlayedErrorCode;
};

/** Recently played error codes. */
export enum AddRadioRecentlyPlayedErrorCode {
  /** The ID provided was malformed. */
  InvalidId = 'INVALID_ID',
  /** Permission denied to add/update a recently played item. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** AddRadioRecentlyPlayedInput contains the parameters to register a play start. */
export type AddRadioRecentlyPlayedInput = {
  /** The type of content the ID maps to. */
  contentType: RadioRecentlyPlayedType;
  /** The ID of the recently played item. */
  id: Scalars['ID'];
};

/** Response from registering a recent play. */
export type AddRadioRecentlyPlayedPayload = {
  __typename?: 'AddRadioRecentlyPlayedPayload';
  /** Error code. */
  error?: Maybe<AddRadioRecentlyPlayedError>;
  /** The added/updated recently played item. */
  recent?: Maybe<RadioRecentlyPlayed>;
};

export type AddReactionInput = {
  emoteID: Scalars['ID'];
  entityID: Scalars['ID'];
};

export type AddReactionPayload = {
  __typename?: 'AddReactionPayload';
  content: ReactableContent;
};

/** Data required to add recommendation feedback. */
export type AddRecommendationFeedbackInput = {
  /** Reason for the feedback (ie. Not interested, offensive, etc). */
  category: RecommendationFeedbackCategory;
  /** The id of the item (channelID, gameID, etc). */
  itemID: Scalars['ID'];
  /** One of CHANNEL, GAME, SHELF, VOD. */
  itemType: RecommendationFeedbackType;
  /** The page this event was fired from. */
  sourceItemPage: Scalars['String'];
  /** The unique id given to this request. */
  sourceItemRequestID: Scalars['ID'];
  /** The tracking id of the shelf / shelf card. */
  sourceItemTrackingID: Scalars['ID'];
};

/** Returns the created feedback item back to the client. */
export type AddRecommendationFeedbackPayload = {
  __typename?: 'AddRecommendationFeedbackPayload';
  /** Feedback item. */
  recommendationFeedback?: Maybe<RecommendationFeedback>;
};

/** Error that may be returned by the AddStreamAuthorizedUser mutation. */
export type AddStreamAuthorizedUserError = {
  __typename?: 'AddStreamAuthorizedUserError';
  /** Type of mutation error. */
  code: AddStreamAuthorizedUserErrorCode;
};

/** AddStreamAuthorizedUserErrorCode is the client error type that occurred during the AddStreamAuthorizedUser mutation. */
export enum AddStreamAuthorizedUserErrorCode {
  /** The broadcaster is not found. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** Invalid argument to add an authorized user. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Maximum limit for adding authorized user is reached. */
  MaxAccountLimit = 'MAX_ACCOUNT_LIMIT',
  /** Permission denied to add an authorized user. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unable to assign the Targeted user to stream on behalf of the broadcaster. */
  TargetUserUnreturnable = 'TARGET_USER_UNRETURNABLE'
}

/** AddStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID. */
export type AddStreamAuthorizedUserInput = {
  /** authorizedUserID for an authorized user who is allow to stream on behalf of broadcaster. */
  authorizedUserID: Scalars['ID'];
  /** channelID of the broadcaster. */
  channelID: Scalars['ID'];
};

/** AddStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users. */
export type AddStreamAuthorizedUserPayload = {
  __typename?: 'AddStreamAuthorizedUserPayload';
  /** The updated channel of broadcaster. */
  channel?: Maybe<Channel>;
  /** Error code. */
  error?: Maybe<AddStreamAuthorizedUserError>;
};

/** The type of ad break being requested. */
export enum AdrollType {
  /** Ad that runs in the middle of a stream/vod. */
  Midroll = 'MIDROLL',
  /** Ad that runs after a stream/vod. */
  Postroll = 'POSTROLL',
  /** Ad that runs prior to seeing a stream/vod. */
  Preroll = 'PREROLL'
}

/** Status of a user's invitation to the Affiliate program. */
export enum AffiliateInvitationStatus {
  /** Invitation cannot be sent, pending a user action. */
  IncompleteWorkflow = 'INCOMPLETE_WORKFLOW',
  /** Invitation is scheduled to be sent. */
  PendingInvite = 'PENDING_INVITE',
  /** Invitation has been sent. */
  Sent = 'SENT'
}

/** Grouping of referral sources with name and count -- e.g. ("UK", 1437). */
export type AggregatedReferrals = {
  __typename?: 'AggregatedReferrals';
  /** Count of the referrals from the named source (1437). */
  count: Scalars['Int'];
  /** Name of the referral source ("UK"). */
  name: Scalars['String'];
};

/** Error from the mutation. */
export type AllocateKeysForBountyError = {
  __typename?: 'AllocateKeysForBountyError';
  /** Error code from the mutation. */
  code: AllocateKeysForBountyErrorCode;
};

/** Possible errors from the mutation. */
export enum AllocateKeysForBountyErrorCode {
  /** The provided input is invalid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The bounty or required key metadata was not found. */
  NotFound = 'NOT_FOUND',
  /** Unknown error being returned from service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Input required to allocate keys for the bounty. */
export type AllocateKeysForBountyInput = {
  /** Unique Identifier for the bounty. */
  bountyID: Scalars['ID'];
  /** UserID that is allocating keys for the bounty. */
  userID: Scalars['ID'];
};

/** Payload from the mutation. */
export type AllocateKeysForBountyPayload = {
  __typename?: 'AllocateKeysForBountyPayload';
  /** The bounty with allocated keys. */
  bounty?: Maybe<Bounty>;
  /** The possible error returned from the service. */
  error?: Maybe<AllocateKeysForBountyError>;
};

export type AllowRejectedChatMessageInput = {
  id: Scalars['ID'];
};

export type AllowRejectedChatMessagePayload = {
  __typename?: 'AllowRejectedChatMessagePayload';
  message?: Maybe<RejectedChatMessage>;
};

/** Input to the allowRejectedCheer mutation. */
export type AllowRejectedCheerInput = {
  /**
   * Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
   * The server will reject any request with an ID that has already been used.
   */
  id: Scalars['ID'];
  /** ID of the user whose message is automodded. */
  targetUserID: Scalars['ID'];
};

/** Payload from the allowRejectedCheer mutation. */
export type AllowRejectedCheerPayload = {
  __typename?: 'AllowRejectedCheerPayload';
  /**
   * Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
   * The server will reject any request with an ID that has already been used.
   */
  id: Scalars['ID'];
};

/** Units defines how many price units is equivalent to 1 unit of currency. */
export enum AndroidCurrencyUnits {
  /** Micro units (1,000,000 micro-units = 1 unit of currency). */
  MicroUnits = 'MICRO_UNITS',
  /** Default units is ISO-4217 format (e.g. 100 JPY units is 100 JPY, 100 USD units is 1.00 USD). */
  NormalUnits = 'NORMAL_UNITS'
}

/** AndroidPaymentTrackingDataInput contains fields to pass in tracking data. */
export type AndroidPaymentTrackingDataInput = {
  /** The user's device ID. */
  deviceID?: InputMaybe<Scalars['ID']>;
  /** The locale of the user. */
  locale?: InputMaybe<Scalars['String']>;
};

/** AndroidReceiptDataInput contains the necessary fields to pass in Android purchase receipt data. */
export type AndroidReceiptDataInput = {
  /** The currency the user was charged in. */
  currency: Scalars['String'];
  /** The amount user was charged. */
  price: Scalars['String'];
  /** The raw receipt of the purchase. */
  rawReceipt: Scalars['String'];
  /** The receipt signature for the purchase. */
  signedReceipt: Scalars['String'];
  /** The unit the user was charged in. */
  units: AndroidCurrencyUnits;
};

/** The available animated emote generation presets. */
export enum AnimatedEmotePreset {
  /** Rave makes the source image change colors. */
  Rave = 'RAVE',
  /** Roll makes the source image roll across. */
  Roll = 'ROLL',
  /** Shake makes the source image shake. */
  Shake = 'SHAKE',
  /** Slide in makes the source image slide in from the left. */
  SlideIn = 'SLIDE_IN',
  /** Slide out makes the source image slide out to the right. */
  SlideOut = 'SLIDE_OUT',
  /** Spin makes the source image spin around in place. */
  Spin = 'SPIN'
}

/** An animated image asset. */
export type AnimatedImageAsset = {
  __typename?: 'AnimatedImageAsset';
  /** Image ID generated by Mako for image. */
  id: Scalars['ID'];
  /** Size of the image. */
  size: EmoteImageSize;
};

/** A mapping of extension type to list of activation configs. */
export type ApplyExtensionActivationsInput = {
  /** A list of activations to apply to the given channelID. */
  activations: Array<ExtensionActivationInput>;
  /** The ID of the channel the activations are being performed on. */
  channelID: Scalars['ID'];
};

/** A list of all installed extensions on the channel after an applyExtensionActivations mutation. */
export type ApplyExtensionActivationsPayload = {
  __typename?: 'ApplyExtensionActivationsPayload';
  /**
   * The list of all installed extensions on the channel after an applyExtensionActivations mutation
   * with their new activation state.
   */
  installedExtensions: Array<ExtensionInstallation>;
};

/** Required input to approve an unban request on a channel. */
export type ApproveUnbanRequestInput = {
  /** ID of the unban request to be resolved. */
  id: Scalars['ID'];
  /** Optional message from the resolver to be shown to the unban requester. */
  resolverMessage?: InputMaybe<Scalars['String']>;
};

/** Result of approving an unban request. */
export type ApproveUnbanRequestPayload = {
  __typename?: 'ApproveUnbanRequestPayload';
  /** Used for errors arising from resolving unban request. */
  error?: Maybe<UnbanRequestError>;
  /** The resolved unban request. */
  unbanRequest?: Maybe<UnbanRequest>;
};

/** ArchiveChanletInput archives a chanlet by chanlet ID. */
export type ArchiveChanletInput = {
  /** The ID of the chanlet being archived. */
  chanletID: Scalars['ID'];
};

/** ArchiveChanletPayload returns the Chanlet that was archived. */
export type ArchiveChanletPayload = {
  __typename?: 'ArchiveChanletPayload';
  /** The chanlet archived. */
  chanlet: Channel;
};

/** Archive community goal error. */
export type ArchiveCommunityPointsCommunityGoalError = {
  __typename?: 'ArchiveCommunityPointsCommunityGoalError';
  /** The error code. */
  code: ArchiveCommunityPointsCommunityGoalErrorCode;
};

/** Archive community goal error code. */
export enum ArchiveCommunityPointsCommunityGoalErrorCode {
  /** The current user is not allowed to archive community goals for this channel. */
  Forbidden = 'FORBIDDEN',
  /** The goal was not found. */
  NotFound = 'NOT_FOUND',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Archive community goal input. */
export type ArchiveCommunityPointsCommunityGoalInput = {
  /** The channel. */
  channelID: Scalars['ID'];
  /** The community goal. */
  goalID: Scalars['ID'];
};

/** Archive community goal payload. */
export type ArchiveCommunityPointsCommunityGoalPayload = {
  __typename?: 'ArchiveCommunityPointsCommunityGoalPayload';
  /** The error, if any. */
  error?: Maybe<ArchiveCommunityPointsCommunityGoalError>;
  /** The community goal that was archived. */
  goal?: Maybe<CommunityPointsCommunityGoal>;
};

/** Inputs for archiving a poll. */
export type ArchivePollInChannelInput = {
  /** The id of the channel that contains the poll to archive. */
  channelID: Scalars['ID'];
};

/** Outputs from the archive poll mutation. */
export type ArchivePollInChannelPayload = {
  __typename?: 'ArchivePollInChannelPayload';
  /** The archived poll. */
  poll?: Maybe<Poll>;
};

/** Inputs for archiving a poll. */
export type ArchivePollInput = {
  /** The id of the poll to archive. */
  pollID: Scalars['ID'];
};

/** Outputs from the create poll mutation. */
export type ArchivePollPayload = {
  __typename?: 'ArchivePollPayload';
  /** The created poll. */
  poll?: Maybe<Poll>;
};

/** Possible errors from the mutation. */
export enum ArkoseEndpointVersion {
  /** Version 1 endpoint. */
  V1 = 'V1',
  /** Version 2 endpoint. */
  V2 = 'V2'
}

/** Error returned after attempting to assign an emote to a bits tier. */
export type AssignEmoteToBitsTierError = {
  __typename?: 'AssignEmoteToBitsTierError';
  /** The error code associated with this error. */
  code: AssignEmoteToBitsTierErrorCode;
};

/** Possible error codes for AssignEmoteToBitsTierError. */
export enum AssignEmoteToBitsTierErrorCode {
  /** Emotes are not allowed in the specified bits tier. */
  EmotesNotAllowedInTier = 'EMOTES_NOT_ALLOWED_IN_TIER',
  /** An active or pending emote is already using this emote's code. */
  EmoteCodeAlreadyExists = 'EMOTE_CODE_ALREADY_EXISTS',
  /** The bits tier has no available empty emote slots. */
  EmoteLimitReached = 'EMOTE_LIMIT_REACHED',
  /** The specified emote does not exist. */
  EmoteNotFound = 'EMOTE_NOT_FOUND',
  /** The emote is not in a valid state to be assigned. */
  InvalidEmoteState = 'INVALID_EMOTE_STATE',
  /** The user is not allowed to assign this emote. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** The input for assign emote to bits tier. */
export type AssignEmoteToBitsTierInput = {
  /** ID of the channel that owns the bits tier. */
  channelID: Scalars['ID'];
  /** ID of the emote to be assigned. */
  emoteID: Scalars['ID'];
  /** Threshold of the bits tier to assign the emote to. */
  tierThreshold: Scalars['Int'];
};

/** Result of assign emote to bits tier. */
export type AssignEmoteToBitsTierPayload = {
  __typename?: 'AssignEmoteToBitsTierPayload';
  /** The updated emote if successful. */
  emote?: Maybe<Emote>;
  /** Error returned after attempting to assign an emote to a bits tier. */
  error?: Maybe<AssignEmoteToBitsTierError>;
};

/** Error returned after attempting to assign an emote to a subscription product. */
export type AssignEmoteToSubscriptionProductError = {
  __typename?: 'AssignEmoteToSubscriptionProductError';
  /** The error code associated with this error. */
  code: AssignEmoteToSubscriptionProductErrorCode;
};

/** Possible error codes for AssignEmoteToSubscriptionProductError. */
export enum AssignEmoteToSubscriptionProductErrorCode {
  /** An active or pending emote is already using this emote's code. */
  EmoteCodeAlreadyExists = 'EMOTE_CODE_ALREADY_EXISTS',
  /** The product has no available empty emote slots. */
  EmoteLimitReached = 'EMOTE_LIMIT_REACHED',
  /** The specified emote does not exist. */
  EmoteNotFound = 'EMOTE_NOT_FOUND',
  /** The emote is not in a valid state to be assigned. */
  InvalidEmoteState = 'INVALID_EMOTE_STATE',
  /** The user is not allowed to assign this emote. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** The input for assign emote to subscription product. */
export type AssignEmoteToSubscriptionProductInput = {
  /** ID of the emote to be assigned. */
  emoteID: Scalars['ID'];
  /** ID of the subscription product to assign the emote to. */
  productID: Scalars['ID'];
};

/** Result of assign emote to subscription product. */
export type AssignEmoteToSubscriptionProductPayload = {
  __typename?: 'AssignEmoteToSubscriptionProductPayload';
  /** The updated emote if successful. */
  emote?: Maybe<Emote>;
  /** Error returned after attempting to assign an emote to a subscription product. */
  error?: Maybe<AssignEmoteToSubscriptionProductError>;
};

/** AssignExtensionBillingManagerError is the error associated with AssignExtensionBillingManager. */
export type AssignExtensionBillingManagerError = {
  __typename?: 'AssignExtensionBillingManagerError';
  /** The associated error code. */
  code: AssignExtensionBillingManagerErrorCode;
};

/** Enums for the difference error codes which can be returned. */
export enum AssignExtensionBillingManagerErrorCode {
  /** Extension does not belong to the same organization as the assigned billing manager member. */
  FailedPrecondition = 'FAILED_PRECONDITION',
  /**
   * The user doesn't meet the requirements to be the assigned billing manager.
   * For example, doesn't have a valid role or did not complete Extension Monetization (TIMs).
   */
  MemberIneligible = 'MEMBER_INELIGIBLE',
  /** User does not have permission to perform action. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Inputs to the SetExtensionBillingManager mutation. */
export type AssignExtensionBillingManagerInput = {
  /** The ID of the extensions. */
  extensionID: Scalars['ID'];
  /** The twitch ID of the organization member. */
  userID: Scalars['ID'];
};

/** Payload retuned from the mutation. */
export type AssignExtensionBillingManagerPayload = {
  __typename?: 'AssignExtensionBillingManagerPayload';
  /** The possible error returned from the service. */
  error?: Maybe<AssignExtensionBillingManagerError>;
  /** The updated extension. */
  extensionClient?: Maybe<ExtensionClient>;
};

/** Information regarding an Amazon Associates store. */
export type AssociatesStore = {
  __typename?: 'AssociatesStore';
  ID: Scalars['ID'];
  /** Whether the owner of this store is enabled to recieve payments. */
  isPayoutEnabled?: Maybe<Scalars['Boolean']>;
  /** The store ID tag. */
  storeID?: Maybe<Scalars['String']>;
};

/** Authenticated Twitch session. */
export type AuthenticatedSession = {
  __typename?: 'AuthenticatedSession';
  /** ID of the client the user authenticated from. */
  clientID: Scalars['ID'];
  /** Creation date of the session. */
  createdAt?: Maybe<Scalars['Time']>;
  /**
   * Date of invalidation of the session.
   * Can be null if the session hasn't been deleted.
   */
  deletedAt?: Maybe<Scalars['Time']>;
  /** Geolocation during authentication, determined by IP. */
  location?: Maybe<Scalars['String']>;
  /** User agent used during authentication. */
  userAgent?: Maybe<Scalars['String']>;
  /** Twitch User ID. */
  userID: Scalars['ID'];
};

/**
 * An automod fragment type, which is text that is flagged by AutoModeration.
 * It contains a list of topics which contain reasons why AutoModeration flagged the text.
 */
export type AutoMod = {
  __typename?: 'AutoMod';
  /** The topics that were flagged by AutoModeration. */
  topics: Array<AutoModTopic>;
};

/** A message rejected by automod. */
export type AutoModCaughtMessage = {
  __typename?: 'AutoModCaughtMessage';
  /** Reason why the message was flagged and/or rejected. */
  category: AutoModCaughtMessageCategory;
  /** id contains the UUID of the AutoModCaughtMessage. */
  id: Scalars['ID'];
  /** The contents of the message itself, including its content, sender, sentAt timestamp, etc. */
  modLogsMessage: ModLogsMessage;
  /** Time when a moderator allowed or denied a flagged message. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** The user (mod) who approve/denied the flagged message. */
  resolver?: Maybe<User>;
  /** The approval status of the caught message. */
  status: AutoModCaughtMessageStatus;
};

/** Reason why a message is flagged and/or rejected. */
export enum AutoModCaughtMessageCategory {
  /** Message contained words that were aggressive. */
  Aggressive = 'AGGRESSIVE',
  /** Message contained identity details. */
  Identity = 'IDENTITY',
  /** Message contained words that were vulgar. */
  Profanity = 'PROFANITY',
  /** Message contained words that were sexual. */
  Sexual = 'SEXUAL'
}

/** Describes a flagged message's posting status. */
export enum AutoModCaughtMessageStatus {
  /** The message was allowed to be sent to chat by a channel moderator or the broadcaster. */
  Allowed = 'ALLOWED',
  /** Deprecated. The message was approved by a channel moderator or the broadcaster. */
  Approved = 'APPROVED',
  /** The message was denied by a channel moderator or the broadcaster. */
  Denied = 'DENIED',
  /** The message expired before being acted upon by a channel moderator or the broadcaster. */
  Expired = 'EXPIRED',
  /** The message status is invalid (something unexpected). */
  Invalid = 'INVALID',
  /** The message has not received a decision from a mod. */
  Pending = 'PENDING'
}

/** Defines all AutoMod level settings for a channel, either may be not be set. */
export type AutoModConfiguration = {
  __typename?: 'AutoModConfiguration';
  /** This field represents the detailed AutoMod category settings. */
  detailedLevels?: Maybe<DetailedAutoModConfiguration>;
  /** This field will be a value between 0 and 4, inclusive. */
  overallLevel?: Maybe<Scalars['Int']>;
};

/** AutomodContent is the automod response for the text evaulated. */
export type AutoModContent = {
  __typename?: 'AutoModContent';
  /** canPass is the result whether the text passed automod enforcement. */
  canPass: Scalars['Boolean'];
  /** error is the error when querying automod content. */
  error?: Maybe<AutoModContentError>;
  /** failureReasons are pieces of the reasons why the text is inappropriate analyzed by automod. */
  failureReasons?: Maybe<Array<AutoModFailureReason>>;
  /** id is the ID generated for the test message (used for tracking). */
  id: Scalars['ID'];
  /** text is the original raw string evaluated by automod. */
  text: Scalars['String'];
};

/** Error associated with query AutoModContent. */
export type AutoModContentError = {
  __typename?: 'AutoModContentError';
  /** Error code. */
  code: AutoModContentErrorCode;
};

/** Client error code. */
export enum AutoModContentErrorCode {
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Resource Exhausted(rate limited). */
  ResourceExhausted = 'RESOURCE_EXHAUSTED'
}

/** AutoModContentInput is the input of query AutoModContent. */
export type AutoModContentInput = {
  /** autoModSettings is the override automod settings that will be passed in. */
  autoModSettings?: InputMaybe<DetailedAutoModLevelsInput>;
  /** channel ID is where the text enforcement will be tested. */
  channelID: Scalars['ID'];
  /** overallLevel is the override overall level that will be passed in (0-4). */
  overallLevel?: InputMaybe<Scalars['Int']>;
  /** text is the original raw string that needs evaluation by automod. */
  text: Scalars['String'];
};

/** AutoModFailureReason is the failure reason from AutoMod. */
export type AutoModFailureReason = {
  __typename?: 'AutoModFailureReason';
  /** endPosition is the end position of the inappropriate substring. */
  endPosition: Scalars['Int'];
  /** normalizedText is the normalized text processed by automod, if you need to get the violation words, use startPosition and endPosition to get the substring from raw text. */
  normalizedText: Scalars['String'];
  /** startPosition is the start position of the inappropriate substring. */
  startPosition: Scalars['Int'];
  /** topics is the topic and its level of the inappropriate substring. */
  topics: DetailedAutoModConfiguration;
};

export type AutoModProperties = {
  __typename?: 'AutoModProperties';
  /** These are integers between 0 and 6, inclusive. */
  aggressiveLevel: Scalars['Int'];
  identityLevel: Scalars['Int'];
  profanityLevel: Scalars['Int'];
  sexualLevel: Scalars['Int'];
};

/** An auto moderation topic with value. */
export type AutoModTopic = {
  __typename?: 'AutoModTopic';
  /** The topic type, defined by Zuma. */
  type: Scalars['String'];
  /** The weight assigned to the topic. */
  weight: Scalars['Int'];
};

/** Contains all auto refill profiles, will have auto refill metadata in the future. */
export type AutoRefill = {
  __typename?: 'AutoRefill';
  /** Lists actions to execute during an auto refill setup session. */
  actions: Array<CheckoutAction>;
  /** The list of auto refill profiles. */
  profiles: Array<AutoRefillProfile>;
  /** A list of active xsolla payment methods that a user has available. This field is intended to be replaced by the User.PaymentMethods query. */
  xsollaPaymentMethods?: Maybe<Array<PaymentMethod>>;
};


/** Contains all auto refill profiles, will have auto refill metadata in the future. */
export type AutoRefillActionsArgs = {
  paymentProvider: PaymentProvider;
};

/** Auto Refill profile information. */
export type AutoRefillProfile = {
  __typename?: 'AutoRefillProfile';
  /** The charge instrument information for starting a purchase. */
  chargeInstrument?: Maybe<ChargeInstrument>;
  /** Unique ID assigned to this profile. */
  id: Scalars['ID'];
  /** Indicates if this profile is active. */
  isEnabled: Scalars['Boolean'];
  /** The offerID that maps to the ability to purchase the intended product. */
  offerID?: Maybe<Scalars['ID']>;
  /** The threshold amount a balance must go below to trigger a reload. */
  threshold: Scalars['Int'];
};

/**
 * A list of configured autohost channels
 *
 * A relay connection type that does not yet support pagination.
 */
export type AutohostChannelConnection = {
  __typename?: 'AutohostChannelConnection';
  /** The channels. */
  nodes?: Maybe<Array<User>>;
};

/** A user's autohosting settings. */
export type AutohostSettings = {
  __typename?: 'AutohostSettings';
  /** True if this channels prefers autohost over vodcast. */
  deprioritizeVodcast: Scalars['Boolean'];
  /** True if this channel has the autohost feature turned on. */
  enabled: Scalars['Boolean'];
  /**
   * Determines what other channels can raid this channel.
   * @deprecated Use User.raidSettings.incomingRaidsPolicy instead.
   */
  incomingRaidsPolicy: AutohostSettingsIncomingRaidsPolicy;
  /** The strategy to use when choosing channels to autohost. */
  strategy: AutohostSettingsStrategy;
  /** True if this user autohosts their team members. */
  teamHost: Scalars['Boolean'];
};

/**
 * DEPRECATED: to be replaced by IncomingRaidsPolicy.
 * Determines what other channels can raid this channel.
 */
export enum AutohostSettingsIncomingRaidsPolicy {
  /** This user can be raded by anyone. */
  All = 'ALL',
  /** This user can be raided by other people in their network. */
  Network = 'NETWORK',
  /** This user cannot be radied by anyone. */
  None = 'NONE'
}

/** The strategy to use when choosing channels to autohost. */
export enum AutohostSettingsStrategy {
  /** Picks channels in the order defined by the user. */
  Ordered = 'ORDERED',
  /** Picks channels at random. */
  Random = 'RANDOM'
}

/**
 * A list of channels that are autohosting the channel
 *
 * A relay connection type that does not yet support pagination.
 */
export type AutohostedByChannelConnection = {
  __typename?: 'AutohostedByChannelConnection';
  /** The channels. */
  nodes?: Maybe<Array<User>>;
};

/** The possible computed states for a user or session. */
export enum Availability {
  Away = 'AWAY',
  Busy = 'BUSY',
  Idle = 'IDLE',
  Offline = 'OFFLINE',
  Online = 'ONLINE'
}

export enum AvailabilityInput {
  Idle = 'IDLE',
  Offline = 'OFFLINE',
  Online = 'ONLINE'
}

/** BackupIngestSession is session metadata related to broadcaster's backup session. */
export type BackupIngestSession = {
  __typename?: 'BackupIngestSession';
  /** The session where the current session was stitched from. */
  stitchedFrom?: Maybe<Array<BackupStreamSession>>;
  /** The session where the current session was stitched to. */
  stitchedTo?: Maybe<Array<BackupStreamSession>>;
};

/** BackupStreamSession identifies the backup stream session. */
export type BackupStreamSession = {
  __typename?: 'BackupStreamSession';
  /** Type of live stream. */
  broadcastFormat: BroadcastFormat;
  /** The ID of backup session. */
  id: Scalars['ID'];
  /** Time when the backup stream was stitched as primary session. */
  stitchedTimeAt: Scalars['Time'];
};

/** Communicates a user's status in chat. */
export type Badge = {
  __typename?: 'Badge';
  /**
   * Identifies an action to trigger when this badge is clicked.
   * @deprecated Should use onClickAction instead
   */
  clickAction?: Maybe<BadgeClickAction>;
  /** The URL to redirect to if the badge's onClickAction is VISIT_URL. */
  clickURL?: Maybe<Scalars['String']>;
  /**
   * A localized, human-friendly description of the badge.
   * Defaults to English if no translation exists for the requested locale.
   */
  description: Scalars['String'];
  /** The badge's unique identifier. */
  id: Scalars['ID'];
  /** A URL to the badge's image. */
  imageURL: Scalars['String'];
  /** Identifies an action to trigger when this badge is clicked. */
  onClickAction?: Maybe<BadgeClickAction>;
  /** Information about the user's relationship to this badge. */
  self?: Maybe<BadgeSelfEdge>;
  /** The identifier of the set which this badge belongs (e.g. "subscriber"). */
  setID: Scalars['ID'];
  /**
   * A localized, human-friendly title for the badge.
   * Defaults to English if no translation exists for the requested locale.
   */
  title: Scalars['String'];
  /**
   * The badge's associated broadcaster.
   * Returns null if this is a global badge.
   */
  user?: Maybe<User>;
  /** The badge's version (e.g. "1mo"). */
  version: Scalars['String'];
};


/** Communicates a user's status in chat. */
export type BadgeImageUrlArgs = {
  size?: InputMaybe<BadgeImageSize>;
};

/** Enumerates possible badge click actions. */
export enum BadgeClickAction {
  /** Go to the Bits purchasing page. */
  GetBits = 'GET_BITS',
  /** Go to the Twitch Turbo purchasing page. */
  GetTurbo = 'GET_TURBO',
  /** Go to the user's subscription page. */
  Subscribe = 'SUBSCRIBE',
  /** Redirect the user to the badge click URL. */
  VisitUrl = 'VISIT_URL'
}

/** Deprecated: Domains that badges belong to. */
export enum BadgeDomain {
  /** Badges that were granted via Twitch crates. */
  Crate = 'CRATE'
}

/** Enumerates valid badge image sizes. */
export enum BadgeImageSize {
  /** Double the normal badge image size: 36x36. */
  Double = 'DOUBLE',
  /** The base badge image size: 18x18. */
  Normal = 'NORMAL',
  /** Quadruple the normal badge image size: 72x72. */
  Quadruple = 'QUADRUPLE'
}

/** Further details about this object, subject to the user's permissions. */
export type BadgeSelfEdge = {
  __typename?: 'BadgeSelfEdge';
  /** Whether the given badge should be visible publicly in the badge owner's chat card badge carousel. */
  isVisibleInChatCard: Scalars['Boolean'];
};

/** A filter for controlling which Bits Badge Tier Emotes to return. */
export enum BadgeTierEmotesFilter {
  /** Returns all bits badge tier emotes for this channel. */
  All = 'ALL',
  /** Returns highest currently unlocked bits badge tier emote and next to be unlocked by user. */
  HighestUnlockedAndNext = 'HIGHEST_UNLOCKED_AND_NEXT',
  /** Returns all locked bits badge tier emotes for this user in this channel. */
  Locked = 'LOCKED',
  /**
   * Returns a few of the locked bits badge tier emotes for this user in this channel.
   * Which emotes and the exact number are determined by the back-end.
   */
  LockedPreview = 'LOCKED_PREVIEW',
  /** Returns all unlocked bits badge tier emotes for this user in this channel. */
  Unlocked = 'UNLOCKED'
}

/**
 * Balance for a Twitch User Account in a FIAT currency. Can be used to purchase
 * product on the Twitch Platform.
 */
export type Balance = {
  __typename?: 'Balance';
  /** Amount in the smallest unit of subcurrency. */
  amount: Scalars['Int'];
  /** ISO-4217 currency code of a user's balance. */
  currency: Currency;
  /** When the credit amount will expire. Can be non-expirable (null). */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Number of digits after the decimal separator. */
  exponent: Scalars['Int'];
};

export type BanUserFromChatRoomError = {
  __typename?: 'BanUserFromChatRoomError';
  code: BanUserFromChatRoomErrorCode;
  /** On DURATION_INVALID, maximum number of seconds a user can be timed out for. */
  maxTimeoutDurationSeconds?: Maybe<Scalars['Int']>;
  /** On DURATION_INVALID, minimum number of seconds a user can be timed out for. */
  minTimeoutDurationSeconds?: Maybe<Scalars['Int']>;
};

export enum BanUserFromChatRoomErrorCode {
  /** Duration provided was too short or too long. */
  DurationInvalid = 'DURATION_INVALID',
  /** User does not have permission to ban in channel. */
  Forbidden = 'FORBIDDEN',
  /** User tried to ban already banned user. */
  TargetAlreadyBanned = 'TARGET_ALREADY_BANNED',
  /** User tried to ban admin. */
  TargetIsAdmin = 'TARGET_IS_ADMIN',
  /** User tried to ban anonymous user. */
  TargetIsAnonymous = 'TARGET_IS_ANONYMOUS',
  /** User tried to ban broadcaster. */
  TargetIsBroadcaster = 'TARGET_IS_BROADCASTER',
  /** User tried to ban global mod. */
  TargetIsGlobalMod = 'TARGET_IS_GLOBAL_MOD',
  /** User tried to ban a moderator without permission. */
  TargetIsMod = 'TARGET_IS_MOD',
  /** User tried to ban themselves. */
  TargetIsSelf = 'TARGET_IS_SELF',
  /** User tried to ban staff. */
  TargetIsStaff = 'TARGET_IS_STAFF',
  /** DEPRECATED: no longer returned. */
  TargetIsVip = 'TARGET_IS_VIP',
  /** Target does not exist. */
  TargetNotFound = 'TARGET_NOT_FOUND'
}

export type BanUserFromChatRoomInput = {
  bannedUserLogin: Scalars['String'];
  channelID: Scalars['ID'];
  /**
   * This argument accepts a string specifying a duration.
   * It takes a succession of a number (positive integer) and a time unit, one of:
   * s[econd[s]], m[inute[s]], h[our[s]], d[ay[s]], w[eek[s]], mo[nth[s]].
   * Number/unit pairs can be contiguous or separated by spaces.
   * Valid examples: "3d4h" "11 minutes" "2month", "1s", "12 second"
   * If not provided, target is banned permanently.
   */
  expiresIn?: InputMaybe<Scalars['String']>;
  /** The reason that the user has been banned or timed out. */
  reason?: InputMaybe<Scalars['String']>;
};

export type BanUserFromChatRoomPayload = {
  __typename?: 'BanUserFromChatRoomPayload';
  /** The new ban status of this user regarding the specified channel. */
  ban?: Maybe<ChatRoomBanStatus>;
  /** Mutation error caused by the user input. */
  error?: Maybe<BanUserFromChatRoomError>;
};

export type BanVideoCommenterInput = {
  /** The id of the channel from where to ban commenter from. */
  channelID: Scalars['ID'];
  /** The id of the commenter to ban. */
  commenterID: Scalars['ID'];
};

export type BanVideoCommenterPayload = {
  __typename?: 'BanVideoCommenterPayload';
  user?: Maybe<User>;
};

/** The required input for an BeginUseBitsInExtension mutation. */
export type BeginUseBitsInExtensionInput = {
  /** Channel on which to use the bits. */
  channelID: Scalars['ID'];
  /** Extension client ID to spend bits in. */
  extensionClientID: Scalars['ID'];
  /** The SKU of the item being bought. */
  sku: Scalars['String'];
};

/** The result of a BeginUseBitsInExtension mutation. */
export type BeginUseBitsInExtensionPayload = {
  __typename?: 'BeginUseBitsInExtensionPayload';
  /** The user's balance. */
  balance?: Maybe<Scalars['Int']>;
  /** How many bits are required for this. */
  bitsRequired?: Maybe<Scalars['Int']>;
  /** Does the front end need to prompt the user. */
  isPromptRequired?: Maybe<Scalars['Boolean']>;
  /** The new transaction ID for this spend. */
  transactionID?: Maybe<Scalars['ID']>;
};

/** BillingAuthInfo holds data to facilitate the Fraud analysis. */
export type BillingAuthInfo = {
  /** Fraud Session ID. */
  recurlyFraudSessionID?: InputMaybe<Scalars['ID']>;
  /**
   * Token generated after completing a 3-D Secure device fingerprinting or
   * authentication challenge.
   */
  threeDSecureActionResultTokenID?: InputMaybe<Scalars['ID']>;
};

/** BitsAdOffer is an offer to earn bits by watching an ad or interacting with an engagement. */
export type BitsAdOffer = BitsOffer & {
  __typename?: 'BitsAdOffer';
  /**
   * bits is the minimum number of bits received from watching an ad.
   * Some ads may reward more, but this is the number displayed to the user before choosing to watch an ad for bits.
   */
  bits: Scalars['Int'];
  id: Scalars['ID'];
  /** type is `BitsOfferType.AD`. */
  type: BitsOfferType;
};

/** Bits Badges with their associated settings. */
export type BitsBadgeTier = {
  __typename?: 'BitsBadgeTier';
  /** The badge for this tier. */
  badge?: Maybe<Badge>;
  /** Whether the broadcaster can upload emoticons for this tier. */
  canUploadEmoticons: Scalars['Boolean'];
  /** The emoticon configurations for emoticons that are currently in the process of being uploaded for this tier. */
  emoticonUploadConfigurations: Array<Maybe<EmoteUploadConfiguration>>;
  /** The emoticons that are associated with this tier. */
  emoticons: Array<Maybe<Emote>>;
  /** Whether the badge is enabled for this threshold. */
  isEnabled: Scalars['Boolean'];
  /** Time when this badge tier was last updated. */
  lastUpdated?: Maybe<Scalars['Time']>;
  /** The amount of bits a user must cheer to achieve this tier. */
  threshold: Scalars['Int'];
  /** The number of users who have unlocked this badge tier. */
  unlockedUsersCount: Scalars['Int'];
};

/** BadgeTier Emoticon data to modify. */
export type BitsBadgeTierEmoticonSetting = {
  /**
   * The text representation that will allow a user to invoke the emoticon in chat.
   * Usually consists of: a creator's emoticon prefix + a codeSuffix.
   */
  code: Scalars['String'];
  /**
   * The creator-defined suffix that differentiates this emoticon from other emoticons in the channel.
   * Usually begins with either a capital letter or a number.
   */
  codeSuffix: Scalars['String'];
  /**
   * I'm going to make these new fields nullable and transition them to non-nullable after deprecate the existing flow
   * Image ID for the 28x28 emote asset.
   */
  imageID1x?: InputMaybe<Scalars['String']>;
  /** Image ID for the 56x56 emote asset. */
  imageID2x?: InputMaybe<Scalars['String']>;
  /** Image ID for the 112x112 emote asset. */
  imageID4x?: InputMaybe<Scalars['String']>;
};

/** BadgeTier metadata to modify. */
export type BitsBadgeTierInput = {
  /** Whether to reset the images to the default images. */
  deleteImage?: InputMaybe<Scalars['Boolean']>;
  /** Wether to reset the badge title to the default title. */
  deleteTitle?: InputMaybe<Scalars['Boolean']>;
  /** A list of emoticons to modify. */
  emoticonSettings?: InputMaybe<Array<BitsBadgeTierEmoticonSetting>>;
  /** Base64 encoded binary data of the 18x18px badge ("1x") image asset. */
  imageData1x?: InputMaybe<Scalars['String']>;
  /** Base64 encoded binary data of the 36x36px badge ("2x") image asset. */
  imageData2x?: InputMaybe<Scalars['String']>;
  /** Base64 encoded binary data of the 72x72px badge ("4x") image asset. */
  imageData4x?: InputMaybe<Scalars['String']>;
  /** Whether the badge is enabled for this threshold. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The threshold to modify. */
  threshold: Scalars['Int'];
  /** Badge title as string. */
  title?: InputMaybe<Scalars['String']>;
};

/** A notification about achieving a new bits badge tier. Used to send a special message. */
export type BitsBadgeTierNotification = {
  __typename?: 'BitsBadgeTierNotification';
  /** Whether or not the notification can be shared with chat. */
  canShare: Scalars['Boolean'];
  /** UUID for notification. */
  id: Scalars['ID'];
  /** Represents the badge tier threshold reached by the user on a channel (e.g. 100, 1000, etc). */
  threshold: Scalars['Int'];
  /** The list of bits badge tier emoticons that were obtained as part of achieving this notification's bits badge tier. */
  unlockedEmoticons: Array<Maybe<Emote>>;
};

/** Represents the state of the notification. */
export enum BitsBadgeTierNotificationState {
  /** User shared the notification with chat. */
  Shared = 'SHARED',
  /** Notification should be shown to user. */
  Show = 'SHOW',
  /** User dismissed the notification. */
  Skipped = 'SKIPPED'
}

/** BitsBundleOffer is an offer to purchase a number of bits for a certain price. */
export type BitsBundleOffer = BitsOffer & {
  __typename?: 'BitsBundleOffer';
  /** amount is the numerical cost of this offer (ex: 20.00). */
  amount: Scalars['Float'];
  /** asin is the Amazon Standard Identification Number for this offer. */
  asin: Scalars['ID'];
  /** bits is the number of bits this offer provides. */
  bits: Scalars['Int'];
  /** Currency code that the price and amount are displayed in (USD, CAD, etc.). */
  currencyCode: Scalars['String'];
  /** discount is the bulk discount this offer provides compared to the base offer [0.0-1.0). */
  discount: Scalars['Float'];
  id: Scalars['ID'];
  /**
   * includesVAT is a boolean flag to indicate that the Value Added Tax (VAT)
   * is included in the price of a Bits product. This is important for Bits prices
   * in EU.
   */
  includesVAT: Scalars['Boolean'];
  /**
   * isPromo is a flag that signifies if the offer is a promotional offer. This is for clients that
   * need to display promotional offers differently.
   */
  isPromo: Scalars['Boolean'];
  /**
   * price is the formatted currency cost of this offer to be displayed to the user.
   * @deprecated Use the 'amount' field and localize it yourself in conjunction with the 'currencyCode' field
   */
  price: Scalars['String'];
  /** promotion contains information about this bits offer if it is a promotional offer. Is null if the offer is not promotional. */
  promotion?: Maybe<BitsPromotion>;
  /** type is `BitsOfferType.BUNDLE`. */
  type: BitsOfferType;
  /**
   * url is the purchase URL to use for this offer.
   * The url contains a `{channelID}` token which should be replaced by the `User.id` of the channel bits are being purchased from.
   */
  url: Scalars['String'];
};

/**
 * BitsChallengeConditionPoolRecipientWeightedShare represents the weighted share of the total bits pool
 * that a recipient user is entitled to upon condition satisfaction.
 */
export type BitsChallengeConditionPoolRecipientWeightedShare = {
  /** TUID of the bits recipient. */
  recipientUserID: Scalars['ID'];
  /**
   * The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
   * dictates the proportion that a particular recipient receives from the pool (shareWeight/totalShareWeight * totalBitsAmountInPool).
   */
  weight: Scalars['Int'];
};

/** An event that captures a single bits transaction. */
export type BitsEvent = {
  __typename?: 'BitsEvent';
  /** Amount of bits used. */
  amount: Scalars['Int'];
  /** Channel bits were used on. */
  channel?: Maybe<User>;
  /** Event ID. */
  id: Scalars['ID'];
  /** What type of event the bits were used on. */
  type: BitsEventType;
  /** Time the bits were used at. */
  usedAt: Scalars['Time'];
};

/** A paginated list of bits events, and its metadata. */
export type BitsEventConnection = {
  __typename?: 'BitsEventConnection';
  /** The list of bits events on this page. */
  edges: Array<BitsEventEdge>;
  /** Information about this page of bits. */
  pageInfo: PageInfo;
  /** The total number of bits events in the overall collection. */
  totalCount: Scalars['Int'];
};

/** Filter and sorting options for querying all bits events for a Twitch user. */
export type BitsEventConnectionCriteriaInput = {
  /** Sort bits events by... defaults to date. */
  sortBy?: InputMaybe<BitsEventSort>;
  /** Sort bits events direction, defaults to descending. */
  sortDirection?: InputMaybe<BitsEventSortDirection>;
  /** Only show bits events of a certain type, defaults to returning all types. */
  type?: InputMaybe<BitsEventType>;
  /** Only show bits events after this date. */
  usedAfter?: InputMaybe<Scalars['Time']>;
  /** Only show bits events before this date. */
  usedBefore?: InputMaybe<Scalars['Time']>;
};

/** An element in a paginated list of bits events, and its metadata. */
export type BitsEventEdge = {
  __typename?: 'BitsEventEdge';
  /** Offset acting as a cursor. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node: BitsEvent;
};

/** Possible sort orders for lists of bits events. */
export enum BitsEventSort {
  /** Sort the bits events by amount. */
  Amount = 'AMOUNT',
  /** Sort the bits events by date. */
  Date = 'DATE'
}

/** Possible sort directions for lists of bits events. */
export enum BitsEventSortDirection {
  /** Sort in ascending order. */
  Asc = 'ASC',
  /** Sort in descending order. */
  Desc = 'DESC'
}

/** Bits event type. */
export enum BitsEventType {
  /** Event for giving bits to broadcaster. */
  GiveBitsToBroadcaster = 'GIVE_BITS_TO_BROADCASTER',
  /** Unknown event type. */
  Unknown = 'UNKNOWN',
  /** Event for using bits on extension. */
  UseBitsOnExtension = 'USE_BITS_ON_EXTENSION',
  /** Event for using bits on poll. */
  UseBitsOnPoll = 'USE_BITS_ON_POLL'
}

/** A list of hashtags to use in chat while using bits. */
export type BitsHashtagConnection = {
  __typename?: 'BitsHashtagConnection';
  /** The list of BitsHashtagEdges. */
  edges?: Maybe<Array<BitsHashtagEdge>>;
};

/** BitsHashtagEdge contains. */
export type BitsHashtagEdge = {
  __typename?: 'BitsHashtagEdge';
  /** The cursor of the record. This will be the BitsHashtagEdge ID. */
  cursor: Scalars['Cursor'];
  /** The node of the edge contains all information about the hashtag. */
  node: BitsHashtagEntry;
};

/** BitsHashtagEntry contains information about a hashtag, sucn as the description and image URL for display. */
export type BitsHashtagEntry = {
  __typename?: 'BitsHashtagEntry';
  /** description text. */
  description?: Maybe<Scalars['String']>;
  /** The ID, which would be the hashtag value. */
  id: Scalars['ID'];
  /** An image to display in autocomplete. */
  imageURL?: Maybe<Scalars['String']>;
};

/** The Bits Key Code that can be claimed to add bits to a user's account. */
export type BitsKeyCode = Claimable & {
  __typename?: 'BitsKeyCode';
  /** A description of what is claimable for the bits key code. */
  description: Scalars['String'];
  /** The ID of the bits key code. */
  id: Scalars['ID'];
  /** The field that gives us claim information for the logged in user. */
  self?: Maybe<SelfClaimEdge>;
  /** The type is `ClaimableType.BITS_KEY_CODE`. */
  type: ClaimableType;
};

/** User edge relating the key's status to the user. */
export type BitsKeyCodeSelfClaimEdge = SelfClaimEdge & {
  __typename?: 'BitsKeyCodeSelfClaimEdge';
  /** If the user is eligible to claim the key code. */
  canClaim: Scalars['Boolean'];
  /** Nullable field for the country where the user redeemed the claimable. */
  countryOfResidence?: Maybe<Scalars['String']>;
  /** The user ID that is claiming the code. */
  id: Scalars['ID'];
  /** Nullable status code for if the user cannot claim the key code. */
  statusCode?: Maybe<Scalars['String']>;
};

/** BitsLeaderboard contains the leaderboard for a specified channel. */
export type BitsLeaderboard = {
  __typename?: 'BitsLeaderboard';
  /**
   * entries is the list of users in the leaderboard ordered by the number of bits cheered.
   * @deprecated the ID field is not unique between leaderboards on leaderboard entries. Use leaderboard item.
   */
  entries: BitsLeaderboardConnection;
  /** id is the id of this leaderboard. */
  id: Scalars['ID'];
  /** items is the list of users in the leaderboard ordered by the number of bits cheered. */
  items: BitsLeaderboardItemConnection;
  /** SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time). */
  secondsRemaining: Scalars['Int'];
};

/** Bits leaderboard connection is used to show the various leaderboard entries. */
export type BitsLeaderboardConnection = {
  __typename?: 'BitsLeaderboardConnection';
  edges: Array<Maybe<BitsLeaderboardEdge>>;
};

/** BitsLeaderboardEdge describes an edge in a bits leaderboard. */
export type BitsLeaderboardEdge = {
  __typename?: 'BitsLeaderboardEdge';
  /** The cursor for this leaderboard edge. */
  cursor: Scalars['String'];
  /** The leaderboard entry at this edge. */
  node?: Maybe<BitsLeaderboardEntry>;
};

/** Leaderboard entry at a specific node in a leaderboard connection. */
export type BitsLeaderboardEntry = {
  __typename?: 'BitsLeaderboardEntry';
  /** id the id of this leaderboard entry. */
  id: Scalars['ID'];
  /** rank the ordinal rank of this leaderboard entry. */
  rank: Scalars['Int'];
  /** score the number of bits cheered by this leaderboard entry. */
  score: Scalars['Int'];
};

/** Leaderboard item at a specific node in a leaderboard connection. */
export type BitsLeaderboardItem = {
  __typename?: 'BitsLeaderboardItem';
  /** entryKey the key of this leaderboard item. */
  entryKey: Scalars['String'];
  /** id the id of this leaderboard item. */
  id: Scalars['ID'];
  /** rank the ordinal rank of this leaderboard item. */
  rank: Scalars['Int'];
  /** score the number of bits cheered by this leaderboard entry. */
  score: Scalars['Int'];
};

/** Bits leaderboard connection is used to show the various leaderboard items. */
export type BitsLeaderboardItemConnection = {
  __typename?: 'BitsLeaderboardItemConnection';
  /** edges ... */
  edges?: Maybe<Array<Maybe<BitsLeaderboardItemEdge>>>;
  /** pageInfo ... */
  pageInfo: PageInfo;
  /** totalCount ... */
  totalCount?: Maybe<Scalars['Int']>;
};

/** BitsLeaderboardItemEdge describes an edge in a bits leaderboard. */
export type BitsLeaderboardItemEdge = {
  __typename?: 'BitsLeaderboardItemEdge';
  /** The cursor for this leaderboard edge. */
  cursor: Scalars['Cursor'];
  /** The leaderboard entry at this edge. */
  node?: Maybe<BitsLeaderboardItem>;
};

/** BitsLeaderboardSettings are channel-specific settings related to Bits Leaderboards. */
export type BitsLeaderboardSettings = {
  __typename?: 'BitsLeaderboardSettings';
  /** isEnabled indicates if the Bits leaderboard is pinned in this channel. */
  isEnabled: Scalars['Boolean'];
  /** timePeriodType indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc. */
  timePeriodType?: Maybe<LeaderboardTimePeriodType>;
};

/** BitsOffer is a way to obtain more bits. */
export type BitsOffer = {
  /** bits is the number of bits this offer grants. */
  bits: Scalars['Int'];
  id: Scalars['ID'];
  /** type is the kind of offer object. */
  type: BitsOfferType;
};

/** BitsOfferType is the kind of offer. */
export enum BitsOfferType {
  /** AD is an advertisement or other engagement that can be watched to earn bits. */
  Ad = 'AD',
  /** BUNDLE is a standard package of bits that can be purchased for a price. */
  Bundle = 'BUNDLE'
}

/** Enum of payment method types. */
export enum BitsPaymentMethodType {
  /** Amazon Pay. */
  AmazonPay = 'AMAZON_PAY',
  /** Paypal. */
  Paypal = 'PAYPAL',
  /** Xsolla. */
  Xsolla = 'XSOLLA'
}

/** The type used when checking which payment methods a user can use. */
export type BitsPaymentMethods = {
  __typename?: 'BitsPaymentMethods';
  /** A list of the valid bits payment methods for a user. */
  paymentMethods?: Maybe<Array<BitsPaymentMethodType>>;
};

/** A product for bits that contains all information about a product, except for the pricing. */
export type BitsProduct = {
  __typename?: 'BitsProduct';
  /** The amount of bits the product is for. */
  amount: Scalars['Int'];
  /** The product ID. */
  id: Scalars['ID'];
  /** The maximum quantity a user can purchase at once. */
  maxQuantity: Scalars['Int'];
  /** The offer id associated with this product's id (if available). */
  offerID?: Maybe<Scalars['ID']>;
  /** A field that contains promotional information about the product. */
  promo?: Maybe<BitsProductPromotion>;
  /** The relation of the product to the user. */
  self?: Maybe<BitsProductSelfEdge>;
  /** The product type, which right now is only "purchase". */
  type: BitsProductType;
};

/** The type used when checking bits product eligibility for a user. */
export type BitsProductEligibility = {
  __typename?: 'BitsProductEligibility';
  /** A boolean that is true when the user is eligible for the product. */
  canPurchase: Scalars['Boolean'];
  /**
   * If the user is ineligible for the product, then this code is set
   * as the reason why the user is ineligible for the product.
   */
  reasonCode?: Maybe<Scalars['String']>;
};

/** Promotional information about bits products. */
export type BitsProductPromotion = {
  __typename?: 'BitsProductPromotion';
  /** The unique ID of the bits product promo. */
  id: Scalars['ID'];
  /** The localized title of the promo product. */
  title: Scalars['String'];
  /** The type of promotion the product is associated with. This type is not enumerable since it is very dynamic. */
  type: Scalars['String'];
};

/** An enumerable that identifies the checkout provider the customer is using. */
export enum BitsProductProvider {
  /** Amazon checkout. */
  Amazon = 'AMAZON',
  /** Android IAP. */
  Android = 'ANDROID',
  /** iOS IAP. */
  Ios = 'IOS',
  /** Paypal checkout. */
  Paypal = 'PAYPAL',
  /** Xsolla checkout. */
  Xsolla = 'XSOLLA'
}

/** Contains the Bits product's preview price and tax info for a Bits purchase, and error if a preview cannot be created. */
export type BitsProductPurchaseInfo = {
  __typename?: 'BitsProductPurchaseInfo';
  /** Lists any additional actions for a bits checkout session. */
  actions: Array<CheckoutAction>;
  /** The error is present if purchase info failed to be retrieved. */
  error?: Maybe<BitsProductPurchaseInfoError>;
  /** Gets the preview price and tax info for the Bits purchase. */
  previewPriceInfo?: Maybe<PriceInfo>;
};

/** Error information shown when priceInfo could not be retrieved for Bits Product. */
export type BitsProductPurchaseInfoError = {
  __typename?: 'BitsProductPurchaseInfoError';
  /** The descriptive error code. */
  code: BitsProductPurchaseInfoErrorCode;
};

/** Possible errors when retrieving bits product purchase info. */
export enum BitsProductPurchaseInfoErrorCode {
  /** The billing info could not be found for the user and provider (410). */
  BillingInfoNotFound = 'BILLING_INFO_NOT_FOUND',
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** The Pricing ID is not found (404). */
  PricingIdNotFound = 'PRICING_ID_NOT_FOUND',
  /** User is not eligible to purchase bits in this region (422). */
  PurchaseIneligible = 'PURCHASE_INELIGIBLE',
  /**
   * Cannot determine User Residence. Either billing address and IP doesn't match or
   * user doesn't have country of resident declared (409).
   */
  UnknownUserResidence = 'UNKNOWN_USER_RESIDENCE',
  /** The user is unauthorized to view purchase info. */
  UserUnauthorized = 'USER_UNAUTHORIZED'
}

/** The relation of a Bits product to a user. */
export type BitsProductSelfEdge = {
  __typename?: 'BitsProductSelfEdge';
  /** Holds configuration necessary to start bits purchase checkout flow for this product for current user. */
  checkoutConfiguration?: Maybe<CheckoutConfiguration>;
  /** Is the user eligible to claim the product at the given quantity. */
  eligibility: BitsProductEligibility;
  /** Gets the preview price and tax info for the Bits purchase, or error if that failed. */
  purchaseInfo: BitsProductPurchaseInfo;
};


/** The relation of a Bits product to a user. */
export type BitsProductSelfEdgeEligibilityArgs = {
  quantity: Scalars['Int'];
};


/** The relation of a Bits product to a user. */
export type BitsProductSelfEdgePurchaseInfoArgs = {
  paymentSession?: InputMaybe<PaymentSession>;
  quantity: Scalars['Int'];
};

/** An enumerable that identifies bits product types. */
export enum BitsProductType {
  /** A product that has to be purchased. */
  PurchasedProduct = 'PURCHASED_PRODUCT',
  /** An unknown product type. */
  Unknown = 'UNKNOWN'
}

export type BitsPromotion = {
  __typename?: 'BitsPromotion';
  /** id indicates the particular promo that this offer is associated with. */
  id: Scalars['ID'];
  /** PromoType indicates the type of promo that the offer represents i.e First time purchase, single purchase, etc... */
  type: Scalars['String'];
};

/** Settings tied to a bits user. */
export type BitsUserSettings = {
  __typename?: 'BitsUserSettings';
  /** Settings specific to the first cheer tutorial. */
  firstCheerTutorial?: Maybe<FirstCheerTutorial>;
};

/** An enumerable that dictates user's Bits usage state. */
export enum BitsUserState {
  /** The user has acquired Bits (purchased, watched ads, etc.) but has never used it. */
  Acquired = 'ACQUIRED',
  /** The user has cheered before. */
  Cheered = 'CHEERED',
  /** The user has never used or acquired Bits. */
  NewUser = 'NEW_USER',
  /** The user has never used or acquired Bits, but clicked "Skip" button to skip the first user experience. */
  Skipped = 'SKIPPED',
  /** The user state is unknown. */
  Unknown = 'UNKNOWN'
}

/** Information regarding a Blizzard account that is linked to Twitch. */
export type BlizzardUser = {
  __typename?: 'BlizzardUser';
  /** The BattleTag that is stored for the user. */
  battleTag: Scalars['String'];
  /** The Blizzard ID that is stored for the user. */
  id: Scalars['ID'];
  /** The region the Blizzard account is from. */
  region: Scalars['String'];
};

/**
 * Location from where the current user blocked target user.
 * NOTE: it is onlyl used from the block_user mutation, this enum should have been named BlockUserContext and be placed in the same mutation file.
 */
export enum BlockContext {
  Chat = 'CHAT',
  Whisper = 'WHISPER'
}

export type BlockUserInput = {
  /** Reason the user is being blocked. */
  reason?: InputMaybe<Scalars['String']>;
  /** Feature from which the user is being blocked. */
  sourceContext?: InputMaybe<BlockContext>;
  /** ID of user to block. */
  targetUserID: Scalars['ID'];
};

export type BlockUserPayload = {
  __typename?: 'BlockUserPayload';
  /** User that was blocked. */
  targetUser: User;
};

/** A BoostSettings is a set of preferences set by a creator regarding Community Boosts for their channel. */
export type BoostSettings = {
  __typename?: 'BoostSettings';
  /** If Boosts earned through community challenges are enabled on this channel. */
  isEarnedEnabled?: Maybe<Scalars['Boolean']>;
  /** If the channel is eligible to recieve boosts. */
  isEligible: Scalars['Boolean'];
  /** If Boosts are enabled on this channel. */
  isEnabled?: Maybe<Scalars['Boolean']>;
  /** If Boosts paid for by the community are enabled on this channel. */
  isPaidEnabled?: Maybe<Scalars['Boolean']>;
};

/** A bounty is a task that a user can complete for a payout. */
export type Bounty = {
  __typename?: 'Bounty';
  /** The campaign that this bounty belongs to. */
  campaign: BountyCampaign;
  /** The chat Call to Action that will be display during the bounty. */
  chatCTA?: Maybe<BountyChatCta>;
  /**
   * When the bounty was claimed by the user.
   * @deprecated Replacing with 'claimedAt' for consistency with 'At' suffix
   */
  claimTime?: Maybe<Scalars['Time']>;
  /** When the bounty was claimed by the user. */
  claimedAt?: Maybe<Scalars['Time']>;
  /**
   * When the bounty expires.
   * @deprecated Replacing with 'expiresAt' as that is a more descriptive property name for the value.
   */
  endAt?: Maybe<Scalars['Time']>;
  /**
   * When the the user stops tracking.
   * @deprecated Replacing with 'trackingStoppedAt' as that is a more descriptive property name for the value.
   */
  endTime?: Maybe<Scalars['Time']>;
  /** When the bounty expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** The bounty's unique identifier. */
  id: Scalars['ID'];
  /** The product keys for the bounty. */
  keys?: Maybe<Array<BountyProductKey>>;
  /** When the bounty was last modified. */
  lastModifiedAt?: Maybe<Scalars['Time']>;
  /** The number of concurrent users (CCU) required to hit the maximum payout for the bounty. */
  maximumPayoutCCU?: Maybe<Scalars['Int']>;
  /** The maximum payout for completing this bounty in USD cents. */
  maximumPayoutCents: Scalars['Int'];
  /** The number of concurrent users (CCU) required to earn a payout for the bounty. */
  minimumPayoutCCU?: Maybe<Scalars['Int']>;
  /** The node includes all bounty moderation metadata. */
  moderationMetadata?: Maybe<BountyModerationMetadata>;
  /**
   * The moderation status of the bounty.
   * @deprecated Replacing with 'status' within moderationMetadata.
   */
  moderationStatus?: Maybe<BountyModerationStatus>;
  /** The actual payout for completing this bounty in USD cents. */
  payoutCents?: Maybe<Scalars['Int']>;
  /** The platform on which the user will play the game for this bounty (ie. PC). */
  platform?: Maybe<Scalars['String']>;
  /** The region that the broadcaster has selected for this bounty (as defined by BountyCampaignKeyDescriptor). */
  region?: Maybe<Scalars['String']>;
  /** Restrictions for this bounty. */
  restriction?: Maybe<BountyRestriction>;
  /**
   * When the bounty was claimed by the user.
   * @deprecated Replacing with 'claimTime' as that is a more descriptive property name for the value.
   */
  startAt?: Maybe<Scalars['Time']>;
  /**
   * When the bounty was started by the user.
   * @deprecated Replacing with 'trackingStartedAt' as that is a more descriptive property name for the value.
   */
  startTime?: Maybe<Scalars['Time']>;
  /** The status of the bounty. */
  status: BountyStatus;
  /** When the user starts tracking the bounty. */
  trackingStartedAt?: Maybe<Scalars['Time']>;
  /** When the user stops tracking the bounty. */
  trackingStoppedAt?: Maybe<Scalars['Time']>;
  /** The videos for this bounty. */
  videos?: Maybe<Array<BountyVideo>>;
};

/** Bounty board settings configure how a user can interact with the Bounty Boards feature. */
export type BountyBoardSettings = {
  __typename?: 'BountyBoardSettings';
  /** This determines whether or not a user has a bounty board notification. */
  hasNotification: Scalars['Boolean'];
  /**
   * This determines whether the user has the Bounty Boards feature enabled.
   * @deprecated Use 'status' instead.
   */
  isEnabled: Scalars['Boolean'];
  /** The user's status on Bounty Board. */
  status: BountyBoardUserStatus;
};

/** Represents the user's status on Bounty Board. */
export enum BountyBoardUserStatus {
  /** The user has been accepted into the Bounty Board program and can participate in bounties. */
  Accepted = 'ACCEPTED',
  /** The user has been banned from the Bounty Board program. */
  Banned = 'BANNED',
  /** The user has been invited to join the Bounty Board program but cannot participate in bounties yet. */
  Invited = 'INVITED',
  /** The user is not part of the Bounty Board program. */
  None = 'NONE'
}

/** A campaign defines the requirements and parameters for a set of bounties. */
export type BountyCampaign = {
  __typename?: 'BountyCampaign';
  /** The list of games that if isAllowAllGames is false, the bounty must use. */
  allowedGames?: Maybe<Array<Game>>;
  /** The platforms on which users can play this campaign's game (ie. PC, PS4, Switch). */
  availablePlatforms?: Maybe<Array<Scalars['String']>>;
  /** The length of this campaign's bounties (in days). */
  bountyLengthDays: Scalars['Int'];
  /** Override Box Art URL only for campaign shown on Bounty Board Dashboard, unrelated to game. */
  boxArtURL?: Maybe<Scalars['String']>;
  /** Details about the campaign that only the sponsoring brand should see. */
  brandDetails?: Maybe<BountyCampaignBrandDetails>;
  /** Override Cover URL only for campaign shown on Bounty Board Dashboard, unrelated to game. */
  coverURL?: Maybe<Scalars['String']>;
  /** Details for this campaign. */
  details: Scalars['String'];
  /** Override Display name only for campaign shown on Bounty Board Dashboard, unrelated to game. */
  displayName?: Maybe<Scalars['String']>;
  /**
   * When the campaign expires.
   * @deprecated Replacing with 'endTime' as that is a more descriptive property name for the value.
   */
  endAt: Scalars['Time'];
  /** When the campaign expires. */
  endTime: Scalars['Time'];
  /**
   * The game identifier that is related to this campaign.
   * @deprecated Replacing with 'allowedGames' as this provides a set of available games instead of a single game
   */
  game?: Maybe<Game>;
  /** The campaign's unique identifier. */
  id: Scalars['ID'];
  /** If the campaing is a promotional campaign. */
  isPromotionEligible?: Maybe<Scalars['Boolean']>;
  /** The information about keys for the campaigns. */
  keyDescriptors?: Maybe<Array<BountyCampaignKeyDescriptor>>;
  /**
   * Why the campaign was rejected.
   * @deprecated Use 'rejectionReason' in 'brandDetails' instead.
   */
  rejectionReason?: Maybe<Scalars['String']>;
  /** If a campaign allows any game to be played. */
  shouldAllowAllGames?: Maybe<Scalars['Boolean']>;
  /** The sponsor that is funding this campaign (ie. Amazon Game Studios). */
  sponsor: Scalars['String'];
  /**
   * When the campaign starts.
   * @deprecated Replacing with 'startTime' as that is a more descriptive property name for the value.
   */
  startAt: Scalars['Time'];
  /** When the campaign starts. */
  startTime: Scalars['Time'];
  /**
   * The status of the campaign.
   * @deprecated Use 'status' in 'brandDetails' instead.
   */
  status?: Maybe<BountyCampaignStatus>;
  /** How many seconds a bounty for this campaign must be streamed to complete the bounty. */
  streamLengthSeconds?: Maybe<Scalars['Int']>;
  /** The click target of the campaign if it is a promotional campaign. */
  targetPromotionalVideoClicks?: Maybe<Scalars['Int']>;
  /** The URL for the terms and conditions page. */
  termsAndConditionsURL?: Maybe<Scalars['String']>;
  /** The title of the campaign (ie. Stream Breakaway for 1 hour). */
  title: Scalars['String'];
  /** The tracking URLs for this campaign. */
  trackingPixels?: Maybe<Array<TrackingPixel>>;
  /** The type of the campaign (ie. PAY_TO_STREAM). */
  type: BountyCampaignType;
  /**
   * The URL of the video for this campaign.
   * @deprecated Use 'videos' instead.
   */
  videoURL?: Maybe<Scalars['String']>;
  /** The video URLS for the campaign. */
  videos?: Maybe<Array<BountyCampaignVideo>>;
};

/** Details about a bounty campaign that only the sponsoring brand should see. */
export type BountyCampaignBrandDetails = {
  __typename?: 'BountyCampaignBrandDetails';
  /**
   * The list of users (if any) blacklisted for the campaign.
   * Limited to 40 users - use totalBlockedBroadcasters for the total count.
   */
  blacklistedBroadcasters?: Maybe<Array<User>>;
  /** The multiplier for the broadcaster payout rate. */
  broadcasterMultiplier?: Maybe<Scalars['Float']>;
  /** Reporting data for the campaign. */
  campaignReporting?: Maybe<BountyCampaignReporting>;
  /** The chat Calls to Action for the campaign. */
  chatCTAs?: Maybe<Array<BountyChatCta>>;
  /**
   * The total number of broadcasters who have claimed the bounty.
   * @deprecated Use 'claimedBountyCount' in 'campaignReporting' instead.
   */
  claimedBountyCount?: Maybe<Scalars['Int']>;
  /**
   * How much of the budget has been claimed (in cents).
   * @deprecated Use 'claimedBudgetCents' in 'campaignReporting' instead.
   */
  claimedBudgetCents?: Maybe<Scalars['Int']>;
  /**
   * The total number of broadcasters who have completed the bounty.
   * @deprecated Use 'completedBountyCount' in 'campaignReporting' instead.
   */
  completedBountyCount?: Maybe<Scalars['Int']>;
  /**
   * The total number of broadcasters who have expanded the bounty.
   * @deprecated Use 'expandedBountyCount' in 'campaignReporting' instead.
   */
  expandedBountyCount?: Maybe<Scalars['Int']>;
  /** If all broadcasters are targeted for the campaign. */
  includesAllBroadcasters?: Maybe<Scalars['Boolean']>;
  /** If all countries are targeted for the campaign. */
  includesAllCountries: Scalars['Boolean'];
  /** If all games are targeted for the campaign. */
  includesAllGames: Scalars['Boolean'];
  /** If variety broadcasters are targeted for the campaign. */
  includesVarietyBroadcasters: Scalars['Boolean'];
  /**
   * Detailed performance metrics for this campaign.
   * @deprecated Use 'performanceMetrics' in 'campaignReporting' instead.
   */
  performanceMetrics?: Maybe<Array<BountyCampaignPerformanceMetric>>;
  /** Why the campaign was rejected. */
  rejectionReason?: Maybe<Scalars['String']>;
  /** How much of the budget has been spent (completed bounties) (in cents). */
  spentBudgetCents?: Maybe<Scalars['Int']>;
  /** The status of the campaign. */
  status?: Maybe<BountyCampaignStatus>;
  /** Targeted countries for the campaign (represented by ISO 3166-1 alpha-2). */
  targetedCountries?: Maybe<Array<Scalars['String']>>;
  /** Targeted Games for the campaign. */
  targetedGames?: Maybe<Array<Game>>;
  /** The total length of the blacklistedBroadcasters list. */
  totalBlockedBroadcasters?: Maybe<Scalars['Int']>;
  /** The total budget for the campaign (in cents). */
  totalBudgetCents?: Maybe<Scalars['Int']>;
  /**
   * The number of broadcasters who have viewed the bounty.
   * @deprecated Use 'viewedBountyCount' in 'campaignReporting' instead.
   */
  viewedBountyCount?: Maybe<Scalars['Int']>;
};

/** The chat Call to Action (CTA) that will be created as part of this campaign. */
export type BountyCampaignChatCtaInput = {
  /** The country that the chat CTA is targeted for (represented by ISO 3166-1 alpha-2). */
  countryCode: Scalars['String'];
  /** The title for the chat CTA. */
  title: Scalars['String'];
  /** The URL for the chat CTA. */
  url: Scalars['String'];
};

/** A list of bounty campaigns related to the subject. */
export type BountyCampaignConnection = {
  __typename?: 'BountyCampaignConnection';
  /** The campaigns. */
  edges?: Maybe<Array<Maybe<BountyCampaignEdge>>>;
  /** Information about pagination in this connection. */
  pageInfo: PageInfo;
};

/**
 * Information about the relationship to the bounty campaign and the subject.
 * Also includes the campaign itself.
 */
export type BountyCampaignEdge = {
  __typename?: 'BountyCampaignEdge';
  /** Uniquely identifies this campaign's position in a connection. */
  cursor: Scalars['Cursor'];
  /** The campaign. */
  node?: Maybe<BountyCampaign>;
};

/** A descriptor for a product key. */
export type BountyCampaignKeyDescriptor = {
  __typename?: 'BountyCampaignKeyDescriptor';
  /** The platform for the key. */
  platform: Scalars['String'];
  /** The region for the key. */
  region: Scalars['String'];
};

/** Metric containing details about how a campaign performed over a time period. */
export type BountyCampaignPerformanceMetric = {
  __typename?: 'BountyCampaignPerformanceMetric';
  /** The number of click-throughs from the Chat CTAs of the campaign. */
  chatCTAClickThroughCount?: Maybe<Scalars['Int']>;
  /** The total number of bounties that were completed. */
  completedBountyCount: Scalars['Int'];
  /** The end time of this metric. */
  endTime: Scalars['Time'];
  /** The total number of minutes watched. */
  minutesWatched: Scalars['Int'];
  /** The start time of this metric. */
  startTime: Scalars['Time'];
  /** The number of viewers that watched at least thirty seconds of the campaign's content. */
  thirtySecondViewerCount: Scalars['Int'];
  /** The total number of viewers that watched the campaign's content. */
  totalViewerCount: Scalars['Int'];
  /** The number of viewers that watched at least two minutes of the campaign's content. */
  twoMinuteViewerCount: Scalars['Int'];
};

/** Details about a bounty campaign reporting that only the sponsoring brand should see. */
export type BountyCampaignReporting = {
  __typename?: 'BountyCampaignReporting';
  /** The total number of clicks from chat CTAs from every bounty. */
  chatCTAsClicks?: Maybe<Scalars['Int']>;
  /** The total number of impressions from chat CTAs from every bounty. */
  chatCTAsImpressions?: Maybe<Scalars['Int']>;
  /** The total number of broadcasters who have claimed the bounty. */
  claimedBountyCount?: Maybe<Scalars['Int']>;
  /** How much of the budget has been claimed (live bounties) (in cents). */
  claimedBudgetCents?: Maybe<Scalars['Int']>;
  /** The total number of broadcasters who have completed the bounty. */
  completedBountyCount?: Maybe<Scalars['Int']>;
  /** The total number of broadcasters who have expanded the bounty. */
  expandedBountyCount?: Maybe<Scalars['Int']>;
  /** Detailed performance metrics for this campaign. */
  performanceMetrics?: Maybe<Array<BountyCampaignPerformanceMetric>>;
  /** How much of the budget has been spent (completed bounties) (in cents). */
  spentBudgetCents?: Maybe<Scalars['Int']>;
  /** The number of broadcasters who have viewed the bounty. */
  viewedBountyCount?: Maybe<Scalars['Int']>;
};

/** The status of a bounty campaign. */
export enum BountyCampaignStatus {
  /** The campaign has been approved. */
  Approved = 'APPROVED',
  /** The campaign is done. */
  Completed = 'COMPLETED',
  /** The campaign is live. */
  Live = 'LIVE',
  /** The campaign is pending approval. */
  Pending = 'PENDING',
  /** The campaign has been rejected. */
  Rejected = 'REJECTED'
}

/** Represents the type of the campaign. */
export enum BountyCampaignType {
  /** A user is paid to stream a game trailer. */
  GameTrailer = 'GAME_TRAILER',
  /** A user is paid to stream a non-game trailer (ie. a movie trailer). */
  MiscTrailer = 'MISC_TRAILER',
  /** A user is paid to stream themselves playing a game. */
  PayToStream = 'PAY_TO_STREAM',
  /** Invalid campaign type. */
  Unknown = 'UNKNOWN'
}

/** Possible upload types for bounty campaigns. */
export enum BountyCampaignUploadType {
  /** Upload type related to the box art image. */
  BoxArt = 'BOX_ART',
  /** Upload type related to the cover image. */
  Cover = 'COVER'
}

/** A video for a bounty board campaign. */
export type BountyCampaignVideo = {
  __typename?: 'BountyCampaignVideo';
  /** The country that the video is targeted for (represented by ISO 3166-1 alpha-2). */
  country: Scalars['String'];
  /** The title of the video. */
  title: Scalars['String'];
  /** The URL of the video. */
  url: Scalars['String'];
};

/** The video that will be created as part of this campaign. */
export type BountyCampaignVideoInput = {
  /** The country that the video is targeted for (represented by ISO 3166-1 alpha-2). */
  country: Scalars['String'];
  /** The title of the video. */
  title: Scalars['String'];
  /** The URL of the video. */
  url: Scalars['String'];
};

/** A chat Call to Action (CTA) that will be trigger in the broadcaster chat while doing the bounty. */
export type BountyChatCta = {
  __typename?: 'BountyChatCTA';
  /** The country targeted for the chat CTA (represented by ISO 3166-1 alpha-2). */
  countryCode: Scalars['String'];
  /** The time (in seconds) between each appearance of the chat CTA. */
  frequencySeconds: Scalars['Int'];
  /** The initial delay (in seconds) before the first chat CTA. */
  initialDelaySeconds: Scalars['Int'];
  /** The title of the chat CTA. */
  title: Scalars['String'];
  /** The URL of the chat CTA. */
  url: Scalars['String'];
};

/** A list of bounty related to the subject. */
export type BountyConnection = {
  __typename?: 'BountyConnection';
  /** The bounties. */
  edges?: Maybe<Array<BountyEdge>>;
  /** Information about pagination in this connection. */
  pageInfo: PageInfo;
};

/**
 * Information about the relationship to the bounty and the subject.
 * Also includes the bounty itself.
 */
export type BountyEdge = {
  __typename?: 'BountyEdge';
  /** Uniquely identifies this bounty's position in a connection. */
  cursor: Scalars['Cursor'];
  /** The bounty. */
  node?: Maybe<Bounty>;
};

/** Represents all the currently possible key product types. */
export enum BountyKeyProductType {
  /** The key is a coupon code. */
  Coupon = 'COUPON',
  /** The key is for downloadable content or a game expansion. */
  Dlc = 'DLC',
  /** The key is a game code. */
  Game = 'GAME',
  /** The key is for a gift card. */
  Giftcard = 'GIFTCARD',
  /** The key is a code for a giveaway. */
  Giveaway = 'GIVEAWAY',
  /** The key is for in game content - character skins, customization, etc. */
  Igc = 'IGC',
  /** The key is for something else. */
  Other = 'OTHER'
}

/** The reason why bounty failed moderation. */
export enum BountyModerationFailReason {
  /** Moderation failed because broadcaster did badmouthing during stream. */
  Badmouthing = 'BADMOUTHING',
  /** Moderation failed because broadcaster had exessive idle time during sponsored stream. */
  Idle = 'IDLE',
  /** Moderation failed because broadcast is not with required content. */
  IncorrectContent = 'INCORRECT_CONTENT',
  /** Moderation failed because broadcast does not meet minimal stream length requirement. */
  MinimumTimeNotMet = 'MINIMUM_TIME_NOT_MET',
  /** Moderation failed because missing sponsored stream VOD. */
  NoVod = 'NO_VOD',
  /** Other reason caused moderation failed. */
  Other = 'OTHER',
  /** Moderation failed because other content layered over/under required content. */
  OtherContentVisible = 'OTHER_CONTENT_VISIBLE'
}

/** Bounty Moderation metadata includes moderation metadata for a specific bounty. */
export type BountyModerationMetadata = {
  __typename?: 'BountyModerationMetadata';
  /** The moderation fail reason of the bounty. */
  reason?: Maybe<BountyModerationFailReason>;
  /** The moderation status of the bounty. */
  status?: Maybe<BountyModerationStatus>;
  /** When the bounty was last moderated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** The moderation status of the bounty. */
export enum BountyModerationStatus {
  /** The bounty has failed the moderation check. */
  Fail = 'FAIL',
  /** The bounty has passed the moderation check. */
  Pass = 'PASS',
  /** The bounty is waiting for moderation check. */
  PendingReview = 'PENDING_REVIEW'
}

/** A key that can be redeemed for a product. */
export type BountyProductKey = {
  __typename?: 'BountyProductKey';
  /** The code that is used to redeem the product. */
  code: Scalars['String'];
  /** The platform where the code is redeemed. */
  platform?: Maybe<Scalars['String']>;
  /** The product type of the key - GAME, DLC, GIVEAWAY, GIFTCARD, etc. */
  productType?: Maybe<BountyKeyProductType>;
  /**
   * The region where the code can be redeemed. The format and granularity of this field varies
   * depending on the product key vendor.
   */
  region?: Maybe<Scalars['String']>;
};

/** Defines the restrictions that are placed on a bounty. */
export type BountyRestriction = {
  __typename?: 'BountyRestriction';
  /** The days of the week that a bounty can be completed on. The values are from 0 to 6, representing day of the week from Monday to Sunday. */
  days?: Maybe<Array<Scalars['Int']>>;
  /** The end of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 2100 means 9 PM UTC. */
  endTime?: Maybe<Scalars['Int']>;
  /** The start of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 1000 means 10 AM UTC. */
  startTime?: Maybe<Scalars['Int']>;
};

/** Represents all the possible bounty statuses. */
export enum BountyStatus {
  /** The bounty can be claimed by the user. */
  Available = 'AVAILABLE',
  /** The bounty was cancelled before it was completed. */
  Cancelled = 'CANCELLED',
  /** The bounty was completed successfully. */
  Completed = 'COMPLETED',
  /** The bounty has been claimed by the user and is in progress. */
  Live = 'LIVE'
}

/** A video that the broadcaster must play on stream to complete the bounty. */
export type BountyVideo = {
  __typename?: 'BountyVideo';
  /** The title of the video. */
  title: Scalars['String'];
  /** The URL of the video. */
  url: Scalars['String'];
};

/** Brand portal settings configure how a company can interact with the brand portal. */
export type BrandPortalSettings = {
  __typename?: 'BrandPortalSettings';
  /** This determines whether or not a company can access all games in brand portal. */
  canAccessAllGames: Scalars['Boolean'];
  /** This determines whether or not a company can access the Brand Portal. */
  isEnabled: Scalars['Boolean'];
};

/** A historical representation of a live stream. */
export type Broadcast = {
  __typename?: 'Broadcast';
  /** The game which was last streamed during the broadcast. */
  game?: Maybe<Game>;
  /** The broadcast's unique identifier. */
  id?: Maybe<Scalars['ID']>;
  /** When the broadcast started. */
  startedAt?: Maybe<Scalars['Time']>;
  /** The title of the broadcast. */
  title?: Maybe<Scalars['String']>;
};

/** BroadcastFormat is type of ingest live sessions. */
export enum BroadcastFormat {
  /** Primary session which backup session was stitched back to. */
  Backup_000 = 'BACKUP_000',
  /** First backup session. */
  Backup_001 = 'BACKUP_001',
  /** Second backup session. */
  Backup_002 = 'BACKUP_002',
  /** Third backup session. */
  Backup_003 = 'BACKUP_003',
  /** Stream with intentional delays requested by the broadcaster. */
  Delay = 'DELAY',
  /** Default live stream. Primary session for the backup session will be shown as live. */
  Live = 'LIVE'
}

/** Settings for a User's broadcast that persist between streams. */
export type BroadcastSettings = {
  __typename?: 'BroadcastSettings';
  /** The game that the user has set as their current game. This will influence what the game field on a Streams object is when the User starts streaming. */
  game?: Maybe<Game>;
  /**
   * The broadcast setting's unique identifier.
   * This happens to be the same as the User's ID, but should not be assumed to have any meaning.
   */
  id: Scalars['ID'];
  /** A flag indicating if the user's broadcast is intended for mature audiences only. */
  isMature: Scalars['Boolean'];
  /** The primary language that the user has configured for their broadcasts. The default value is "", when the user has not indicated a primary language. */
  language: Language;
  /**
   * The text that will be in the notification that sends when the user starts broadcasting.
   * The default value is "<user> went live!", when the user has not set a custom value.
   * @deprecated Use liveUpNotificationInfo instead.
   */
  liveUpNotification?: Maybe<Scalars['String']>;
  /** The information about the live up notification of a user. */
  liveUpNotificationInfo?: Maybe<LiveUpNotificationInfo>;
  /** The title of the user's broadcast. The default value is "", when the user has not indicated a title. */
  title: Scalars['String'];
};

/**
 * Describes from which source the video originated.
 * NOTE: Should have been named VideoBroadcastType.
 */
export enum BroadcastType {
  /** If the video is of a past broadcast, it's an ARCHIVE. */
  Archive = 'ARCHIVE',
  /** When the video is a subsection of a past broadcast, it's a HIGHLIGHT. */
  Highlight = 'HIGHLIGHT',
  /** When a video has been premiered on Twitch and is saved, it's a PAST_PREMIERE. */
  PastPremiere = 'PAST_PREMIERE',
  /** When the video is directly uploaded to Twitch via the video manager, it's an PREMIERE_UPLOAD. */
  PremiereUpload = 'PREMIERE_UPLOAD',
  /** (Legacy) When the video is directly uploaded to Twitch via the upload tool, it's an UPLOAD. */
  Upload = 'UPLOAD'
}

/** An indicator of the viewer reach for a pool of a broadcasters. */
export type BroadcasterViewerReach = {
  __typename?: 'BroadcasterViewerReach';
  /** Range of the number of broadcasters in the pool. */
  broadcasterPool: Range;
  /** Range of minutes watched for this bounty campaign. */
  minutesWatched: Range;
  /** Range of total viewers across the broadcaster pool. */
  viewerPool: Range;
};

/** Associated metrics for the "Build a Community" quest. */
export type BuildACommunity = {
  __typename?: 'BuildACommunity';
  /** Image URL for the quest's badge. */
  badgeURL?: Maybe<Scalars['String']>;
  /** Time that this quest was completed. */
  completedAt?: Maybe<Scalars['Time']>;
  /** Number of followers needed to complete the quest. */
  followers?: Maybe<QuestGoalInt>;
  /** Number of Unique Chatters needed to complete the quest. */
  uniqueChatters?: Maybe<QuestGoalInt>;
};

/** Required input to bulk approve a list of unban requests on a channel. */
export type BulkApproveUnbanRequestInput = {
  /** IDs of the unban requests to be approved. */
  ids: Array<Scalars['ID']>;
};

/** Result of bulk approving unban requests. */
export type BulkApproveUnbanRequestPayload = {
  __typename?: 'BulkApproveUnbanRequestPayload';
  /** Used for errors arising from bulk approving unban requests. */
  error?: Maybe<UnbanRequestError>;
  /** The approved unban requests. */
  unbanRequests?: Maybe<Array<UnbanRequest>>;
};

/** Required input to deny a list of unban requests on a channel. */
export type BulkDenyUnbanRequestInput = {
  /** IDs of the unban requests to be denied. */
  ids: Array<Scalars['ID']>;
};

/** Result of bulk denying unban requests. */
export type BulkDenyUnbanRequestPayload = {
  __typename?: 'BulkDenyUnbanRequestPayload';
  /** Used for errors arising from bulk denying unban requests. */
  error?: Maybe<UnbanRequestError>;
  /** The denied unban requests. */
  unbanRequests?: Maybe<Array<UnbanRequest>>;
};

/** CCPA cookie vendor for a user. */
export type CcpaCookieVendor = {
  __typename?: 'CCPACookieVendor';
  /** User content status for each vendor. */
  consentStatus: ConsentStatus;
  /** A flag that shows if the consent is given by the user or by consent service as default value. */
  hasUserSetConsent: Scalars['Boolean'];
  /** A flag that shows if the vendor should be visible to management page. */
  isVisible: Scalars['Boolean'];
  /** Vendor name. */
  name: VendorName;
};

/** List of CCPA cookie vendors. */
export type CcpaVendorConsent = {
  __typename?: 'CCPAVendorConsent';
  /** status for vendors. */
  status: Array<CcpaCookieVendor>;
};

/** Possible values of actionPrompted in SubmitCSATFeedbackInput. */
export enum CsatActionPrompted {
  /** The user registers their client app (i.e. save information for an app), in their personal console. */
  ClientAppRegister = 'CLIENT_APP_REGISTER',
  /** The user creates a new drop campaign. */
  DropCreateCampaign = 'DROP_CREATE_CAMPAIGN',
  /** The user moves a drop's state to active. */
  DropMoveStateToActive = 'DROP_MOVE_STATE_TO_ACTIVE',
  /** The user move's a drop's state to testing. */
  DropMoveStateToTesting = 'DROP_MOVE_STATE_TO_TESTING',
  /** The user creates a new extension. */
  ExtensionCreate = 'EXTENSION_CREATE',
  /** The user changes the state of an extension. */
  ExtensionStateChange = 'EXTENSION_STATE_CHANGE',
  /** The user submits box art for their game. */
  GamesSubmitBoxArt = 'GAMES_SUBMIT_BOX_ART',
  /** The user views the analytics page of their game. */
  GamesViewAnalytics = 'GAMES_VIEW_ANALYTICS',
  /** The user adds another user to their organization. */
  OrganizationAddUser = 'ORGANIZATION_ADD_USER',
  /** The user creates a new organization. */
  OrganizationCreate = 'ORGANIZATION_CREATE'
}

/** Possible ratings that the user can submit as part of their feedback. */
export enum CsatRating {
  /** The user selects "Neutral". */
  Neutral = 'NEUTRAL',
  /** The user selects "Somewhat Dissatisfied". */
  SomewhatDissatisfied = 'SOMEWHAT_DISSATISFIED',
  /** The user selects "Somewhat Satisfied". */
  SomewhatSatisfied = 'SOMEWHAT_SATISFIED',
  /** The user selects "Very Dissatisfied". */
  VeryDissatisfied = 'VERY_DISSATISFIED',
  /** The user selects "Very Satisfied". */
  VerySatisfied = 'VERY_SATISFIED'
}

/** A visible campaign on a given user's channel. */
export type Campaign = {
  __typename?: 'Campaign';
  /** The domain that campaign belongs to. */
  domain: Scalars['String'];
  /** The time the campaign ends being active. */
  endDate: Scalars['Time'];
  /** Unique identifier for the campaign. */
  id: Scalars['ID'];
  /** The objectives users can progress in within this campaign. */
  objectives: Array<CampaignObjective>;
  /** The time the campaign becomes active. */
  startDate: Scalars['Time'];
};

/** This type holds the information about the grouping of objectives. Each group has a list of cheermotes that progress objectives in this particular group. */
export type CampaignCheergroup = {
  __typename?: 'CampaignCheergroup';
  /** A list of upper cased cheermotes that can advance objectives belonging to this group. */
  cheerCodes: Array<Scalars['String']>;
  /** An a parent group this cheer group belongs to (e.g. "North America"). */
  division?: Maybe<Scalars['String']>;
  /** A url to the image representing this group (e.g. team icon in esports context). */
  imageUrl: Scalars['String'];
  /** A name representing this group (e.g. team name in esports context). */
  name: Scalars['String'];
};

/** CampaignDiscoveryEventType contains the different types of discovery events that campaign objectives can track. */
export enum CampaignDiscoveryEventType {
  /** An event describing a user's interaction with the command center. */
  EngageCommandCenter = 'ENGAGE_COMMAND_CENTER',
  /** An event describing a user's interaction with a stream. */
  EngageStream = 'ENGAGE_STREAM'
}

/**
 * This type holds information about a campaign objective, which belongs to a campaign.
 * An objective can hold multiple milestones which users can hit and get rewards.
 * An objective can hold a cheer group.
 */
export type CampaignObjective = {
  __typename?: 'CampaignObjective';
  /** Cheergroup this objective might belong to. */
  cheergroup?: Maybe<CampaignCheergroup>;
  /** Short description about the objective. */
  description: Scalars['String'];
  /** Unique identifier for the objective. */
  id: Scalars['ID'];
  /** If the objective belongs to an active parent campaign. */
  isActive: Scalars['Boolean'];
  /** Milestones users can hit by advancing this objective. */
  milestones?: Maybe<Array<Milestone>>;
  /** User's participation towards the objective. */
  participation: Scalars['Int'];
  /** Global progress for the objective. */
  progress: Scalars['Int'];
  /** The type of objective this is for. It can be either INDIVIDUAL or GLOBAL (TEAM is deprecated). */
  tag: Scalars['String'];
  /** Short title for the objective. */
  title: Scalars['String'];
};

/** All Campaign properties that are running for a given user. */
export type CampaignProperties = {
  __typename?: 'CampaignProperties';
  /** All the current active campaigns for a given user. */
  activeCampaigns?: Maybe<Array<Scalars['String']>>;
  /** All the current domains a user is participating in. */
  domains?: Maybe<Array<Scalars['String']>>;
  /** Determines whether or not a user has a pass they can sell on their channel. */
  hasPass: Scalars['Boolean'];
  /** Objectives users can progress within all the active campaigns for the first domain. */
  objectives?: Maybe<Array<CampaignObjective>>;
  /** Triggers users can activate to get / give rewards within this campaign. */
  triggers?: Maybe<Array<CampaignTrigger>>;
};

/** Metadata for the reward that only impacts how the rewards are rendered on the front end apps. */
export type CampaignRewardMetadata = {
  __typename?: 'CampaignRewardMetadata';
  /**
   * Whether the reward is initially unavailable upon redeeming.
   * @deprecated No longer supported
   */
  isPending: Scalars['Boolean'];
  /**
   * Reward subtype usually specific to the game the campaign belongs to (e.g. skin, spray, etc).
   * @deprecated No longer supported
   */
  subType?: Maybe<Scalars['String']>;
};

/**
 * This type holds information about a campaign trigger, which belongs to a campaign.
 * A trigger has a list of rewards that can be earned by various one time events.
 */
export type CampaignTrigger = {
  __typename?: 'CampaignTrigger';
  /** Short description about the trigger. */
  description: Scalars['String'];
  /** Unique identifier for the trigger. */
  id: Scalars['ID'];
  /** Whether the trigger is currently active. */
  isActive: Scalars['Boolean'];
  /** List of rewards attached to this trigger. */
  rewards?: Maybe<Array<TournamentReward>>;
  /** Short title for the trigger. */
  title: Scalars['String'];
  /** Maximum amount of trigger quantity required for the trigger (e.g. # of bits in cheer). */
  triggerAmountMax: Scalars['Int'];
  /** Minimum amount of trigger quantity required for the trigger (e.g. # of bits in cheer). */
  triggerAmountMin: Scalars['Int'];
  /** String defining the trigger type (e.g. CHEER). */
  triggerType: TriggerType;
};

/** The type of the campaign. */
export enum CampaignType {
  /** The default campaign type that allows all drop types but manual_triggers. */
  Default = 'DEFAULT',
  /** The manual trigger campaign type only allows for manual trigger type drops. */
  ManualTriggerBased = 'MANUAL_TRIGGER_BASED'
}

/** Error code for an error that occurs while canceling the active boosts. */
export type CancelActiveBoostOrdersError = {
  __typename?: 'CancelActiveBoostOrdersError';
  /** Error code for error that occurred while canceling the active boosts. */
  code: CancelActiveBoostOrdersErrorCode;
};

/** Error types recognized. */
export enum CancelActiveBoostOrdersErrorCode {
  /** Internal error being returned from service. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER'
}

/** The required input for a cancelActiveBoostOrdersInput mutation. */
export type CancelActiveBoostOrdersInput = {
  /** The Id of the channel for which we want to cancel boosts. */
  channelID: Scalars['ID'];
};

/** Data that was mutated after canceling the active boosts. */
export type CancelActiveBoostOrdersPayload = {
  __typename?: 'CancelActiveBoostOrdersPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CancelActiveBoostOrdersError>;
};

/** Error code for an error that occurs while canceling the bounty. */
export type CancelBountyError = {
  __typename?: 'CancelBountyError';
  /** Error code for error that occurred while canceling the bounty. */
  code: CancelBountyErrorCode;
};

/** Error types recognized. */
export enum CancelBountyErrorCode {
  /** Bounty isn't live, thus cannot be canceled. */
  BountyNotLive = 'BOUNTY_NOT_LIVE',
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER',
  /** Unknown error being returned from service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** CancelBountyInput includes the bounty a user is trying to cancel. */
export type CancelBountyInput = {
  /** Unique Identifier for the bounty. */
  bountyID: Scalars['ID'];
  /** Reason that the user canceled the bounty. */
  reason?: InputMaybe<Scalars['String']>;
  /** UserID of the user that will cancel the bounty. */
  userID: Scalars['ID'];
};

/** Data that was mutated after canceling the bounty. */
export type CancelBountyPayload = {
  __typename?: 'CancelBountyPayload';
  /** The canceled bounty with the updated status. */
  bounty?: Maybe<Bounty>;
  /** The possible error returned from the service. */
  error?: Maybe<CancelBountyError>;
  /** The user that now has the canceled bounty. */
  user?: Maybe<User>;
};

export type CancelFriendRequestInput = {
  /** The authenticated user will cancel the friend request sent to the user with an ID equal to targetID. */
  targetID: Scalars['ID'];
};

export type CancelFriendRequestPayload = {
  __typename?: 'CancelFriendRequestPayload';
  /** The user whose friend request was just cancelled. */
  user?: Maybe<User>;
};

/** CancelPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding. */
export type CancelPayoutOnboardingWorkflowInput = {
  /** TargetUserID is the ID of the user whose workflow will be started. */
  targetUserID: Scalars['ID'];
};

/** CancelPayoutOnboardingWorkflowPayload is the payload returned after canceling a payout onboarding workflow. */
export type CancelPayoutOnboardingWorkflowPayload = {
  __typename?: 'CancelPayoutOnboardingWorkflowPayload';
  /** A new workflow status. */
  workflow?: Maybe<PayoutOnboardingWorkflow>;
};

/** An error returned from the cancelPredictionEvent mutation. */
export type CancelPredictionEventError = {
  __typename?: 'CancelPredictionEventError';
  /** Code describing the error. */
  code: CancelPredictionEventErrorCode;
};

/** Possible error codes from the cancelPredictionEvent mutation. */
export enum CancelPredictionEventErrorCode {
  /** This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken. */
  EventEnded = 'EVENT_ENDED',
  /** The current user is forbidden from cancelling this Prediction Event. */
  Forbidden = 'FORBIDDEN',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for canceling a Prediction Event (and refunding all users who have contributed). */
export type CancelPredictionEventInput = {
  /** The unique identifier of the Prediction Event to cancel. */
  id: Scalars['ID'];
};

/** Payload for canceling a Prediction Evnet. */
export type CancelPredictionEventPayload = {
  __typename?: 'CancelPredictionEventPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<CancelPredictionEventError>;
  /** The canceled Prediction Event. */
  predictionEvent?: Maybe<PredictionEvent>;
};

/** CancelRaidError is the error associated with a cancelRaid. */
export type CancelRaidError = {
  __typename?: 'CancelRaidError';
  /** The associated error code. */
  code: CancelRaidErrorCode;
};

/** CancelRaidErrorCode are the possible errors that this mutation returns. */
export enum CancelRaidErrorCode {
  /** The request is missing valid channel parameters. */
  InvalidChannel = 'INVALID_CHANNEL',
  /** The user tries to unraid without an active raid. */
  NoActiveRaid = 'NO_ACTIVE_RAID',
  /** The a raid does not exist. */
  RaidDoesNotExist = 'RAID_DOES_NOT_EXIST'
}

/** Inputs to the cancelRaid mutation. */
export type CancelRaidInput = {
  /** Source ID. */
  sourceID: Scalars['ID'];
};

/** Outputs from the cancelRaid mutation. */
export type CancelRaidPayload = {
  __typename?: 'CancelRaidPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CancelRaidError>;
  /** The cancelled raid. */
  raid?: Maybe<Raid>;
};

/** Inputs for the mutation. Gift to be canceled by productID and originID. */
export type CancelSubscriptionGiftInput = {
  /** originID is the origin id created during the gift purchase. */
  originID: Scalars['ID'];
  /** productID is the ticket product id for this gift. */
  productID: Scalars['ID'];
};

/** The returned payload from the mutation for canceling a Subscription Gift. */
export type CancelSubscriptionGiftPayload = {
  __typename?: 'CancelSubscriptionGiftPayload';
  /** SubscriptionGift object that was deleted. */
  gift?: Maybe<SubscriptionGift>;
};

/** Required input to cancel an unban request. */
export type CancelUnbanRequestInput = {
  /** ID of the unban request to be canceled. */
  id: Scalars['ID'];
};

/** Result of canceling an unban request. */
export type CancelUnbanRequestPayload = {
  __typename?: 'CancelUnbanRequestPayload';
  /** Used for errors arising from canceling the unban request. */
  error?: Maybe<UnbanRequestError>;
  /** The canceled unban request. */
  unbanRequest?: Maybe<UnbanRequest>;
};

/** Describes the conditions around a user's cancellation of their purchase (e.g. refund policy). */
export enum CancellationPolicyType {
  /** The product is not refundable. */
  NonRefundable = 'NON_REFUNDABLE',
  /** The product is refundable. */
  Refundable = 'REFUNDABLE'
}

/** The status of a chat message. */
export enum CaughtMessageStatus {
  /** The caught message is approved by a mod. */
  Allowed = 'ALLOWED',
  /** The caught message is denied by a mod. */
  Denied = 'DENIED',
  /** The caught message is pending for a while and now it's expired. */
  Expired = 'EXPIRED',
  /** INVALID status. */
  Invalid = 'INVALID',
  /** The caught message is pending review. */
  Pending = 'PENDING'
}

/** Celebration is a configuration that denotes when a celebration is triggerd and when sort of celebration will show when it triggers. */
export type Celebration = {
  __typename?: 'Celebration';
  /** Area of the channel page in which the celebration will appear. */
  area: CelebrationArea;
  /** Duration which the celebration will play. */
  durationMilliseconds: Scalars['Int'];
  /** Effect which will be shown when then celebration is triggered. */
  effect: CelebrationEffect;
  /**
   * Amount that needs to be met in order to trigger this celebration.
   * For example, when the event type is subscription gift, this value will
   * determine how many gifts must be given at a single time to trigger the
   * celebration.
   */
  eventThreshold: Scalars['Int'];
  /** Type of event which will trigger this celebration. */
  eventType: CelebrationEventType;
  /** Unique identifier for the celebration. */
  id: Scalars['ID'];
  /**
   * Intensity of the celebration.
   * Should be bounded (TBA) value which will determine the spectacle of the celebration.
   */
  intensity: Scalars['Int'];
  /** If true, the celebration is enabled. */
  isEnabled: Scalars['Boolean'];
};

/** Area in which the celebration will show. */
export enum CelebrationArea {
  /** Celebration will show everywhere over the channel page. */
  Everywhere = 'EVERYWHERE',
  /** Unknown celebration area. */
  Unknown = 'UNKNOWN',
  /** Celebration will show over the video and panel. */
  VideoAndPanel = 'VIDEO_AND_PANEL',
  /** Celebration will show only over the video. */
  VideoOnly = 'VIDEO_ONLY'
}

/** The channels configuration of celebrations. */
export type CelebrationConfig = {
  __typename?: 'CelebrationConfig';
  /** List of celebrations for this channel. */
  celebrations: Array<Celebration>;
  /** The identifier for the celebration config. */
  id: Scalars['ID'];
  /** If celebrations are enabled on this channel. */
  isEnabled: Scalars['Boolean'];
};

/** Type of effect that can show during a celebration. */
export enum CelebrationEffect {
  /** Will show fireworks when the celebration triggers. */
  Fireworks = 'FIREWORKS',
  /** Will show an flamethrowers when the celebration triggers. */
  Flamethrowers = 'FLAMETHROWERS',
  /** Will show an emote rain when the celebration triggers. */
  Rain = 'RAIN',
  /** Unknown effect. */
  Unknown = 'UNKNOWN'
}

/** Celebration error. */
export type CelebrationError = {
  __typename?: 'CelebrationError';
  /** Code describing the error. */
  code: CelebrationErrorCode;
};

/** Vote in celebration error code. */
export enum CelebrationErrorCode {
  /** A celebration with that same event type and threshold already exists. */
  CelebrationAlreadyExists = 'CELEBRATION_ALREADY_EXISTS',
  /** Attempted to preform operation on celebration that does not exist. */
  CelebrationNotFound = 'CELEBRATION_NOT_FOUND',
  /** The user has reached the limit (20) of celebrations they can have. */
  OverCelebrationLimit = 'OVER_CELEBRATION_LIMIT',
  /** Requesting user does not have permission. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Type of event that can trigger a celebration. */
export enum CelebrationEventType {
  /** Cheering with bits. */
  BitsCheer = 'BITS_CHEER',
  /** Gifting subscriptions to other users. */
  SubscriptionGift = 'SUBSCRIPTION_GIFT',
  /** Unknown event type. */
  Unknown = 'UNKNOWN'
}

/** Type of intensity of a celebration. */
export enum CelebrationIntensity {
  /** A large intensity celebration. */
  Large = 'LARGE',
  /** A medium intensity celebration. */
  Medium = 'MEDIUM',
  /** A small intensity celebration. */
  Small = 'SMALL',
  /** Unknown intensity. */
  Unknown = 'UNKNOWN'
}

/** A celebration product that a user may purchase. */
export type CelebrationProduct = ProductCatalogItem & {
  __typename?: 'CelebrationProduct';
  /** A list of benefits the user will receive when purchasing the celebration product. */
  benefits?: Maybe<Array<ProductCatalogBenefit>>;
  /** A description of the product. */
  description?: Maybe<Scalars['String']>;
  /** The identifier of the celebration product. */
  id: Scalars['ID'];
  /** The intensity of the celebration product. */
  intensity: CelebrationIntensity;
  /** Indicates if the celebration product is enabled for purchase in the channel. */
  isEnabled: Scalars['Boolean'];
  /** A list of offers available for purchasing this celbration product. */
  offers?: Maybe<Array<Offer>>;
  /** The owner (ex: channel) of the celebration product. */
  owner: Scalars['ID'];
  /** A list of potential offers that a broadcaster could set for purchasing this celebration product. */
  potentialOffers?: Maybe<Array<Offer>>;
  /** The title of the product. */
  title: Scalars['String'];
};

/** A celebration product benefit the user will receive when purchasing the celebration product. */
export type CelebrationProductBenefit = ProductCatalogBenefit & {
  __typename?: 'CelebrationProductBenefit';
  /** The identifier of the celebration product benefit. */
  id: Scalars['ID'];
};

/** Configuration settings to change for a celebration product. */
export type CelebrationProductConfigInput = {
  /** The intensity of the celebration product. */
  intensity: CelebrationIntensity;
  /** If the celebration product is enabled for purchase in the channel. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** ID of the offer (i.e. price) through which the celebration can be purchased in the channel. */
  offerID?: InputMaybe<Scalars['ID']>;
};

/** A container for celebration settings for the logged in user. */
export type CelebrationUserSettings = {
  __typename?: 'CelebrationUserSettings';
  /** A boolean flag that denotes if the user has opted out of seeing celebrations. */
  isOptedOut: Scalars['Boolean'];
};

/** A condition to be satisfied by a specific owner. */
export type ChallengeCondition = {
  __typename?: 'ChallengeCondition';
  /** When the condition was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Settings that define how the effects of the condition participants associated with this condition will be processed. */
  effectSettings?: Maybe<Array<ChallengeEffectSettings>>;
  /** Unique ID of the condition. */
  id: Scalars['ID'];
  /** The name of the condition. */
  name: Scalars['String'];
  /** The user who creates and owns the condition. */
  owner?: Maybe<User>;
  /** A summary of condition participants attached to the condition. */
  participantSummary?: Maybe<ChallengeConditionParticipantSummaryByState>;
  /** The current state of the condition. */
  state: ChallengeConditionState;
  /** The list of effect types supported by this condition. */
  supportedEffects: Array<ChallengeEffectType>;
  /** When the condition times out. */
  timeoutAt?: Maybe<Scalars['Time']>;
  /** When the condition was last modified. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Whether the condition becomes inactive once it has been satisfied. */
  willDisableWhenSatisfied: Scalars['Boolean'];
};

/** A condition participant action that will be taken if an associated condition is satisfied. */
export type ChallengeConditionParticipant = {
  __typename?: 'ChallengeConditionParticipant';
  /** The associated condition. */
  condition?: Maybe<ChallengeCondition>;
  /** The effect that will occur if the condition participant is satisfied. */
  effect: ChallengeEffect;
  /** Final state of the condition participant. */
  endState: ChallengeConditionParticipantEndState;
  /** Unique ID of the condition participant. */
  id: Scalars['ID'];
  /** The user who creates and owns the condition participant. */
  owner?: Maybe<User>;
  /** Whether or not the condition participant was successfully processed upon condition completion. */
  processingState: ChallengeConditionParticipantProcessingState;
};

/** Final state of the condition participant. */
export enum ChallengeConditionParticipantEndState {
  /** Condition participant was canceled. */
  Canceled = 'CANCELED',
  /** Associated condition was canceled. */
  ConditionCanceled = 'CONDITION_CANCELED',
  /** Associated condition expired. */
  ConditionExpired = 'CONDITION_EXPIRED',
  /** Associated condition was satisfied. */
  ConditionSatisfied = 'CONDITION_SATISFIED',
  /** Condition participant expired before associated condition could be satisfied. */
  Expired = 'EXPIRED',
  /** Condition participant failed validation prior to being processed. */
  FailedValidation = 'FAILED_VALIDATION',
  /** Pending completion of associated condition. */
  Pending = 'PENDING',
  /** Unknown state. */
  Unknown = 'UNKNOWN'
}

/** Whether or not the condition participant was successfully processed upon condition completion. */
export enum ChallengeConditionParticipantProcessingState {
  /** Error processing condition participant. */
  Error = 'ERROR',
  /** Pending completion of associated condition. */
  Pending = 'PENDING',
  /** Condition participant processed successfully. */
  Success = 'SUCCESS',
  /** Unknown state. */
  Unknown = 'UNKNOWN'
}

/** A summary of participants attached to a particular condition in a particular state. */
export type ChallengeConditionParticipantSummary = {
  __typename?: 'ChallengeConditionParticipantSummary';
  /** Summary of participant effects attached to a particular condition in a particular state. */
  effects?: Maybe<ChallengeEffectSummary>;
  /** Total count of participants attached to a particular condition in a particular state. */
  total: Scalars['Int'];
};

/** A summary of condition participants attached to a particular condition, grouped by state. */
export type ChallengeConditionParticipantSummaryByState = {
  __typename?: 'ChallengeConditionParticipantSummaryByState';
  /** Summary of participants attached to a particular condition in the CANCELED state. */
  canceled?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the CONDITION_CANCELED state. */
  conditionCanceled?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the CONDITION_TIMEOUT state. */
  conditionTimeout?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the FAILED_VALIDATION state. */
  failedValidation?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the PENDING state. */
  pending?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the SATISFIED state. */
  satisfied?: Maybe<ChallengeConditionParticipantSummary>;
  /** Summary of participants attached to a particular condition in the TIMEOUT state. */
  timeout?: Maybe<ChallengeConditionParticipantSummary>;
  /** Total count of participants attached to a particular condition. */
  total: Scalars['Int'];
};

/** The current state of the condition. */
export enum ChallengeConditionState {
  /** New condition participants can be associated with this condition. */
  Active = 'ACTIVE',
  /** Condition was manually terminated. New condition participants cannot be associated. */
  Canceled = 'CANCELED',
  /** Condition was automatically terminated. New condition participants cannot be associated. */
  Expired = 'EXPIRED',
  /** Condition was satisfied for the final time. New condition participants cannot be associated with this condition. */
  Inactive = 'INACTIVE',
  /** Unknown state. */
  Unknown = 'UNKNOWN'
}

/** An effect that will occur if a challenge condition participant is satisfied. */
export type ChallengeEffect = {
  __typename?: 'ChallengeEffect';
  /** Details of the effect. */
  details: ChallengeEffectDetails;
  /** The type of effect. */
  type: ChallengeEffectType;
};

/** Details of the effect. */
export type ChallengeEffectDetails = ChallengeUseBitsEffectDetails;

/** Settings that define how effects will be processed when a condition is satisfied. */
export type ChallengeEffectSettings = {
  __typename?: 'ChallengeEffectSettings';
  /** Details of the effect settings. */
  details: ChallengeEffectSettingsDetails;
  /** The type of effect. */
  type: ChallengeEffectType;
};

/** Details of the effect settings. */
export type ChallengeEffectSettingsDetails = ChallengeUseBitsEffectSettingsDetails;

/** A summary of effects attached to a particular condition in a particular state. Keys correspond to ChallengeEffectType enum. */
export type ChallengeEffectSummary = {
  __typename?: 'ChallengeEffectSummary';
  /** USE_BITS effects. */
  useBits?: Maybe<ChallengeUseBitsEffectSummary>;
};

/** The type of effect. */
export enum ChallengeEffectType {
  /** Unknown type. */
  Unknown = 'UNKNOWN',
  /** Type of effect that results in using a user's bits. */
  UseBits = 'USE_BITS'
}

/** Details of the UseBits effect. */
export type ChallengeUseBitsEffectDetails = {
  __typename?: 'ChallengeUseBitsEffectDetails';
  /** The user who uses the bits. */
  benefactor?: Maybe<User>;
  /** The amount of bits to be used. */
  bitsAmount: Scalars['Int'];
};

/** Details of the UseBits effect settings. */
export type ChallengeUseBitsEffectSettingsDetails = {
  __typename?: 'ChallengeUseBitsEffectSettingsDetails';
  /** A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied. */
  bitsRecipientWeightedShares: Array<ChallengeUseBitsPoolRecipientWeightedShare>;
};

/** A summary of USE_BITS effects attached to a particular condition in a particular state. */
export type ChallengeUseBitsEffectSummary = {
  __typename?: 'ChallengeUseBitsEffectSummary';
  /** Sum of Bits rolling up to a particular condition in a particular state. */
  totalBitsAmount: Scalars['Int'];
  /** Total count of USE_BITS effects rolling up to a particular condition in a particular state. */
  totalEffects: Scalars['Int'];
};

/**
 * ChallengeUseBitsPoolRecipientWeightedShare represents the weighted share of the total bits pool
 * that a recipient user is entitled to upon condition satisfaction.
 */
export type ChallengeUseBitsPoolRecipientWeightedShare = {
  __typename?: 'ChallengeUseBitsPoolRecipientWeightedShare';
  /** The bits recipient user. */
  recipient?: Maybe<User>;
  /**
   * The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
   * dictates the proportion that a particular recipient receives from the pool (shareWeight/totalShareWeight * totalBitsAmountInPool).
   */
  weight: Scalars['Int'];
};

/** Error returned during an invalid change username request. */
export type ChangeUsernameCodeError = {
  __typename?: 'ChangeUsernameCodeError';
  /** Error code returned by the backend. */
  code: ChangeUsernameErrorCode;
};

/** Possible error codes returned from a change username. */
export enum ChangeUsernameErrorCode {
  /** Login was changed recently (last 60 days). */
  LoginChangeCooldown = 'LOGIN_CHANGE_COOLDOWN',
  /** Login change requires a verified email. */
  LoginChangeEmailVerified = 'LOGIN_CHANGE_EMAIL_VERIFIED',
  /** Login contains characters that are not allowed. */
  LoginContainsInvalidCharacters = 'LOGIN_CONTAINS_INVALID_CHARACTERS',
  /** Login is too long. */
  LoginTooLong = 'LOGIN_TOO_LONG',
  /** Login is too short. */
  LoginTooShort = 'LOGIN_TOO_SHORT',
  /** Login is not available. */
  LoginUnavailable = 'LOGIN_UNAVAILABLE',
  /** Sudo token expired, prompt the user to log in again. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** Too many attempts to update login. */
  RequestsThrottled = 'REQUESTS_THROTTLED',
  /** Unrecognized error returned from the backend service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Input for a change username. */
export type ChangeUsernameInput = {
  /** The new login for the user. */
  login: Scalars['String'];
  /** User id of the user being updated. */
  userID: Scalars['ID'];
};

/** The result of a change username. */
export type ChangeUsernamePayload = {
  __typename?: 'ChangeUsernamePayload';
  /** Error code for error returned from change username. */
  error?: Maybe<ChangeUsernameCodeError>;
  /** The modified user. */
  user?: Maybe<User>;
};

/** ChangelogEntry is an entry that displays new items and notifications in the creator homepage changelog. */
export type ChangelogEntry = {
  __typename?: 'ChangelogEntry';
  /** content is localized text content for the changelog entry. */
  content: Scalars['String'];
  /** iconURL is the url for the entry's icon image. */
  iconURL: Scalars['String'];
  /** id is a unique human readable slug for the entry e.g. "squad-stream". */
  id: Scalars['ID'];
  /** linkText is the text that the linkURL should display. */
  linkText?: Maybe<Scalars['String']>;
  /** linkURL is an optional link for more content for this changelog entry. */
  linkURL?: Maybe<Scalars['String']>;
  /** position is where entry should be located within changelog entries of the same date. */
  position: Scalars['Int'];
  /** publishedAt is the timestamp that the changelog entry was published. */
  publishedAt?: Maybe<Scalars['Time']>;
  /** title is the localized title of the changelog entry. */
  title: Scalars['String'];
};

/** ChanletSort indicates the desired order of chanlets in the list returned by LoadChanletsByUserID. */
export enum ChanletSort {
  /** ChanletSortNone indicates that the order of chanlets returned is insignificant to the client and is allowed to be arbitrary. */
  None = 'NONE',
  /** ChanletSortViewerCount indicates chanlets should return sorted by viewer counts, descending. */
  ViewerCount = 'VIEWER_COUNT'
}

/** A User's place on Twitch. */
export type Channel = {
  __typename?: 'Channel';
  /** All Prediction Events that are actively accepting new predictions. */
  activePredictionEvents?: Maybe<Array<PredictionEvent>>;
  /** A mapping of AutoMod categories to levels. */
  autoModConfiguration?: Maybe<AutoModConfiguration>;
  /** A list of content attributes created for the channel, that can be associated with the chanlets, to augment the multi-view experience. */
  availableContentAttributes?: Maybe<Array<MultiviewContentAttribute>>;
  /**
   * A list of available Drops that viewers of this channel can claim when certain game events are met.
   * @deprecated use channel.viewerDropCampaigns
   */
  availableDrops?: Maybe<Array<Maybe<DropObject>>>;
  /** A paginated list of users who are banned from this channel. */
  bannedUsers?: Maybe<ChannelBannedUserConnection>;
  /** The boost settings for the channel. */
  boostSettings?: Maybe<BoostSettings>;
  /**
   * The language the broadcaster has chosen to stream in.
   * @deprecated Use stream.language instead.
   */
  broadcasterLanguage: Scalars['String'];
  /** The celebration configuration for the channel, which contains if celebrations are enabled and a list of configured celebrations. */
  celebrations?: Maybe<CelebrationConfig>;
  /** The stream key for this channel if it is a multi-view chanlet. The requesting user must "own" this chanlet to be authorized to see this. */
  chanletStreamKey?: Maybe<Scalars['String']>;
  /** A list of the channel's chanlets (sub-channels) in a multi-view experience. */
  chanlets?: Maybe<Array<Channel>>;
  /** Get the chatters on this channel. */
  chatters?: Maybe<ChattersInfo>;
  /** The clip settings for a channel, includes settings on clip creation. */
  clipsSettings?: Maybe<ChannelClipsSettings>;
  /** Get a single community points custom reward redemption by its ID. */
  communityPointsCustomRewardRedemption?: Maybe<CommunityPointsCustomRewardRedemption>;
  /** The queue of community points custom reward redemptions in this channel. */
  communityPointsRedemptionQueue?: Maybe<CommunityPointsCustomRewardRedemptionConnection>;
  /** Details about community points in the channel. */
  communityPointsSettings?: Maybe<CommunityPointsChannelSettings>;
  /** For a multi-view chanlet, this is the list of content attributes that have been associated with the given chanlet. */
  contentAttributes?: Maybe<Array<MultiviewContentAttribute>>;
  /** The channel's badge flair setting and assets that are available to eligible subscribers. */
  creatorBadgeFlair?: Maybe<CreatorBadgeFlair>;
  /** Fetch the requesting user's currently playing radio content. */
  currentRadioTrack?: Maybe<RadioCurrentlyPlaying>;
  /**
   * Returns configurations for a dashboard view in different parts of Twitch, such as Stream Manager
   * or Twitch Studio. Includes configurations for things like layout and other features.
   */
  dashboardView: ChannelDashboardView;
  /** The channel's name, with user-specified formatting. */
  displayName?: Maybe<Scalars['String']>;
  /** A drop 2.0 campaign including personal settings (e.g. account connection status). (Streamer dashboard individual item). */
  dropCampaign?: Maybe<DropCampaign>;
  /** A list of all available Drops 2.0 campaigns that a channel is eligible to participate in. (Streamer dashboard list). */
  dropCampaigns?: Maybe<Array<DropCampaign>>;
  /** founderBadgeAvailability is a number of available slots for Founder Badge entitlement. */
  founderBadgeAvailability: Scalars['Int'];
  /**
   * The name of the last game played on this channel.
   * @deprecated Use user.lastBroadcast.game.name instead.
   */
  game: Scalars['String'];
  /** The Home of a channel. */
  home?: Maybe<ChannelHome>;
  /** The structure that contains information about the channel's Hype Train execution and config. */
  hypeTrain: HypeTrain;
  /** The channel's unique identfier. */
  id: Scalars['ID'];
  /**
   * A setting which states whether or not users can create Clips on this channel.
   * By default, clipping on a channel is enabled.
   * @deprecated Use channel.clipsSettings instead.
   */
  isClipsEnabled: Scalars['Boolean'];
  /** Whether or not the channel is a hidden multi-view chanlet that is only meant to be accessible through another channel and not exist as a completely independent channel. */
  isHiddenChanlet: Scalars['Boolean'];
  /**
   * Whether the broadcaster has designated the channel's broadcast for mature audiences only.
   * @deprecated Use stream.isMature instead.
   */
  isMature: Scalars['Boolean'];
  /** Whether the channel is using the new AutoMod vendor for enforcement. */
  isMemberOfAutoModRollout?: Maybe<Scalars['Boolean']>;
  /** Whether the channel has opted out of drops. */
  isOptedOutOfDrops?: Maybe<Scalars['Boolean']>;
  /** leaderboardSet contains the set of leaderboards that are active on this channel. */
  leaderboardSet?: Maybe<LeaderboardSet>;
  /** leaderboardTimePeriod indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc. */
  leaderboardTimePeriod?: Maybe<LeaderboardTimePeriodType>;
  /** All Prediction Events that are no longer accepting new predictions, and are awaiting resolution. */
  lockedPredictionEvents?: Maybe<Array<PredictionEvent>>;
  /** Retrieves video manager videos for the channel, this requires owner or editor permissions. */
  managedVideos?: Maybe<VideoConnection>;
  /** Returns a resolver to query moderation logs. */
  moderationLogs?: Maybe<ModerationLogs>;
  /** The channel's name. */
  name: Scalars['String'];
  /** The number of VIP roles a user can assign in their channel. */
  numberOfVIPsAllowed?: Maybe<Scalars['Int']>;
  /** The user who owns this channel. */
  owner?: Maybe<User>;
  /** Configurations for chanlets this channel owns. */
  ownerChanletAttributes?: Maybe<OwnerChanletAttributes>;
  /** Settings dictating how Prediction Events are run on this channel. */
  predictionSettings?: Maybe<ChannelPredictionSettings>;
  /** Fetches most recent chat messages sent for the given channel. */
  recentChatMessages: Array<Message>;
  /** A single page of Prediction Events that have been resolved. */
  resolvedPredictionEvents?: Maybe<PredictionEventConnection>;
  /** The restriction that is currently active on the channel for restricting a user's access to it. */
  restriction?: Maybe<ResourceRestriction>;
  /**
   * The stream schedule of the user.
   * Returns null when the user has not set a schedule.
   */
  schedule?: Maybe<Schedule>;
  /** The requesting user's relationship with the channel. */
  self?: Maybe<ChannelSelfEdge>;
  /** Extension information pertaining to the active user. Note that this is not part of the `self` property as this still returns data for anonymous users. */
  selfInstalledExtensions?: Maybe<Array<ExtensionInstallationSelfEdge>>;
  /** The channel's social media links and favicons. */
  socialMedias?: Maybe<Array<SocialMedia>>;
  /**
   * A user-defined status message.
   * @deprecated Use user.lastBroadcast.title instead.
   */
  status: Scalars['String'];
  /**
   * The live broadcast associated with this channel, if currently broadcasting.
   * @deprecated Use user.stream instead.
   */
  stream?: Maybe<Stream>;
  /** A list of streams for a given channel for multi-view. */
  streams?: Maybe<Array<Stream>>;
  /** Channel trailer for this channel. */
  trailer?: Maybe<Trailer>;
  /**
   * Requests from channel-banned users to be unbanned submitted on the channel.
   * Accessible by users with moderator role or higher.
   */
  unbanRequests?: Maybe<UnbanRequestConnection>;
  /** Settings for users creating unban requests on the channel. */
  unbanRequestsSettings?: Maybe<UnbanRequestsSettings>;
  /** The URL to view the channel in a browser. */
  url: Scalars['String'];
  /** Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference. */
  videoStreamSettings?: Maybe<VideoStreamSettings>;
  /** A list of available Drop 2.0 Campaigns of which drops viewers of this channel can claim when certain game events or minutes watched events are met. (Channel highlight card). */
  viewerDropCampaigns?: Maybe<Array<DropCampaign>>;
};


/** A User's place on Twitch. */
export type ChannelBannedUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A User's place on Twitch. */
export type ChannelChanletsArgs = {
  bypassDisableFlag?: InputMaybe<Scalars['Boolean']>;
  sort?: InputMaybe<ChanletSort>;
};


/** A User's place on Twitch. */
export type ChannelCommunityPointsCustomRewardRedemptionArgs = {
  id: Scalars['ID'];
};


/** A User's place on Twitch. */
export type ChannelCommunityPointsRedemptionQueueArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<CommunityPointsRedemptionQueueOptions>;
};


/** A User's place on Twitch. */
export type ChannelDashboardViewArgs = {
  type: ChannelDashboardViewType;
};


/** A User's place on Twitch. */
export type ChannelDropCampaignArgs = {
  id: Scalars['ID'];
};


/** A User's place on Twitch. */
export type ChannelLeaderboardSetArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** A User's place on Twitch. */
export type ChannelManagedVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<VideoSort>;
  statuses?: InputMaybe<Array<VideoStatus>>;
  types?: InputMaybe<Array<BroadcastType>>;
};


/** A User's place on Twitch. */
export type ChannelResolvedPredictionEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A User's place on Twitch. */
export type ChannelSelfInstalledExtensionsArgs = {
  isMobile?: InputMaybe<Scalars['Boolean']>;
};


/** A User's place on Twitch. */
export type ChannelUnbanRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<UnbanRequestsOptions>;
};

/** Channel Analytics in Creator Dashboard. */
export type ChannelAnalytics = {
  __typename?: 'ChannelAnalytics';
  /** SubCountSeries in Channel Analytics that shows a user's sub count over time. */
  subCountSeries?: Maybe<SubCountSeries>;
};

/** Analytics around what other content my viewers watch. */
export type ChannelAnalyticsContentOverlap = {
  __typename?: 'ChannelAnalyticsContentOverlap';
  /** Other channels that my viewers like to watch. */
  channels?: Maybe<Array<ChannelOverlap>>;
  /** Games that my viewers like to watch. */
  games?: Maybe<Array<GameOverlap>>;
};

/** ChannelBannedUser is an object that defines metadata about a channel ban. */
export type ChannelBannedUser = {
  __typename?: 'ChannelBannedUser';
  /** When the ban was created. */
  bannedAt: Scalars['Time'];
  /** Representation of the banned user. */
  bannedUser?: Maybe<User>;
  /** Representation of the mod that banned the user. */
  modUser?: Maybe<User>;
};

/** Paginated list of users banned from a channel. */
export type ChannelBannedUserConnection = {
  __typename?: 'ChannelBannedUserConnection';
  /** The elements of the list. */
  edges?: Maybe<Array<ChannelBannedUserEdge>>;
  /** Information about this page of banned users. */
  pageInfo: PageInfo;
};

/** Element in a list of users banned from a channel. */
export type ChannelBannedUserEdge = {
  __typename?: 'ChannelBannedUserEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A ban record for a user banned from a channel. */
  node?: Maybe<ChannelBannedUser>;
};

/** ChannelBlockedTerm is an object that defines things that automod should permit in a channel. */
export type ChannelBlockedTerm = {
  __typename?: 'ChannelBlockedTerm';
  /** If the term is permitted or banned type. */
  category: Scalars['String'];
  /** When the term was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** When the term expires at. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** If mods should be able to see and edit this term. */
  isModEditable: Scalars['Boolean'];
  /** phrases are the string representation of a term. */
  phrases: Array<Scalars['String']>;
  /** Where the term came from, usually a mod user ID. */
  source?: Maybe<Scalars['String']>;
  /** When the term was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** A challenge to which users can contribute bits. */
export type ChannelChallenge = {
  /** Total bits amount contributed. */
  bitsAmount: Scalars['Int'];
  /** Time when challenge was created. */
  createdAt: Scalars['Time'];
  /** User that created the challenge. */
  createdBy?: Maybe<User>;
  /** Amount of seconds from when the challenge starts to when it ends. */
  durationSeconds: Scalars['Int'];
  /** ID of challenge. */
  id: Scalars['ID'];
  /** User who owns this challenge. The challenge will appear on their channel. */
  ownedBy?: Maybe<User>;
  /**
   * Amount of milliseconds before the challenge times out.
   * 0 when the challenge has timed out.
   */
  remainingDurationMilliseconds: Scalars['Int'];
  /**
   * The authenticated user's relationship with this challenge.
   * Main use case is to connect the user to a challenge to allow bit contributions.
   * Null if un-authenticated user is making this query.
   */
  self?: Maybe<ChannelChallengeSelfEdge>;
  /** The status of the challenge. */
  status: ChannelChallengeStatus;
  /** Time when challenge was updated. */
  updatedAt: Scalars['Time'];
};

/** A connection between the challenge and metadata. */
export type ChannelChallengeConnection = {
  __typename?: 'ChannelChallengeConnection';
  /** The list of challenges for the user. */
  edges?: Maybe<Array<ChannelChallengeEdge>>;
  /** Information about pagination in this connection. */
  pageInfo: PageInfo;
};

/** A page entry, that contains the Challenge item and a cursor to return from the query to allow pagination. */
export type ChannelChallengeEdge = {
  __typename?: 'ChannelChallengeEdge';
  /** Cursor used for next query. */
  cursor: Scalars['Cursor'];
  /** The underlying challenge. */
  node: ChannelChallenge;
};

/** A participant contributing to a challenge and associated information. */
export type ChannelChallengeParticipant = {
  __typename?: 'ChannelChallengeParticipant';
  /** The bits this participant has contributed to a challenge. */
  bits: Scalars['Int'];
  /** The Challenge this participant contributed to. */
  challenge?: Maybe<ChannelChallenge>;
  /** Time when participant first contributed to the challenge. */
  firstContributedAt: Scalars['Time'];
  /** id of the participant in the challenge. */
  id: Scalars['ID'];
  /** Time when participant last contributed to the challenge. */
  lastContributedAt: Scalars['Time'];
};

/** A connection between a challenge and the authenticated user. */
export type ChannelChallengeSelfEdge = {
  __typename?: 'ChannelChallengeSelfEdge';
  /** The participant object pertaining to the authenticated user. */
  participant?: Maybe<ChannelChallengeParticipant>;
};

/** Possible sort orders for lists of challenges. */
export enum ChannelChallengeSort {
  /** Sort the challenges by time. */
  EndTime = 'END_TIME',
  /** Sort the challenges by time. */
  StartTime = 'START_TIME'
}

/** The status of the challenge. */
export enum ChannelChallengeStatus {
  /** Challenge is active. Users can contribute bits, with the challenge information publicly visible. */
  Active = 'ACTIVE',
  /** Challenge was manually ended by a user and marked as "completed". Users cannot contribute bits. Challenge information publicly visible. */
  Completed = 'COMPLETED',
  /** Challenge was manually ended by a user and marked as "failed". Users cannot contribute bits. Challenge information publicly visible. */
  Failed = 'FAILED',
  /** Challenge has ended and is no longer publicly visible. Users cannot contribute bits. Challenge information publicly visible. */
  TimedOut = 'TIMED_OUT',
  /** Encountered some challenge status that we do not know how to handle. */
  Unknown = 'UNKNOWN'
}

/** ChannelClipsCreationAuthRestrictionOptionsInput are the additional options for the auth restrictions. */
export type ChannelClipsCreationAuthRestrictionOptionsInput = {
  /** The time requirement in minutes, of how long a follower needs to be following to create clips. */
  followingLengthMinutes?: InputMaybe<Scalars['Int']>;
};

/**
 * ChannelClipsCreationRestrictedTo contains the roles that are allowed to create Clips on a channel
 * that has isClipsEnabled set to true.
 */
export type ChannelClipsCreationRestrictedTo = {
  __typename?: 'ChannelClipsCreationRestrictedTo';
  /** Clip creation is restricted to users that are followers. */
  isFollower: Scalars['Boolean'];
  /** Clip creation is restricted to users that are subscribers. */
  isSubscriber: Scalars['Boolean'];
};

/**
 * ChannelClipsCreationRestrictedToInput contains the roles that are allowed to create Clips on a channel
 * that has isClipsEnabled set to true.
 */
export type ChannelClipsCreationRestrictedToInput = {
  /** Allow channel followers to create Clips. */
  followers: Scalars['Boolean'];
  /** Allow channel subscribers to create Clips. */
  subscribers: Scalars['Boolean'];
};

/** ChannelClipsCreationRestrictionOptions are the additional options for the auth restrictions. */
export type ChannelClipsCreationRestrictionOptions = {
  __typename?: 'ChannelClipsCreationRestrictionOptions';
  /** The time requirement in minutes, of how long a follower needs to be following to create clips. */
  followingLengthMinutes?: Maybe<Scalars['Int']>;
};

/** ChannelClipsSettings are the clips setting for the channel, including restriction settings for clip creation. */
export type ChannelClipsSettings = {
  __typename?: 'ChannelClipsSettings';
  /** If isClipsEnabled is true, allow the following roles to create Clips on the channel. */
  creationRestrictedTo?: Maybe<ChannelClipsCreationRestrictedTo>;
  /** If there are clip creation restrictions, use the following to add options to those restrictions. */
  creationRestrictionOptions?: Maybe<ChannelClipsCreationRestrictionOptions>;
  /** Set whether or not users can create Clips on this channel. */
  isClipsCreationEnabled: Scalars['Boolean'];
};

/**
 * Data about a single configured Mosaic layout. This layout
 * specifies a configuration of panel dimensions and positions
 * in a grid, as defined by the Mosaic algorithm.
 */
export type ChannelDashboardLayout = {
  /** A unique identifier to uniquely reference this layout. */
  id: Scalars['ID'];
  /** When the layout was last updated */
  lastUpdated?: Maybe<Scalars['Time']>;
  /** The display name for the layout shown to the user. */
  name: Scalars['String'];
  /**
   * A version to identify how the layout was generated,
   * such as for deprecation purposes.
   */
  version: Scalars['String'];
};

/**
 * A view for editing a channel, including panels, layouts, options, etc.
 * Includes views like Stream Manager, Twitch Studio, etc.
 */
export type ChannelDashboardView = {
  __typename?: 'ChannelDashboardView';
  /** Panel layout configurations for this view type. */
  layouts?: Maybe<Array<ChannelDashboardLayout>>;
  /**
   * Information about the view pertaining to the current channel for the
   * current user, such as how many custom layouts have been used.
   */
  options: ChannelDashboardViewOptions;
};

/**
 * Details about the specific data of a layout type for
 * a channel, such as the number of custom layouts available
 * for use by the current user.
 */
export type ChannelDashboardViewOptions = {
  __typename?: 'ChannelDashboardViewOptions';
  /**
   * Total (maximum) number of custom layouts the user can use for the channel
   * for the specific dashboard view type.
   */
  customLayoutsTotal?: Maybe<Scalars['Int']>;
  /** Amount of layouts the user has used for the channel for a specific dashboard view type. */
  customLayoutsUsed?: Maybe<Scalars['Int']>;
};

/** What channel feature the dashboard view is for. */
export enum ChannelDashboardViewType {
  /** Views for Stream Manager layout panels and other components. */
  StreamManager = 'STREAM_MANAGER',
  /** Views for Twitch Studio layout panels. */
  TwitchStudio = 'TWITCH_STUDIO'
}

/** The Home of a channel. */
export type ChannelHome = {
  __typename?: 'ChannelHome';
  /** The preferences that power a channel's home page. */
  preferences?: Maybe<ChannelHomePreferences>;
  /** The shelves that are shown on a channel's home page. */
  shelves?: Maybe<ChannelHomeShelves>;
};

/** A list of categories displayed on a channel home's Category Shelf. */
export type ChannelHomeCategoryShelf = {
  __typename?: 'ChannelHomeCategoryShelf';
  /** The list of categories to display in the shelf. */
  edges: Array<ChannelHomeCategoryShelfEdge>;
};

/** The edges of the channel home category shelf. */
export type ChannelHomeCategoryShelfEdge = {
  __typename?: 'ChannelHomeCategoryShelfEdge';
  /** The category to display in the shelf. */
  node?: Maybe<Game>;
};

/** A list of categories displayed on a channel home's Category Shelf. */
export type ChannelHomeCategorySuggestionsShelf = {
  __typename?: 'ChannelHomeCategorySuggestionsShelf';
  /** The list of categories to display in the shelf. */
  edges: Array<ChannelHomeCategorySuggestionsShelfEdge>;
};

/** Contains a category and a boolean to denote whether the user has chosen to hide that category from their channel home page's category shelf. */
export type ChannelHomeCategorySuggestionsShelfEdge = {
  __typename?: 'ChannelHomeCategorySuggestionsShelfEdge';
  /** This is true if the user has chosen to hide this category from their category shelf. */
  isHidden: Scalars['Boolean'];
  /** The category. */
  node?: Maybe<Game>;
};

/** The streamer's channel home preferences. */
export type ChannelHomePreferences = {
  __typename?: 'ChannelHomePreferences';
  /** The hero preset. */
  heroPreset: HeroPreset;
  /** The type of streamer shelf to display. */
  streamerShelfType: StreamerShelfType;
};

/** The shelves that are shown on a channel's home page. */
export type ChannelHomeShelves = {
  __typename?: 'ChannelHomeShelves';
  /** A list of categories displayed on a channel home's Category Shelf. */
  categoryShelf?: Maybe<ChannelHomeCategoryShelf>;
  /** A list of suggested categories to display on a channel home's Category Shelf. */
  categoryShelfSuggestions?: Maybe<ChannelHomeCategorySuggestionsShelf>;
  /** The type and, if applicable, the list of users displayed in a channel home's Streamer Shelf. */
  streamerShelf?: Maybe<ChannelHomeStreamerShelf>;
};


/** The shelves that are shown on a channel's home page. */
export type ChannelHomeShelvesCategoryShelfArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** The shelves that are shown on a channel's home page. */
export type ChannelHomeShelvesCategoryShelfSuggestionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** The shelves that are shown on a channel's home page. */
export type ChannelHomeShelvesStreamerShelfArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

/** The list of users displayed in a channel home's Streamer Shelf. */
export type ChannelHomeStreamerShelf = {
  __typename?: 'ChannelHomeStreamerShelf';
  /** The list of users to display in the shelf. */
  edges: Array<ChannelHomeStreamerShelfEdge>;
  /** The type of streamer shelf to display (Autohost, Team, or Disabled). */
  type: StreamerShelfType;
};

/** The edges of the channel home streamer shelf. */
export type ChannelHomeStreamerShelfEdge = {
  __typename?: 'ChannelHomeStreamerShelfEdge';
  /** The user to display in the shelf. */
  node?: Maybe<User>;
};

/** Paginated list of moderation actions on a channel. */
export type ChannelModerationActionConnection = {
  __typename?: 'ChannelModerationActionConnection';
  /** List of moderation actions. */
  edges?: Maybe<Array<ChannelModerationActionEdge>>;
  /** Information about page. */
  pageInfo: PageInfo;
};

/** Element in a list of moderation actions of a user on a channel. */
export type ChannelModerationActionEdge = {
  __typename?: 'ChannelModerationActionEdge';
  /** A cursor for the current node. */
  cursor: Scalars['Cursor'];
  /** A moderation action. */
  node?: Maybe<ChannelModerationActionEntry>;
};

/** An entry of a moderation action performed on a channel. */
export type ChannelModerationActionEntry = {
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
};

/**
 * Moderation Actions relating to automod levels.
 * ex: automod level change.
 */
export type ChannelModerationActionOnAutomodLevelEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnAutomodLevelEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** New automod level properties (based on Sift categories, to be deprecated). */
  automodNewProperties?: Maybe<AutoModProperties>;
  /** Previous automod level properties (based on Sift categories, to be deprecated). */
  automodOldProperties?: Maybe<AutoModProperties>;
  /** Previous automod level properties. */
  automodPreviousLevels?: Maybe<AutoModConfiguration>;
  /** The newly updated automod level properties. */
  automodUpdatedLevels?: Maybe<AutoModConfiguration>;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
};

/**
 * Moderation Actions relating to automod terms.
 * ex: add permitted term, remove permitted term, add banned term, remove banned term.
 */
export type ChannelModerationActionOnAutomodTermEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnAutomodTermEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** If the action originated from a message caught by Automod. */
  isFromAutomod: Scalars['Boolean'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
  /** Strings that were add/deleted from permitted/blocked lists. */
  terms?: Maybe<Array<Scalars['String']>>;
};

/**
 * Moderation Actions relating to another channel.
 * ex: host, unhost, raid, unraid.
 */
export type ChannelModerationActionOnChannelEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnChannelEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** Is auto hosted. */
  isAutoHosted: Scalars['Boolean'];
  /** Is hosted after raiding. */
  isHostedAfterRaiding: Scalars['Boolean'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
  /** Should the viewer count for host or raids should be shown. */
  shouldRevealViewerCount: Scalars['Boolean'];
  /** Target channel for hosting and raiding. */
  target?: Maybe<User>;
  /** How many users participated in a host or raid. */
  viewerCount?: Maybe<Scalars['Int']>;
};

/**
 * Moderation Actions relating to chat messages.
 * ex: delete message.
 */
export type ChannelModerationActionOnChatMessageEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnChatMessageEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The message contents of the message deleted. */
  messageBody?: Maybe<Scalars['String']>;
  /** The id of the message deleted. */
  messageID?: Maybe<Scalars['ID']>;
  /** The sender of the message. */
  messageSender?: Maybe<User>;
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
};

/**
 * Moderation Actions realting to chat modes.
 * ex: slow on, followers only on, emotes only, sub only, clear chat.
 */
export type ChannelModerationActionOnChatModeEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnChatModeEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** Duration of the chat time in seconds. */
  durationSeconds?: Maybe<Scalars['Int']>;
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
};

/**
 * Moderation Actions relating to unban requests.
 * ex: approve, deny.
 */
export type ChannelModerationActionOnUnbanRequestsEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnUnbanRequestsEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
  /** Reason for action. */
  reason: Scalars['String'];
  /** The user which the action targets if any. */
  target?: Maybe<User>;
};

/**
 * Moderation Actions relating to a user.
 * ex: ban, unban, timeout, untimeout, mod, unmod, vip, unvip.
 */
export type ChannelModerationActionOnUserEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOnUserEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** Duration of the chat time in seconds for timeouts. */
  durationSeconds?: Maybe<Scalars['Int']>;
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
  /** Reason for action. */
  reason: Scalars['String'];
  /** The user which the action targets if any. */
  target?: Maybe<User>;
};

/** Moderation Actions that are unused, invalid or deprecated. */
export type ChannelModerationActionOtherEntry = ChannelModerationActionEntry & {
  __typename?: 'ChannelModerationActionOtherEntry';
  /** The action that was taken. */
  action: ModerationAction;
  /** Timestamp when action was taken. */
  createdAt: Scalars['Time'];
  /** UUID of the moderation action. */
  id: Scalars['ID'];
  /** The moderator who took the action. */
  moderator?: Maybe<User>;
};

export type ChannelNotificationSetting = {
  __typename?: 'ChannelNotificationSetting';
  /** The setting category. */
  category: Scalars['String'];
  /** Whether this setting is on or off for the given event. */
  isEnabled: Scalars['Boolean'];
  /** The exact state of the setting. ("on", "off", "friends_only", etc). */
  settingState: Scalars['String'];
};

/** Data about notification settings for a follow relationship. */
export type ChannelNotificationSettings = {
  __typename?: 'ChannelNotificationSettings';
  /** If true, enabled notifications will be send. If false, all notifications are disabled, even if their individual setting is enabled. */
  isEnabled: Scalars['Boolean'];
  /** A list of channel notification settings. */
  nodes: Array<ChannelNotificationSetting>;
};

/** Channel that my viewers also like to watch. */
export type ChannelOverlap = {
  __typename?: 'ChannelOverlap';
  /** How much my viewers like to watch this channel. */
  score: Scalars['Float'];
  /** Channel that my viewers also like to watch. */
  viewersAlsoWatch?: Maybe<User>;
};

/** An enumeration of permissions a user can have on a channel. */
export enum ChannelPermission {
  /** Permission to manage Chanlets, which represent sub-streams in a multiview mode. */
  MultiviewAdmin = 'MULTIVIEW_ADMIN',
  /** Permission to create restrictions on the channel. */
  SetChannelRestriction = 'SET_CHANNEL_RESTRICTION'
}

/** ChannelPermittedTerm is an object that defines things that automod should permit in a channel. */
export type ChannelPermittedTerm = {
  __typename?: 'ChannelPermittedTerm';
  /** If the term is permitted or banned type. */
  category: Scalars['String'];
  /** When the term was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** When the term expires at. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** If mods should be able to see and edit this term. */
  isModEditable: Scalars['Boolean'];
  /** phrases are the string representation of a term. */
  phrases: Array<Scalars['String']>;
  /** Where the term came from, usually a mod user ID. */
  source?: Maybe<Scalars['String']>;
  /** When the term was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** Settings dictating how Prediction Events are run on a channel. */
export type ChannelPredictionSettings = {
  __typename?: 'ChannelPredictionSettings';
  /** Whether channel moderators are allowed to create and resolve Prediction Events. */
  canModeratorsManagePredictions: Scalars['Boolean'];
  /** Whether the channel is allowed to run Prediction Events at all. */
  isEligibleForPredictions: Scalars['Boolean'];
};

/** A restriction for a specific channel. */
export type ChannelRestriction = {
  __typename?: 'ChannelRestriction';
  /** The time that the restriction is no longer active. */
  endsAt?: Maybe<Scalars['Time']>;
  /**
   * Information about being exempt from the restriction.
   * @deprecated Use resourceRestriction.exemptions instead.
   */
  exemptionInfo: ChannelRestrictionExemptionInfo;
  /** The ID of the channel restriction. */
  id: Scalars['ID'];
  /** The time that the restriction becomes active. */
  startsAt?: Maybe<Scalars['Time']>;
  /** The type of restriction on this channel. */
  type: ChannelRestrictionType;
};

/** Exemption information for a specific channel restriction. */
export type ChannelRestrictionExemptionInfo = {
  __typename?: 'ChannelRestrictionExemptionInfo';
  /**
   * The type of exemption.
   * @deprecated Use channelRestriction.type instead.
   */
  exemptionType: Scalars['String'];
};

/** An enumeration of the different restriction types. */
export enum ChannelRestrictionType {
  /** The channel is restricted by the All-Access Pass. */
  AllAccessPass = 'ALL_ACCESS_PASS',
  /** The channel is restricted by a subscription. */
  SubOnlyLive = 'SUB_ONLY_LIVE',
  /** The resource is restricted for an unknown reason. */
  Unknown = 'UNKNOWN'
}

/** Information about the requesting user with respect to a channel. */
export type ChannelSelfEdge = {
  __typename?: 'ChannelSelfEdge';
  /** Whether or not the requesting user can request an unban on the channel. */
  canRequestUnban?: Maybe<Scalars['Boolean']>;
  /**
   * Properties relating to the authenticated user's community points in a channel.
   * Null if community points are not enabled in the channel.
   */
  communityPoints?: Maybe<CommunityPointsProperties>;
  /** Whether or not the requesting user is authorized to view the channel's content in a channel restrictions context. */
  isAuthorized: Scalars['Boolean'];
  /** Whether or not the resource is restricted for the requesting user. */
  isResourceRestricted: Scalars['Boolean'];
  /** Returns the user's last unban request on the channel. */
  lastUnbanRequest?: Maybe<UnbanRequest>;
  /** Chat messages sent in a channel that are relevant to moderators. */
  modChatLogs?: Maybe<ModLogsMessageConnection>;
  /** List of channel feature permissions the logged in user has on the channel. */
  permissions: Array<ChannelPermission>;
  /** List of recent (either still active or recently resolved) Predictions made by this user on this Channel. */
  recentPredictions?: Maybe<Array<Prediction>>;
  /** If restricted, how the resource is restricted. */
  restrictionType?: Maybe<ResourceRestrictionType>;
  /** Reason why user cannot request an unban on the channel. */
  unbanRequestRestriction?: Maybe<UnbanRequestRestrictionReason>;
};


/** Information about the requesting user with respect to a channel. */
export type ChannelSelfEdgeModChatLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAutoModCaughtMessages?: InputMaybe<Scalars['Boolean']>;
  includeMessageCount?: InputMaybe<Scalars['Boolean']>;
  includeTargetedActions?: InputMaybe<Scalars['Boolean']>;
  order?: InputMaybe<SortOrder>;
};

/** The possible user roles within a channel. */
export enum ChannelUserRole {
  /** The channel owner. */
  Broadcaster = 'BROADCASTER',
  /** An editor for the channel. */
  Editor = 'EDITOR',
  /** A moderator for the channel. */
  Moderator = 'MODERATOR',
  /** A user with no roles. */
  Regular = 'REGULAR',
  /** A subscriber of the channel. */
  Subscriber = 'SUBSCRIBER'
}

/** Channel/Viewer pair. */
export type ChannelViewer = {
  __typename?: 'ChannelViewer';
  /**
   * Fetches global badges and channel badges earned by the User on a channel.
   * The returned list of badges will exclude badges that userID has elected to hide.
   * If the user is the authenticated user, Badge.self.isVisibleInChatCard will reflect
   * the user's stored preference, which can be editted on a per-badge basis with the
   * setBadgePublicVisiblity mutation.
   */
  earnedBadges?: Maybe<Array<Badge>>;
  /** ID of the form userID:channelID. */
  id: Scalars['ID'];
};

/** Information about the intended device for making a refill purchase for a user. */
export type ChargeInstrument = {
  __typename?: 'ChargeInstrument';
  /** A charge instrument Id. */
  id: Scalars['ID'];
};

/** Input charge instrument information. */
export type ChargeInstrumentInput = {
  /** A charge instrument Id. */
  id: Scalars['ID'];
};

/** ChargeModel describes the model used for charging the user. Will only contain one credit model, one external model, or one internal model. */
export type ChargeModel = {
  __typename?: 'ChargeModel';
  /** A charge model in which a user is charged using credits purchased or earned on Twitch. */
  credit?: Maybe<CreditChargeModel>;
  /** A charge model in which a user is charged via a third-party in a fiat currency. */
  external?: Maybe<ExternalChargeModel>;
  /** A charge model in which a user is charged by Twitch in a fiat currency. */
  internal?: Maybe<InternalChargeModel>;
};

/** ChargeModelPlan defines the payment plan of the charge model. */
export type ChargeModelPlan = {
  __typename?: 'ChargeModelPlan';
  /** The time interval for the charge model. */
  interval: ChargeModelPlanInterval;
  /** The renewal policy for the charge model. */
  renewalPolicy: RenewalPolicy;
};

/** ChargeModelPlanInterval is the time interval for the charge model. */
export type ChargeModelPlanInterval = {
  __typename?: 'ChargeModelPlanInterval';
  /** The duration of the charge model interval (used with the unit). */
  duration: Scalars['Int'];
  /** The unit of the charge model interval. */
  unit: ChargeModelPlanIntervalUnit;
};

/** ChargeModelPlanIntervalUnit defines the unit of the charge model interval. */
export enum ChargeModelPlanIntervalUnit {
  /** Interval unit of Days. */
  Days = 'DAYS',
  /** Interval unit of Months. */
  Months = 'MONTHS',
  /** Unknown interval unit. */
  Unknown = 'UNKNOWN'
}

/** ChatPauseSetting represents the possible settings for the user's preferred way to pause chat when moderating. */
export enum ChatPauseSetting {
  /** ALTKEY pauses chat when the user presses the alt key (option for mac users). It unpauses when the key is released. */
  Altkey = 'ALTKEY',
  /** MOUSEOVER pauses chat whenever a user's mouse hovers over the list, unpauses automatically after 5 seconds if no scroll is performed. */
  Mouseover = 'MOUSEOVER',
  /** MOUSEOVER_ALTKEY pauses chat on mouse hover and hitting the alt key. */
  MouseoverAltkey = 'MOUSEOVER_ALTKEY',
  /** SCROLL_ONLY is the default behavior and pauses chat every time the users scrolls over the chat list. */
  ScrollOnly = 'SCROLL_ONLY'
}

/** Reasons that a user might not be allowed to chat in a specific channel. */
export enum ChatRestrictedReason {
  /**
   * The user is prevented from chatting by followers-only mode. They should
   * either follow the channel, or wait longer to satisfy the required time.
   * See user.self.follower.followedAt for when the user followed, and
   * user.self.chatSettings.followersOnlyDurationMinutes for the minimum
   * required follow time.
   */
  FollowersOnly = 'FOLLOWERS_ONLY',
  /**
   * The user is prevented from chatting without a verified phone number.
   * They will be prompted to verify one upon chatting.
   */
  RequireVerifiedPhoneNumber = 'REQUIRE_VERIFIED_PHONE_NUMBER',
  /**
   * The user can't chat because they've chatted too recently. See
   * user.self.lastRecentChatMessageAt to calculate how much time is remaining
   * before they can chat again.
   */
  SlowMode = 'SLOW_MODE',
  /**
   * The user is prevented from chatting by subscribers-only mode. They should
   * subscribe to the channel to chat.
   */
  SubscribersOnly = 'SUBSCRIBERS_ONLY',
  /**
   * The user is prevented from chatting by verified-only mode. They should
   * verify their account to chat.
   */
  VerifiedOnly = 'VERIFIED_ONLY'
}

export type ChatRoomBanStatus = {
  __typename?: 'ChatRoomBanStatus';
  /** The user being banned of this chat. */
  bannedUser?: Maybe<User>;
  /** The time the ban was imposed. */
  createdAt: Scalars['Time'];
  /** The time at which the ban will automatically expire. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** The time in ms at which the ban will expire. */
  expiresInMs?: Maybe<Scalars['Int']>;
  /** Conveys if the ban is permanent. */
  isPermanent: Scalars['Boolean'];
  /** The moderator that carried out the action. */
  moderator?: Maybe<User>;
  /** The reason the user was banned. */
  reason?: Maybe<Scalars['String']>;
  /** The entity representing the users channel or chat room. */
  roomOwner?: Maybe<User>;
};

/** ChatSettings are settings and rules for chatting in a channel. */
export type ChatSettings = {
  __typename?: 'ChatSettings';
  /**
   * autoModLevel is an integer from 0-4 representing the level of automoderation of chat
   * 0 is off, 4 is the highest level of moderation.
   * @deprecated No longer used.
   */
  autoModLevel: Scalars['Int'];
  /** blockLinks indicates if links should be deleted from non-mod messages. */
  blockLinks: Scalars['Boolean'];
  /** chatDelayMs is the delay before non-mods see a message. */
  chatDelayMs: Scalars['Int'];
  /**
   * The number of minutes a user must be following the broadcaster in order to chat
   * If value is null, followers only mode is not enabled.
   */
  followersOnlyDurationMinutes?: Maybe<Scalars['Int']>;
  /**
   * isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
   * match their language.
   * @deprecated No longer used.
   */
  isBroadcasterLanguageModeEnabled: Scalars['Boolean'];
  /** Indicates whether chat is currently enforcing that messages may only contain emotes. */
  isEmoteOnlyModeEnabled: Scalars['Boolean'];
  /** Indicates whether subscribers are allowed to bypass slowmode. */
  isFastSubsModeEnabled: Scalars['Boolean'];
  /**
   * If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
   * be inserted into automod if the channel has automod enabled.
   * @deprecated No longer used.
   */
  isOptedOutOfGlobalBannedWordsList: Scalars['Boolean'];
  /** Indicates whether chat is currently restricted to subscribers only. */
  isSubscribersOnlyModeEnabled: Scalars['Boolean'];
  /**
   * Indicates whether chat is currently enforcing that messages must be reasonably unique
   * from recent messages. Previously known as "r9k mode".
   */
  isUniqueChatModeEnabled: Scalars['Boolean'];
  /** requireVerifiedAccount indicates if users must be verified to chat. */
  requireVerifiedAccount: Scalars['Boolean'];
  /** rules is a list of rules to display to users when joining a chat channel. */
  rules: Array<Scalars['String']>;
  /**
   * The number of seconds a user must wait in between sending chat messages
   * If value is null, slow mode is not enabled.
   */
  slowModeDurationSeconds?: Maybe<Scalars['Int']>;
};

/**
 * ChatTheme is a client-side UI theme.
 * It can be used to provide different images based on the dominant background color they are designed to display on.
 */
export enum ChatTheme {
  Dark = 'DARK',
  Light = 'LIGHT'
}

/** Various user specific settings on how to render chat. */
export type ChatUiSettings = {
  __typename?: 'ChatUISettings';
  /** Setting to store the user's preferred way to pause chat when moderating. */
  chatPauseSetting?: Maybe<ChatPauseSetting>;
  /** Setting for how deleted messages should be displayed for channel broadcaster or moderator. */
  deletedMessageDisplaySetting?: Maybe<DeletedMessageDisplaySetting>;
  /** Whether emote animations are enabled. */
  isEmoteAnimationsEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether the emote animations setting callout has been dismissed. */
  isEmoteAnimationsSettingCalloutDismissed?: Maybe<Scalars['Boolean']>;
  /** Whether readable chat colors are enabled. */
  isReadableChatColorsEnabled?: Maybe<Scalars['Boolean']>;
};

/** User info about the chatter. */
export type Chatter = {
  __typename?: 'Chatter';
  /** User login of the chatter. */
  login: Scalars['String'];
};

/** Information about the active chatters on a channel. */
export type ChattersInfo = {
  __typename?: 'ChattersInfo';
  /** List with the broadcaster. */
  broadcasters: Array<Chatter>;
  /** Number of active chatters. */
  count: Scalars['Int'];
  /** List of active moderators. */
  moderators: Array<Chatter>;
  /** List of active staff members. */
  staff: Array<Chatter>;
  /** List of active viewers. */
  viewers: Array<Chatter>;
  /** List of active VIPs. */
  vips: Array<Chatter>;
};

/** Actions required when initiating a checkout flow. */
export enum CheckoutAction {
  /** Action to indicate this user is authorized to make purchases. */
  AuthorizedUser = 'AUTHORIZED_USER',
  /** Action to block saved payment methods. */
  BlockSavedPaymentMethod = 'BLOCK_SAVED_PAYMENT_METHOD',
  /** Action to disable new credit cards from being added on purchases. */
  DisableNewCreditCard = 'DISABLE_NEW_CREDIT_CARD',
  /** Action to disable new credit cards from being added on purchases. */
  DisableNewDirectDebit = 'DISABLE_NEW_DIRECT_DEBIT',
  /** Action to show velocity limit CTA. */
  ExceededVelocityLimits = 'EXCEEDED_VELOCITY_LIMITS',
  /** Action to indicate xsolla should be prioritized. */
  PrioritizeXsolla = 'PRIORITIZE_XSOLLA',
  /** Action to show the user enabled 2FA before saving their payment method. */
  VerifiedSavedPaymentMethod = 'VERIFIED_SAVED_PAYMENT_METHOD'
}

/** Configs that help initiate the bits checkout flow. */
export type CheckoutConfiguration = {
  __typename?: 'CheckoutConfiguration';
  /** Contains configuration (e.g. iFrameURL) to enable completing purchases via Xsolla, a payment provider. */
  xsolla?: Maybe<Xsolla>;
};


/** Configs that help initiate the bits checkout flow. */
export type CheckoutConfigurationXsollaArgs = {
  giftRecipientIDs?: InputMaybe<Array<Scalars['ID']>>;
  isDarkMode?: InputMaybe<Scalars['Boolean']>;
  offerTagBindings?: InputMaybe<Array<OfferTagBindingInput>>;
  paymentSession?: InputMaybe<PaymentSession>;
  productID?: InputMaybe<Scalars['ID']>;
  productType?: InputMaybe<PurchaseableProductType>;
  quantity?: InputMaybe<Scalars['Int']>;
  tenantTracking?: InputMaybe<Scalars['String']>;
};

/** Inputs for checkoutConfiguration. */
export type CheckoutConfigurationInput = {
  /** Whether the gift is anonymous. */
  isAnonymous?: InputMaybe<Scalars['Boolean']>;
  /** Whether the purchase is a gift. */
  isGift: Scalars['Boolean'];
  /** Whether the user is reactivating their subscription with a recurring or non-recurring payment plan. */
  isReactivateRecurring?: InputMaybe<Scalars['Boolean']>;
  /** The number of gifts being purchased. */
  mysteryGiftCount?: InputMaybe<Scalars['Int']>;
  /** Payment's session tracking. */
  paymentSession?: InputMaybe<PaymentSession>;
  /** The ID of the gift recipient. */
  recipientID?: InputMaybe<Scalars['ID']>;
  /** The country code for tax purposes. */
  taxCountryCode?: InputMaybe<Scalars['String']>;
};

/** Price information about an item in the checkout process. */
export type CheckoutPriceSummary = {
  __typename?: 'CheckoutPriceSummary';
  /** The currency associated with the price of a subscription product. */
  currency: Currency;
  /** The description associated with pricing information. */
  description: Scalars['String'];
  /** The discounted total with breakdown by discounted price and tax. */
  discount?: Maybe<DiscountBreakdown>;
  /** The ISO-4217 wording of deriving price. */
  exponent: Scalars['Int'];
  /** Identifier used for caching. */
  id: Scalars['ID'];
  /** If the tax is already included in price. */
  isTaxInclusive: Scalars['Boolean'];
  /** The numerical price of a subscription product. */
  price: Scalars['Int'];
  /** Pricing identifier of the item being purchased. */
  pricingIdentifier: Scalars['String'];
  /** The tax rate of localized product. */
  tax: Scalars['Int'];
  /** The total price given price and tax. */
  total: Scalars['Int'];
};

/** CheerInfo is the channel-specific bits/cheer settings and current state. */
export type CheerInfo = {
  __typename?: 'CheerInfo';
  /** Gets the list of available bits badges the user offers. */
  availableBadges?: Maybe<Array<Badge>>;
  /**
   * Badge tier emotes are the emotes in this channel that are unlocked when a user unlocks a Bits badge tier.
   * Filter determines which emotes are returned.
   */
  badgeTierEmotes: Array<Maybe<Emote>>;
  /** cheerGroups contain all of the channel-specific Cheermotes, grouped by type. */
  cheerGroups: Array<CheermoteGroup>;
  /**
   * emotes are the metadata about the different cheermotes that can be use to cheer in this channel.
   * This can optionally be filtered to return only certain cheermotes by either prefix and/or emote types.
   * If `prefixes` is null or empty all available cheermotes will be returned, and then `type` filter
   * will be applied to the result unless it's null or empty.
   * If includeUpperTiers is true, the upper tiers of the cheermotes will be returned.
   * @deprecated Scheduled to be removed. Use cheerGroups instead
   */
  emotes: Array<Maybe<Cheermote>>;
  /**
   * hashtags for augmenting cheering with different actions, such as #charity will donate bits to
   * charity, or like #eddie to cheer and support Eddie.
   * @deprecated Hashtags is no longer a supported feature.
   */
  hashtags?: Maybe<BitsHashtagConnection>;
  id: Scalars['ID'];
  /** leaderboard contains the top users by number of bits cheered for the channel. */
  leaderboard?: Maybe<BitsLeaderboard>;
  /**
   * recentTimeoutMs is the remaining duration the recent message will be pinned for.
   * This feature is deprecated and will always return 0.
   * @deprecated Recent cheer is a a removed feature, this functionality shouldn't be used anymore.
   */
  recentTimeoutMs: Scalars['Int'];
  /** settings are the channel-specific cheer settings. */
  settings: CheerSettings;
};


/** CheerInfo is the channel-specific bits/cheer settings and current state. */
export type CheerInfoBadgeTierEmotesArgs = {
  filter: BadgeTierEmotesFilter;
};


/** CheerInfo is the channel-specific bits/cheer settings and current state. */
export type CheerInfoEmotesArgs = {
  includeSponsored?: InputMaybe<Scalars['Boolean']>;
  includeUpperTiers?: InputMaybe<Scalars['Boolean']>;
  prefixes?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<Array<CheermoteType>>;
};


/** CheerInfo is the channel-specific bits/cheer settings and current state. */
export type CheerInfoHashtagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** CheerInfo is the channel-specific bits/cheer settings and current state. */
export type CheerInfoLeaderboardArgs = {
  first: Scalars['Int'];
};

/** Bits partner settings associated with the badges. */
export type CheerPartnerBadgeSettings = {
  __typename?: 'CheerPartnerBadgeSettings';
  /** Whether or not the broadcaster is enabled to upload bits badge tier emote rewards. */
  canUploadBadgeTierEmoticons?: Maybe<Scalars['Boolean']>;
  /** A list of tiers, starting from 1 bit to as high as 5,000,000 bits. */
  tiers: Array<BitsBadgeTier>;
};

/** Bits partner settings associated with the chat message. */
export type CheerPartnerChatMessageSettings = {
  __typename?: 'CheerPartnerChatMessageSettings';
  /** The setting that controls if the user has project v enabled on their channel. */
  isOptedOutOfProjectV: Scalars['Boolean'];
  /** The minimum setting that controls the minimum bits that must be part of a cheer emote. */
  minBitsPerEmote: Scalars['Int'];
  /** The minimum setting that controls the minimum amount a user must cheer in the channel. */
  minBitsToCheer: Scalars['Int'];
};

/** Bits partner dashboard settings for the bits cheer bomb events. */
export type CheerPartnerCheerBombSettings = {
  __typename?: 'CheerPartnerCheerBombSettings';
  /** Flag that is true if the user has opted out of seasonal cheer bomb events. */
  isOptedOut: Scalars['Boolean'];
};

/** Bits partner settings for custom cheermote prefix. */
export type CheerPartnerCustomPrefixSettings = {
  __typename?: 'CheerPartnerCustomPrefixSettings';
  /** Flag that is set if the user has the custom cheermote prefix enabled. */
  isEnabled: Scalars['Boolean'];
  /** The prefix string that is used in their channel for their custom cheermote. */
  prefix: Scalars['String'];
  /** The custom prefix images that have been uploaded by the user. */
  tiers?: Maybe<Array<CheermoteTier>>;
};

/** Bits partner dashboard settings for the bits leaderboard. */
export type CheerPartnerLeaderboardSettings = {
  __typename?: 'CheerPartnerLeaderboardSettings';
  /** Flag that is true if the user has bits leaderboards turned on. */
  isEnabled: Scalars['Boolean'];
  /** The time period the user wants the leaderboard to be displayed as. */
  timePeriod: LeaderboardTimePeriodType;
};

/** Bits partner settings associated with recent cheers. */
export type CheerPartnerRecentCheerSettings = {
  __typename?: 'CheerPartnerRecentCheerSettings';
  /** Flag that when true pins the recent cheer to their channel. */
  canPin: Scalars['Boolean'];
  /** The minimum bits a user must cheer to show their cheer on the chat header. */
  minimumBits: Scalars['Int'];
  /** The amount of time a recent cheer is shown before being dismissed. */
  timeoutMilliseconds: Scalars['Int'];
};

/** Cheer settings, configured in their partner dashboard. */
export type CheerPartnerSettings = {
  __typename?: 'CheerPartnerSettings';
  /** Partner settings related to bit badges. */
  badges?: Maybe<CheerPartnerBadgeSettings>;
  /** Partner settings related to chat messages with bits. */
  chatMessage: CheerPartnerChatMessageSettings;
  /** Partner settings related to seasonal cheer bomb events. */
  cheerBomb: CheerPartnerCheerBombSettings;
  /** Partner settings related to the custom cheermote prefix. */
  customPrefix: CheerPartnerCustomPrefixSettings;
  /**
   * Flag that is set when a user has filled out the bits legal ammendement.
   * This can be true and isOnboarding false for legacy partners who onboarded before bits.
   */
  hasSignedBitsAmendment: Scalars['Boolean'];
  /** An ID used for caching purposes for Apollo. */
  id: Scalars['ID'];
  /** Flag that is set when a user has been onboarded for bits usage. */
  isOnboarded: Scalars['Boolean'];
  /**
   * Partner settings related to the bits leaderboard.
   * @deprecated Use leaderboard settings in user settings instead.
   */
  leaderboard: CheerPartnerLeaderboardSettings;
  /** Partner settings related to the recent cheer message. */
  recentCheer: CheerPartnerRecentCheerSettings;
  /** Partner settings related to sponsored cheermotes. */
  sponsoredCheermotes: CheerPartnerSponsoredCheermoteSettings;
};

/** Partner settings related to sponsored cheermotes. */
export type CheerPartnerSponsoredCheermoteSettings = {
  __typename?: 'CheerPartnerSponsoredCheermoteSettings';
  /** The sponsored cheermote channel settings that are associated with the user. */
  campaigns?: Maybe<SponsoredCheermoteChannelSettingsConnection>;
};

/** CheerSettings are the channel-specific cheer settings. */
export type CheerSettings = {
  __typename?: 'CheerSettings';
  /** cheerMinimumBits is the minimum number of bits per message (sum of all cheermotes) required to cheer in this channel. */
  cheerMinimumBits: Scalars['Int'];
  /** emoteMinimumBits is the smallest number of bits that can be spent on an individual cheermote in this channel. */
  emoteMinimumBits: Scalars['Int'];
  /**
   * event is the name of a special cheering event this channel is currently participating in.
   * If there is no current event this will return null.
   */
  event?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Indicates if the bits football cheerbomb event is enabled on the channel. */
  isCheerBombEventEnabled: Scalars['Boolean'];
  /**
   * Indicates if polls is enabled.
   * @deprecated Unsupported field. Check partner or affiliate status instead of using this field
   */
  isPollsEnabled: Scalars['Boolean'];
  /**
   * isRecentEnabled indicates if recent cheers are pinned in this channel.
   * This can be used by a client to update `CheerInfo.recent` as new cheers are received.
   */
  isRecentEnabled: Scalars['Boolean'];
  /**
   * isTopEnabled indicates if top cheers are pinned in this channel.
   * This can be used by a client to update `CheerInfo.top` as new cheers are received.
   */
  isTopEnabled: Scalars['Boolean'];
  /**
   * leaderboard contains all of the Bits settings related to Bits Leaderboards for this channel.
   * @deprecated Use leaderboard settings in user settings instead.
   */
  leaderboard?: Maybe<BitsLeaderboardSettings>;
  /** recentMinimumBits is the number of bits required for a cheer to be pinned. */
  recentMinimumBits: Scalars['Int'];
  /** recentTimeoutMs is the amount of time a pinned recent message should be displayed for. */
  recentTimeoutMs: Scalars['Int'];
};

/** Cheermote is the metadata about different variations of a single cheermote that can be use to cheer in this channel. */
export type Cheermote = {
  __typename?: 'Cheermote';
  /**
   * A nullable campaign associated with the cheermote. This would only be attached to
   * cheermotes that are of the CheermoteType.SPONSORED.
   */
  campaign?: Maybe<CheermoteCampaign>;
  /** The ID of the cheermote. */
  id: Scalars['ID'];
  /**
   * prefix for this cheering action (Kappa, cheer, Kreygasm, etc).
   * Any case-insensitive match of this prefix directly followed by a number
   * (Kappa100, kappa100, kApPa100, etc) is to be considered a cheering message.
   */
  prefix: Scalars['String'];
  /** tiers are bits breakpoints for different images for this cheermote. */
  tiers: Array<CheermoteTier>;
  /** type is the kind of cheermote (custom vs 1st- or 3rd-party global). */
  type: CheermoteType;
};

/**
 * A campaign that is in association with a cheermote. Like, Old Spice could have a cheermote with
 * Terry Crew's head that they will sponsor X Bits that get added on to cheers that use their cheermote.
 */
export type CheermoteCampaign = {
  __typename?: 'CheermoteCampaign';
  /** The percentage of remaining bits that can be added to cheers. */
  bitsPercentageRemaining: Scalars['Float'];
  /** An optional field that shows the user how many bits are being used to sponsor the campaign. */
  bitsTotal?: Maybe<Scalars['Int']>;
  /** An optional field that shows the user how many bits have been used out of the sponsored pool. */
  bitsUsed?: Maybe<Scalars['Int']>;
  /** Image url for the brand image. */
  brandImageURL: Scalars['String'];
  /** The name of the brand, used in strings. */
  brandName: Scalars['String'];
  /** The cheermote campaign ID. This is unique. */
  id: Scalars['ID'];
  /** The minimum bits amount to make a cheer add bits from the sponsored campaign. */
  minimumBitsAmount: Scalars['Int'];
  /** The nullable edge that relates the user to the campaign. */
  self?: Maybe<CheermoteCampaignSelfEdge>;
  /** Thresholds for matching on sponsored cheering. */
  thresholds: Array<CheermoteCampaignThreshold>;
  /** Amount of bits that an individual user can contribute. */
  userLimit: Scalars['Int'];
};

/** Edge that relates a cheermote campaign to the logged in user. */
export type CheermoteCampaignSelfEdge = {
  __typename?: 'CheermoteCampaignSelfEdge';
  /** The total bits used by the user in the campaign. */
  bitsUsed: Scalars['Int'];
  /** Eligibility for the user to cheer with the sponsored bits in the campaign. */
  canBeSponsored: Scalars['Boolean'];
  /** The ID is comprised of the campaign ID and the user ID. */
  id: Scalars['ID'];
};

/** Threshold for sponsored cheermote campaign matching. */
export type CheermoteCampaignThreshold = {
  __typename?: 'CheermoteCampaignThreshold';
  /** Id for threshold, generated using the campaign id and the minimum bits field. */
  id: Scalars['ID'];
  /** Percentage for matching. */
  matchedPercent: Scalars['Float'];
  /** Minimum number of bits to get this level of matching. */
  minimumBits: Scalars['Int'];
};

/** The color that should be used to display each cheer amount. */
export type CheermoteColorConfig = {
  __typename?: 'CheermoteColorConfig';
  /**
   * bits is the minimum number of bits that are required to render this tier.
   * To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
   */
  bits: Scalars['Int'];
  /** color is the hex color used to render the number of bits for this tier. */
  color: Scalars['String'];
};

/**
 * The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
 * This includes things like the possible sizes, colors, backgrounds, and display order.
 */
export type CheermoteDisplayConfig = {
  __typename?: 'CheermoteDisplayConfig';
  /**
   * A list of the backgrounds that a Cheermote can be rendered at. For example, ["light", "dark"]
   * Although this is probably more accurately represented as an emum, these strings are going to have to be used
   * when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
   * same enum -> string mapping, we will just pass these directly as strings.
   */
  backgrounds: Array<Scalars['String']>;
  /** A list of the colors that should be used to display text for each Cheer amount. */
  colors: Array<CheermoteColorConfig>;
  /** A list of the order in which CheermoteTypes should be displayed. */
  order: Array<CheermoteType>;
  /**
   * A list of the scales that a Cheermote can be rendered at. For example,  ["1", "1.5", "2", "3", "4"]
   * Although this is probably more accurately represented as an emum, these strings are going to have to be used
   * when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
   * same enum -> string mapping, we will just pass these directly as strings.
   */
  scales: Array<Scalars['String']>;
  /** A list of the display types available for Cheermotes. */
  types: Array<CheermoteDisplayType>;
};

/** Information about the methods to display a Cheermote. */
export type CheermoteDisplayType = {
  __typename?: 'CheermoteDisplayType';
  /**
   * The animation style. For example, "static" or "animated"
   * Although this is probably more accurately represented as an emum, these strings are going to have to be used
   * when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
   * same enum -> string mapping, we will just pass these directly as strings.
   */
  animation: Scalars['String'];
  /**
   * The extension for this animation style. For example, "png" or "gif"
   * Although this is probably more accurately represented as an emum, these strings are going to have to be used
   * when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
   * same enum -> string mapping, we will just pass these directly as strings.
   */
  extension: Scalars['String'];
};

/** Contains a group of related Cheermotes that share the same CDN template. */
export type CheermoteGroup = {
  __typename?: 'CheermoteGroup';
  /** The Cheermotes which belong to this group. */
  nodes: Array<Cheermote>;
  /**
   * The template URL that clients can use to construct the image URL for each cheermote tier.
   * The displayConfig field on Query provides values you'll need to fill in this template,
   * so don't forget to request that as well.
   */
  templateURL: Scalars['String'];
};

/** CheermoteImage is a single image variation of a `CheermoteTier`. */
export type CheermoteImage = {
  __typename?: 'CheermoteImage';
  /**
   * dpiScale is the scale of the cheermote image.
   * Currently available scales are: 1, 1.5, 2, 3, or 4.
   * @deprecated Scheduled to be removed.
   */
  dpiScale: Scalars['Float'];
  /**
   * The ID of CheermoteImage.
   * @deprecated Scheduled to be removed.
   */
  id: Scalars['ID'];
  /**
   * isAnimated is true for animated cheermotes and false otherwise.
   * @deprecated Scheduled to be removed.
   */
  isAnimated: Scalars['Boolean'];
  /**
   * theme is the UI theme the cheermote is designed to be rendered on.
   * @deprecated Scheduled to be removed.
   */
  theme: ChatTheme;
  /**
   * url is the URL of the image asset.
   * @deprecated Scheduled to be removed.
   */
  url: Scalars['String'];
};

/** CheermoteTier has information about a single tier of a cheermote. */
export type CheermoteTier = {
  __typename?: 'CheermoteTier';
  /**
   * bits is the minimum number of bits that are required to render this tier.
   * To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
   */
  bits: Scalars['Int'];
  /**
   * Can this cheer tier be used as a cheermote.
   * @deprecated Scheduled to be removed.
   */
  canCheer: Scalars['Boolean'];
  /** Can this cheer tier be shown in the Bits card. */
  canShowInBitsCard: Scalars['Boolean'];
  /**
   * color is the hex color used to render the number of bits for this tier.
   * @deprecated Scheduled to be removed.
   */
  color: Scalars['String'];
  /** The ID of CheermoteTier. */
  id: Scalars['ID'];
  /**
   * images are urls for the cheermote that match various settings.
   * This can optionally be filtered to only certain variations or called without arguments to return all available images.
   * @deprecated Scheduled to be removed.
   */
  images: Array<Maybe<CheermoteImage>>;
  /**
   * tierID of this specific cheermote icon. For "Kappa100" this will be "100".
   * @deprecated Scheduled to be removed.
   */
  tierID: Scalars['ID'];
};


/** CheermoteTier has information about a single tier of a cheermote. */
export type CheermoteTierImagesArgs = {
  dpiScale?: InputMaybe<Scalars['Float']>;
  isAnimated?: InputMaybe<Scalars['Boolean']>;
  theme?: InputMaybe<ChatTheme>;
};

/** The supported cheermote tier thresholds. */
export enum CheermoteTierThreshold {
  /** Cheermote tier threshold requiring at least 1 Bit. */
  Tier_1 = 'TIER_1',
  /** Cheermote tier threshold requiring at least 100 Bits. */
  Tier_100 = 'TIER_100',
  /** Cheermote tier threshold requiring at least 1000 Bits. */
  Tier_1000 = 'TIER_1000',
  /** Cheermote tier threshold requiring at least 5000 Bits. */
  Tier_5000 = 'TIER_5000',
  /** Cheermote tier threshold requiring at least 10000 Bits. */
  Tier_10000 = 'TIER_10000'
}

/** CheermoteToken is used to render a cheermote in a message. */
export type CheermoteToken = {
  __typename?: 'CheermoteToken';
  /** The number of bits in the cheermote. */
  bitsAmount: Scalars['Int'];
  /** The prefix of the cheermote (e.g. cheer in cheer100). */
  prefix: Scalars['String'];
  /**
   * The tier of the cheer used to determine which image to show for the cheermote.
   * In cheer150, this would be 100.
   */
  tier: Scalars['Int'];
};

/** CheermoteType is the kind of cheermore (custom vs 1st- or 3rd-party global). */
export enum CheermoteType {
  /** The type for the anonymous cheer action. */
  Anonymous = 'ANONYMOUS',
  /** Charity Cheermotes. */
  Charity = 'CHARITY',
  /** Custom Channel Cheermotes. */
  Custom = 'CUSTOM',
  /** The type for the generic "Cheer" action. */
  Default = 'DEFAULT',
  /** Cheermotes for display only. The cannot be cheered, but will be rendered in Chat. */
  DisplayOnly = 'DISPLAY_ONLY',
  /** First Party Cheermotes, like Kappa and BibleThump. */
  FirstParty = 'FIRST_PARTY',
  /** Sponsored Cheermotes. */
  Sponsored = 'SPONSORED',
  /** Third Party Cheermotes, like Muxy and BitBoss. */
  ThirdParty = 'THIRD_PARTY',
  /**
   * Unknown cheermote type, we only return this if we get a bad cheermote,
   * we decided this is better than erroring the whole response, the front end should treat this the same as DISPLAY_ONLY.
   */
  Unknown = 'UNKNOWN'
}

/** Error code for an error that occurs while claiming the bounty. */
export type ClaimBountyError = {
  __typename?: 'ClaimBountyError';
  /** Error code for error that occurred while claiming the bounty. */
  code: ClaimBountyErrorCode;
};

/** Error types recognized. */
export enum ClaimBountyErrorCode {
  /** User already claimed that bounty. */
  BountyAlreadyClaimed = 'BOUNTY_ALREADY_CLAIMED',
  /** User reached the maximum number of bounties. */
  BountyLimitReached = 'BOUNTY_LIMIT_REACHED',
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER',
  /** Unknown error being returned from service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** ClaimBountyInput includes the bounty a user is trying to claim. */
export type ClaimBountyInput = {
  /** Unique Identifier for the bounty campaign. */
  bountyCampaignID: Scalars['ID'];
  /** Unique Identifier for the bounty. */
  bountyID: Scalars['ID'];
  /** Platform selected by the user to play this bounty's game on. */
  platform?: InputMaybe<Scalars['String']>;
  /** Region selected by the user for the game key. */
  region?: InputMaybe<Scalars['String']>;
  /** UserID of the user that will claim the bounty. */
  userID: Scalars['ID'];
};

/** Data that was mutated after claiming the bounty. */
export type ClaimBountyPayload = {
  __typename?: 'ClaimBountyPayload';
  /** The claimed bounty with the updated status. */
  claimedBounty?: Maybe<Bounty>;
  /** The possible error returned from the service. */
  error?: Maybe<ClaimBountyError>;
  /** The user that now has the claimed bounty. */
  user?: Maybe<User>;
};

/** An error from claiming community points. */
export type ClaimCommunityPointsError = {
  __typename?: 'ClaimCommunityPointsError';
  /** An identifier for the error that occurred. */
  code?: Maybe<ClaimCommunityPointsErrorCode>;
};

/** The possible reasons a claim could fail. */
export enum ClaimCommunityPointsErrorCode {
  /** The current user is not allowed to claim these points. */
  Forbidden = 'FORBIDDEN',
  /** The point claim was not found. */
  NotFound = 'NOT_FOUND'
}

/** Input for claiming community points. */
export type ClaimCommunityPointsInput = {
  /** The channel ID the claim is in. */
  channelID: Scalars['ID'];
  /** The claim ID. */
  claimID: Scalars['ID'];
};

/** The response from claiming community points. */
export type ClaimCommunityPointsPayload = {
  __typename?: 'ClaimCommunityPointsPayload';
  /** The points claim that was claimed. */
  claim?: Maybe<CommunityPointsClaim>;
  /** The user's point balance in the channel, after the claim. */
  currentPoints?: Maybe<Scalars['Int']>;
  /** An error that occurred while claiming. If there is an error, the claim did not go through. */
  error?: Maybe<ClaimCommunityPointsError>;
};

/** ClaimDropRewardsInput has fields required to claim a drop. */
export type ClaimDropRewardsInput = {
  /** dropInstanceID is the unique drop instance to claim. */
  dropInstanceID: Scalars['ID'];
};

/** ClaimDropRewardsPayload returns the state of the claim. */
export type ClaimDropRewardsPayload = {
  __typename?: 'ClaimDropRewardsPayload';
  /**
   * Summary information for the drop the reward is claimed of.
   * @deprecated No longer supported. Use dropType instead.
   */
  drop?: Maybe<DropObject>;
  /** dropInstanceID is the same as the provided input. */
  dropInstanceID?: Maybe<Scalars['ID']>;
  /** A single Drop. This could be either an event or time based drop. */
  dropType?: Maybe<DropType>;
  /** UserAccountConnected is a boolean specifying if the user has a connected account link to the game the Reward is for. */
  isUserAccountConnected?: Maybe<Scalars['Boolean']>;
  /** rewards lists the rewards that were claimed and their statuses. */
  rewards: Array<DropReward>;
  /** status is an enum specifying the status of the claim request. */
  status?: Maybe<DropInstanceEligibilityStatus>;
};

/** Hint describing the current availability state of the claim for the user. */
export enum ClaimHint {
  /**
   * We found no existing entitlements for the customer for the offer.
   * The offer is ready for claiming.
   */
  Available = 'AVAILABLE',
  /**
   * We found an existing entitlement for the customer, but the currently linked Amazon account is NOT the account on the entitlement.
   * This is preventing a future claim by the querying account.
   */
  ClaimedAmazonLinkConflict = 'CLAIMED_AMAZON_LINK_CONFLICT',
  /**
   * We found an existing entitlement linked to the household, but the querying account did not claim it themselves.
   * This is preventing a future claim by the querying account.
   */
  ClaimedByMemberOfHousehold = 'CLAIMED_BY_MEMBER_OF_HOUSEHOLD',
  /**
   * We found an existing entitlement for the customer, and the currently linked Amazon account is the account on the entitlement.
   * This is preventing a future claim by the querying account.
   */
  ClaimedNoConflicts = 'CLAIMED_NO_CONFLICTS',
  /**
   * Customer does not have Twitch Prime.
   * The user needs to sign up before claiming.
   */
  NeedPrime = 'NEED_PRIME',
  /**
   * The entitlement we found is for a code offer, and we have run out of codes.
   * We may restock codes in the future and will report another claim hint type if so.
   */
  OfferFullyClaimed = 'OFFER_FULLY_CLAIMED',
  /**
   * We found an existing entitlement for one of the accounts for the customer.
   * The existing entitlement is not blocking an additional claim.
   */
  ReclaimableNoConflicts = 'RECLAIMABLE_NO_CONFLICTS',
  /**
   * No valid claim hint was provided.
   * This will also occur when we implement new claim hints but have not yet updated this repo.
   */
  Unknown = 'UNKNOWN'
}

/** Error code for an error that occurs while claiming prime offer. */
export type ClaimPrimeOfferError = {
  __typename?: 'ClaimPrimeOfferError';
  /** Error code for error that occurred while claiming prime offer. */
  code: ClaimPrimeOfferErrorCode;
};

/** Error types recognized. */
export enum ClaimPrimeOfferErrorCode {
  /** Status when offer is already claimed by the current user or an associated account. */
  OfferAlreadyClaimed = 'OFFER_ALREADY_CLAIMED',
  /** Unknown error being returned from service. */
  Unknown = 'UNKNOWN'
}

export type ClaimPrimeOfferInput = {
  /** Unique Identifier for an offer. */
  offerID: Scalars['ID'];
};

/** Data that was mutated after claiming the prime offer, in this case, the entitlement. */
export type ClaimPrimeOfferPayload = {
  __typename?: 'ClaimPrimeOfferPayload';
  /** The possible error returned from the service. */
  error?: Maybe<ClaimPrimeOfferError>;
  /** The connection for whether the user is entitled to the offer. */
  self?: Maybe<PrimeOfferSelfConnection>;
};

/** An interface to represent a claimable thing. */
export type Claimable = {
  /** A description of what the claimable is. */
  description: Scalars['String'];
  /** The ID of the claimable. */
  id: Scalars['ID'];
  /** A field that is populated with relevant information about claiming the object given a valid logged in user. */
  self?: Maybe<SelfClaimEdge>;
  /** The type of claimable. */
  type: ClaimableType;
};

/** The enumerated types of claimables. */
export enum ClaimableType {
  /** A key code that has a bits amount associated with it. */
  BitsKeyCode = 'BITS_KEY_CODE',
  /** A key code that has a gift card with monetary value associated with it. */
  GiftCardKeyCode = 'GIFT_CARD_KEY_CODE',
  /** A key code that has a subscription to a product associated with it. */
  SubsKeyCode = 'SUBS_KEY_CODE'
}

/** ClearUnreadFriendRequestsPaylod is the payload returned by ClearUnreadFriendRequests. */
export type ClearUnreadFriendRequestsPayload = {
  __typename?: 'ClearUnreadFriendRequestsPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The authorization a user has provided to an OAuth client. */
export type ClientAuthorization = {
  __typename?: 'ClientAuthorization';
  /** The ID of the client. */
  clientID: Scalars['ID'];
  /** The name of the client. */
  clientName?: Maybe<Scalars['String']>;
  /** The time when the authorization was created. */
  createdAt?: Maybe<Scalars['Time']>;
};

/** A recorded, replayable part of a live broadcast. */
export type Clip = {
  __typename?: 'Clip';
  /**
   * The broadcast of the clip. This should only be used to fetch the ID of the broadcast.
   * Because not all videos have broadcasts (e.g. uploads), not all clips will have a broadcast.
   */
  broadcast?: Maybe<Broadcast>;
  /** The broadcaster from which the clip originated. */
  broadcaster?: Maybe<User>;
  /**
   * The curator's clip champ badge if it has been attained on the broadcaster's channel.
   * This has been deprecated and will be always be null.
   * @deprecated Clip Champ Badges are no longer being awarded
   */
  champBadge?: Maybe<Badge>;
  /** The time when the clip was created. */
  createdAt: Scalars['Time'];
  /**
   * Different video qualities are being created in the background.
   * The creation state indicates when the source quality clip is playable
   * and transcoding of the clip in other video qualities has begun.
   */
  creationState?: Maybe<ClipCreationState>;
  /** The user who created the clip. */
  curator?: Maybe<User>;
  /** The duration of the clip, in seconds. */
  durationSeconds: Scalars['Int'];
  /** The URL used in the embed player. */
  embedURL: Scalars['String'];
  /** The game depicted in the clip. */
  game?: Maybe<Game>;
  /** The clip's unique identifier. */
  id: Scalars['ID'];
  /** Whether or not the clip has been published. */
  isPublished?: Maybe<Scalars['Boolean']>;
  /** The language of the clip. */
  language: Language;
  /**
   * The playback access token that determines whether the user can watch the clip.
   * Fetched for both authed and unauthed users.
   */
  playbackAccessToken?: Maybe<PlaybackAccessToken>;
  /** Metadata around the raw media. */
  rawMedia: ClipRawMedia;
  /** The different quality options of this clip's raw media used for editing. */
  rawVideoQualities?: Maybe<Array<ClipVideoQuality>>;
  /** The reactions associated with this clips. */
  reactions?: Maybe<Array<Maybe<Reaction>>>;
  /** Lists of related clips based on different algorithms. */
  relatedClips?: Maybe<ClipRelatedClips>;
  /** A URL-friendly identifier. */
  slug: Scalars['String'];
  /**
   * A URL to a thumbnail image.
   * Valid sizes are "86x45", "260x147", and "480x272".
   */
  thumbnailURL: Scalars['String'];
  /** The title of the clip. */
  title: Scalars['String'];
  /** A URL to the clip's page. */
  url: Scalars['String'];
  /**
   * The video of the clip. Because not all broadcasts are archived, not all clips will
   * have a video.
   */
  video?: Maybe<Video>;
  /** The number of seconds into a VOD this clip was generated from. */
  videoOffsetSeconds?: Maybe<Scalars['Int']>;
  /**
   * The different quality options of this clip available for playback.
   * The clip will first be available in the source video quality, indicated by when the
   * clipCreationState is 'CREATED'. videoQualities will gradually be added to afterwards as
   * more video quality options become playable.
   */
  videoQualities?: Maybe<Array<ClipVideoQuality>>;
  /** The number of times this clip has been viewed. */
  viewCount: Scalars['Int'];
};


/** A recorded, replayable part of a live broadcast. */
export type ClipPlaybackAccessTokenArgs = {
  params: PlaybackAccessTokenParams;
};


/** A recorded, replayable part of a live broadcast. */
export type ClipThumbnailUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

/** A list of clips related to the subject. */
export type ClipConnection = {
  __typename?: 'ClipConnection';
  /** The clips. */
  edges?: Maybe<Array<Maybe<ClipEdge>>>;
  /** Information about pagination in this connection. */
  pageInfo?: Maybe<PageInfo>;
};

/** An enumeration on the different status strings returned by a clip status. */
export enum ClipCreationState {
  /**
   * Clip has been successfully created in the source video quality.
   * The field videoQualities will be gradually added to with other quality options.
   */
  Created = 'CREATED',
  /**
   * The creating status indicates that the source quality video is still
   * undergoing processing and transcoding.
   */
  Creating = 'CREATING',
  /**
   * Clip creation failed and will remain in this state.
   * Possible errors can happen due to problems in downloading and slicing
   * the source of the original video, clipping offline channels, transcoding, etc.
   */
  Failed = 'FAILED'
}

export type ClipEdge = {
  __typename?: 'ClipEdge';
  /** Uniquely identifies this clip's position in a connection. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The clip. */
  node?: Maybe<Clip>;
};

/** ClipRawMedia describes metadata about the clip's raw media used in clip editing. */
export type ClipRawMedia = {
  __typename?: 'ClipRawMedia';
  /** Default Offset is the seconds into the raw clip media the default clip begins at. */
  defaultClipInitialOffset: Scalars['Float'];
  /** Total duration of the raw media. */
  duration: Scalars['Float'];
  /** Total number of frames displayed in the spritesheet film strip. */
  filmStripFrames: Scalars['Int'];
  /** Seconds covered by each frame in the spritesheet film strip. */
  filmStripSecondsPerFrame: Scalars['Int'];
  /** Height of the frames displayed. */
  frameHeight: Scalars['Int'];
  /** Width of the frames displayed. */
  frameWidth: Scalars['Int'];
  /** Spritesheet displayed to user for clip editing. */
  spritesheetURL: Scalars['String'];
  /** Status of the clip's raw media. */
  status: ClipCreationState;
  /** URL link to the video mp4 containing to upwards of 90 seconds of the raw video from which the clip can be created from. */
  videoURL: Scalars['String'];
};

/**
 * There are different algorithms that return a different set of related clips.
 * They only return up to 4 clips per list.
 */
export type ClipRelatedClips = {
  __typename?: 'ClipRelatedClips';
  /** Up-to 4  randomly selected, top viewed clips from the same broadcaster created within the last 4 days. */
  broadcaster?: Maybe<Array<Clip>>;
  /**
   * Up-to 10 clips, in order, combined from the other returned clip sets.
   * Clips are included in the priority of similar, broadcaster, game, and then top.
   */
  combined?: Maybe<Array<Clip>>;
  /** Up-to 4  randomly selected, top viewed clips from the same user created within the last 4 days. */
  curator?: Maybe<Array<Clip>>;
  /** Up-to 4  randomly selected, top viewed clips from the same game created within the last 4 days. */
  game?: Maybe<Array<Clip>>;
  /**
   * Up-to 4 similar clips, based on the recommendations service.
   * Deprecated: The underlying recommendations service that determined similar clips has been deprecated.
   * @deprecated Similar clips relied on a deprecated backend service.
   */
  similar?: Maybe<Array<Clip>>;
  /** Up-to 4 randomly selected, top viewed clips created within the last 4 days. */
  top?: Maybe<Array<Clip>>;
};

/** ClipSegmentInput represents a single segment of a clip. */
export type ClipSegmentInput = {
  /** The number of seconds this clip segment encompasses. */
  durationSeconds: Scalars['Float'];
  /** The offset into the clip's 90 second raw media. */
  offsetSeconds: Scalars['Float'];
  /**
   * Valid input speeds are 0.25, 0.5, 1.0, 1.5, and 2.0.
   * The segment speed will be set to 1 by default if unspecified.
   */
  speed?: InputMaybe<Scalars['Float']>;
};

/** ClipVideoQuality describes metadata about an available playback source for a clip. */
export type ClipVideoQuality = {
  __typename?: 'ClipVideoQuality';
  /**
   * Frame rate is the number of frames per second of this video.
   * This value is a 64-bit float, with a default value of 30.0,
   * and is used for supporting different playback speeds.
   * Frame rate will be empty for raw media video qualities.
   */
  frameRate?: Maybe<Scalars['Float']>;
  /**
   * Clips can have multiple playback qualities via transcoding.
   * Some examples of qualities include "1080", "720", "480", "360", and "source".
   */
  quality: Scalars['String'];
  /** The source video URL for the clip in this specific playback quality. */
  sourceURL: Scalars['String'];
};

/** The set of methods to restrict clips results. */
export enum ClipsFilter {
  /** No limit on clips creation period. */
  AllTime = 'ALL_TIME',
  /** Limit results to clips created in the period between now and the last 24 hours. */
  LastDay = 'LAST_DAY',
  /** Limit results to clips created in the period between now and the last 30 days. */
  LastMonth = 'LAST_MONTH',
  /** Limit results to clips created in the period between now and the last 7 days. */
  LastWeek = 'LAST_WEEK',
  /** Limit results to trending clips. */
  Trending = 'TRENDING'
}

/**
 * An enumeration on the different time frames to filter clips results based on
 * creation time.
 */
export enum ClipsPeriod {
  /** No limit on when the clips were created. */
  AllTime = 'ALL_TIME',
  /** Limit results to clips created in the period between now and the last 24 hours. */
  LastDay = 'LAST_DAY',
  /** Limit results to clips created in the period between now and the last 30 days. */
  LastMonth = 'LAST_MONTH',
  /** Limit results to clips created in the period between now and the last 7 days. */
  LastWeek = 'LAST_WEEK'
}

/** An enumeration on the different sort orders of clips results. */
export enum ClipsSort {
  /** Sort the clips ascending by created_at. */
  CreatedAtAsc = 'CREATED_AT_ASC',
  /** Sort the clips descending by created_at. */
  CreatedAtDesc = 'CREATED_AT_DESC',
  /** Sort the clips descending by popularity. */
  Trending = 'TRENDING',
  /** Sort the clips ascending by views. */
  ViewsAsc = 'VIEWS_ASC',
  /** Sort the clips descending by views. */
  ViewsDesc = 'VIEWS_DESC'
}

/** CloneExtensionDiscoveryDataError is an error associated with the cloneExtensionDiscoveryData mutation. */
export enum CloneExtensionDiscoveryDataError {
  /** Version specified is invalid. */
  InvalidNewVersion = 'INVALID_NEW_VERSION',
  /** User is unable to clone the extension. */
  Unauthorized = 'UNAUTHORIZED',
  /** The Version to clone from does not exist. */
  VersionNotFound = 'VERSION_NOT_FOUND'
}

/** CloneExtensionDiscoveryData copies a given version's discovery data to another version. */
export type CloneExtensionDiscoveryDataInput = {
  /** The extension ID of the extension to clone. */
  id: Scalars['ID'];
  /** The version to clone to. */
  newVersion: Scalars['String'];
  /** The extension version to clone from. */
  version: Scalars['String'];
};

/** CloneExtensionDiscoveryDataPayload returns any errors that occur during the copying of the discovery data. */
export type CloneExtensionDiscoveryDataPayload = {
  __typename?: 'CloneExtensionDiscoveryDataPayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<CloneExtensionDiscoveryDataError>;
  /** The updated extension discovery data. */
  manifest?: Maybe<ExtensionVersionDiscoveryManifest>;
};

/** CloneExtensionManifestError is an error associated with the cloneExtensionManifest mutation. */
export enum CloneExtensionManifestError {
  /** Version specified is invalid. */
  InvalidNewVersion = 'INVALID_NEW_VERSION',
  /** User is unable to clone the extension. */
  Unauthorized = 'UNAUTHORIZED',
  /** The version to clone to already exists. */
  VersionAlredyExists = 'VERSION_ALREDY_EXISTS',
  /** The Version to clone from does not exist. */
  VersionNotFound = 'VERSION_NOT_FOUND'
}

/** CloneExtensionManifest copies the data in a given extension version to a new version. */
export type CloneExtensionManifestInput = {
  /** The extension ID of the extension to clone. */
  id: Scalars['ID'];
  /** The version of the clone. */
  newVersion: Scalars['String'];
  /** The extension version to clone. */
  version: Scalars['String'];
};

/** CloneExtensionManifestPayload returns any errors that occur during update and the new manifest. */
export type CloneExtensionManifestPayload = {
  __typename?: 'CloneExtensionManifestPayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<CloneExtensionManifestError>;
  /** The updated extension manifest. */
  manifest?: Maybe<ExtensionManifest>;
};

/** Represents a cloud broadcast and its state. */
export type CloudBroadcast = {
  __typename?: 'CloudBroadcast';
  /** The id of the cloud broadcast. */
  id: Scalars['ID'];
  /** The status of a cloud broadcast. */
  state: CloudBroadcastState;
  /**
   * The ingest URI for the broadcast.
   * This is available if the broadcast is in an online state; otherwise null.
   */
  uri?: Maybe<Scalars['String']>;
};

/** A cloud broadcast provider id. */
export type CloudBroadcastProvider = {
  __typename?: 'CloudBroadcastProvider';
  /** The supported capabilities of a cloud broadcast. */
  capabilities?: Maybe<CloudBroadcastProviderCapabilities>;
  /** The friendly display name of the provider. */
  displayName: Scalars['String'];
  /** The logical id of the provider, for interacting with providers. */
  id: Scalars['ID'];
};

/** Capabilities of a cloud broadcast provider. */
export type CloudBroadcastProviderCapabilities = {
  __typename?: 'CloudBroadcastProviderCapabilities';
  /** The maximum supported broadcast framerate for the provider, if available. */
  framerate?: Maybe<Scalars['Int']>;
  /** The maximum supported broadcast height for the provider, if available. */
  height?: Maybe<Scalars['Int']>;
  /** The ID of the provider associated with the capabilities. */
  id: Scalars['ID'];
  /** Whether or not if the broadcaster can send broadcasts to the service. */
  isAvailable: Scalars['Boolean'];
  /** The maximum supported broadcast width for the provider, if available. */
  width?: Maybe<Scalars['Int']>;
};

/** A cloud broadcast provider id. */
export type CloudBroadcastProviderKey = {
  __typename?: 'CloudBroadcastProviderKey';
  /** The friendly display name of the provider. */
  displayName: Scalars['String'];
  /** The logical id of the provider, for interacting with providers. */
  id: Scalars['ID'];
};

/** Represents the status of a cloud broadcast. */
export enum CloudBroadcastState {
  /** Broadcast is offline and needs to be started. */
  Offline = 'OFFLINE',
  /** Broadcast is online and ready. */
  Online = 'ONLINE',
  /** Broadcast is pending and currently starting. */
  Pending = 'PENDING',
  /** The broadcast status is unknown. */
  Unknown = 'UNKNOWN'
}

/** Collection (a.k.a. Playlist) is a backend concept for a list of videos. */
export type Collection = {
  __typename?: 'Collection';
  /** The user-supplied description of the collection. */
  description: Scalars['String'];
  /** The collection's identifier. */
  id: Scalars['ID'];
  /** The paginated items in the collection. At this time, they will all be VoDs. */
  items: CollectionConnection;
  /** Total length of the collection as summed from all video lengths. */
  lengthSeconds: Scalars['Int'];
  /** The owner of the collection. */
  owner?: Maybe<User>;
  /**
   * The thumbnailURL for the collection.
   * If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
   */
  thumbnailURL?: Maybe<Scalars['String']>;
  /** The user-supplied title of the collection. */
  title: Scalars['String'];
  /** The type of collection, either a series or default collection which is ''. */
  type: CollectionType;
  /** Time when the collection was last updated. */
  updatedAt: Scalars['Time'];
  /** The total view count of a collection. */
  viewCount?: Maybe<Scalars['Int']>;
};


/** Collection (a.k.a. Playlist) is a backend concept for a list of videos. */
export type CollectionItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Collection (a.k.a. Playlist) is a backend concept for a list of videos. */
export type CollectionThumbnailUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

/** A paginated list of videos, and its metadata. */
export type CollectionConnection = {
  __typename?: 'CollectionConnection';
  /** The list of items in this page. */
  edges: Array<Maybe<CollectionItemEdge>>;
  /** Information about this page of videos. */
  pageInfo: PageInfo;
  /** The total number of items in the collection. */
  totalCount: Scalars['Int'];
};

/** The types of objects that can be contained in a collection. */
export type CollectionItem = Video;

/**
 * A page entry, that contains a collection item and a cursor to return
 * from the query to allow pagination.
 */
export type CollectionItemEdge = {
  __typename?: 'CollectionItemEdge';
  cursor: Scalars['Cursor'];
  node: CollectionItem;
};

/** A Collection input to set options to include all items in a collection. */
export type CollectionOptions = {
  /** Include all playlist items including private and deleted items. */
  includeAllItems?: InputMaybe<Scalars['Boolean']>;
};

/** The set of different collection types. */
export enum CollectionType {
  /** Default collection type. */
  Default = 'DEFAULT',
  /** Series collection type. */
  Series = 'SERIES'
}

/**
 * These two types allow clients to query for a LIST of COLLECTIONS
 * (i.e. a two-dimensional array of videos).
 */
export type CollectionsConnection = {
  __typename?: 'CollectionsConnection';
  edges: Array<Maybe<CollectionsItemEdge>>;
  pageInfo: PageInfo;
};

export type CollectionsItemEdge = {
  __typename?: 'CollectionsItemEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node: Collection;
};

/** Options for filtering collections. */
export type CollectionsOptions = {
  /** Option to include empty collections. */
  includeEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Only return collections that include the given video ID. */
  withVideoID?: InputMaybe<Scalars['ID']>;
};

/** An automatic community points reward. */
export type CommunityPointsAutomaticReward = {
  __typename?: 'CommunityPointsAutomaticReward';
  /** The background color for the reward icon. */
  backgroundColor?: Maybe<Scalars['String']>;
  /** The point cost of this reward. */
  cost?: Maybe<Scalars['Int']>;
  /** The default background color for this reward. */
  defaultBackgroundColor: Scalars['String'];
  /** The default point cost of this reward. */
  defaultCost: Scalars['Int'];
  /** The default image for this reward. */
  defaultImage: CommunityPointsImage;
  /** Time that the global template for this reward was last updated in a way that should show a new content indicator to viewers. */
  globallyUpdatedForIndicatorAt: Scalars['Time'];
  /** The unique identifier of this reward in this channel. */
  id: Scalars['ID'];
  /** The custom icon for this reward, if any. */
  image?: Maybe<CommunityPointsImage>;
  /** Whether this reward is turned on or off in this channel at the moment. */
  isEnabled: Scalars['Boolean'];
  /** Whether only non-subscribers are allowed to redeem this reward in this channel. */
  isHiddenForSubs: Scalars['Boolean'];
  /** The lowest the broadcaster is allowed to set the cost of this reward. */
  minimumCost: Scalars['Int'];
  /** The type of automatic reward this is. */
  type: CommunityPointsAutomaticRewardType;
  /**
   * Time that this reward was last updated for the channel in a way that should show a new content indicator to viewers.
   * Will be null if the channel hasn't made any updates to override the global settings.
   */
  updatedForIndicatorAt?: Maybe<Scalars['Time']>;
};

/** Types of CommunityPointsAutomaticRewards. */
export enum CommunityPointsAutomaticRewardType {
  /** Unlock a chosen modification for a subscriber emote. */
  ChosenModifiedSubEmoteUnlock = 'CHOSEN_MODIFIED_SUB_EMOTE_UNLOCK',
  /** Unlock a chosen subscriber emote. */
  ChosenSubEmoteUnlock = 'CHOSEN_SUB_EMOTE_UNLOCK',
  /** Unlock a random subscriber emote. */
  RandomSubEmoteUnlock = 'RANDOM_SUB_EMOTE_UNLOCK',
  /** Send a highlighted chat message. */
  SendHighlightedMessage = 'SEND_HIGHLIGHTED_MESSAGE',
  /** Send a single message through sub-only mode. */
  SingleMessageBypassSubMode = 'SINGLE_MESSAGE_BYPASS_SUB_MODE'
}

/** Information on how points are earned by viewers in a specific channel. */
export type CommunityPointsChannelEarningSettings = {
  __typename?: 'CommunityPointsChannelEarningSettings';
  /** The average number of points per hour earned by a regular (non-sub) user on this channel. */
  averagePointsPerHour: Scalars['Int'];
  /**
   * The average number of points per hour earned by a subscriber on this channel.
   * @deprecated Front-end messaging will update to display base averagePointsPerHour value and multipliers instead.
   */
  averagePointsPerHourSubscriber: Scalars['Int'];
  /** How many points are earned for cheering in a channel. */
  cheerPoints: Scalars['Int'];
  /** How many minutes will pass in between bonus claims becoming available. */
  claimPeriodMinutes: Scalars['Int'];
  /** How many points are earned for clicking a bonus claim. */
  claimPoints: Scalars['Int'];
  /** How many points are earned for following the channel. */
  followPoints: Scalars['Int'];
  /** A unique identifier. */
  id: Scalars['ID'];
  /** The possible multipliers users can have on earning points. */
  multipliers: Array<CommunityPointsMultiplier>;
  /** How many minutes must be watched to earn points for passively watching the channel. */
  passiveWatchPeriodMinutes: Scalars['Int'];
  /** How many points are earned for passively watching the channel. */
  passiveWatchPoints: Scalars['Int'];
  /** How many points are earned for following a raid by the channel. */
  raidPoints: Scalars['Int'];
  /**
   * The earning multiplier applied to subscribers to the channel.
   * This multiplier only applies to "watch" and "claim" actions.
   * @deprecated This is the T1 specific multipler value, which is now included in multipliers list.
   */
  subscriberMultiplier: Scalars['Float'];
  /** How many points are earned for gifting a subscription in a channel. */
  subscriptionGiftPoints: Scalars['Int'];
  /**
   * How many points are earned for watching consecutive streams.
   * This list will be sorted from shortest duration to longest duration.
   * Watch streaks beyond the longest duration here will be treated the same as watch streaks of the longest duration.
   */
  watchStreakPoints: Array<CommunityPointsWatchStreakEarningSettings>;
};

/** Settings for a channel's Community Points. */
export type CommunityPointsChannelSettings = {
  __typename?: 'CommunityPointsChannelSettings';
  /** Archived community goals for this channel. */
  archivedGoals?: Maybe<CommunityPointsCommunityGoalConnection>;
  /** Automatic rewards for this channel. If no automatic rewards exist, will be an empty array. */
  automaticRewards?: Maybe<Array<CommunityPointsAutomaticReward>>;
  /** The default max contribution to a community goal per user per stream. */
  communityGoalMaxContributionPerStream: Scalars['Int'];
  /** The default small contribution to a community goal. */
  communityGoalSmallContribution: Scalars['Int'];
  /** Single custom reward by the given id for this channel. */
  customReward?: Maybe<CommunityPointsCustomReward>;
  /** Collections of the custom reward templates for this channel. */
  customRewardTemplateCollections?: Maybe<Array<CommunityPointsCustomRewardTemplateCollection>>;
  /** Custom rewards for this channel. If no custom rewards exist, will be an empty array. */
  customRewards?: Maybe<Array<CommunityPointsCustomReward>>;
  /** The default image for community points. */
  defaultImage: CommunityPointsImage;
  /**
   * Properties concerning the user's participation in the Channel Points early access program.
   * @deprecated Early Access period is over.
   */
  earlyAccess?: Maybe<CommunityPointsEarlyAccessSettings>;
  /** Information on how points are earned by viewers in this channel. */
  earning?: Maybe<CommunityPointsChannelEarningSettings>;
  /** A list of the emote variants (base emote + modifications) that are available for this channel. */
  emoteVariants?: Maybe<Array<CommunityPointsEmoteVariant>>;
  /** Non-archived community goals for this channel. */
  goals?: Maybe<Array<CommunityPointsCommunityGoal>>;
  /** The channel's custom community points icon. Null if they have not set an icon. */
  image?: Maybe<CommunityPointsImage>;
  /** Whether the channel is allowed to turn community points on now. */
  isAvailable: Scalars['Boolean'];
  /**
   * Whether the channel will be allowed to turn community points on at full public launch.
   * @deprecated Early Access period is over.
   */
  isAvailableAtLaunch: Scalars['Boolean'];
  /** Whether the channel has community points turned on now. */
  isEnabled: Scalars['Boolean'];
  /**
   * Whether the channel will have community points turned on at full public launch.
   * @deprecated Early Access period is over.
   */
  isEnabledAtLaunch: Scalars['Boolean'];
  /** The channel's custom community points name. Null if they have not set a name. */
  name?: Maybe<Scalars['String']>;
  /**
   * The amount of points earned for participating in a raid from the channel.
   * @deprecated Should use earning.raidPoints instead
   */
  raidPointAmount: Scalars['Int'];
  /** A list of Smart Costs acknowledgements. */
  smartCostsAcknowledgements?: Maybe<Array<SmartCostsAcknowledgement>>;
  /** A summary of information about unfulfilled redemptions of each custom reward. */
  summarizedRewards?: Maybe<Array<CommunityPointsRewardSummary>>;
  /** A list of the progress for all ongoing Update Custom Reward Redemption Statuses requests. */
  updateCustomRewardRedemptionStatusesProgress?: Maybe<Array<CommunityPointsUpdateCustomRewardRedemptionStatusesProgress>>;
};


/** Settings for a channel's Community Points. */
export type CommunityPointsChannelSettingsArchivedGoalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Settings for a channel's Community Points. */
export type CommunityPointsChannelSettingsCustomRewardArgs = {
  id: Scalars['ID'];
};


/** Settings for a channel's Community Points. */
export type CommunityPointsChannelSettingsGoalsArgs = {
  includeGoalTypes?: InputMaybe<Array<CommunityPointsCommunityGoalType>>;
};

/** Points that are available for a user to click to claim in a channel. */
export type CommunityPointsClaim = {
  __typename?: 'CommunityPointsClaim';
  /** The claim's unique ID. */
  id: Scalars['ID'];
  /**
   * The multipliers that will affect this claim.
   * Multipliers start at a base of 1.0, and are additive.
   * Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
   */
  multipliers: Array<CommunityPointsMultiplier>;
  /** The baseline points this claim will grant, before applying multipliers. */
  pointsEarnedBaseline: Scalars['Int'];
  /** The total points this claim will grant. */
  pointsEarnedTotal: Scalars['Int'];
};

/** Community goal. */
export type CommunityPointsCommunityGoal = {
  __typename?: 'CommunityPointsCommunityGoal';
  /** The amount of community points that this goal needs to succeed. */
  amountNeeded: Scalars['Int'];
  /** The background color of this goal. Should be a hex color string, for example "FF0000". */
  backgroundColor: Scalars['String'];
  /** The default image of community goals. */
  defaultImage: CommunityPointsImage;
  /** The description of this goal. */
  description?: Maybe<Scalars['String']>;
  /**
   * The *initial* duration the streamer set for the goal.
   * Only really used during the UNSTARTED state; once the goal is started
   * the endedAt timestamp is populated (and updated for extended deadlines).
   */
  durationDays: Scalars['Int'];
  /** When the goal ended / will end. */
  endedAt?: Maybe<Scalars['Time']>;
  /** The id of the goal. */
  id: Scalars['ID'];
  /** The image of the goal. */
  image?: Maybe<CommunityPointsImage>;
  /**
   * If this goal is available to be contributed to.
   * true when the goal is active and the streamer is live.
   * For MLP, this is just whether the channel is live.
   */
  isInStock: Scalars['Boolean'];
  /** The max per stream, per user contribution limit. */
  perStreamUserMaximumContribution: Scalars['Int'];
  /** The total points contributed to this goal. */
  pointsContributed: Scalars['Int'];
  /**
   * The small contribution needed to contribute to the goal. Contribution can only be
   * less than this amount if the goal has less than this amount left to complete or if
   * the viewer has less than this amount to be able to contribute.
   */
  smallContribution: Scalars['Int'];
  /** When the goal started. */
  startedAt?: Maybe<Scalars['Time']>;
  /** The current status of this goal. */
  status: CommunityPointsCommunityGoalStatus;
  /** The title of this goal. */
  title: Scalars['String'];
  /** The type of this goal. */
  type: CommunityPointsCommunityGoalType;
};

/** A paginated list of community goals. */
export type CommunityPointsCommunityGoalConnection = {
  __typename?: 'CommunityPointsCommunityGoalConnection';
  /** The list of community goals in this page. */
  edges?: Maybe<Array<CommunityPointsCommunityGoalEdge>>;
  /** Information about this page of community goals. */
  pageInfo: PageInfo;
};

/** Community goal contribution. */
export type CommunityPointsCommunityGoalContribution = {
  __typename?: 'CommunityPointsCommunityGoalContribution';
  /** The community goal. */
  goal: CommunityPointsCommunityGoal;
  /** The amount of user's channel points contributed to this community goal this stream. */
  userPointsContributedThisStream: Scalars['Int'];
};

/** A community goal page entry, contains an item and a cursor. */
export type CommunityPointsCommunityGoalEdge = {
  __typename?: 'CommunityPointsCommunityGoalEdge';
  /** Identifies this community goal's position in a connection. */
  cursor: Scalars['Cursor'];
  /** The community goal. */
  node: CommunityPointsCommunityGoal;
};

/** Community goal status. */
export enum CommunityPointsCommunityGoalStatus {
  /** Goal archived. */
  Archived = 'ARCHIVED',
  /** Goal ended. */
  Ended = 'ENDED',
  /** Goal marked fulfilled by streamer. */
  Fulfilled = 'FULFILLED',
  /** Goal was started. */
  Started = 'STARTED',
  /** Goal status unknown. */
  Unknown = 'UNKNOWN',
  /** Goal was just created. */
  Unstarted = 'UNSTARTED'
}

/** Community goal type. */
export enum CommunityPointsCommunityGoalType {
  /** Community Boost Goal. */
  Boost = 'BOOST',
  /** Goal owned by creator. */
  Creator = 'CREATOR',
  /** Goal type unknown. */
  Unknown = 'UNKNOWN'
}

/** The different types of content for community points. */
export enum CommunityPointsContentType {
  /** The content type for automatic rewards. */
  AutomaticReward = 'AUTOMATIC_REWARD',
  /** The content type for custom rewards. */
  CustomReward = 'CUSTOM_REWARD',
  /** The content type is not understood by GQL. */
  Unknown = 'UNKNOWN'
}

/** A custom community points reward on a channel. */
export type CommunityPointsCustomReward = {
  __typename?: 'CommunityPointsCustomReward';
  /** The custom background color for this reward. If no background color specified, will be null. */
  backgroundColor?: Maybe<Scalars['String']>;
  /**
   * The cooldown expires at field indidicates when reward will be able to be redeemed after the cooldown is set.
   * This field will only have a value if the global cooldown feature is enabled and has been recently redeemed.
   */
  cooldownExpiresAt?: Maybe<Scalars['Time']>;
  /** The point cost of this reward. */
  cost: Scalars['Int'];
  /** The default image for community points custom rewards. */
  defaultImage: CommunityPointsImage;
  /** The most rewards of this type that can be redeemed per the global cooldown. */
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting;
  /** Whether this reward has real world value. Null if the broadcaster has not set this field yet. */
  hasRealWorldValue?: Maybe<Scalars['Boolean']>;
  /** The unique identifier for this reward. */
  id: Scalars['ID'];
  /** The custom image for this reward. If no image exists, will be null. */
  image?: Maybe<CommunityPointsImage>;
  /** Whether this reward is enabled in this channel at the moment. */
  isEnabled: Scalars['Boolean'];
  /**
   * Whether this reward is in stock at the moment.
   * If the reward has already been redeemed the maximum number of times per stream, this will be false.
   */
  isInStock: Scalars['Boolean'];
  /** Whether redemptions of this reward are temporarily paused. */
  isPaused: Scalars['Boolean'];
  /** Whether only subscribers are allowed to redeem this reward in this channel. */
  isSubOnly: Scalars['Boolean'];
  /** Whether this reward requires users to enter text input. */
  isUserInputRequired: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per stream. */
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting;
  /** The most rewards of this type that can be redeemed per user per stream. */
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting;
  /** The user-facing prompt for this reward. If no prompt exists, will be null. */
  prompt?: Maybe<Scalars['String']>;
  /**
   * The value of redemptions of the reward for the current stream.
   * This field will only have a value if the max per user per stream is enabled and has been recently redeemed.
   */
  redemptionsRedeemedCurrentStream?: Maybe<Scalars['Int']>;
  /**
   * Whether redemptions for this reward should skip the broadcaster's request queue and get
   * automatically fulfilled.
   */
  shouldRedemptionsSkipRequestQueue: Scalars['Boolean'];
  /** The id for the CustomReward template this reward was created from. Will be null if not created from a template. */
  templateID?: Maybe<Scalars['ID']>;
  /** The short title displayed for this reward. */
  title: Scalars['String'];
  /** Time that this reward was last updated in a way that should show a new content indicator to viewers. */
  updatedForIndicatorAt: Scalars['Time'];
};

/** Settings for how often a custom reward may be redeemed per stream. */
export type CommunityPointsCustomRewardGlobalCooldownSetting = {
  __typename?: 'CommunityPointsCustomRewardGlobalCooldownSetting';
  /** The most rewards of this type that can be redeemed per the global cooldown. */
  globalCooldownSeconds: Scalars['Int'];
  /** Whether the cooldown is being enforced. */
  isEnabled: Scalars['Boolean'];
};

/** Input for creating and updating a Community Points custom reward's max per stream settings. */
export type CommunityPointsCustomRewardGlobalCooldownSettingInput = {
  /** The most rewards of this type that can be redeemed per global cooldown. */
  globalCooldownSeconds: Scalars['Int'];
  /** Whether the cooldown is being enforced. */
  isEnabled: Scalars['Boolean'];
};

/** Settings for how often a custom reward may be redeemed per stream. */
export type CommunityPointsCustomRewardMaxPerStreamSetting = {
  __typename?: 'CommunityPointsCustomRewardMaxPerStreamSetting';
  /** Whether the maximum is being enforced. */
  isEnabled: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per stream. */
  maxPerStream: Scalars['Int'];
};

/** Input for creating and updating a Community Points custom reward's max per stream settings. */
export type CommunityPointsCustomRewardMaxPerStreamSettingInput = {
  /** Whether the maximum is being enforced. */
  isEnabled: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per stream. */
  maxPerStream: Scalars['Int'];
};

/** Settings for how often a custom reward may be redeemed per stream. */
export type CommunityPointsCustomRewardMaxPerUserPerStreamSetting = {
  __typename?: 'CommunityPointsCustomRewardMaxPerUserPerStreamSetting';
  /** Whether the maximum is being enforced. */
  isEnabled: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per user per stream. */
  maxPerUserPerStream: Scalars['Int'];
};

/** Input for creating and updating a Community Points custom reward's max per stream settings. */
export type CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput = {
  /** Whether the maximum is being enforced. */
  isEnabled: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per user per stream. */
  maxPerUserPerStream: Scalars['Int'];
};

/** A community points custom reward that has been redeemed in a channel. */
export type CommunityPointsCustomRewardRedemption = {
  __typename?: 'CommunityPointsCustomRewardRedemption';
  /** The unique ID of this redemption. */
  id: Scalars['ID'];
  /** The user-provided text input, if it exists. */
  input?: Maybe<Scalars['String']>;
  /**
   * The custom reward that was redeemed.
   * @deprecated Use the 'rewardID' and 'rewardTitle' fields instead.
   */
  reward?: Maybe<CommunityPointsCustomReward>;
  /** The unique ID of the reward that was redeemed. */
  rewardID: Scalars['ID'];
  /** The title of the custom reward that was redeemed, at the time it was redeemed. */
  rewardTitle: Scalars['String'];
  /** The status of this redemption. */
  status: CommunityPointsCustomRewardRedemptionStatus;
  /** The time that the reward was redeemed at. */
  timestamp: Scalars['Time'];
  /** The user that redeemed the reward. */
  user?: Maybe<User>;
};

/**
 * A paginated list of Community Points redemptions, and its metadata.
 * Only returns results for logged-in, authorized users, otherwise returns a nil response.
 */
export type CommunityPointsCustomRewardRedemptionConnection = {
  __typename?: 'CommunityPointsCustomRewardRedemptionConnection';
  /** The list of items in this page. */
  edges: Array<CommunityPointsCustomRewardRedemptionEdge>;
  /** Information about this page of Community Points redemptions. */
  pageInfo: PageInfo;
};

/**
 * A page entry, that contains a CommunityPointsCustomRewardRedemption item and a cursor to
 * return from the query to allow pagination.
 */
export type CommunityPointsCustomRewardRedemptionEdge = {
  __typename?: 'CommunityPointsCustomRewardRedemptionEdge';
  /** Cursor used for next query. */
  cursor: Scalars['Cursor'];
  /** The underlying Community Points redemption. */
  node: CommunityPointsCustomRewardRedemption;
};

/** Ways to sort Community Points redemptions. */
export enum CommunityPointsCustomRewardRedemptionQueueSortOrder {
  /** The newest redemption first. */
  Newest = 'NEWEST',
  /** The oldest redemption first. */
  Oldest = 'OLDEST'
}

/** Possible states for a CommunityPointsCustomRewardRedemption. */
export enum CommunityPointsCustomRewardRedemptionStatus {
  /** A redemption that has been canceled by the broadcaster. */
  Canceled = 'CANCELED',
  /** A redemption that has been fulfilled by the broadcaster. */
  Fulfilled = 'FULFILLED',
  /** A redemption that has been reported by the broadcaster. */
  Reported = 'REPORTED',
  /** A redemption that has not been acted on by the broadcaster. */
  Unfulfilled = 'UNFULFILLED'
}

/** A template used to create a custom reward. */
export type CommunityPointsCustomRewardTemplate = {
  __typename?: 'CommunityPointsCustomRewardTemplate';
  /** The custom background color for a reward created from this template. */
  backgroundColor: Scalars['String'];
  /** The point cost for a reward created from this template. */
  cost: Scalars['Int'];
  /**
   * The maximum number of redemptions for the reward created from this
   * template that can be redeemed per the global cooldown.
   */
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting;
  /** The unique identifier for this reward template. */
  id: Scalars['ID'];
  /** The default image for a reward created from this template. */
  image: CommunityPointsImage;
  /**
   * Whether only subscribers are allowed to redeem the reward created
   * from this template.
   */
  isSubOnly: Scalars['Boolean'];
  /**
   * Whether the reward created from this template requires users to enter
   * text input.
   */
  isUserInputRequired: Scalars['Boolean'];
  /**
   * The maximum number of redemptions for the reward created from this
   * template that can be redeemed per stream.
   */
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting;
  /**
   * The maximum number of redemptions for the reward created from this
   * template that can be redeemed per user per stream.
   */
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting;
  /**
   * The user-facing prompt for the reward created from this template.
   * If no prompt exists, will be null.
   */
  prompt?: Maybe<Scalars['String']>;
  /**
   * Whether redemptions for the reward created from this template should
   * skip the broadcaster's request queue and get automatically fulfilled.
   */
  shouldRedemptionsSkipRequestQueue: Scalars['Boolean'];
  /** The short title displayed for the reward created from this template. */
  title: Scalars['String'];
};

/** A collection of custom reward templates for a category on a channel. */
export type CommunityPointsCustomRewardTemplateCollection = {
  __typename?: 'CommunityPointsCustomRewardTemplateCollection';
  /** The category these templated custom rewards are for. */
  category: CommunityPointsCustomRewardTemplateCollectionCategory;
  /** The templated custom rewards. */
  customRewardTemplates: Array<CommunityPointsCustomRewardTemplate>;
};

/** The possible categories for a collection of custom reward templates. */
export enum CommunityPointsCustomRewardTemplateCollectionCategory {
  /** The templates are for custom rewards that are related to actions in a game. */
  Game = 'GAME',
  /** The templates are for custom rewards that are related to actions irl. */
  Irl = 'IRL',
  /** The templates are for custom rewards that are related to actions on twitch. */
  Twitch = 'TWITCH',
  /** Unknown category. */
  Unknown = 'UNKNOWN'
}

/** Custom reward user redemption. */
export type CommunityPointsCustomRewardUserRedemption = {
  __typename?: 'CommunityPointsCustomRewardUserRedemption';
  /** The custom reward. */
  reward: CommunityPointsCustomReward;
  /** The amount of redempetions per user on this reward during the current stream. */
  userRedemptionsCurrentStream: Scalars['Int'];
};

/** Properties concerning the user's participation in the Community Points early access program. */
export type CommunityPointsEarlyAccessSettings = {
  __typename?: 'CommunityPointsEarlyAccessSettings';
  /** Whether the user is eligible to sign up for Community Points early access. */
  canSignUp: Scalars['Boolean'];
  /** Whether the user has signed up for Community Points early access. */
  isSignedUp: Scalars['Boolean'];
};

/** A community points emote. */
export type CommunityPointsEmote = {
  __typename?: 'CommunityPointsEmote';
  /** The emote's identifier. */
  id: Scalars['ID'];
  /** The text token of the emote. */
  token: Scalars['String'];
};

/** A community points emote modification. */
export type CommunityPointsEmoteModification = {
  __typename?: 'CommunityPointsEmoteModification';
  /** The modified emote. */
  emote: CommunityPointsEmote;
  /** Time that the modification was last updated globally in a way that should show a new content indicator to viewers. */
  globallyUpdatedForIndicatorAt: Scalars['Time'];
  /** The emote modification's identifier. */
  id: Scalars['ID'];
  /** The modifier of the emote. */
  modifier: CommunityPointsEmoteModifier;
  /**
   * The dark version of the icon to represent the modification made to the emote.
   * @deprecated Use field in modifier.
   */
  modifierIconDark: CommunityPointsImage;
  /**
   * The light version of the icon to represent the modification made to the emote.
   * @deprecated Use field in modifier.
   */
  modifierIconLight: CommunityPointsImage;
  /**
   * The title for the modification.
   * @deprecated Use field in modifier.
   */
  title: Scalars['String'];
};

/** A community points emote modifier. */
export type CommunityPointsEmoteModifier = {
  __typename?: 'CommunityPointsEmoteModifier';
  /** The dark version of the icon to represent a modification made to an emote. */
  iconDark: CommunityPointsImage;
  /** The light version of the icon to represent a modification made to an emote. */
  iconLight: CommunityPointsImage;
  /** The emote modifier's identifier. */
  id: Scalars['ID'];
  /** The title of the modifier. */
  title: Scalars['String'];
};

/** A community points emote variant, includes base emote plus modifications. */
export type CommunityPointsEmoteVariant = {
  __typename?: 'CommunityPointsEmoteVariant';
  /** The base emote for this variant. */
  emote: CommunityPointsEmote;
  /** The emote variant's identifier. */
  id: Scalars['ID'];
  /** Whether community points can be used to unlock the base emote. */
  isUnlockable: Scalars['Boolean'];
  /** The modifications available to be unlocked for this emote. */
  modifications: Array<CommunityPointsEmoteModification>;
};

/** Image URLs of different sizes for community points rewards. */
export type CommunityPointsImage = {
  __typename?: 'CommunityPointsImage';
  /** The URL for the small size image. */
  url: Scalars['String'];
  /** The URL for the medium size image. */
  url2x: Scalars['String'];
  /** The URL for the large size image. */
  url4x: Scalars['String'];
};

/** The information required for the client to upload an image for Community Points. */
export type CommunityPointsImageUploadInfo = {
  __typename?: 'CommunityPointsImageUploadInfo';
  /** The upload ID. */
  uploadID: Scalars['ID'];
  /** The URL to upload to. */
  url: Scalars['String'];
};

/** Holds the last time a content type was viewed. */
export type CommunityPointsLastViewedContentByType = {
  __typename?: 'CommunityPointsLastViewedContentByType';
  /** The type of content that was viewed at the lastViewedAt time. */
  contentType: CommunityPointsContentType;
  /** The time at which the contentType was last viewed. Will be null if the content hasn't been viewed. */
  lastViewedAt?: Maybe<Scalars['Time']>;
};

/** Holds the last time a specific piece of content was viewed. */
export type CommunityPointsLastViewedContentByTypeAndId = {
  __typename?: 'CommunityPointsLastViewedContentByTypeAndID';
  /** A unique identifier for the piece of content based on the type of content dictated by contentType. */
  contentID: Scalars['ID'];
  /** The type of content that was viewed at the lastViewedAt time. */
  contentType: CommunityPointsContentType;
  /** The time at which the content was last viewed. Will be null if the content hasn't been viewed. */
  lastViewedAt?: Maybe<Scalars['Time']>;
};

/** Availability of limited earn actions for a viewer in a specific channel. */
export type CommunityPointsLimitedEarnings = {
  __typename?: 'CommunityPointsLimitedEarnings';
  /**
   * Timestamp of when points will become available for cheering on the channel.
   * This will be nil if isCheerAvailable is true and can be nil when isCheerAvailable is false
   * indicating that there is not currently a time in the future when it will become available.
   */
  cheerAvailableAt?: Maybe<Scalars['Time']>;
  /** A unique identifier. */
  id: Scalars['ID'];
  /** Can the user cheer to get points on the channel. */
  isCheerAvailable: Scalars['Boolean'];
  /** Can the user follow to get points on the channel. */
  isFollowAvailable: Scalars['Boolean'];
  /** Can the user gift a subscription in the channel to get points on the channel. */
  isSubscriptionGiftAvailable: Scalars['Boolean'];
  /**
   * Timestamp of when points will become available for gifting subscriptions on the channel.
   * This will be nil if isSubscriptionGiftAvailable is true and can be nil when isSubscriptionGiftAvailable is false
   * indicating that there is not currently a time in the future when it will become available.
   */
  subscriptionGiftAvailableAt?: Maybe<Scalars['Time']>;
};

/** A multiplier affecting the rate of community points earned for a user in a channel. */
export type CommunityPointsMultiplier = {
  __typename?: 'CommunityPointsMultiplier';
  /**
   * The multiplying factor being applied.
   * Multipliers start at a base of 1.0, and are additive.
   * Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
   */
  factor: Scalars['Float'];
  /** The reason that the multiplier is being applied. */
  reasonCode: CommunityPointsMultiplierReason;
};

/** Reasons that community point earning could be multiplied for a user in a channel. */
export enum CommunityPointsMultiplierReason {
  /** Tier-1 Subscriber. */
  SubT1 = 'SUB_T1',
  /** Tier-2 Subscriber. */
  SubT2 = 'SUB_T2',
  /** Tier-3 Subscriber. */
  SubT3 = 'SUB_T3'
}

/** Properties relating to a user's community points in a channel. */
export type CommunityPointsProperties = {
  __typename?: 'CommunityPointsProperties';
  /**
   * Multipliers currently affecting the logged in user's rate of point gaining in this channel.
   * If there are no multipliers active, will be an empty array.
   */
  activeMultipliers?: Maybe<Array<CommunityPointsMultiplier>>;
  /** Points that are available for the user to click to claim in this channel. Null if there are no points available to claim. */
  availableClaim?: Maybe<CommunityPointsClaim>;
  /** The number of community points this user currently has available to use in this channel. */
  balance: Scalars['Int'];
  /**
   * Whether the user can redeem rewards on this channel for free.
   * The main example is broadcasters on their own channels.
   */
  canRedeemRewardsForFree: Scalars['Boolean'];
  /** The community goal contributions. */
  goalContributions?: Maybe<Array<CommunityPointsCommunityGoalContribution>>;
  /** Timestamps of when the user last viewed the different types of community points content on the channel. */
  lastViewedContent?: Maybe<Array<CommunityPointsLastViewedContentByType>>;
  /** Availability of limited earning actions for the user in this channel. */
  limitedEarnings?: Maybe<CommunityPointsLimitedEarnings>;
  /** The custom reward user redemptions for the current live stream. */
  userRedemptions?: Maybe<Array<CommunityPointsCustomRewardUserRedemption>>;
};

/** Optional filters that can be applied to a redemption queue query. */
export type CommunityPointsRedemptionQueueOptions = {
  /** The order of the results, either oldest first or newest first. */
  order?: InputMaybe<CommunityPointsCustomRewardRedemptionQueueSortOrder>;
  /** Filter results to only redemptions of this reward. */
  rewardID?: InputMaybe<Scalars['ID']>;
  /** Filter results to only redemptions of this status. */
  status?: InputMaybe<CommunityPointsCustomRewardRedemptionStatus>;
};

/**
 * A summary of information about redemptions of a given custom community points reward.
 * Only returns results for logged-in, authorized users, otherwise returns a nil response.
 */
export type CommunityPointsRewardSummary = {
  __typename?: 'CommunityPointsRewardSummary';
  /** The total number of unfulfilled redemptions of this reward on the channel. */
  count: Scalars['Int'];
  /**
   * If the count is at the max, the true count could be any number greater than or equal to the count.
   * Clients should indicate that there could be more redemptions than the number indicates.
   * For example, if count = 100 and isCountAtMaximum = true, clients could show "100+".
   */
  isCountAtMaximum: Scalars['Boolean'];
  /** The reward being summarized. */
  node: CommunityPointsCustomReward;
};

/** An error from redeeming an unlock emote Community Points reward. */
export type CommunityPointsUnlockEmoteError = {
  __typename?: 'CommunityPointsUnlockEmoteError';
  /** The error code. */
  code: CommunityPointsUnlockEmoteErrorCode;
};

/** Possible errors from redeeming an unlock emote Community Points reward. */
export enum CommunityPointsUnlockEmoteErrorCode {
  /** The user is already entitled to the emote provided. */
  EmoteAlreadyEntitled = 'EMOTE_ALREADY_ENTITLED',
  /** The user does not have sufficient points to redeem the reward. */
  InsufficientPoints = 'INSUFFICIENT_POINTS',
  /** The emote ID provided is for the wrong channel or the wrong type of emote. */
  InvalidEmote = 'INVALID_EMOTE',
  /** The user is entitled to all emotes that would be randomly selected from. */
  NoEmotesAvailable = 'NO_EMOTES_AVAILABLE',
  /** The reward cost has changed since the user has tried to redeem it. */
  RewardCostMismatch = 'REWARD_COST_MISMATCH',
  /** The reward is currently disabled. */
  RewardDisabled = 'REWARD_DISABLED',
  /** The user is not allowed to redeem this reward on this channel. */
  RewardForbidden = 'REWARD_FORBIDDEN',
  /** The client is retrying a redemption with a transaction id that has already been redeemed. */
  TransactionAlreadyCommitted = 'TRANSACTION_ALREADY_COMMITTED',
  /** The client is retrying a redemption with a transaction id that is currently being redeemed in another request. */
  TransactionInProgress = 'TRANSACTION_IN_PROGRESS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Methods for updating community points CustomReward redemption statuses. */
export enum CommunityPointsUpdateCustomRewardRedemptionStatusesMethod {
  /** Statuses for all redemptions for the channel are being updated. */
  ByChannel = 'BY_CHANNEL',
  /** Statuses for the provided redemptions are being updated. */
  ByRedemptions = 'BY_REDEMPTIONS',
  /** Statuses for all redemptions for a reward are being updated. */
  ByReward = 'BY_REWARD',
  /** Unknown method. */
  Unknown = 'UNKNOWN'
}

/** The type representing Community Points Update Custom Reward Redemption Statuses Progress. */
export type CommunityPointsUpdateCustomRewardRedemptionStatusesProgress = {
  __typename?: 'CommunityPointsUpdateCustomRewardRedemptionStatusesProgress';
  /** The channel ID the redemptions are being updated for. */
  channelID: Scalars['ID'];
  /** Unique identifier for the progress. */
  id: Scalars['ID'];
  /** The method being used to update the custom reward redemption statuses. */
  method: CommunityPointsUpdateCustomRewardRedemptionStatusesMethod;
  /** The new status the redemptions are being set to. */
  newStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The number of redemptions that have been processed so far. */
  processed: Scalars['Int'];
  /**
   * The reward ID the redemptions being updated are for.
   * Will only be set if method is BY_REWARD.
   */
  rewardID?: Maybe<Scalars['ID']>;
  /** The total number of redemptions being updated. */
  total: Scalars['Int'];
};

/** Properties relating to a user's community points across twitch. */
export type CommunityPointsUserProperties = {
  __typename?: 'CommunityPointsUserProperties';
  /** Timestamps of when the user last viewed the different global pieces of content for community points. */
  lastViewedContent?: Maybe<Array<CommunityPointsLastViewedContentByTypeAndId>>;
};

/** Settings for how many community points are awarded for a watch streak of a specific duration. */
export type CommunityPointsWatchStreakEarningSettings = {
  __typename?: 'CommunityPointsWatchStreakEarningSettings';
  /** How many points are awarded for a streak of this length. */
  points: Scalars['Int'];
  /** How long of a streak a user has. */
  streakLength: Scalars['Int'];
};

/** A company that is on Twitch. */
export type Company = {
  __typename?: 'Company';
  /** The bounty board campaigns that the company owns. */
  bountyCampaigns?: Maybe<BountyCampaignConnection>;
  /** The brand portal settings for the company. */
  brandPortalSettings?: Maybe<BrandPortalSettings>;
  /** ID of the Company in the CurseForge Infrastructure. */
  curseCompanyID?: Maybe<Scalars['ID']>;
  /** The estimated viewer reach for the pool of broadcasters this company is considering targeting. */
  estimatedBroadcasterViewerReach?: Maybe<BroadcasterViewerReach>;
  /**
   * The games associated with the company. Optionally include games that a company can use for Bounty Board
   * campaigns (ie. "Just Chatting" for trailer campaigns).
   */
  games?: Maybe<Array<Game>>;
  /** The company's unique identifier. */
  id: Scalars['ID'];
  /** Legacy Companies need to agree to the Drops Terms. */
  isCampaignsEnabled: Scalars['Boolean'];
  /** Legacy Companies are required to sign the Contract. */
  isContractSigned: Scalars['Boolean'];
  /** Indicates if the Company is a Legacy Company from the first iteration of the DevSite. */
  isLegacy: Scalars['Boolean'];
  /** The human-readable name of the company. */
  name: Scalars['String'];
  /** Indicates if company is a developer, publisher or other. */
  type: OrganizationType;
  /** The Company URL for their Corporate Website. */
  url: Scalars['String'];
};


/** A company that is on Twitch. */
export type CompanyBountyCampaignsArgs = {
  campaignID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<BountyCampaignStatus>;
};


/** A company that is on Twitch. */
export type CompanyEstimatedBroadcasterViewerReachArgs = {
  countries?: InputMaybe<Array<Scalars['String']>>;
  gameNames: Array<Scalars['String']>;
  streamLengthSeconds?: InputMaybe<Scalars['Int']>;
  targetAllBroadcasters: Scalars['Boolean'];
  targetAllCountries?: InputMaybe<Scalars['Boolean']>;
  targetAllGames?: InputMaybe<Scalars['Boolean']>;
  targetVarietyBroadcasters: Scalars['Boolean'];
};


/** A company that is on Twitch. */
export type CompanyGamesArgs = {
  includeBountyBoardGames?: InputMaybe<Scalars['Boolean']>;
};

/** A Competition created by a competition organizer. */
export type Competition = {
  __typename?: 'Competition';
  /** Banner image for the competition event page. */
  bannerImageURL?: Maybe<Scalars['String']>;
  /** The time when a competition organizer cancelled a competition. */
  cancelledAt?: Maybe<Scalars['Time']>;
  /** This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed. */
  checkInDurationMinutes: Scalars['Int'];
  /** The time the competition was created. */
  createdAt: Scalars['Time'];
  /** Long form text block description for the competition and will be converted to Markdown client-side. */
  description?: Maybe<Scalars['String']>;
  /** The time the competition is scheduled to end. */
  endAt: Scalars['Time'];
  /** The format contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.). */
  format: CompetitionFormat;
  /** The game being played in the competition. */
  game?: Maybe<Game>;
  /** Unique Competition ID. */
  id: Scalars['ID'];
  /** Primary artwork for the competition. */
  imageURL?: Maybe<Scalars['String']>;
  /** The name of the competition. */
  name: Scalars['String'];
  /** The competition organizer. */
  owner?: Maybe<User>;
  /** The participant-facing points of contact for the competition that only registered participants can see. */
  participantOnlyContactInfo?: Maybe<CompetitionContactInfo>;
  /** The type of participant for the competition. e.g. SOLO, TEAM, ... */
  participantType: CompetitionParticipantType;
  /** Paginated list of participants in the competition. */
  participants?: Maybe<CompetitionParticipantConnection>;
  /** A list of phases in the competition. */
  phases: Array<CompetitionPhase>;
  /** Paginated list of players in the competition. */
  players?: Maybe<CompetitionPlayerConnection>;
  /** Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side. */
  prizeDescription?: Maybe<Scalars['String']>;
  /** The public points of contact for the competition that anyone can see. */
  publicContactInfo?: Maybe<CompetitionContactInfo>;
  /** The time the competition is scheduled to end registration. */
  registrationEndAt: Scalars['Time'];
  /** The maximum number of players in a REGISTERED state. */
  registrationLimit: Scalars['Int'];
  /** The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ... */
  registrationType: RegistrationType;
  /** Long form text block description that explains the rules for the competition and will be converted to Markdown client-side. */
  rulesDescription?: Maybe<Scalars['String']>;
  /** The relationship between the authenticated user and the competition. */
  self?: Maybe<CompetitionSelfEdge>;
  /** Paginated, ordered list representing the standings of the competition. */
  standings?: Maybe<CompetitionStandingConnection>;
  /** The time the competition is scheduled to start. */
  startAt: Scalars['Time'];
  /** The state of the tournament. */
  state: CompetitionState;
  /** The number of players within a single team entity. Must be 1 for solo-type competitions. */
  teamSize: Scalars['Int'];
  /** Paginated list of teams in the competition. */
  teams?: Maybe<CompetitionTeamConnection>;
  /** Link URL to any additional terms and conditions. */
  termsURL?: Maybe<Scalars['String']>;
  /** The time the competition was last updated. */
  updatedAt: Scalars['Time'];
  /** Visibility of the competition. */
  visibility: CompetitionVisibilityState;
};


/** A Competition created by a competition organizer. */
export type CompetitionParticipantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A Competition created by a competition organizer. */
export type CompetitionPlayersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<CompetitionPlayerState>;
};


/** A Competition created by a competition organizer. */
export type CompetitionStandingsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A Competition created by a competition organizer. */
export type CompetitionTeamsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** Enum for fields passing through automod. */
export enum CompetitionAutomodField {
  /** Competition banner image URL. */
  BannerImageUrl = 'BANNER_IMAGE_URL',
  /** Competition name. */
  CompetitionName = 'COMPETITION_NAME',
  /** Competition description. */
  Description = 'DESCRIPTION',
  /** Competition image URL. */
  ImageUrl = 'IMAGE_URL',
  /** Public contact info discord URL. */
  PciDiscord = 'PCI_DISCORD',
  /** Public contact info email. */
  PciEmail = 'PCI_EMAIL',
  /** Player discord username. */
  PlayerDiscordUsername = 'PLAYER_DISCORD_USERNAME',
  /** Player in game username. */
  PlayerInGameUsername = 'PLAYER_IN_GAME_USERNAME',
  /** Participant only contact info discord URL. */
  PociDiscord = 'POCI_DISCORD',
  /** Participant only contact info email. */
  PociEmail = 'POCI_EMAIL',
  /** Competition prize description. */
  Prize = 'PRIZE',
  /** Competition rules description. */
  Rules = 'RULES',
  /** Team name. */
  TeamName = 'TEAM_NAME',
  /** Terms URL. */
  TermsUrl = 'TERMS_URL',
  /** Used when the field is unknown. */
  Unknown = 'UNKNOWN'
}

/** Paginated list of Competitions. */
export type CompetitionConnection = {
  __typename?: 'CompetitionConnection';
  /** The elements of the list. */
  edges: Array<CompetitionEdge>;
  /** Are there more competitions in the list and what is the cursor. */
  pageInfo: PageInfo;
};

/** The contact information to contact the organizers for the competition. */
export type CompetitionContactInfo = {
  __typename?: 'CompetitionContactInfo';
  /** Link to Discord server for competition contact purposes. */
  discordURL?: Maybe<Scalars['String']>;
  /** Email address point of contact for the competition. */
  email?: Maybe<Scalars['String']>;
};

/**
 * Contains information about a Competition's relationship to a given page (connection),
 * and the Competition itself.
 */
export type CompetitionEdge = {
  __typename?: 'CompetitionEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A competition record in the list of competitons. */
  node: Competition;
};

/** Information to communicate to the user about an error state. */
export type CompetitionError = {
  __typename?: 'CompetitionError';
  /** The fields failing to pass automod (on an automod failure). */
  automodFailedFields?: Maybe<Array<CompetitionAutomodField>>;
  /** The error code. */
  code: CompetitionErrorCode;
  /** The error message string. */
  message: Scalars['String'];
};

/** Enum for user errors. */
export enum CompetitionErrorCode {
  /** Used when an attempt to add a resource but that resource already exists. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** Used when a competition field fails to pass automod. */
  AutomodFailed = 'AUTOMOD_FAILED',
  /** Used when an argument that is passed in is invalid in some way. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Used when the registration limit on the competition has been reached. */
  LimitReached = 'LIMIT_REACHED',
  /** Used when an argument is missing but was required. */
  RequiredArgument = 'REQUIRED_ARGUMENT',
  /** Used when the error is unknown. */
  Unknown = 'UNKNOWN'
}

/** The CompetitionFormat contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.). */
export type CompetitionFormat = {
  __typename?: 'CompetitionFormat';
  /** The details of the format, currently only used for LEADERBOARD type. */
  details?: Maybe<FormatTypeDetails>;
  /** The type of the format for the competition. */
  type: FormatType;
};

/** The competition Image type sent by the user to determine what image is being uploaded to the competition. */
export enum CompetitionImageType {
  /** Banner image for the competition. */
  Banner = 'BANNER',
  /** Thumbnail image for the competition. */
  Thumbnail = 'THUMBNAIL',
  /** Image type is unknown. */
  Unknown = 'UNKNOWN'
}

/** Identifiers for the competition image. */
export type CompetitionImageUpload = {
  __typename?: 'CompetitionImageUpload';
  /** ID of the upload. */
  id: Scalars['ID'];
  /** URL at which clients can access the image. */
  url: Scalars['String'];
};

/** A Lobby in a phase. */
export type CompetitionLobby = {
  __typename?: 'CompetitionLobby';
  /** Lobby ID of lobby to advance the winner to. */
  advanceNextLobby?: Maybe<Scalars['ID']>;
  /** Unique lobby ID. */
  id: Scalars['ID'];
  /** Lobby ID of lobby to advance the loser to. */
  lossNextLobby?: Maybe<Scalars['ID']>;
  /** The participants of a lobby, and their scores. */
  participants?: Maybe<Array<CompetitionLobbyParticipant>>;
  /** The count of reported scores of the lobby. */
  reportedScoreCount: Scalars['Int'];
  /** The state of the lobby. */
  state: LobbyState;
  /** The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie and winner returns null */
  winner?: Maybe<CompetitionLobbyParticipant>;
};

/** A CompetitionLobbyParticipant, and its scores, in a lobby. */
export type CompetitionLobbyParticipant = {
  __typename?: 'CompetitionLobbyParticipant';
  /** The detailed participant associated with the lobby participant, can be a Competition Player or Competition Team. */
  detailedParticipant: CompetitionParticipant;
  /** Unique ID for CompetitionLobbyParticipant. */
  id: Scalars['ID'];
  /** The score for this participant. */
  score?: Maybe<Scalars['Int']>;
  /** Tie breaker points awarded to the participant for this lobby */
  tiebreakerScore?: Maybe<Scalars['Int']>;
};

/** The features a user has access to when creating a competition with the Versus product. */
export type CompetitionOrganizerCapability = {
  __typename?: 'CompetitionOrganizerCapability';
  /** The features a user available to them when they are a Competition Organizer. null or [] mean no special permissions are given to this user. */
  allowedRegistrationTypes?: Maybe<Array<RegistrationType>>;
  /** Can this user upload or attach additional terms of service for a competition. */
  canAttachTerms?: Maybe<Scalars['Boolean']>;
  /** Can this user create competitions in Versus. */
  canCreateCompetitions?: Maybe<Scalars['Boolean']>;
  /** Can this user change participant statuses (invited -> registered) without participant consent. */
  canManageParticipantStatus?: Maybe<Scalars['Boolean']>;
  /** Can this user host a Custom Format competition. */
  canUseCustomFormat?: Maybe<Scalars['Boolean']>;
};

/** A CompetitionParticipant is either a CompetitionPlayer who is playing solo or a CompetitionTeam who plays as a team. */
export type CompetitionParticipant = CompetitionPlayer | CompetitionTeam;

/** Sorted list of competition participants. */
export type CompetitionParticipantConnection = {
  __typename?: 'CompetitionParticipantConnection';
  /** The elements of the list. */
  edges: Array<CompetitionParticipantEdge>;
  /** Are there more competition participants and what is the cursor. */
  pageInfo: PageInfo;
  /** The total amount of competition participants in the competition. */
  totalCount: Scalars['Int'];
};

/**
 * Contains information about a competition participant relationship to the paginated request,
 * and the participant themselves.
 */
export type CompetitionParticipantEdge = {
  __typename?: 'CompetitionParticipantEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A competition participant record. */
  node: CompetitionParticipant;
};

/** The participant type signifies whether the competition will be played as team or solo. */
export enum CompetitionParticipantType {
  /** Participant is represented as solo. */
  Solo = 'SOLO',
  /** Participants are represented as a team. */
  Team = 'TEAM',
  /** Unknown participant type. */
  Unknown = 'UNKNOWN'
}

/** A Phase created by a competition organizer. */
export type CompetitionPhase = {
  __typename?: 'CompetitionPhase';
  /** Unique phase ID. */
  id: Scalars['ID'];
  /** The lobbies in a phase. */
  lobbies: Array<CompetitionLobby>;
  /** The state of the phase. It is derived on whether any of the lobbies are actively playing. */
  state: PhaseState;
  /** For more complex tournaments, the type determines how you progress after a phase. */
  type?: Maybe<CompetitionPhaseType>;
};

/** The phase type subdivides phases for more complex tournament types. */
export enum CompetitionPhaseType {
  /** This phase contains participants who have lost a lobby once. */
  DoubleEliminationLosers = 'DOUBLE_ELIMINATION_LOSERS',
  /** This phase contains participants who have not used their second-chance. */
  DoubleEliminationWinners = 'DOUBLE_ELIMINATION_WINNERS',
  /** Phase type is not applicable to a phase of this competition type. */
  NotApplicable = 'NOT_APPLICABLE',
  /** Phase type is unknown. */
  Unknown = 'UNKNOWN'
}

/** The placement within the competition for an participant. */
export type CompetitionPlacement = {
  __typename?: 'CompetitionPlacement';
  /** The position in the total participant list a participant ranks. */
  position?: Maybe<Scalars['Int']>;
};

/** A player is solo participant in a Competition. */
export type CompetitionPlayer = {
  __typename?: 'CompetitionPlayer';
  /** Competition ID player is a part of. */
  competitionID: Scalars['ID'];
  /** The time the player was added. */
  createdAt: Scalars['Time'];
  /** The discord username for the player. */
  discordUsername?: Maybe<Scalars['String']>;
  /** Unique ID for competition player. */
  id: Scalars['ID'];
  /** The in game username for the player. */
  inGameUsername?: Maybe<Scalars['String']>;
  /** Indicates whether the player is disqualified. */
  isDisqualified: Scalars['Boolean'];
  /** The state a player has in the competition. */
  state: CompetitionPlayerState;
  /** The associated team the user is part of. */
  team?: Maybe<CompetitionTeam>;
  /** The total score for the competition player. */
  totalScore: Scalars['Int'];
  /** The associated user. */
  user: User;
};

/** Paginated list of players in a Competition. */
export type CompetitionPlayerConnection = {
  __typename?: 'CompetitionPlayerConnection';
  /** The elements of the list. */
  edges: Array<CompetitionPlayerEdge>;
  /** Are there more players in the competition and what is the cursor. */
  pageInfo: PageInfo;
  /** The total amount of players in the competition. */
  totalCount: Scalars['Int'];
};

/**
 * Contains information about a Players relationship to a given page (connection),
 * and the Player themselves.
 */
export type CompetitionPlayerEdge = {
  __typename?: 'CompetitionPlayerEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A competition record in the list of competitions. */
  node: CompetitionPlayer;
};

/** The states a player can have in the competition. */
export enum CompetitionPlayerState {
  /** The player has checked in to compete now. */
  CheckedIn = 'CHECKED_IN',
  /** The player has competed in the competition. */
  Competed = 'COMPETED',
  /** The player has declined the competition. */
  Declined = 'DECLINED',
  /** The player has been invited. */
  Invited = 'INVITED',
  /** The player has registered to compete in this competition in the future. */
  Registered = 'REGISTERED',
  /** The player state is unknown. */
  Unknown = 'UNKNOWN'
}

/** The relationship between the authenticated user and the competition. */
export type CompetitionSelfEdge = {
  __typename?: 'CompetitionSelfEdge';
  /** Whether the user is invited to the competition. */
  isInvited?: Maybe<Scalars['Boolean']>;
  /** Whether the user is the owner. */
  isOwner?: Maybe<Scalars['Boolean']>;
  /** Whether the user is a player in the competition. */
  isPlayer?: Maybe<Scalars['Boolean']>;
  /** Whether the user is registered in the competition. */
  isRegistered?: Maybe<Scalars['Boolean']>;
};

/** A single participant's competition standing including score and placement. */
export type CompetitionStanding = {
  __typename?: 'CompetitionStanding';
  /** A record of all lobbies (1 per phase) in which the participant has competed. */
  history?: Maybe<Array<HistoricalCompetitionLobby>>;
  /** The participant whose score and placement are being reported. */
  participant: CompetitionParticipant;
  /** Placement is a participant's rank in the competition standings. */
  placement: CompetitionPlacement;
  /** The participant's current score for the competition. */
  score?: Maybe<Scalars['Int']>;
  /** Summation of bonus points awarded to a participant. */
  tiebreakerScore?: Maybe<Scalars['Int']>;
  /** Percentage of done lobbies the participant has won out of the done lobbies the participant in, if participant is not in any done lobbies this will be null. */
  winPercentage?: Maybe<Scalars['Int']>;
};

/** Paginated list of standings for a Competition. */
export type CompetitionStandingConnection = {
  __typename?: 'CompetitionStandingConnection';
  /** The elements of the list. */
  edges: Array<CompetitionStandingEdge>;
  /** Are there more standings for the competition and what is the cursor. */
  pageInfo: PageInfo;
};

/**
 * Contains information about a CompetitionStanding's relationship to a given page (connection),
 * and the standing itself.
 */
export type CompetitionStandingEdge = {
  __typename?: 'CompetitionStandingEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A competition standing record in the list of competition standings. */
  node: CompetitionStanding;
};

/** The State of the Competition. */
export enum CompetitionState {
  /** A competition that finished with no conclusion. */
  Cancelled = 'CANCELLED',
  /** A competition that's awaiting check-ins. */
  CheckIn = 'CHECK_IN',
  /** Live competition. */
  Live = 'LIVE',
  /** Past competition. */
  Past = 'PAST',
  /** A competition that's ready to be started. */
  Ready = 'READY',
  /** Unknown state. */
  Unknown = 'UNKNOWN',
  /** Upcoming competition. */
  Upcoming = 'UPCOMING'
}

/** A Team is scheduled or has competed in a Competition. */
export type CompetitionTeam = {
  __typename?: 'CompetitionTeam';
  /** The captain of the team is a Competition Player. */
  captain?: Maybe<CompetitionPlayer>;
  /** CompetitionID we are a part of. */
  competitionID: Scalars['ID'];
  /** Unique ID for competition team. */
  id: Scalars['ID'];
  /** Indicates whether the team is disqualified. */
  isDisqualified: Scalars['Boolean'];
  /** The members of the team are Competition Players. */
  members?: Maybe<Array<CompetitionPlayer>>;
  /** The name of the competition team. */
  name: Scalars['String'];
  /** The relationship between the authenticated user and the competition team. */
  self?: Maybe<CompetitionTeamSelfEdge>;
  /** The total score for the competition team. */
  totalScore: Scalars['Int'];
};

/** List of competition teams and their scores. */
export type CompetitionTeamConnection = {
  __typename?: 'CompetitionTeamConnection';
  /** The elements of the list. */
  edges: Array<CompetitionTeamEdge>;
  /** Are there more teams in the competition and what is the cursor. */
  pageInfo: PageInfo;
  /** The total amount of teams in the competition. */
  totalCount: Scalars['Int'];
};

/**
 * Contains information about a Team relationship to a given page (connection),
 * and the Team themselves.
 */
export type CompetitionTeamEdge = {
  __typename?: 'CompetitionTeamEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A competition team record. */
  node: CompetitionTeam;
};

/** The relationship between the authenticated user and the competition Team. */
export type CompetitionTeamSelfEdge = {
  __typename?: 'CompetitionTeamSelfEdge';
  /** Whether the user is the captain. */
  isCaptain: Scalars['Boolean'];
};

/** Information to communicate to the user about an error state. */
export type CompetitionUploadImageError = {
  __typename?: 'CompetitionUploadImageError';
  /** The error code. */
  code: CompetitionUploadImageErrorCode;
  /** The error message string. */
  message: Scalars['String'];
};

/** Enum for user errors. */
export enum CompetitionUploadImageErrorCode {
  /** Used when an argument that is passed in is invalid in some way. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Used when an argument is missing but was required. */
  RequiredArgument = 'REQUIRED_ARGUMENT',
  /** Used when the error is unknown. */
  Unknown = 'UNKNOWN'
}

/** The Visibility of the Competition. */
export enum CompetitionVisibilityState {
  /** Private competition. */
  Private = 'PRIVATE',
  /** Public competition. */
  Public = 'PUBLIC',
  /** Unknown state. */
  Unknown = 'UNKNOWN'
}

/** The required configuration to activate a component extension. */
export type ComponentActivationInput = {
  /** The slot name of where the component extension should be displayed. */
  slot: Scalars['String'];
  /**
   * The horizontal positioning of the left side of the component extension from the left side
   * of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
   */
  x?: InputMaybe<Scalars['Int']>;
  /**
   * The vertical positioning of the top side of the component extension from the top side
   * of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
   */
  y?: InputMaybe<Scalars['Int']>;
};

/** The view configuration of an extension if the component anchor is supported. */
export type ComponentView = ExtensionView & {
  __typename?: 'ComponentView';
  /**
   * Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  aspectRatioX: Scalars['Int'];
  /**
   * Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  aspectRatioY: Scalars['Int'];
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /**
   * Specifies whether to automatically scale the extension iframe using css zoom as the video
   * player dimensions change.
   */
  hasAutoscale: Scalars['Boolean'];
  /**
   * If Autoscale is true, this indicates the baseline width of the extension.
   * This fields is optional, but is required if hasAutoscale is true.
   */
  scalePixels?: Maybe<Scalars['Int']>;
  /**
   * The percentage of the available space (0-100) (between the top and bottom player controls)
   * that the extension aims to consume.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  targetHeight: Scalars['Int'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** The view configuration of an extension if the component anchor is supported. */
export type ComponentViewInput = {
  /** The developer configured height of the extension as a ratio relative to it's width. */
  aspectHeight: Scalars['Int'];
  /** The developer configured width of the extension as a ratio relative to it's height. */
  aspectWidth: Scalars['Int'];
  /**
   * Specifies whether CSS zooming should be applied to the CE container, creating a consistent
   * size of 1024 pixels along the long edge of the component. Default: true.
   */
  hasZoom: Scalars['Boolean'];
  /**
   * Size of the long edge of the Component Extension, relative to the length of the corresponding
   * interactable dimension of the video.
   */
  size: Scalars['Float'];
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
  /**
   * If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
   * Default: 1024.
   */
  zoomPixels?: InputMaybe<Scalars['Int']>;
};

/** ConfigView holds the view configuration of an extension if the config page is supported. */
export type ConfigView = ExtensionView & {
  __typename?: 'ConfigView';
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** ConfigViewInput holds the view configuration of an extension if the config page is supported. */
export type ConfigViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** ConnectAdIdentityInput accepts a deviceID and other parameters to generate an ad identity for that user. */
export type ConnectAdIdentityInput = {
  /** mobile is an optional field that provides mobile device data. */
  mobile?: InputMaybe<MobileAdIdentityInput>;
  /** targetDeviceID is the acting device ID. */
  targetDeviceID: Scalars['ID'];
};

/** ConnectAdIdentityPayload contains the identity URL. */
export type ConnectAdIdentityPayload = {
  __typename?: 'ConnectAdIdentityPayload';
  /** URL that the client should use to link ad identity. */
  identityURL?: Maybe<Scalars['String']>;
};

/** The consent status returned for the current user. */
export type Consent = {
  __typename?: 'Consent';
  /** The unique identifier of a consent status. */
  id: Scalars['ID'];
  /** Identifier to determine whether consent is denied due to user underage. */
  isDeniedUnderage: Scalars['Boolean'];
  /** Privacy law, e.g. CCPA or GDPR. */
  privacyLawName: PrivacyLawName;
  /** Identifier to determine whether should notification to the user. */
  shouldShowNotification: Scalars['Boolean'];
  /** Identifier to determine whether should show the consent settings page to the user. */
  shouldShowSettingsPage: Scalars['Boolean'];
  /** A list of vendor consent status of a user. */
  vendorConsentStatus: VendorConsent;
  /**
   * A list of vendor consent status of a user.
   * @deprecated Use vendorConsentStatus instead
   */
  vendorStatus: Array<VendorConsentStatus>;
};

/** List of features from GVL https://vendorlist.consensu.org/v2/vendor-list.json. */
export enum ConsentFeature {
  /** Link different devices. */
  LinkDifferentDevices = 'LINK_DIFFERENT_DEVICES',
  /** Match and combine offline data sources. */
  MatchCombineOfflineDataSources = 'MATCH_COMBINE_OFFLINE_DATA_SOURCES',
  /** Receive and use automati…tics for identification. */
  ReceiveUseAutoSentDeviceCharacteristicsForIdentification = 'RECEIVE_USE_AUTO_SENT_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION'
}

/** List of purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json. */
export enum ConsentPurpose {
  /** Apply market research to…erate audience insights. */
  ApplyMarketResearchToGenerateAudienceInsights = 'APPLY_MARKET_RESEARCH_TO_GENERATE_AUDIENCE_INSIGHTS',
  /** Create a personalised ads profile. */
  CreatePersonalisedAdsProfile = 'CREATE_PERSONALISED_ADS_PROFILE',
  /** Create a personalised content profile. */
  CreatePersonalisedContentProfile = 'CREATE_PERSONALISED_CONTENT_PROFILE',
  /** Develop and improve products. */
  DevelopImproveProducts = 'DEVELOP_IMPROVE_PRODUCTS',
  /** Measure ad performance. */
  MeasureAdPerformance = 'MEASURE_AD_PERFORMANCE',
  /** Measure content performance. */
  MeasureContentPerformance = 'MEASURE_CONTENT_PERFORMANCE',
  /** Select basic ads. */
  SelectBasicAds = 'SELECT_BASIC_ADS',
  /** Select personalised ads. */
  SelectPersonalisedAds = 'SELECT_PERSONALISED_ADS',
  /** Select personalised content. */
  SelectPersonalisedContent = 'SELECT_PERSONALISED_CONTENT',
  /** Store and/or access information on a device. */
  StoreAccessInfoOnDevice = 'STORE_ACCESS_INFO_ON_DEVICE'
}

/** List of special features from GVL https://vendorlist.consensu.org/v2/vendor-list.json. */
export enum ConsentSpecialFeature {
  /** Actively scan device cha…tics for identification. */
  ActivelyScanDeviceCharacteristicsForIdentification = 'ACTIVELY_SCAN_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION',
  /** Use precise geolocation data. */
  UsePreciseGeoData = 'USE_PRECISE_GEO_DATA'
}

/** List of special purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json. */
export enum ConsentSpecialPurpose {
  /** Ensure security, prevent fraud, and debug. */
  EnsureSecurityPreventFraudDebug = 'ENSURE_SECURITY_PREVENT_FRAUD_DEBUG',
  /** Technically deliver ads or content. */
  TechnicallyDeliverAdsContent = 'TECHNICALLY_DELIVER_ADS_CONTENT'
}

/** ConsentStatus is the flag to show user gives or denies the consent. */
export enum ConsentStatus {
  /** User denies consent. */
  Denied = 'DENIED',
  /** User gives consent. */
  Given = 'GIVEN'
}

/** An enumeration on the different content type that enable tagging. */
export enum ContentType {
  /** Games and other stream categories. */
  Category = 'CATEGORY',
  /** Clip will enable tagging in v2. */
  Clip = 'CLIP',
  /** @deprecated Use 'USER' instead */
  LiveChannel = 'LIVE_CHANNEL',
  /** User is enabled for tagging in v1. */
  User = 'USER',
  /** VOD will enable tagging in v2. */
  Vod = 'VOD'
}

/** Contribute community goal error. */
export type ContributeCommunityPointsCommunityGoalError = {
  __typename?: 'ContributeCommunityPointsCommunityGoalError';
  /** The error code. */
  code: ContributeCommunityPointsCommunityGoalErrorCode;
};

/** Contribute community goal error codes. */
export enum ContributeCommunityPointsCommunityGoalErrorCode {
  /** The current user has already completed this transaction. */
  DuplicateTransaction = 'DUPLICATE_TRANSACTION',
  /** The current user is not allowed to contribute community points towards community goals for this channel. */
  Forbidden = 'FORBIDDEN',
  /** The current user has already reached the maximum points contributable per stream. */
  MaxPerStream = 'MAX_PER_STREAM',
  /** The goal is not currently redeemable, possibly because stream is not live. */
  NotCurrentlyRedeemable = 'NOT_CURRENTLY_REDEEMABLE',
  /** The current user does not have enough points to contribute this amount. */
  NotEnoughPoints = 'NOT_ENOUGH_POINTS',
  /** The community goal was not found. */
  NotFound = 'NOT_FOUND',
  /** The current user has a contribution already in progress. */
  TransactionInProgress = 'TRANSACTION_IN_PROGRESS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** The current user is banned. */
  UserBanned = 'USER_BANNED'
}

/** Contribute community goal input. */
export type ContributeCommunityPointsCommunityGoalInput = {
  /** The redemption amount. */
  amount: Scalars['Int'];
  /** The channel. */
  channelID: Scalars['ID'];
  /** The id of the community goal. */
  goalID: Scalars['ID'];
  /** The id of this transaction. */
  transactionID: Scalars['ID'];
};

/** Contribute community goal payload. */
export type ContributeCommunityPointsCommunityGoalPayload = {
  __typename?: 'ContributeCommunityPointsCommunityGoalPayload';
  /** The error, if any. */
  error?: Maybe<ContributeCommunityPointsCommunityGoalError>;
};

/** Contribute to challenge error. */
export type ContributeToChallengeError = {
  __typename?: 'ContributeToChallengeError';
  /** Code describing the error. */
  code: ContributeToChallengeErrorCode;
};

/** Contribute to challenge error code. */
export enum ContributeToChallengeErrorCode {
  /** User tried to contribute to a challenge that is not active. */
  ChallengeNotActive = 'CHALLENGE_NOT_ACTIVE',
  /** User tried to contribute to a challenge that doesn't exist i.e. there is no indicated challenge at all). */
  ChallengeNotFound = 'CHALLENGE_NOT_FOUND',
  /** User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100). */
  InsufficientBitsBalance = 'INSUFFICIENT_BITS_BALANCE',
  /** Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist). */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** User is not allowed to contribute to the challenge (e.g. they're banned in the channel). */
  UserForbidden = 'USER_FORBIDDEN'
}

/** Inputs for contributing to a challenge. */
export type ContributeToChallengeInput = {
  /** The amount of bits being contributed for this challenge. */
  bits: Scalars['Int'];
  /** The id of the challenge that is being contributed to. */
  challengeID: Scalars['ID'];
  /** The user id of the contributer. */
  userID: Scalars['ID'];
};

/** Output from the contribute to challenge mutation. */
export type ContributeToChallengePayload = {
  __typename?: 'ContributeToChallengePayload';
  /** The participant object returned by the Contribute to Challenge operation. */
  challengeParticipant?: Maybe<ChannelChallengeParticipant>;
  /** If present, there was an error with the request. */
  error?: Maybe<ContributeToChallengeError>;
};

/** CookieVendorType is the type of cookie. */
export enum CookieVendorType {
  /** Vendors cookies that are used for advertising purposes. */
  Advertising = 'ADVERTISING',
  /** Vendors cookies that are used for analytics purposes. */
  Analytics = 'ANALYTICS',
  /** Vendors cookies that are essential. */
  Essential = 'ESSENTIAL'
}

/** Errors for creating emotes. */
export type CreateArchivedEmoteError = {
  __typename?: 'CreateArchivedEmoteError';
  /** The associated error code. */
  code: CreateArchivedEmoteErrorCode;
};

/** Possible error codes returned for creating emotes. */
export enum CreateArchivedEmoteErrorCode {
  /** The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines). */
  EmoteCodeUnacceptable = 'EMOTE_CODE_UNACCEPTABLE',
  /** The uploaded emote image could not be found. */
  EmoteImageNotFound = 'EMOTE_IMAGE_NOT_FOUND',
  /** The creator has reached their limit of archived emotes. */
  EmoteLimitReached = 'EMOTE_LIMIT_REACHED',
  /** An animated image asset was not supplied, but is required for the selected asset type. */
  EmoteMissingAnimatedAsset = 'EMOTE_MISSING_ANIMATED_ASSET',
  /** A static image asset was not supplied, but is required for the selected asset type. */
  EmoteMissingStaticAsset = 'EMOTE_MISSING_STATIC_ASSET',
  /** Data for least one of the image sizes is not provided or invalid. */
  IncompleteEmoteImageData = 'INCOMPLETE_EMOTE_IMAGE_DATA',
  /** The emote code suffix submitted contains invalid characters. */
  InvalidCodeSuffix = 'INVALID_CODE_SUFFIX',
  /** The selected emote asset type was invalid. */
  InvalidEmoteAssetType = 'INVALID_EMOTE_ASSET_TYPE',
  /** The selected emote state was invalid. */
  InvalidEmoteState = 'INVALID_EMOTE_STATE',
  /** The upload emote image could not be parsed. */
  InvalidImageUpload = 'INVALID_IMAGE_UPLOAD',
  /** Only the channel owner is allowed to upload archived emotes. */
  InvalidOwner = 'INVALID_OWNER',
  /** There were not enough image assets supplied for the selected asset type. */
  NotEnoughEmoteImageAssets = 'NOT_ENOUGH_EMOTE_IMAGE_ASSETS',
  /** There were more emote groups supplied than required for the emote state. */
  TooManyEmoteGroups = 'TOO_MANY_EMOTE_GROUPS',
  /** There were more image assets supplied than required for the selected asset type. */
  TooManyEmoteImageAssets = 'TOO_MANY_EMOTE_IMAGE_ASSETS',
  /** Other errors returned from the service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The data needed to finalize the creation of a non-active (aka archived) Emote. */
export type CreateArchivedEmoteInput = {
  /** The type of image asset for the emote. */
  assetType?: InputMaybe<EmoteAssetType>;
  /** The channel's emote prefix and the codeSuffix of the emote put together. This is how the emote is invoked in chat. */
  code: Scalars['String'];
  /** The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code. */
  codeSuffix: Scalars['String'];
  /** A list containing the image IDs for all assets needed for the emote. */
  imageAssets: Array<EmoteImageAssetInput>;
};

/** Results of the create emote publish. */
export type CreateArchivedEmotePayload = {
  __typename?: 'CreateArchivedEmotePayload';
  /** The newly created emote if successful. */
  emote?: Maybe<Emote>;
  /** Service error, if any. */
  error?: Maybe<CreateArchivedEmoteError>;
};

/** A 4xx-level error from the CreateBadgeFlair mutation */
export type CreateBadgeFlairError = {
  __typename?: 'CreateBadgeFlairError';
  /** Code describing the cause of the error. */
  code: CreateBadgeFlairErrorCode;
  /** String containing any relevant error message from Subscriptions. */
  message: Scalars['String'];
};

/** Error code describing a CreateBadgeFlairError */
export enum CreateBadgeFlairErrorCode {
  /** Channel ID argument was invalid or empty. */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** Image ID for 1x image was invalid or empty. */
  InvalidFlairImage_1XId = 'INVALID_FLAIR_IMAGE_1X_ID',
  /** Image ID for 2x image was invalid or empty. */
  InvalidFlairImage_2XId = 'INVALID_FLAIR_IMAGE_2X_ID',
  /** Image ID for 4x image was invalid or empty. */
  InvalidFlairImage_4XId = 'INVALID_FLAIR_IMAGE_4X_ID',
  /** Tier value was invalid or empty. */
  InvalidTier = 'INVALID_TIER'
}

/** Input to the CreateBadgeFlair mutation */
export type CreateBadgeFlairInput = {
  /** ID of the creator/channel which owns this custom badge flair. */
  channelID: Scalars['ID'];
  /** The S3 ID of the 1x sized badge, provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation). */
  image1xID: Scalars['ID'];
  /** The S3 ID of the 2x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation). */
  image2xID: Scalars['ID'];
  /** The S3 ID of the 4x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation). */
  image4xID: Scalars['ID'];
  /** Sub tier which receives access to this flair. */
  tier: CreatorBadgeFlairTier;
};

/** Payload from the CreateBadgeFlair mutation */
export type CreateBadgeFlairPayload = {
  __typename?: 'CreateBadgeFlairPayload';
  /** Error representing any 4xx-level error, if any. */
  error?: Maybe<CreateBadgeFlairError>;
};

/** CreateBitsChallengeConditionForExtensionInput creates a Bits condition on behalf of a user by an extension. */
export type CreateBitsChallengeConditionForExtensionInput = {
  /**
   * A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
   * If this is not defined during condition creation, it must be defined when the condition is satisfied.
   */
  bitsRecipientWeightedShares?: InputMaybe<Array<BitsChallengeConditionPoolRecipientWeightedShare>>;
  /** Description of the condition. */
  description?: InputMaybe<Scalars['String']>;
  /** Whether to disable the condition once it has been satisfied or keep it active. */
  disableWhenSatisfied: Scalars['Boolean'];
  /** ID of the extension creating the conditional. */
  extensionID: Scalars['ID'];
  /**
   * ID of the channel where the extension is installed.
   * TODO: change to required once the extension coordinator starts sending this param.
   */
  extensionInstallationChannelID?: InputMaybe<Scalars['ID']>;
  /** Name of the condition. */
  name: Scalars['String'];
  /** Time when the condition should time out. */
  timeoutAt?: InputMaybe<Scalars['Time']>;
};

/** CreateBitsChallengeConditionForExtensionPayload returns the new condition that was created. */
export type CreateBitsChallengeConditionForExtensionPayload = {
  __typename?: 'CreateBitsChallengeConditionForExtensionPayload';
  /** The newly created condition. */
  condition?: Maybe<ChallengeCondition>;
  /** If present, there was an error in the request. */
  error?: Maybe<CreateChallengeConditionError>;
};

/** CreateBitsChallengeConditionParticipantForExtensionInput creates a Bits condition participant on behalf of a user by an extension. */
export type CreateBitsChallengeConditionParticipantForExtensionInput = {
  /** Bits quantity to be held pending condition satisfaction. */
  bitsAmount: Scalars['Int'];
  /** ID of the associated condition. */
  conditionID: Scalars['ID'];
  /** TUID of condition owner. */
  conditionOwnerID: Scalars['ID'];
  /** ID of the extension creating the conditionParticipant. */
  extensionID: Scalars['ID'];
  /** Time in seconds, after which the conditionParticipant is expired and the Bits are released (range: 1-43_200). */
  ttlSeconds: Scalars['Int'];
};

/** CreateBitsChallengeConditionParticipantForExtensionPayload returns the new condition participant that was created. */
export type CreateBitsChallengeConditionParticipantForExtensionPayload = {
  __typename?: 'CreateBitsChallengeConditionParticipantForExtensionPayload';
  /** The newly created condition participant. */
  conditionParticipant?: Maybe<ChallengeConditionParticipant>;
  /** If present, there was an error in the request. */
  error?: Maybe<CreateChallengeConditionParticipantError>;
};

/** CreateBountyCampaignInput includes the campaign that is being created. */
export type CreateBountyCampaignInput = {
  /** The platforms that the campaign applies to. */
  availablePlatforms?: InputMaybe<Array<Scalars['String']>>;
  /** The list of broadcaster IDs to blacklist (if any) for the campaign. */
  blacklistedBroadcasters?: InputMaybe<Array<Scalars['ID']>>;
  /** Optional box art URL for the campaign. */
  boxArtURL?: InputMaybe<Scalars['String']>;
  /** The message that will be shown to the broadcaster when they view the campaign. */
  broadcasterMessage?: InputMaybe<Scalars['String']>;
  /** The multiplier for the broadcaster payout rate. */
  broadcasterMultiplier: Scalars['Float'];
  /** The budget for the campaign in cents. */
  budgetCents: Scalars['Int'];
  /** The chat Calls to Action for the campaign. */
  chatCTAs?: InputMaybe<Array<BountyCampaignChatCtaInput>>;
  /** The ID of the content that the campaign is related to. */
  contentID?: InputMaybe<Scalars['ID']>;
  /** Optional cover URL for the campaign. */
  coverURL?: InputMaybe<Scalars['String']>;
  /** Optional display for the campaign. */
  displayName?: InputMaybe<Scalars['String']>;
  /** When the campaign will end. */
  endAt: Scalars['Time'];
  /** If the campaing is a promotional campaign. */
  isPromotionEligible?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the organization that the campaign is related to. */
  organizationID: Scalars['ID'];
  /** If the campaign should allow any game to be played. */
  shouldAllowAllGames?: InputMaybe<Scalars['Boolean']>;
  /** The optional name of the sponsor of the campaign. */
  sponsor?: InputMaybe<Scalars['String']>;
  /** When the campaign will start. */
  startAt: Scalars['Time'];
  /** Deprecated. How long the broadcaster needs to stream the sponsored content to complete the bounty (in minutes). */
  streamLengthMinutes?: InputMaybe<Scalars['Int']>;
  /** How long the broadcaster needs to stream the sponsored content to complete the bounty (in seconds). */
  streamLengthSeconds?: InputMaybe<Scalars['Int']>;
  /** Flag to target all broadcaters for the campaign. */
  targetAllBroadcasters?: InputMaybe<Scalars['Boolean']>;
  /** Flag to target all countries for the campaign. */
  targetAllCountries?: InputMaybe<Scalars['Boolean']>;
  /** Flag to target all games for the campaign. */
  targetAllGames?: InputMaybe<Scalars['Boolean']>;
  /** The click target of the campaign if it is a promotional campaign. */
  targetPromotionalVideoClicks?: InputMaybe<Scalars['Int']>;
  /** Flag to target variety broadcaters for the campaign. */
  targetVarietyBroadcasters?: InputMaybe<Scalars['Boolean']>;
  /** Targeted countries for the campaign (represented by ISO 3166-1 alpha-2). */
  targetedCountries?: InputMaybe<Array<Scalars['String']>>;
  /** Targeted Games (game titles) for the campaign. */
  targetedGames?: InputMaybe<Array<Scalars['String']>>;
  /** The title of the campaign. */
  title: Scalars['String'];
  /** The tracking URLs for this campaign. */
  trackingPixels?: InputMaybe<Array<TrackingPixelInput>>;
  /** The type of the campaign. */
  type?: InputMaybe<BountyCampaignType>;
  /** Deprecated, use videos instead. The URL of the video for this campaign. */
  videoURL?: InputMaybe<Scalars['String']>;
  /** The video URLS for the campaign. */
  videos?: InputMaybe<Array<BountyCampaignVideoInput>>;
};

/** Data that was mutated after the campaign was created. */
export type CreateBountyCampaignPayload = {
  __typename?: 'CreateBountyCampaignPayload';
  /** The campaign that was created. */
  campaign?: Maybe<BountyCampaign>;
};

/** CreateBountyCampaignUploadConfigInput is the input for create bounty campaign upload configuration. */
export type CreateBountyCampaignUploadConfigInput = {
  /** The ID of the organization that the campaign is related to. */
  organizationID: Scalars['ID'];
  /** The image type to be uploaded. */
  uploadType: BountyCampaignUploadType;
};

/** Returned information about image upload including URL to upload the image to. */
export type CreateBountyCampaignUploadConfigPayload = {
  __typename?: 'CreateBountyCampaignUploadConfigPayload';
  /** Unique identifier for the image. */
  imageID?: Maybe<Scalars['ID']>;
  /** Unique identifier for the generated URL. */
  uploadID?: Maybe<Scalars['ID']>;
  /** The actual URL to be used by the client to upload the image. */
  uploadURL?: Maybe<Scalars['String']>;
};

/** Inputs for creating a new celebration. */
export type CreateCelebrationInput = {
  /** Where on the channel page the celebration will show. */
  area: CelebrationArea;
  /** Channel id to create the celebration on. */
  channelID: Scalars['ID'];
  /** Length the celebration will play. */
  durationMilliseconds: Scalars['Int'];
  /** Effect which will show when the celebration triggers (ex Fireworks). */
  effect: CelebrationEffect;
  /** Threshold which will trigger the celebration (ex: Cheering 100 Bits). */
  eventThreshold: Scalars['Int'];
  /** Event type which will trigger the celebration (ex: Cheering Bits). */
  eventType: CelebrationEventType;
  /**
   * Intensity of the celebration.
   * Should be bounded (TBA) value which will determine the spectacle of the celebration.
   */
  intensity: Scalars['Int'];
  /** If true, the celebration is enabled. */
  isEnabled: Scalars['Boolean'];
};

/** Outputs from the create celebration mutation. */
export type CreateCelebrationPayload = {
  __typename?: 'CreateCelebrationPayload';
  /** The created celebration. */
  celebration?: Maybe<Celebration>;
  /** If present, there was an error with the request. */
  error?: Maybe<CelebrationError>;
};

/** Create Challenge Condition error. */
export type CreateChallengeConditionError = {
  __typename?: 'CreateChallengeConditionError';
  /** Code describing the error. */
  code: CreateChallengeConditionErrorCode;
};

/** Create Challenge Condition error code. */
export enum CreateChallengeConditionErrorCode {
  /** User tried to create a condition with a bits recipient that is ineligible to receive bits. */
  BitsRecipientIneligible = 'BITS_RECIPIENT_INELIGIBLE',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Create Challenge Condition Participant error. */
export type CreateChallengeConditionParticipantError = {
  __typename?: 'CreateChallengeConditionParticipantError';
  /** Code describing the error. */
  code: CreateChallengeConditionParticipantErrorCode;
};

/** Create Challenge Condition Participant error code. */
export enum CreateChallengeConditionParticipantErrorCode {
  /** User tried to create a condition participant with a USE_BITS effect type, but they are ineligible to use bits. */
  BitsBenefactorIneligible = 'BITS_BENEFACTOR_INELIGIBLE',
  /** User tried to create a condition participant for an inactive condition. */
  ConditionNotActive = 'CONDITION_NOT_ACTIVE',
  /** User tried to create a condition participant for a non-existent condition. */
  ConditionNotFound = 'CONDITION_NOT_FOUND',
  /** User tried to create a condition participant with an effect type that is not supported by the associated condition. */
  EffectTypeUnsupportedByCondition = 'EFFECT_TYPE_UNSUPPORTED_BY_CONDITION',
  /** User tried to create a condition participant with a USE_BITS effect type, but they lacked sufficient bits. */
  InsufficientBitsBalance = 'INSUFFICIENT_BITS_BALANCE',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** CreateChanletInput creates a chanlet under the given channelID. */
export type CreateChanletInput = {
  /** The ID of the channel the chanlet should belong to. */
  channelID: Scalars['ID'];
};

/** CreateChanletPayload returns the new chanlet that was created. */
export type CreateChanletPayload = {
  __typename?: 'CreateChanletPayload';
  /** The chanlet that was created. */
  chanlet: Channel;
  /** The channelID that the chanlet was created under. */
  channelID: Scalars['ID'];
};

/** CreateClipError is an error associated with the createClip mutation. */
export type CreateClipError = {
  __typename?: 'CreateClipError';
  /** The associated error code. */
  code?: Maybe<CreateClipErrorCode>;
};

/** CreateClipErrorCode contains the possible errors that can occur when creating a clip. */
export enum CreateClipErrorCode {
  /** The channel has been banned and cannot be clipped. */
  ChannelBanned = 'CHANNEL_BANNED',
  /** This channel cannot be clipped. */
  ChannelNotClippable = 'CHANNEL_NOT_CLIPPABLE',
  /** Clip cannot be created because channel is no longer live. */
  ChannelNotLive = 'CHANNEL_NOT_LIVE',
  /** Clip cannot be created because the request is throttled. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Unknown error. */
  Unknown = 'UNKNOWN',
  /** User has been banned from the channel and cannot clip. */
  UserBanned = 'USER_BANNED',
  /** User does not have permissions and cannot clip. */
  UserRestricted = 'USER_RESTRICTED',
  /** User has been timed out from the channel and cannot clip. */
  UserTimedOut = 'USER_TIMED_OUT'
}

/**
 * CreateClipInput creates a clip either from a broadcast or video. If both broadcastID
 * and videoID are set, the broadcastID will be preferred.
 */
export type CreateClipInput = {
  /** The ID of the broadcast to create a clip from. */
  broadcastID?: InputMaybe<Scalars['ID']>;
  /** The ID of the broadcaster that the broadcast or video belongs to. */
  broadcasterID: Scalars['ID'];
  /** The number of seconds into the broadcast or video to create the clip from. */
  offsetSeconds: Scalars['Float'];
  /** The ID of the video to create a clip from. */
  videoID?: InputMaybe<Scalars['ID']>;
};

/** CreateClipPayload returns the created clip or any error that prevented the clip creation. */
export type CreateClipPayload = {
  __typename?: 'CreateClipPayload';
  /** The created clip has all fields execpt for durationSeconds and viewCount. */
  clip?: Maybe<Clip>;
  /** The error when a clip fails to create. */
  error?: Maybe<CreateClipError>;
};

/** Inputs for creating a new collection. */
export type CreateCollectionInput = {
  /** A description of the collection being created. */
  description?: InputMaybe<Scalars['String']>;
  /** The id of the user who will own the collection. */
  ownerID: Scalars['ID'];
  /** The title of the collection being created. */
  title: Scalars['String'];
};

/** The response from creating a new collection. */
export type CreateCollectionPayload = {
  __typename?: 'CreateCollectionPayload';
  /** The newly created collection. */
  collection?: Maybe<Collection>;
};

/** Create community goal error. */
export type CreateCommunityPointsCommunityGoalError = {
  __typename?: 'CreateCommunityPointsCommunityGoalError';
  /** The error code. */
  code: CreateCommunityPointsCommunityGoalErrorCode;
};

/** Create community goal error code. */
export enum CreateCommunityPointsCommunityGoalErrorCode {
  /** Goal background color is invalid. */
  BackgroundColorInvalid = 'BACKGROUND_COLOR_INVALID',
  /** Goal description failed automod. */
  DescriptionAutomodFailed = 'DESCRIPTION_AUTOMOD_FAILED',
  /** Goal description is invalid. */
  DescriptionInvalid = 'DESCRIPTION_INVALID',
  /** Goal already exists. */
  DuplicateGoal = 'DUPLICATE_GOAL',
  /** Goal duration is invalid. */
  DurationInvalid = 'DURATION_INVALID',
  /** The current user is not allowed to create goals for this channel. */
  Forbidden = 'FORBIDDEN',
  /** Goal amount is invalid. */
  GoalAmountInvalid = 'GOAL_AMOUNT_INVALID',
  /** Goal title failed automod. */
  TitleAutomodFailed = 'TITLE_AUTOMOD_FAILED',
  /** Goal title is invalid. */
  TitleInvalid = 'TITLE_INVALID',
  /** Too many goals already exists. */
  TooManyGoals = 'TOO_MANY_GOALS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Create community goal input. */
export type CreateCommunityPointsCommunityGoalInput = {
  /** The amount of community points that this goal needs to succeed. */
  amountNeeded: Scalars['Int'];
  /** The background color of this goal. */
  backgroundColor: Scalars['String'];
  /** The channel. */
  channelID: Scalars['ID'];
  /** The description of this goal. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * The *initial* duration the streamer set for the goal.
   * Only really used during the UNSTARTED state; once the goal is started
   * the endedAt timestamp is populated (and updated for extended deadlines).
   */
  durationDays: Scalars['Int'];
  /** The title of this goal. */
  title: Scalars['String'];
};

/** Create community goal payload. */
export type CreateCommunityPointsCommunityGoalPayload = {
  __typename?: 'CreateCommunityPointsCommunityGoalPayload';
  /** The error, if any. */
  error?: Maybe<CreateCommunityPointsCommunityGoalError>;
  /** The community goal that was created. */
  goal?: Maybe<CommunityPointsCommunityGoal>;
};

/** An error from creating a custom Community Points reward in a channel. */
export type CreateCommunityPointsCustomRewardError = {
  __typename?: 'CreateCommunityPointsCustomRewardError';
  /** An identifier for the error that occurred. */
  code: CreateCommunityPointsCustomRewardErrorCode;
  /** On TOO_MANY_REWARDS, the most custom rewards a channel can have. */
  maxRewards?: Maybe<Scalars['Int']>;
};

/** The possible reasons creating a custom Community Points reward in a channel could fail. */
export enum CreateCommunityPointsCustomRewardErrorCode {
  /** The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000". */
  BackgroundColorInvalid = 'BACKGROUND_COLOR_INVALID',
  /** The cost is invalid. Costs must be greater than 0. */
  CostInvalid = 'COST_INVALID',
  /** A reward with the provided title already exists. Custom reward titles must be unique. */
  DuplicateReward = 'DUPLICATE_REWARD',
  /** The current user is not allowed to create a reward in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The globalCooldown is invalid. globalCooldown must be greater tham 0. */
  GlobalCooldownInvalid = 'GLOBAL_COOLDOWN_INVALID',
  /** The maxPerStream is invalid. maxPerStream must be greater than 0. */
  MaxPerStreamInvalid = 'MAX_PER_STREAM_INVALID',
  /** The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0. */
  MaxPerUserPerStreamInvalid = 'MAX_PER_USER_PER_STREAM_INVALID',
  /** The prompt failed AutoMod. */
  PromptAutomodFailed = 'PROMPT_AUTOMOD_FAILED',
  /** The template id provided is invalid. Template id must be the id for a valid template or null. */
  TemplateInvalid = 'TEMPLATE_INVALID',
  /** The title failed AutoMod. */
  TitleAutomodFailed = 'TITLE_AUTOMOD_FAILED',
  /** The title is invalid. Titles must not be empty and must be at most 45 characters long. */
  TitleInvalid = 'TITLE_INVALID',
  /** The channel has too many rewards. An existing reward must be deleted before you can create a new reward. */
  TooManyRewards = 'TOO_MANY_REWARDS',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for creating a custom Community Points reward in a channel. */
export type CreateCommunityPointsCustomRewardInput = {
  /**
   * The optional custom background color for this reward.
   * Should be a hex color string, for example "FF0000".
   */
  backgroundColor?: InputMaybe<Scalars['String']>;
  /** The channel ID that the reward is being created in. */
  channelID: Scalars['ID'];
  /** The point cost of this reward. */
  cost: Scalars['Int'];
  /** The length of the global cooldown applied to rewards redeemed of this type. */
  globalCooldownSetting?: InputMaybe<CommunityPointsCustomRewardGlobalCooldownSettingInput>;
  /** Whether only subscribers are allowed to redeem this reward in this channel. */
  isSubOnly: Scalars['Boolean'];
  /** Whether this reward requires users to enter text input. */
  isUserInputRequired: Scalars['Boolean'];
  /** The most rewards of this type that can be redeemed per stream. */
  maxPerStreamSetting?: InputMaybe<CommunityPointsCustomRewardMaxPerStreamSettingInput>;
  /** The most rewards of this type that can be redeemed per user per stream. */
  maxPerUserPerStreamSetting?: InputMaybe<CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput>;
  /** The optional user-facing prompt for this reward. */
  prompt?: InputMaybe<Scalars['String']>;
  /**
   * Optional boolean for whether redemptions for this reward should skip the broadcaster's
   * request queue and get automatically fulfilled. Defaults to false.
   */
  shouldRedemptionsSkipRequestQueue?: InputMaybe<Scalars['Boolean']>;
  /** The id for the CustomRewardTemplate this reward is being created from. Null if a template wasn't used. */
  templateID?: InputMaybe<Scalars['ID']>;
  /** The short title displayed for this reward. */
  title: Scalars['String'];
};

/** The response from creating a custom Community Points reward in a channel. */
export type CreateCommunityPointsCustomRewardPayload = {
  __typename?: 'CreateCommunityPointsCustomRewardPayload';
  /** An error that occurred while creating a custom Community Points reward in a channel. */
  error?: Maybe<CreateCommunityPointsCustomRewardError>;
  /** The newly created reward. */
  reward?: Maybe<CommunityPointsCustomReward>;
};

/** An error from generating upload info for Community Points images. */
export type CreateCommunityPointsImageUploadInfoError = {
  __typename?: 'CreateCommunityPointsImageUploadInfoError';
  /** An identifier for the error that occurred. */
  code?: Maybe<CreateCommunityPointsImageUploadInfoErrorCode>;
};

/** The possible reasons generating upload info for Community Points images could fail. */
export enum CreateCommunityPointsImageUploadInfoErrorCode {
  /** Your provided custom reward ID was not found. */
  CustomRewardNotFound = 'CUSTOM_REWARD_NOT_FOUND',
  /** The current user is not allowed to upload images for this channel. */
  Forbidden = 'FORBIDDEN',
  /** More than one image type was specified in the request. */
  MoreThanOneType = 'MORE_THAN_ONE_TYPE'
}

/**
 * Input for generating upload info (urls and upload IDs) for uploading Community Points images.
 * Channel ID is required. Only one of the other three fields should be set, to indicate what the image is being uploaded for.
 */
export type CreateCommunityPointsImageUploadInfoInput = {
  /** If set, this request is for uploading new images for the given automatic reward. */
  automaticRewardType?: InputMaybe<CommunityPointsAutomaticRewardType>;
  /** The channel ID to upload images for. */
  channelID: Scalars['ID'];
  /** If set, this request is for uploading new images for the given custom reward. */
  customRewardID?: InputMaybe<Scalars['ID']>;
  /** If set, this request is for uploading new images for the given community goal. */
  goalID?: InputMaybe<Scalars['ID']>;
  /** If set, this request is for uploading new images for the channel Community Points icon. */
  icon?: InputMaybe<Scalars['Boolean']>;
};

/** The response from generating upload info for Community Points images. */
export type CreateCommunityPointsImageUploadInfoPayload = {
  __typename?: 'CreateCommunityPointsImageUploadInfoPayload';
  /** An error that occurred retrieving upload info for Community Points. */
  error?: Maybe<CreateCommunityPointsImageUploadInfoError>;
  /** The upload info (url and upload ID) for the large version of the image. */
  uploadInfoLarge?: Maybe<CommunityPointsImageUploadInfo>;
  /** The upload info (url and upload ID) for the medium version of the image. */
  uploadInfoMedium?: Maybe<CommunityPointsImageUploadInfo>;
  /** The upload info (url and upload ID) for the small version of the image. */
  uploadInfoSmall?: Maybe<CommunityPointsImageUploadInfo>;
};

/** The competition contact info for creates. */
export type CreateCompetitionContactInfoInput = {
  /** Link to Discord server for competition contact purposes. */
  discordURL?: InputMaybe<Scalars['String']>;
  /** Email address point of contact for the competition. */
  email?: InputMaybe<Scalars['String']>;
};

/** Create a Competition. */
export type CreateCompetitionInput = {
  /** Banner image for the competition event page. */
  bannerImageURL?: InputMaybe<Scalars['String']>;
  /** This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed. */
  checkInDurationMinutes: Scalars['Int'];
  /** Long form description of the competition. */
  description?: InputMaybe<Scalars['String']>;
  /** The time the competition is scheduled to end. */
  endAt: Scalars['Time'];
  /** The competition format type (i.e. enum values of LEADERBOARD, ROUND_ROBIN, SINGLE_ELIM etc.). */
  formatType: FormatType;
  /** The game_id of the game being played in the competition. */
  gameID: Scalars['ID'];
  /** Primary artwork for the competition. */
  imageURL?: InputMaybe<Scalars['String']>;
  /** The required inputs for leaderboard format. */
  leaderboardDetails?: InputMaybe<CreateCompetitionLeaderboardDetailsInput>;
  /** The name of the competition. */
  name: Scalars['String'];
  /** Owner of the Competition, or filled in as user making the request. */
  ownerID?: InputMaybe<Scalars['ID']>;
  /** The participant-facing points of contact for the competition that only registered players can see. */
  participantOnlyContactInfo?: InputMaybe<CreateCompetitionContactInfoInput>;
  /** The type of participant for the competition. e.g. SOLO, TEAM, ... */
  participantType: CompetitionParticipantType;
  /** Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side. */
  prizeDescription?: InputMaybe<Scalars['String']>;
  /** The public points of contact for the competition that anyone can see. */
  publicContactInfo?: InputMaybe<CreateCompetitionContactInfoInput>;
  /** The time the competition is scheduled to end registration. */
  registrationEndAt: Scalars['Time'];
  /** The maximum number of players in a REGISTERED state. A default value will be set if none is provided. */
  registrationLimit?: InputMaybe<Scalars['Int']>;
  /** The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ... */
  registrationType: RegistrationType;
  /** Long form text block description that explains the rules for the competition and will be converted to Markdown client-side. */
  rulesDescription?: InputMaybe<Scalars['String']>;
  /** The time the competition is scheduled to start. */
  startAt: Scalars['Time'];
  /** The state the Competition. Defaults to the UPCOMING state if not specified. */
  state?: InputMaybe<CompetitionState>;
  /** The number of players within a single team entity. Must be 1 for solo-type competitions. */
  teamSize: Scalars['Int'];
  /** Link URL to any additional terms and conditions. */
  termsURL?: InputMaybe<Scalars['String']>;
};

/** The required inputs for leaderboard format. */
export type CreateCompetitionLeaderboardDetailsInput = {
  /** The max participant count for a lobby in phase. Valid values are 1-100. */
  lobbyMaxSize: Scalars['Int'];
  /** The number of phases to be created for the competition. Valid values are 1-20. */
  phaseCount: Scalars['Int'];
  /** A label for additional points to resolve a tie. */
  tiebreakerLabel?: InputMaybe<TiebreakerLabel>;
};

/** Data that was mutated after the competition was created. */
export type CreateCompetitionPayload = {
  __typename?: 'CreateCompetitionPayload';
  /** The competition that was created. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Create new tags associated with CLIP, STREAM, or VOD with contentID. */
export type CreateContentTagsInput = {
  /** ID of the channel owning the content. */
  authorID: Scalars['ID'];
  /** ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs. */
  contentID: Scalars['ID'];
  /** Type of content being returned. Can only be of values CLIP, STREAM, or VOD. */
  contentType: ContentType;
  /** List of tag IDs to be added to the content. */
  tagIDs: Array<Scalars['ID']>;
};

/** Result of mutation is the updated tags. */
export type CreateContentTagsPayload = {
  __typename?: 'CreateContentTagsPayload';
  /** Content which tags have been added to. */
  content?: Maybe<TaggedContent>;
};

/**
 * Error codes for issues that may occur when trying to create a
 * new Mosaic layout.
 */
export enum CreateDashboardViewMosaicLayoutErrorCode {
  /** User has reached a limit of layouts they can store. */
  CustomLimitExceeded = 'CUSTOM_LIMIT_EXCEEDED',
  /**
   * One or more unspecified aguments are invalid. These are not
   * user-actionable, but might indicate a logic error.
   */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The channelID argument is required. */
  InvalidArgumentChannelid = 'INVALID_ARGUMENT_CHANNELID',
  /** The layout argument is required. */
  InvalidArgumentLayout = 'INVALID_ARGUMENT_LAYOUT',
  /** The name argument is required. */
  InvalidArgumentName = 'INVALID_ARGUMENT_NAME',
  /** The provided type argument is invalid. */
  InvalidArgumentType = 'INVALID_ARGUMENT_TYPE',
  /** The userID argument is required. */
  InvalidArgumentUserid = 'INVALID_ARGUMENT_USERID',
  /** The version argument is required. */
  InvalidArgumentVersion = 'INVALID_ARGUMENT_VERSION',
  /** An unhandled error. */
  Unknown = 'UNKNOWN'
}

/**
 * Input parameters for creating a new custom mosaic layout,
 * such as for Stream Manager, Twitch Studio, etc.
 * Requires at least the type and id to be specified.
 */
export type CreateDashboardViewMosaicLayoutInput = {
  /** The channel for which to create a new Mosaic layout. */
  channelID: Scalars['ID'];
  /** The Mosaic data blob (in string form) representing the new Mosaic layout. */
  data: Scalars['MosaicData'];
  /** The display name of the new Mosaic layout. */
  name: Scalars['String'];
  /**
   * The type of Mosaic layout being modified, such as for Twitch Studio,
   * Stream Manager, etc.
   */
  type: ChannelDashboardViewType;
  /** The version tag for a Mosaic layout, which can be used for deprecation. */
  version: Scalars['String'];
};

/** Result of the createDashboardViewMosaicLayout mutation. */
export type CreateDashboardViewMosaicLayoutPayload = {
  __typename?: 'CreateDashboardViewMosaicLayoutPayload';
  /** Represents an error when attempting to create a layout, if applicable. */
  errorCode?: Maybe<CreateDashboardViewMosaicLayoutErrorCode>;
  /** The the layout that was created. */
  layout?: Maybe<ChannelDashboardLayout>;
};

/** CreateDropBenefitInput has fields required to create a drop benefit. */
export type CreateDropBenefitInput = {
  /** The redirect URL where a user can link their account. */
  accountLinkURL: Scalars['String'];
  /** The ID of this benefit object. */
  benefitID: Scalars['ID'];
  /** The display name of this benefit object. */
  benefitName: Scalars['String'];
  /** The global limit of how often this benefit can be entitled to a user. */
  entitlementLimit: Scalars['Int'];
  /** The game that awarded the Drop. */
  gameID: Scalars['ID'];
  /** Specifies if this reward is considered for a game that is available on iOS. */
  isIosAvailable?: InputMaybe<Scalars['Boolean']>;
  /** The RBAC organization ID of the owner. */
  ownerID: Scalars['ID'];
};

/** CreateDropBenefitPayload returns the result of the creation. */
export type CreateDropBenefitPayload = {
  __typename?: 'CreateDropBenefitPayload';
  /** Returns the created Benefit. */
  dropBenefit?: Maybe<DropBenefit>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** CreateDropCampaignInput has the fields necessary to create a campaign for an RBAC organization. */
export type CreateDropCampaignInput = {
  /** The redirect URL where a user can link their account. */
  accountLinkURL: Scalars['String'];
  /** The type of a campaign defines what type of drops are allowed to be added to the campaign. */
  campaignType?: InputMaybe<CampaignType>;
  /** The description of this campaign. */
  description: Scalars['String'];
  /** The URL that links to the details / marketing page for this drop. */
  detailsURL: Scalars['String'];
  /** The date at which this campaign ends and all contained drops end at the latest. */
  endAt: Scalars['Time'];
  /** The game associated with this campaign. */
  gameID: Scalars['ID'];
  /** The name of the campaign. */
  name: Scalars['String'];
  /** This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops. */
  ownerID: Scalars['ID'];
  /** The date at which this campaign starts and all contained drops start the earliest. */
  startAt: Scalars['Time'];
};

/** CreateDropCampaignyPayload returns the newly created campaign. */
export type CreateDropCampaignPayload = {
  __typename?: 'CreateDropCampaignPayload';
  /** Returns the created Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /**
   * error, if there was one.
   * A mapped error returned by the drops management service.
   */
  error?: Maybe<DropsError>;
};

/** Possible errors from CreateDropImageUploadURL. */
export enum CreateDropImageUploadUrlErrorCode {
  /** There was an issue calling a dependency of this call. */
  ServiceDependencyFailure = 'SERVICE_DEPENDENCY_FAILURE',
  /** An issue not matching any other specific error code. */
  Unknown = 'UNKNOWN',
  /** The user does not have permissions to create this type of image for this service. */
  UserUnauthorized = 'USER_UNAUTHORIZED'
}

/** Information needed to generate a URL to upload a drop image to. */
export type CreateDropImageUploadUrlInput = {
  /** The campaign this image is for if it's of type LINK_NOTIFICATION. */
  campaignID?: InputMaybe<Scalars['ID']>;
  /** The type of image this is. */
  imageType: DropImageType;
  /** The item ID this image is for if it's of type ITEM. */
  itemID?: InputMaybe<Scalars['ID']>;
  /** The drop service this image will be created for. */
  serviceID: Scalars['ID'];
  /** The JWT used to verify the request. */
  token: Scalars['String'];
};

/** Returned information about image upload including URL to upload the image to. */
export type CreateDropImageUploadUrlPayload = {
  __typename?: 'CreateDropImageUploadURLPayload';
  /** Error (if any) from trying to create the upload URL. */
  error?: Maybe<CreateDropImageUploadUrlErrorCode>;
  /** Unique identifier for the generated URL. */
  uploadID?: Maybe<Scalars['ID']>;
  /** The actual URL to be used by the client to upload the image. */
  url?: Maybe<Scalars['String']>;
};

/** CreateExtensionClientError is an error associated with the createExtensionClient mutation. */
export enum CreateExtensionClientError {
  /** The specified name was invalid. */
  InvalidName = 'INVALID_NAME',
  /** The specified name is already taken by another extension or app. */
  NameInUse = 'NAME_IN_USE'
}

/** CreateExtensionClientInput creates an extension with a given name. */
export type CreateExtensionClientInput = {
  /** name is the name of the extension client ID. */
  name: Scalars['String'];
  /** organizationID is the organization ID that the extension will be binded with in RBAC. */
  organizationID?: InputMaybe<Scalars['ID']>;
  /** redirectURI is the URI that can be used for OAuth login using the extension's client ID. */
  redirectURI: Scalars['String'];
};

/** CreateExtensionClientPayload returns the created extension ID. */
export type CreateExtensionClientPayload = {
  __typename?: 'CreateExtensionClientPayload';
  /** The created extension client. */
  client?: Maybe<ExtensionClient>;
  /** The error when the mutation fails to create an extension client. */
  error?: Maybe<CreateExtensionClientError>;
};

/** CreateExtensionImageUploadInfoError is wrapper for error associated with the createExtensionImageUploadInfo mutation. */
export type CreateExtensionImageUploadInfoError = {
  __typename?: 'CreateExtensionImageUploadInfoError';
  /** Error code. */
  code: CreateExtensionImageUploadInfoErrorCode;
  /** On TOO_MANY_UPLOAD_DISCOVERY_IMAGE, TOO_MANY_UPLOAD_LOGO_IMAGE ,TOO_MANY_UPLOAD_SCREENSHOT_IMAGE, TOO_MANY_UPLOAD_TASKBAR_IMAGE, the maximum number of specific image allowed (existing + incoming). */
  maximum?: Maybe<Scalars['Int']>;
  /** On NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE, NOT_ENOUGH_UPLOAD_LOGO_IMAGE ,NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE, NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE, the minimum number of screenshots allowed (existing + incoming). */
  minimum?: Maybe<Scalars['Int']>;
};

/** CreateExtensionImageUploadInfoErrorCode is an error code associated with CreateExtensionImageUploadInfoError. */
export enum CreateExtensionImageUploadInfoErrorCode {
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** Not enough discovery image to upload. Must >= 0. */
  NotEnoughUploadDiscoveryImage = 'NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE',
  /** Not enough logo image to upload. Must >= 0. */
  NotEnoughUploadLogoImage = 'NOT_ENOUGH_UPLOAD_LOGO_IMAGE',
  /** Not enough screenshot image to upload. Must >= 0. */
  NotEnoughUploadScreenshotImage = 'NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE',
  /** Not enough taskbar image to upload. Must >= 0. */
  NotEnoughUploadTaskbarImage = 'NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE',
  /** Too many discovery image to upload. Must <= 1. */
  TooManyUploadDiscoveryImage = 'TOO_MANY_UPLOAD_DISCOVERY_IMAGE',
  /** Too many logo image to upload. Must <= 1. */
  TooManyUploadLogoImage = 'TOO_MANY_UPLOAD_LOGO_IMAGE',
  /** Too many screenshot image to upload. Must <= 1. */
  TooManyUploadScreenshotImage = 'TOO_MANY_UPLOAD_SCREENSHOT_IMAGE',
  /** Too many taskbar image to upload. Must <= 1. */
  TooManyUploadTaskbarImage = 'TOO_MANY_UPLOAD_TASKBAR_IMAGE',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Information needed to generate a URL and UploadId to upload extension images to. */
export type CreateExtensionImageUploadInfoInput = {
  /** Whether to upload new discovery image. */
  discovery?: InputMaybe<Scalars['Boolean']>;
  /** The extension:version the images are for. */
  extensionID: Scalars['ID'];
  /** Whether to upload new logo image. */
  logo?: InputMaybe<Scalars['Boolean']>;
  /** Amount of new screenshot image to be uploaded. */
  screenshots?: InputMaybe<Scalars['Int']>;
  /** Whether to upload new taskbar image. */
  taskbar?: InputMaybe<Scalars['Boolean']>;
};

/** Returned information about images upload including URL to upload the image to. */
export type CreateExtensionImageUploadInfoPayload = {
  __typename?: 'CreateExtensionImageUploadInfoPayload';
  /** Url and UploadId for discovery. */
  discovery?: Maybe<ExtensionImageUploadResponse>;
  /** The error when the mutation fails to create upload information. */
  error?: Maybe<CreateExtensionImageUploadInfoError>;
  /** Url and UploadId for logo. */
  logo?: Maybe<ExtensionImageUploadResponse>;
  /** Urls and UploadIds for screenshots. */
  screenshots?: Maybe<Array<Maybe<ExtensionImageUploadResponse>>>;
  /** Url and UploadId for taskbar. */
  taskbar?: Maybe<ExtensionImageUploadResponse>;
};

/** CreateExtensionZipUploadInfoError is an error associated with the createExtensionZipUploadInfo mutation. */
export enum CreateExtensionZipUploadInfoError {
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Information needed to generate a URL and UploadId to upload extension zip file to. */
export type CreateExtensionZipUploadInfoInput = {
  /** The extension:version the zip file is for. */
  extensionID: Scalars['ID'];
  /** The file name of the zip file. */
  filename?: InputMaybe<Scalars['String']>;
};

/** Returned information about zip file upload including URL to upload the zip to. */
export type CreateExtensionZipUploadInfoPayload = {
  __typename?: 'CreateExtensionZipUploadInfoPayload';
  /** The error when the mutation fails to upload a zip file. */
  error?: Maybe<CreateExtensionZipUploadInfoError>;
  /** Url and UploadId for zip file. */
  response?: Maybe<ExtensionZipUploadResponse>;
};

export type CreateFriendRequestInput = {
  /** The authenticated user will send a friend request to the user with an ID equal to targetID. */
  targetID: Scalars['ID'];
};

export type CreateFriendRequestPayload = {
  __typename?: 'CreateFriendRequestPayload';
  /** The user who is the target of the friend request. */
  user?: Maybe<User>;
};

/** Error associated with mutation CreateGameApplication. */
export type CreateGameApplicationError = {
  __typename?: 'CreateGameApplicationError';
  /** Error code. */
  code?: Maybe<CreateGameApplicationErrorCode>;
};

/** Client error code. */
export enum CreateGameApplicationErrorCode {
  /** The game has already been owned by another company. */
  GameHasAlreadyBeenOwned = 'GAME_HAS_ALREADY_BEEN_OWNED',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Sumbitting user does not have authorization to create a game application for the organization. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Input to the CreateGameApplication mutation. */
export type CreateGameApplicationInput = {
  /** Company ID. */
  companyID: Scalars['ID'];
  /** Game ID. */
  gameID: Scalars['ID'];
};

/** Output from the CreateGameApplication mutation. */
export type CreateGameApplicationPayload = {
  __typename?: 'CreateGameApplicationPayload';
  /** The possible error returned from service. */
  error?: Maybe<CreateGameApplicationError>;
  /** The game application. */
  gameApplication?: Maybe<GameApplication>;
};

/** GameID that needs to upload a box art image. */
export type CreateGameBoxArtUploadUrlInput = {
  /** Game identifier. */
  gameID: Scalars['ID'];
};

/** URL info that can be used to upload the image. */
export type CreateGameBoxArtUploadUrlPayload = {
  __typename?: 'CreateGameBoxArtUploadURLPayload';
  /** response with non-nullable data. */
  response?: Maybe<CreateGameBoxArtUploadUrlResponse>;
};

/** URL info that can be used to upload the image. */
export type CreateGameBoxArtUploadUrlResponse = {
  __typename?: 'CreateGameBoxArtUploadURLResponse';
  /** Upload id to be used on the upload request. */
  uploadID: Scalars['ID'];
  /**
   * URL to be used by the client, to upload the image.
   * NOTE: The image that is uploaded later must be a 600x800px, no larger than 1 MB, JPEG.
   */
  url: Scalars['String'];
};

/** CreateLoyaltyBadge creates a new badge with these settings. */
export type CreateLoyaltyBadgeInput = {
  /** The channel ID where the badge will be uploaded. */
  channelID: Scalars['ID'];
  /** The S3 ID of the 1x sized badge. */
  image1xID: Scalars['ID'];
  /** The S3 ID of the 2x sized badge. */
  image2xID: Scalars['ID'];
  /** The S3 ID of the 4x sized badge. */
  image4xID: Scalars['ID'];
  /** The number of months of the badge. */
  requiredTenureMonths: Scalars['Int'];
};

/** CreateLoyaltyBadgePayload returns the created badge. */
export type CreateLoyaltyBadgePayload = {
  __typename?: 'CreateLoyaltyBadgePayload';
  /** The created badge. */
  badge?: Maybe<LoyaltyBadge>;
  /** A code indicating why the create call failed, if it did. */
  errorCode?: Maybe<CreateLoyaltyBadgeResponseCode>;
};

/** A code indicating why the create call failed, if it did. */
export enum CreateLoyaltyBadgeResponseCode {
  /** Badge already exists for this tenure. */
  ErrBadgeExists = 'ERR_BADGE_EXISTS',
  /** User is timed out of badge creation. */
  ErrBadgeTimeout = 'ERR_BADGE_TIMEOUT',
  /** The badge image 1x submitted was not valid. */
  ErrInvalidBadgeImage_1XId = 'ERR_INVALID_BADGE_IMAGE_1X_ID',
  /** The badge image 2x submitted was not valid. */
  ErrInvalidBadgeImage_2XId = 'ERR_INVALID_BADGE_IMAGE_2X_ID',
  /** The badge image 4x submitted was not valid. */
  ErrInvalidBadgeImage_4XId = 'ERR_INVALID_BADGE_IMAGE_4X_ID',
  /** The badge tenure submitted was not valid. */
  ErrInvalidBadgeRequiredTenureMonths = 'ERR_INVALID_BADGE_REQUIRED_TENURE_MONTHS',
  /** Only eligible users can create a badge. */
  ErrInvalidUser = 'ERR_INVALID_USER',
  /** Unknown error occurred, most likely a server error. */
  ErrUnknown = 'ERR_UNKNOWN'
}

/** CreateLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to. */
export type CreateLoyaltyBadgeUploadConfigInput = {
  /** The channel ID where the badge will be uploaded. */
  channelID: Scalars['ID'];
  /** The size of the badge. */
  size: Scalars['Int'];
};

/** CreateLoyaltyBadgeUploadConfigPayload returns the badge upload config. */
export type CreateLoyaltyBadgeUploadConfigPayload = {
  __typename?: 'CreateLoyaltyBadgeUploadConfigPayload';
  /** A code indicating why the config call failed, if it did. */
  errorCode?: Maybe<CreateLoyaltyBadgeUploadConfigResponseCode>;
  /** The badge upload config. */
  uploadConfig?: Maybe<LoyaltyBadgeUploadConfig>;
};

/** A code indicating why the config call failed, if it did. */
export enum CreateLoyaltyBadgeUploadConfigResponseCode {
  /** The badge submitted was not valid. */
  ErrInvalidBadgeSize = 'ERR_INVALID_BADGE_SIZE',
  /** Only eligible users can create a badge upload config. */
  ErrInvalidUser = 'ERR_INVALID_USER',
  /** Unknown error occurred, most likely a server error. */
  ErrUnknown = 'ERR_UNKNOWN'
}

/** The required input to create a moderator comment on a channel. */
export type CreateModeratorCommentInput = {
  /** The channel where the moderator comment was created. */
  channelID: Scalars['ID'];
  /** The target of the moderator comment. */
  targetID: Scalars['ID'];
  /** The body of the comment. */
  text: Scalars['String'];
};

/** Result of a createModeratorComment mutation. */
export type CreateModeratorCommentPayload = {
  __typename?: 'CreateModeratorCommentPayload';
  /** The moderator comment created. */
  comment?: Maybe<ModLogsComment>;
};

/** Input for creating a new highlight with multi-segment support. */
export type CreateMultiVideoHighlightInput = {
  /** Metadata used to create the highlight. */
  metadata: CreateMultiVideoHighlightMetadata;
};

/** Metadata to describe the requested highlight to be created. */
export type CreateMultiVideoHighlightMetadata = {
  /** The ID of the user who created this highlight. */
  creatorID: Scalars['ID'];
  /** The long form description of the Highlight content. */
  description: Scalars['String'];
  /** The primary game featured in the highlight, if any. */
  game?: InputMaybe<Scalars['ID']>;
  /** List of ordered time ranges from the source VOD used to create the highlight. */
  highlightRanges: Array<HighlightRange>;
  /** The language the highlight content is in. */
  language: Scalars['String'];
  /** Discovery tags to associate with the Highlight. */
  tags: Array<Scalars['String']>;
  /** The title of the the highlight. */
  title: Scalars['String'];
};

/** Response of highlight creation, the new highlight entering the creation process. */
export type CreateMultiVideoHighlightPayload = {
  __typename?: 'CreateMultiVideoHighlightPayload';
  /** The created Video representing the Highlight. */
  highlight?: Maybe<Video>;
};

/** Contains the channel ID to create new image upload URL for. */
export type CreateMultiviewContentAttributeImageUploadConfigInput = {
  /** The channel for which the content attribute belongs to. */
  channelID: Scalars['ID'];
};

/** Payload contains the upload ID and URL, as well as the URL to access the uploaded image. */
export type CreateMultiviewContentAttributeImageUploadConfigPayload = {
  __typename?: 'CreateMultiviewContentAttributeImageUploadConfigPayload';
  /** The channel for which the content attribute belongs to. */
  channel?: Maybe<Channel>;
  /** The URL to access this image once uploaded. */
  imageURL: Scalars['String'];
  /** Generated unique identifier for this upload. */
  uploadID: Scalars['ID'];
  /** Generated unique URL to upload the image to. */
  uploadURL: Scalars['String'];
};

/** Contains a list of new content attributes to be created. */
export type CreateMultiviewContentAttributesInput = {
  /** params is a list of multi-view content attribute params for creating new records. */
  params: Array<MultiviewContentAttributeParams>;
};

/** Contains the results from the create request. */
export type CreateMultiviewContentAttributesPayload = {
  __typename?: 'CreateMultiviewContentAttributesPayload';
  /** Unprocessed content attributes. */
  failedCreates: Array<MultiviewContentAttribute>;
  /** Processed content attributes. */
  succeededCreates: Array<MultiviewContentAttribute>;
};

/** Error associated with mutation CreateGameApplication. */
export type CreateOrganizationApplicationError = {
  __typename?: 'CreateOrganizationApplicationError';
  /** Error code. */
  code?: Maybe<CreateOrganizationApplicationErrorCode>;
};

/** Client error code. */
export enum CreateOrganizationApplicationErrorCode {
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT'
}

/** Input to the CreateOrganizationApplication mutation. */
export type CreateOrganizationApplicationInput = {
  /** City the applying Organization is located in. e.g. San Fransico. */
  city?: InputMaybe<Scalars['String']>;
  /**
   * Email of the person creating the application.
   * Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
   */
  contactEmail?: InputMaybe<Scalars['String']>;
  /** First Name of person creating the application. */
  contactFirstName: Scalars['String'];
  /** Last Name of the person creating the application. */
  contactLastName: Scalars['String'];
  /** Title of the person creating the application. e.g. Director of Sales. */
  contactTitle: Scalars['String'];
  /** Country the applying organization is located in. e.g. US. */
  country: Scalars['String'];
  /** List of game IDs that belong to the applying organization. */
  gameIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Industry the applying organization is operating in e.g. e-sports, gaming, health care, energy. */
  industry: Scalars['String'];
  /** Reason for wanting to add the organization. */
  joinReason?: InputMaybe<Scalars['String']>;
  /** The name of applying organization. */
  organizationName: Scalars['String'];
  /** Indicate which Twitch products the organization wants to manage; e.g. creating Drops, managing game box art, accessing game Insights. */
  productInterest?: InputMaybe<Scalars['String']>;
  /** Estimated size of the applying organization. e.g. 1-5, 6-20, 21-50, 51-100, 101-1000, and 1000+. */
  size: Scalars['String'];
  /** State the applying organization is located in. e.g. CA. */
  state?: InputMaybe<Scalars['String']>;
  /** The type of work the applying organization does. */
  type: OrganizationType;
  /**
   * The Twitch ID for the user submitting the applicaton.
   * Deprecated as the userID now comes off the authenticated user.
   */
  userID?: InputMaybe<Scalars['ID']>;
  /** The website address for the applying organization. */
  website: Scalars['String'];
};

/** Output from the CreateGameApplication mutation. */
export type CreateOrganizationApplicationPayload = {
  __typename?: 'CreateOrganizationApplicationPayload';
  /** The organization application id. */
  applicationID?: Maybe<Scalars['ID']>;
  /** The possible error returned from service. */
  error?: Maybe<CreateOrganizationApplicationError>;
};

/** CreateOrganizationInviteError is the error associated with a CreateOrganizationInvite. */
export type CreateOrganizationInviteError = {
  __typename?: 'CreateOrganizationInviteError';
  /** The associated error code. */
  code: CreateOrganizationInviteErrorCode;
};

/** CreateOrganizationInviteErrorCode defines a client error that occurred while creating an organization Invite. */
export enum CreateOrganizationInviteErrorCode {
  /** Organization Invite already exists. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /**
   * The user doesn't meet the requirements to have this role. For example, when trying to assign the
   * "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
   */
  MemberIneligible = 'MEMBER_INELIGIBLE',
  /** User does not have permission to perform action. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** The user does not exist. */
  UserNotFound = 'USER_NOT_FOUND'
}

/** Inputs to the CreateOrganizationInvite mutation. */
export type CreateOrganizationInviteInput = {
  /** The Twitch ID of user being invited to join the organization. */
  inviteeTwitchID: Scalars['ID'];
  /** The Twitch ID of user being doing the inviting and is already a member of the organization. */
  inviterTwitchID: Scalars['ID'];
  /** The ID of the organization. */
  organizationID: Scalars['ID'];
  /** The Role a Invite has in an organization. */
  role: OrganizationMemberRole;
};

/** Outputs from the CreateOrganizationInvite mutation. */
export type CreateOrganizationInvitePayload = {
  __typename?: 'CreateOrganizationInvitePayload';
  /** The possible error returned from the service. */
  error?: Maybe<CreateOrganizationInviteError>;
  /** The created invite. returned on successful creation. */
  invite?: Maybe<OrganizationInvite>;
};

/** CreateOrganizationJWTError is the error associated with a CreateOrganizationJWT. */
export type CreateOrganizationJwtError = {
  __typename?: 'CreateOrganizationJWTError';
  /** The associated error code. */
  code: CreateOrganizationJwtErrorCode;
};

/** CreateOrganizationJWTErrorCode defines a client error that occurred while creating Organization JWT. */
export enum CreateOrganizationJwtErrorCode {
  /** The operation passed in was invalid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** User does not have permission to create the JWT for this operation and company. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Inputs to the CreateOrganizationJWT mutation. */
export type CreateOrganizationJwtInput = {
  /** Operation to be used in drops to get a jwt for. */
  operation: Scalars['String'];
  /** Organization id for which to generate the jwt. */
  organizationID: Scalars['ID'];
};

/** Outputs from the CreateOrganizationJWT mutation. */
export type CreateOrganizationJwtPayload = {
  __typename?: 'CreateOrganizationJWTPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CreateOrganizationJwtError>;
  /** The new orgnizationJWT. */
  jwt?: Maybe<Scalars['String']>;
};

/** CreateOrganizationMemberError is the error associated with a CreateOrganizationMember. */
export type CreateOrganizationMemberError = {
  __typename?: 'CreateOrganizationMemberError';
  /** The associated error code. */
  code: CreateOrganizationMemberErrorCode;
};

/** CreateOrganizationMemberErrorCode defines a client error that occurred while creating an organization member. */
export enum CreateOrganizationMemberErrorCode {
  /** Organization Member already exists. */
  AlreadyExists = 'ALREADY_EXISTS',
  /**
   * The user doesn't meet the requirements to have this role. For example, when trying to assign the
   * "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
   */
  MemberIneligible = 'MEMBER_INELIGIBLE',
  /** User does not have permission to perform action. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** The user does not exist. */
  UserNotFound = 'USER_NOT_FOUND'
}

/** Inputs to the CreateOrganizationMember mutation. */
export type CreateOrganizationMemberInput = {
  /** Users email. */
  email: Scalars['String'];
  /** Users first name. */
  firstName: Scalars['String'];
  /** Users last name. */
  lastName: Scalars['String'];
  /** The ID of the organization. */
  organizationID: Scalars['ID'];
  /** The Role a member has in an organization. */
  role: OrganizationMemberRole;
  /** Users title. */
  title: Scalars['String'];
  /** The user's Twitch ID. */
  userID: Scalars['ID'];
};

/** Outputs from the CreateOrganizationMember mutation. */
export type CreateOrganizationMemberPayload = {
  __typename?: 'CreateOrganizationMemberPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CreateOrganizationMemberError>;
  /** The new orgnizationMember. */
  organizationMember?: Maybe<OrganizationMember>;
};

/** The upload info struct that is returned from AWS. */
export type CreatePanelImageUploadInfo = {
  __typename?: 'CreatePanelImageUploadInfo';
  /** A unique identifier for the generated URL. */
  uploadID: Scalars['ID'];
  /** The actual URL to be used by the client to upload the image. */
  url: Scalars['String'];
};

/** Information required to generate a URL to upload a panel image to. */
export type CreatePanelImageUploadInfoInput = {
  /** The channel the panel belongs to. */
  channelID: Scalars['ID'];
  /** The cropped height of the image. */
  height: Scalars['Int'];
  /** The left edge of the cropped image. */
  left: Scalars['Int'];
  /** The top edge of the cropped image. */
  top: Scalars['Int'];
  /** The cropped width of the image. */
  width: Scalars['Int'];
};

/** The response resulting from a successful panel image URL creation. */
export type CreatePanelImageUploadInfoPayload = {
  __typename?: 'CreatePanelImageUploadInfoPayload';
  /** The upload info struct that is returned from AWS. */
  uploadInfo?: Maybe<CreatePanelImageUploadInfo>;
};

/**
 * CreatePanelInput contains a panel with created data
 * The schema here has arguments for both extension panels and default panels
 * each panel needs a PanelType, and channelID it corresponds to,
 * but each panel does not need the other arguments
 * extension panels can have a slotID
 * default panels can have a title, image, link, and/or description.
 */
export type CreatePanelInput = {
  channelID: Scalars['ID'];
  description?: InputMaybe<Scalars['String']>;
  imageURL?: InputMaybe<Scalars['String']>;
  linkURL?: InputMaybe<Scalars['String']>;
  slotID?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  type: PanelType;
};

/** CreatePanelPayload contains the panel data after the create succeeds. */
export type CreatePanelPayload = {
  __typename?: 'CreatePanelPayload';
  panel: Panel;
};

/**
 * CreatePartnershipApplication accepts a userID and other parameters to create the partnership application of a given user.
 * The required input for a createPartnershipApplicationInput mutation.
 */
export type CreatePartnershipApplicationInput = {
  /**
   * Broadcast category (selected by the applicant).
   * eg: gaming, creative.
   */
  category: Scalars['String'];
  /**
   * Country from where the applicant belongs (selected by the applicant).
   * eg: US, NZ, UK.
   */
  country: Scalars['String'];
  /** Description why the applicant wants to be a partner. */
  description: Scalars['String'];
  /** First and last name of the applicant. */
  fullName: Scalars['String'];
  /** Broadcast language (selected by the applicant). */
  language: Scalars['String'];
};

/**
 * Whether or not the partnership application submission to was successful.
 * The result of a createPartnershipApplicationInput mutation.
 */
export type CreatePartnershipApplicationPayload = {
  __typename?: 'CreatePartnershipApplicationPayload';
  /**
   * A successful creation returns the partnership application.
   * A failed creation returns null.
   */
  partnershipApplication?: Maybe<PartnershipApplication>;
};

/** Inputs for creating a choice. */
export type CreatePollChoiceInput = {
  /** Title of the choice. */
  title: Scalars['String'];
};

/** Vote in poll error. */
export type CreatePollError = {
  __typename?: 'CreatePollError';
  /** Code describing the error. */
  code: CreatePollErrorCode;
};

/** Vote in poll error code. */
export enum CreatePollErrorCode {
  /** User attempted to create poll with restricted content. */
  AutomodFailed = 'AUTOMOD_FAILED',
  /** User attempted to create poll with bits on a channel where bits are not enabled. */
  ChannelNotBitsEnabled = 'CHANNEL_NOT_BITS_ENABLED',
  /** User attempted to create poll when a poll was already active. */
  PollAlreadyActive = 'POLL_ALREADY_ACTIVE',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Inputs for creating a new poll. */
export type CreatePollInput = {
  /** The cost in bits for casting a vote. */
  bitsCost?: InputMaybe<Scalars['Int']>;
  /** Denotes if votes can be cast with bits. */
  bitsVoting?: InputMaybe<Scalars['Boolean']>;
  /** Choices that can be voted for in the poll. */
  choices: Array<CreatePollChoiceInput>;
  /** The cost in Community Points for casting a vote. */
  communityPointsCost?: InputMaybe<Scalars['Int']>;
  /** Duration of the poll in seconds. */
  durationSeconds: Scalars['Int'];
  /** Denotes if votes can be cast with Community Points. */
  isCommunityPointsVotingEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Denotes if the poll allows voting for multiple options. */
  multichoiceEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Id of the channel this poll is owned by. */
  ownedBy: Scalars['ID'];
  /**
   * Denotes if subscribers receives bonus votes.
   * Deprecated: Subscriber multipliers are no longer supported.
   */
  subscriberMultiplier?: InputMaybe<Scalars['Boolean']>;
  /**
   * Denotes if the poll is only open to subscribers.
   * Deprecated: Subscriber-only polls are no longer supported.
   */
  subscriberOnly?: InputMaybe<Scalars['Boolean']>;
  /** Title of the poll. */
  title: Scalars['String'];
};

/** Outputs from the create poll mutation. */
export type CreatePollPayload = {
  __typename?: 'CreatePollPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<CreatePollError>;
  /** The created poll. */
  poll?: Maybe<Poll>;
};

export type CreatePostInput = {
  body: Scalars['String'];
  channelID: Scalars['ID'];
  embedURLs?: InputMaybe<Array<Scalars['String']>>;
  postToTwitter?: InputMaybe<Scalars['Boolean']>;
};

export type CreatePostPayload = {
  __typename?: 'CreatePostPayload';
  post?: Maybe<Post>;
  tweet?: Maybe<Scalars['String']>;
  tweetStatus: Scalars['Int'];
};

/** An error returned from the createPredictionEvent mutation. */
export type CreatePredictionEventError = {
  __typename?: 'CreatePredictionEventError';
  /** Code describing the error. */
  code: CreatePredictionEventErrorCode;
  /** If the error code is TOO_MANY_OUTCOMES, this will be the maximum number of Outcomes. */
  maxOutcomes?: Maybe<Scalars['Int']>;
  /** If the error code is INVALID_PREDICTION_WINDOW, this will be the maximum Prediction Window in seconds. */
  maxPredictionWindowSeconds?: Maybe<Scalars['Int']>;
};

/** Possible error codes from the createPredictionEvent mutation. */
export enum CreatePredictionEventErrorCode {
  /** User attempted to create a Prediction Event with restricted content. */
  AutomodFailed = 'AUTOMOD_FAILED',
  /** Channel Points are not enabled on this channel. */
  ChannelPointsNotEnabled = 'CHANNEL_POINTS_NOT_ENABLED',
  /** The colors chosen for each Option must be unique. */
  ColorsNotUnique = 'COLORS_NOT_UNIQUE',
  /**
   * There is already an active or pending Prediction Event on the channel. The Event must be resolved before a new
   * Prediction Event can be created.
   */
  EventAlreadyActive = 'EVENT_ALREADY_ACTIVE',
  /** The current user is forbidden from creating Prediction Events on the specified channel. */
  Forbidden = 'FORBIDDEN',
  /** The specified Prediction Window is invalid. Prediction window must be positive. Prediction window has a maximum. */
  InvalidPredictionWindow = 'INVALID_PREDICTION_WINDOW',
  /** Events must have at least 2 Outcomes. */
  NotEnoughOutcomes = 'NOT_ENOUGH_OUTCOMES',
  /** Events have a maximum number of Outcomes. */
  TooManyOutcomes = 'TOO_MANY_OUTCOMES',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for creating a Prediction Event. */
export type CreatePredictionEventInput = {
  /** The channel to create the Prediction Event on. */
  channelID: Scalars['ID'];
  /** Outcomes that can be chosen in the Prediction Event. */
  outcomes: Array<CreatePredictionOutcomeInput>;
  /** The duration of the Prediction Window, in seconds. */
  predictionWindowSeconds: Scalars['Int'];
  /** The intended title of the Prediction Event. */
  title: Scalars['String'];
};

/** Payload for creating a prediction event. */
export type CreatePredictionEventPayload = {
  __typename?: 'CreatePredictionEventPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<CreatePredictionEventError>;
  /** The created Prediction Event. */
  predictionEvent?: Maybe<PredictionEvent>;
};

/** Input for creating a Prediction Outcome. */
export type CreatePredictionOutcomeInput = {
  /** Color of the Outcome. */
  color: PredictionOutcomeColor;
  /** Title of the Outcome. */
  title: Scalars['String'];
};

/** CreateRaidError is the error associated with a createRaid. */
export type CreateRaidError = {
  __typename?: 'CreateRaidError';
  /** The associated error code. */
  code: CreateRaidErrorCode;
};

/** CreateRaidErrorCode are the possible errors that this mutation returns. */
export enum CreateRaidErrorCode {
  /** The user is already raiding another channel. */
  AlreadyRaiding = 'ALREADY_RAIDING',
  /** The user tries to raid an unraidable channel. */
  CannotRaidThisChannel = 'CANNOT_RAID_THIS_CHANNEL',
  /** The user tries to raid themselves. */
  CannotRaidYourself = 'CANNOT_RAID_YOURSELF',
  /** The request is missing valid channel parameters. */
  InvalidChannel = 'INVALID_CHANNEL',
  /** The user tries to raid with too many viewers. */
  TooManyViewersToRaid = 'TOO_MANY_VIEWERS_TO_RAID'
}

/** Inputs to the createRaid mutation. */
export type CreateRaidInput = {
  /**
   * Caller is expected to be a channel owner, editor, or staff.
   * User ID of the source channel hosting the raid.
   */
  sourceID: Scalars['ID'];
  /** User ID of the target channel. */
  targetID: Scalars['ID'];
};

/** Outputs from the createRaid mutation. */
export type CreateRaidPayload = {
  __typename?: 'CreateRaidPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CreateRaidError>;
  /** The created raid. */
  raid?: Maybe<Raid>;
};

/** Inputs to the createRewardedVideo mutation. */
export type CreateRewardedVideoTokenInput = {
  /** userID requesting the rewarded video token. */
  userID: Scalars['ID'];
};

/** Outputs from the createRewardedVideo mutation. */
export type CreateRewardedVideoTokenPayload = {
  __typename?: 'CreateRewardedVideoTokenPayload';
  /** token used to initialize the truex client application. */
  token?: Maybe<Scalars['String']>;
};

export type CreateRoomError = {
  __typename?: 'CreateRoomError';
  code: CreateRoomErrorCode;
  /** On MAX_ROOMS_LIMIT_EXCEEDED: Maximum number of rooms user can create. */
  maxAllowedRooms?: Maybe<Scalars['Int']>;
  /** On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters. */
  maxLength?: Maybe<Scalars['Int']>;
  /** On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters. */
  minLength?: Maybe<Scalars['Int']>;
};

export enum CreateRoomErrorCode {
  /** User cannot create any more rooms. */
  MaxRoomsLimitExceeded = 'MAX_ROOMS_LIMIT_EXCEEDED',
  /** Name contains invalid characters (e.g. spaces). */
  NameContainsInvalidCharacters = 'NAME_CONTAINS_INVALID_CHARACTERS',
  /** Name failed automod check. */
  NameInappropriate = 'NAME_INAPPROPRIATE',
  /** Name too short or too long. */
  NameLengthInvalid = 'NAME_LENGTH_INVALID',
  /** Name was not unique to channel. */
  NameNotUnique = 'NAME_NOT_UNIQUE',
  /** Invalid roles specified (e.g. a more permissive role for send than read). */
  RolesInvalid = 'ROLES_INVALID',
  /** Topic failed automod check. */
  TopicInappropriate = 'TOPIC_INAPPROPRIATE',
  /** Topic too short or too long. */
  TopicLengthInvalid = 'TOPIC_LENGTH_INVALID'
}

export type CreateRoomInput = {
  /** Deprecated. Use minimumReadMessagesRole instead. */
  isPreviewable?: InputMaybe<Scalars['Boolean']>;
  /** Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead. */
  minimumAllowedRole?: InputMaybe<RoomRole>;
  /** Minimum role required to read messages in the room. */
  minimumReadMessagesRole?: InputMaybe<RoomRole>;
  /** Minimum role required to send messages in the room. */
  minimumSendMessagesRole?: InputMaybe<RoomRole>;
  /** The name of the room. */
  name: Scalars['String'];
  /** The topic for the room. */
  topic: Scalars['String'];
};

export type CreateRoomPayload = {
  __typename?: 'CreateRoomPayload';
  error?: Maybe<CreateRoomError>;
  room?: Maybe<Room>;
};

/** The possible errors. */
export enum CreateScheduleError {
  /** Channel already has a schedule. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** Cannot create a schedule for this channel. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** The input to create a schedule. */
export type CreateScheduleInput = {
  /** The channel ID the schedule belongs to. */
  channelID: Scalars['ID'];
};

/** The payload returned after creating a schedule. */
export type CreateSchedulePayload = {
  __typename?: 'CreateSchedulePayload';
  /** The channel with the new schedule. */
  channel?: Maybe<Channel>;
  /** The possible error. */
  error?: Maybe<CreateScheduleError>;
};

/** CreateScheduleSegmentError is a wrapper for error associated with the CreateScheduleSegment mutation. */
export type CreateScheduleSegmentError = {
  __typename?: 'CreateScheduleSegmentError';
  /** Error code. */
  code: CreateScheduleSegmentErrorCode;
  /** If the error is related to overlapping segments, provide the existing segment causing a conflict. */
  conflictingSegment?: Maybe<ScheduleSegment>;
  /** If the error is related to an input out of service-defined bounds, provide the maximum allowed value. */
  maximum?: Maybe<Scalars['Int']>;
  /** If the error is related to an input out of service-defined bounds, provide the minimum allowed value. */
  minimum?: Maybe<Scalars['Int']>;
};

/** The possible errors when creating a schedule segment. */
export enum CreateScheduleSegmentErrorCode {
  /** The segment first occurrence date is set in the past. */
  FirstOccurrenceDateInPast = 'FIRST_OCCURRENCE_DATE_IN_PAST',
  /** The input is not valid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The category is not valid. */
  InvalidCategories = 'INVALID_CATEGORIES',
  /** The number of categories is invalid. Refer to the error for min and max acceptable values. */
  InvalidCategoryCount = 'INVALID_CATEGORY_COUNT',
  /** The duration is invalid. Refer to the error for min and max acceptable values. */
  InvalidDuration = 'INVALID_DURATION',
  /** The segment is invalid. */
  InvalidSegment = 'INVALID_SEGMENT',
  /** The number of segments is invalid. Refer to the error for min and max acceptable values. */
  InvalidSegmentCount = 'INVALID_SEGMENT_COUNT',
  /** The the start day is not valid. */
  InvalidStartDay = 'INVALID_START_DAY',
  /** The start hour is not valid. */
  InvalidStartHour = 'INVALID_START_HOUR',
  /** The start minute is not valid. */
  InvalidStartMinute = 'INVALID_START_MINUTE',
  /** The timezone is not valid. */
  InvalidTimezone = 'INVALID_TIMEZONE',
  /** The title length is invalid. Refer to the error for min and max acceptable values. */
  InvalidTitle = 'INVALID_TITLE',
  /** The schedule to create a segment for was not found. */
  NotFound = 'NOT_FOUND',
  /** The segment time overlaps with another segment time. */
  OverlappingSegments = 'OVERLAPPING_SEGMENTS',
  /** Not authorized to edit this user schedule. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** The count for the number of times segment should repeat is invalid. The value must be 0 or greater. */
  RepeatEndsAfterCountInvalid = 'REPEAT_ENDS_AFTER_COUNT_INVALID',
  /** The title failed the moderation check. */
  TitleFailedModeration = 'TITLE_FAILED_MODERATION'
}

/** The input to create a new schedule segment. */
export type CreateScheduleSegmentInput = {
  /** The categories of the new segment. */
  categories: Array<Scalars['ID']>;
  /** The duration of the segment in minutes. */
  durationMinutes?: InputMaybe<Scalars['Int']>;
  /** The start date and time of the first occurrence of the segment. */
  firstOccurrenceDate?: InputMaybe<Scalars['Time']>;
  /** The number of times the segment should repeat. If 1, this is a single segment. */
  repeatEndsAfterCount?: InputMaybe<Scalars['Int']>;
  /** The ID of the schedule. */
  scheduleID: Scalars['ID'];
  /** The start time of the new segment. Ignored for single segments. */
  start?: InputMaybe<SegmentStartTimeInput>;
  /** The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles". */
  timezone: Scalars['String'];
  /** The title of the new segment. */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload returned when creating a new schedule segment. */
export type CreateScheduleSegmentPayload = {
  __typename?: 'CreateScheduleSegmentPayload';
  /** The possible error. */
  error?: Maybe<CreateScheduleSegmentError>;
  /** The updated schedule with the created segment. */
  schedule?: Maybe<Schedule>;
};

/** CreateSocialMediaError is a user error while creating a social media. */
export enum CreateSocialMediaError {
  /** The title failed moderation. */
  FailedTitleModeration = 'FAILED_TITLE_MODERATION',
  /** The provided url is invalid. */
  InvalidUrl = 'INVALID_URL',
  /** The provided title was too long. */
  TitleTooLong = 'TITLE_TOO_LONG',
  /** Maximun number of social medias reached. */
  TooMany = 'TOO_MANY'
}

/** CreateSocialMediaInput creates social media under the given channelID. */
export type CreateSocialMediaInput = {
  /** The ID of the channel the social media should belong to. */
  channelID: Scalars['ID'];
  /** The visible text of the social media item. */
  title: Scalars['String'];
  /** The web address of the social media item. */
  url: Scalars['String'];
};

/** CreateSocialMediaPayload returns the new social medias that were created. */
export type CreateSocialMediaPayload = {
  __typename?: 'CreateSocialMediaPayload';
  /** The channel of the social media that was created. */
  channel?: Maybe<Channel>;
  /** The potential error when creating a social media. */
  error?: Maybe<CreateSocialMediaError>;
};

/** CreateSquadStreamInvitationError is the error associated with a createSquadStreamInvitation. */
export type CreateSquadStreamInvitationError = {
  __typename?: 'CreateSquadStreamInvitationError';
  /** The associated error code. */
  code: CreateSquadStreamInvitationErrorCode;
};

/** CreateSquadStreamInvitationErrorCode are the possible errors that this mutation returns. */
export enum CreateSquadStreamInvitationErrorCode {
  /** The recipient is already invited to the squad. */
  InvitationAlreadyExists = 'INVITATION_ALREADY_EXISTS',
  /** The sender does not have permission to invite the recipient. */
  InvitationBlocked = 'INVITATION_BLOCKED',
  /** The invitation is not valid (e.g. the user is inviting themselves). */
  InvitationInvalid = 'INVITATION_INVALID',
  /** The squad is already full. */
  SquadFull = 'SQUAD_FULL',
  /** The user is not authorized to invite members to the squad. */
  Unauthorized = 'UNAUTHORIZED',
  /** The recipient is already in the squad. */
  UserAlreadyInSquad = 'USER_ALREADY_IN_SQUAD',
  /** The recipient does not have access to squad streams. */
  UserCannotAccessSquads = 'USER_CANNOT_ACCESS_SQUADS'
}

/** Inputs to the createSquadStreamInvitation mutation. */
export type CreateSquadStreamInvitationInput = {
  /** The user ID of the broadcaster that should be invited to join the squad stream. */
  recipientUserID: Scalars['ID'];
  /** The user ID of the broadcaster that is sending the invitation to join the squad stream. */
  senderUserID: Scalars['ID'];
};

/** Outputs from the createSquadStreamInvitation mutation. */
export type CreateSquadStreamInvitationPayload = {
  __typename?: 'CreateSquadStreamInvitationPayload';
  /** The possible error returned from the service. */
  error?: Maybe<CreateSquadStreamInvitationError>;
  /** The updated squad stream. */
  squadStream?: Maybe<SquadStream>;
};

/** Inputs to creating a stucco. */
export type CreateStuccoInput = {
  /** ID of the channel this stucco belongs to. */
  channelID: Scalars['ID'];
  /** Description representing the stucco, should be the words contained in the stucco, used by screen readers. */
  description: Scalars['String'];
  /** Base64 encoded binary data of the 92x28px stucco ("1x") image asset. */
  imageData1x: Scalars['String'];
  /** Base64 encoded binary data of the 182x56px stucco ("2x") image asset. */
  imageData2x: Scalars['String'];
  /** Base64 encoded binary data of the 368x112px stucco ("4x") image asset. */
  imageData4x: Scalars['String'];
  /** Text code representing the stucco without any prefixes (prefixes are added in the backend). */
  suffix: Scalars['String'];
};

/** Inputs for creating a new stucco pack. */
export type CreateStuccoPackInput = {
  /** Id of the channel this pack is part of. */
  channelID: Scalars['ID'];
  /** Updated list of stuccos for this pack. */
  stuccos?: InputMaybe<Array<CreateStuccoPackItemInput>>;
};

/** Single item in a stuccopack, as part of the create stucco pack call, representing one stucco to be used in a certain slot. */
export type CreateStuccoPackItemInput = {
  /** Slot index in the pack (used for ordering). */
  slotIndex: Scalars['Int'];
  /** Id of the stucco. */
  stuccoID: Scalars['ID'];
};

/** Outputs from the create stucco pack mutation. */
export type CreateStuccoPackPayload = {
  __typename?: 'CreateStuccoPackPayload';
  /** The created stucco pack. */
  stuccoPack?: Maybe<StuccoPack>;
};

/** The output for the create update stucco mutation. */
export type CreateStuccoPayload = {
  __typename?: 'CreateStuccoPayload';
  /** The created or updated stucco. */
  stucco?: Maybe<Stucco>;
};

/** Error from create unban request mutation. */
export type CreateUnbanRequestError = {
  __typename?: 'CreateUnbanRequestError';
  /** Error code from create unban request mutation. */
  code: CreateUnbanRequestErrorCode;
};

/** Error codes from create unban request mutation. */
export enum CreateUnbanRequestErrorCode {
  /** User already has a request for the current ban. */
  AlreadyCreated = 'ALREADY_CREATED',
  /** User is not banned in the channel. */
  NotBanned = 'NOT_BANNED',
  /** User is attempting to create a request too since their ban. Must wait for cooldown period to end. */
  TooSoonSinceBan = 'TOO_SOON_SINCE_BAN',
  /** Channel is not receiving unban requests. */
  UnbanRequestsDisabled = 'UNBAN_REQUESTS_DISABLED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Required input to create an unban request on a channel. */
export type CreateUnbanRequestInput = {
  /** Channel on which requester is requesting an unban. */
  channelID: Scalars['ID'];
  /** Custom message from unban requester to attach to unban request. */
  requesterMessage: Scalars['String'];
};

/** Result of a createUnbanRequest mutation. */
export type CreateUnbanRequestPayload = {
  __typename?: 'CreateUnbanRequestPayload';
  /** Error from attempting to create unban request. */
  error?: Maybe<CreateUnbanRequestError>;
  /** The newly created unban request. */
  unbanRequest?: Maybe<UnbanRequest>;
};

/** CreateVideoAppealInput details needed to create a video appeal. */
export type CreateVideoAppealInput = {
  /** city is the appeal city. */
  city: Scalars['String'];
  /** country is the appeal country. */
  country: Scalars['String'];
  /** fullName is the appeal full name. */
  fullName: Scalars['String'];
  /** state is the appeal state. */
  state: Scalars['String'];
  /** streetAddress1 is the appeal street address 1. */
  streetAddress1: Scalars['String'];
  /** streetAddress2 is the appeal street address 2. */
  streetAddress2?: InputMaybe<Scalars['String']>;
  /** trackAppeals is list of tracks that are being appealed. */
  trackAppeals: Array<TrackAppealRequestInput>;
  /** videoID is the id of the vod that this appeal is for. */
  videoID: Scalars['ID'];
  /** zipcode is the appeal zipcode. */
  zipcode: Scalars['String'];
};

/** CreateVideoAppealPayload the ID of the video for the appeal made. */
export type CreateVideoAppealPayload = {
  __typename?: 'CreateVideoAppealPayload';
  /** The ID of the Vod this appeal was created for. */
  videoID?: Maybe<Scalars['ID']>;
};

/** CreateVideoBookmarkError is the error associated with a createVideoBookmark. */
export type CreateVideoBookmarkError = {
  __typename?: 'CreateVideoBookmarkError';
  /** The associated error code. */
  code?: Maybe<CreateVideoBookmarkErrorCode>;
};

/** CreateVideoBookmarkErrorCode are the possible errors that this mutation returns. */
export enum CreateVideoBookmarkErrorCode {
  /** Archives are disabled for the channel. */
  ArchivesDisabled = 'ARCHIVES_DISABLED',
  /** The broadcaster is not live. */
  BroadcasterNotLive = 'BROADCASTER_NOT_LIVE',
  /** The premiere broadcast format is unsupported. */
  BroadcastFormatInvalidPremiere = 'BROADCAST_FORMAT_INVALID_PREMIERE',
  /** The rerun broadcast format is unsupported.. */
  BroadcastFormatInvalidRerun = 'BROADCAST_FORMAT_INVALID_RERUN',
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** The description length has exceeded the max length. */
  MaxDescriptionLengthExceeded = 'MAX_DESCRIPTION_LENGTH_EXCEEDED',
  /** The user is unauthorized to create the bookmark. */
  UserUnauthorized = 'USER_UNAUTHORIZED',
  /** The VOD for the associated broadcast is not yet ready. */
  VodNotReady = 'VOD_NOT_READY'
}

/** Input for creating a new bookmark. */
export type CreateVideoBookmarkInput = {
  /** ID of the broadcast the bookmark is made for. */
  broadcastID?: InputMaybe<Scalars['ID']>;
  /** Channel ID of the channel the bookmark is made for. */
  channelID?: InputMaybe<Scalars['ID']>;
  /** A description for the bookmark. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * The medium where the request came from.
   * e.g. "popout_chat", "chat", "live_dashboard_button", "live_dashboard_hotkey", "live_dashboard_chat".
   */
  medium: Scalars['String'];
  /**
   * The platform where the request came from.
   * e.g."web", "android", "ios".
   */
  platform: Scalars['String'];
};

/** Response for creating a bookmark, the bookmark that was created. */
export type CreateVideoBookmarkPayload = {
  __typename?: 'CreateVideoBookmarkPayload';
  /** Error of the create video bookmark request. */
  error?: Maybe<CreateVideoBookmarkError>;
  /** The bookmark that was created. */
  videoBookmark?: Maybe<VideoBookmark>;
};

export type CreateVideoCommentInput = {
  /** The id of the parent video comment when you reply. */
  commentID?: InputMaybe<Scalars['ID']>;
  /** Position of the video where this comment will be added. */
  contentOffsetSeconds: Scalars['Int'];
  /** The message of the comment. */
  message: Scalars['String'];
  /** The id of the video this comment belongs to. */
  videoID: Scalars['ID'];
};

export type CreateVideoCommentPayload = {
  __typename?: 'CreateVideoCommentPayload';
  /** The comment that was created. */
  comment: VideoComment;
};

export type CreateVideoHighlightInput = {
  /** The time in the source Archive type video that the Highlight will end at. */
  endOffsetSeconds: Scalars['Int'];
  /** Metadata to set for the highlight. */
  metadata: CreateVideoHighlightMetadata;
  /** The id of the Archive type video to create the Highlight from. */
  sourceVideoID: Scalars['ID'];
  /** The time in the source Archive type video that the Highlight will begin at. */
  startOffsetSeconds: Scalars['Int'];
};

export type CreateVideoHighlightMetadata = {
  /** The long form description of the Highlight content. */
  description: Scalars['String'];
  /** The primary game featured in the highlight, if any. */
  game?: InputMaybe<Scalars['ID']>;
  /** The language the highlight content is in. */
  language: Scalars['String'];
  /** Discovery tags to associate with the Highlight. */
  tags: Array<Scalars['String']>;
  /** The title of the the highlight. */
  title: Scalars['String'];
};

export type CreateVideoHighlightPayload = {
  __typename?: 'CreateVideoHighlightPayload';
  /** The created Video representing the Highlight. */
  highlight: Video;
};

/** Input to CreateVideoThumbnailUploadRequest mutation. */
export type CreateVideoThumbnailUploadRequestInput = {
  /** Crop height of the thumbnail. */
  cropH: Scalars['Int'];
  /** Crop width of the thumbnail. */
  cropW: Scalars['Int'];
  /** Crop X of the thumbnail. */
  cropX: Scalars['Int'];
  /** Crop Y of the thumbnail. */
  cropY: Scalars['Int'];
  /** ID of the video being updated. */
  videoID: Scalars['ID'];
};

/** Output from CreateVideoThumbnailUploadRequest mutation. */
export type CreateVideoThumbnailUploadRequestPayload = {
  __typename?: 'CreateVideoThumbnailUploadRequestPayload';
  /** The created thumbnail upload request url. */
  url?: Maybe<Scalars['String']>;
};

/** Data pertaining to a creator's badge flair for their own channel. */
export type CreatorBadgeFlair = {
  __typename?: 'CreatorBadgeFlair';
  /** The set of badge flair assets for each tier. */
  assets?: Maybe<Array<CreatorBadgeFlairAsset>>;
  /** The creator's setting for which badge flair, if any, can be displayed. */
  setting?: Maybe<CreatorBadgeFlairSetting>;
};

/** A set of URLs where clients can find the badge flair asset for a given creator at a given tier */
export type CreatorBadgeFlairAsset = {
  __typename?: 'CreatorBadgeFlairAsset';
  /** The "1x" dimension (18x18) image URL. */
  image1xURL: Scalars['String'];
  /** The "2x" dimension (36x36) image URL. */
  image2xURL: Scalars['String'];
  /** The "4x" dimension (72x72) image URL. */
  image4xURL: Scalars['String'];
  /** The tier to which these flair assets correspond to, as determined by the creator at time of upload. */
  tier: CreatorBadgeFlairTier;
};

/**
 * Setting for a user's channel that indicates what type of badge flair, if any,
 * is available for eligible subscribers to select.
 */
export enum CreatorBadgeFlairSetting {
  /** Indicates badge flair using a custom user-provided flair asset is available. */
  Custom = 'CUSTOM',
  /** Indicates badge flair using the default Twitch-provided flair asset is available. */
  Default = 'DEFAULT',
  /** Indicates no badge flair is available. */
  None = 'NONE'
}

/** Valid subscription tiers that custom badge flair can be associated to. */
export enum CreatorBadgeFlairTier {
  /** Tier 2 subscriptions (sometimes represented with string "2000"). */
  Tier_2 = 'TIER_2',
  /** Tier 3 subscriptions (sometimes represented with string "3000"). */
  Tier_3 = 'TIER_3'
}

/**
 * A CreatorCampArticle is a represenation of an article from
 * https://www.twitch.tv/creatorcamp.
 */
export type CreatorCampArticle = {
  __typename?: 'CreatorCampArticle';
  /** The ID of the article is also a human readable "slug" e.g. "twitch-101". */
  id: Scalars['ID'];
  /** The locale associated with this article's translations. */
  locale: Scalars['String'];
  /** A URL pointing to an image associated with this article. */
  previewImage?: Maybe<Scalars['String']>;
  /** A short introduction for the article. */
  previewText?: Maybe<Scalars['String']>;
  /** The localized title of the article. */
  title: Scalars['String'];
  /** The cannonical location of this article on the CreatorCamp site. */
  url: Scalars['String'];
  /** The length of the article's video in seconds. */
  videoDurationSeconds?: Maybe<Scalars['Int']>;
  /**
   * A URL pointing to the embedded video in this article. Most
   * CreatorCamp articles have an assoicated video.
   */
  videoURL?: Maybe<Scalars['String']>;
};

/**
 * A CreatorCampCategory is a grouping of CreatorCamp articles.
 * https://www.twitch.tv/creatorcamp.
 */
export type CreatorCampCategory = {
  __typename?: 'CreatorCampCategory';
  /** A list of CreatorCamp articles in this category. */
  articles: Array<CreatorCampArticle>;
  /** The ID of the category is also a human-readable "slug" e.g. "learn-the-basics". */
  id: Scalars['ID'];
  /** The localized title of the category. */
  title: Scalars['String'];
};

/** Creator Dashboard shown in twilight. */
export type CreatorDashboard = {
  __typename?: 'CreatorDashboard';
  /** Channel Analytics query for the Channel Analytics Tab in the Creator Dashboard. */
  channelAnalytics?: Maybe<ChannelAnalytics>;
};

/**
 * The container for creator gifts the creator has. This will be null if the creator
 * does not have this feature enabled.
 */
export type CreatorGifting = {
  __typename?: 'CreatorGifting';
  /** The identifier for the creator gifting type. This is the user's ID. */
  id: Scalars['ID'];
  /** The balance of gift subscriptions the creator has to give. These subscriptions do not pay out to the creator. */
  subscriptionsBalance?: Maybe<Scalars['Int']>;
};

/** Top level Creator Home object, includes data for clusters and panels. */
export type CreatorHome = {
  __typename?: 'CreatorHome';
  /** Clusters for layout information. */
  clusters: Array<CreatorHomeCluster>;
  /** Id for caching. */
  id: Scalars['ID'];
};

/** Predefined clusters for creators. */
export type CreatorHomeCluster = {
  __typename?: 'CreatorHomeCluster';
  /** Unique identifier for the cluster, i.e. "FAR_FROM_AFFILIATE". */
  id: Scalars['ID'];
};

/** Creator metrics for the given time period. */
export type CreatorMetricsByInterval = {
  __typename?: 'CreatorMetricsByInterval';
  /** Creator metrics aggregated and broken up by the interval length. */
  items?: Maybe<Array<Maybe<CreatorMetricsByIntervalItem>>>;
};

/** Creator metrics for the given time period. */
export type CreatorMetricsByIntervalItem = {
  __typename?: 'CreatorMetricsByIntervalItem';
  /** Ad breaks in seconds for the time period. */
  adBreaksInSecondsString: Scalars['String'];
  /** Ad seconds per hour for the time period. */
  adSecondsPerHour: Scalars['Float'];
  /** Average viewers for the time period. */
  averageViewers: Scalars['Float'];
  /** Clips views for the time period. */
  clipViewsString: Scalars['String'];
  /** Clips created for the time period. */
  clipsCreatedString: Scalars['String'];
  /** Number of follows for the time period. */
  followsString: Scalars['String'];
  /** Host raids percentage for the time period. */
  hostRaidsPercentage: Scalars['Float'];
  /** Live views for the time period. */
  liveViewsString: Scalars['String'];
  /** Max viewers for the time period. */
  maxViewersString: Scalars['String'];
  /** Time streamed (in minutes) for the time period. */
  minutesStreamedString: Scalars['String'];
  /** Minutes watched for the time period. */
  minutesWatchedString: Scalars['String'];
  /** New subscriptions for the time period. */
  newSubscriptionsString: Scalars['String'];
  /** Promotion clicks for the time period. */
  promotionClickString: Scalars['String'];
  /** Promotion displays for the time period. */
  promotionDisplayString: Scalars['String'];
  /** Starting timestamp for the time period. */
  timestamp: Scalars['Time'];
  /** Total chat messages for the time period. */
  totalChatMessagesString: Scalars['String'];
  /** Total chatters for the time period. */
  totalChattersString: Scalars['String'];
  /** Unique viewers for the time period. */
  uniqueViewersString: Scalars['String'];
};

/** Onboarding content and tips that are shown during the streamer onboarding experience. */
export type CreatorOnboardingContent = {
  __typename?: 'CreatorOnboardingContent';
  /** The time when the onboarding content was first shown to the user. */
  firstSeenAt?: Maybe<Scalars['Time']>;
  /** The id of the creator onboarding content. */
  id: Scalars['ID'];
};

/** A url to be shared by a creator to gain referrals, and associated metadata. */
export type CreatorReferralLink = {
  __typename?: 'CreatorReferralLink';
  /** The body text that will show on social media when the associated url is shared -- og:description. */
  description: Scalars['String'];
  /** The ID of the referral link. */
  id: Scalars['ID'];
  /** The image that will show on social media when the associated url is shared -- og:image. */
  imageURL: Scalars['String'];
  /** The title text that will show on social media when the associated url is shared -- og:title. */
  title: Scalars['String'];
  /** The url of the referral link. */
  url: Scalars['String'];
};

/** A paginated list of creator referral links. */
export type CreatorReferralLinkConnection = {
  __typename?: 'CreatorReferralLinkConnection';
  /** The list edges contain CreatorReferralLink with pagination information. */
  edges: Array<CreatorReferralLinkEdge>;
  /** Information about this page of creator referral links. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of creator referral links. */
export type CreatorReferralLinkEdge = {
  __typename?: 'CreatorReferralLinkEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the creator referral link for the current edge. */
  node: CreatorReferralLink;
};

/** Contains a reference to the link object and the number of referrals from that link. */
export type CreatorReferralLinkStat = {
  __typename?: 'CreatorReferralLinkStat';
  /** The reference to the link that caused the associated number of referrals. */
  link: CreatorReferralLink;
  /** The number of referred users for the given link. */
  referralCount: Scalars['Int'];
};

/** Contains the statistics summary for creator referral link. */
export type CreatorReferralSummary = {
  __typename?: 'CreatorReferralSummary';
  /** Average referrals per day in the given date range. */
  averageReferrals: Scalars['Int'];
  /** List of data points in the summary. */
  days: Array<CreatorReferralSummaryDay>;
  /** Total referrals in the given date range. */
  totalReferrals: Scalars['Int'];
  /** Trend of the referrals per day in the given date range, when compared to the previous date range of the same length. */
  trend: CreatorReferralTrend;
};

/** Each data point contains date and list of links with number of referred users. */
export type CreatorReferralSummaryDay = {
  __typename?: 'CreatorReferralSummaryDay';
  /** The date for the enclosed data. */
  date: Scalars['Time'];
  /** List of CreatorReferralLinkStat objects on the given date. */
  linkStats: Array<CreatorReferralLinkStat>;
  /** The total number of referred users on the given date. */
  referralCountSum: Scalars['Int'];
};

/** Specifies the general trend of this data set vs the previous data set. */
export enum CreatorReferralTrend {
  /** The new data set has decreased relative to the previous data set. */
  Negative = 'NEGATIVE',
  /** The new data set has not changed relative to the previous data set. */
  Neutral = 'NEUTRAL',
  /** The new data set has increased relative to the previous data set. */
  Positive = 'POSITIVE'
}

/** Single item of stats for the time series. */
export type CreatorTimeseriesItem = {
  __typename?: 'CreatorTimeseriesItem';
  /** Streamed duration (in minutes). */
  minutesStreamed?: Maybe<Scalars['Int']>;
  /** Timestamp of the broken down time series. */
  timestamp: Scalars['Time'];
  /** Value at the timestamp. */
  value: Scalars['Float'];
};

/** List of timestamp, value metric pairs and total for that metric. */
export type CreatorTimeseriesMetric = {
  __typename?: 'CreatorTimeseriesMetric';
  /** CreatorTimeseries data (timestamp, value) associated with this metric. */
  items?: Maybe<Array<CreatorTimeseriesItem>>;
  /** Total (sum) of all CreatorTimeseriesMetrics values. */
  total: Scalars['Int'];
};

/**
 * Metrics within a time frame broken down by granularity.
 * This is used for per team stats, per channel stats use "TimeseriesStats".
 */
export type CreatorTimeseriesMetrics = {
  __typename?: 'CreatorTimeseriesMetrics';
  /** Seconds of ads played per time chunk. */
  adBreaksInSeconds: CreatorTimeseriesMetric;
  /** Ad time (in seconds) per hour per time chunk. */
  adTimePerHour: CreatorTimeseriesMetric;
  /** Average number of viewers per time chunk. */
  averageViewers: CreatorTimeseriesMetric;
  /** Number of chat messages per time chunk. */
  chatMessages: CreatorTimeseriesMetric;
  /** Number of clip views per time chunk. */
  clipViews: CreatorTimeseriesMetric;
  /** Number of clips created per time chunk. */
  clipsCreated: CreatorTimeseriesMetric;
  /** Number of follows during this timestamp. */
  follows: CreatorTimeseriesMetric;
  /** Granularity of the time series, default unit is five minutes. */
  granularity: Granularity;
  /** Host/Raid viewers per time chunk. */
  hostRaidViewers: CreatorTimeseriesMetric;
  /** Live number of views per time chunk. */
  liveViews: CreatorTimeseriesMetric;
  /** Max viewers per time chunk. */
  maxViewers: CreatorTimeseriesMetric;
  /** Minutes watched per time chunk. */
  minutesWatched: CreatorTimeseriesMetric;
  /** Number of subscriptions per time chunk. */
  newSubscriptions: CreatorTimeseriesMetric;
  /** Promotion clicks for the time period. */
  promotionClick: CreatorTimeseriesMetric;
  /** Promotion displays for the time period. */
  promotionDisplay: CreatorTimeseriesMetric;
  /** Time streamed per time chunk. */
  timeStreamed: CreatorTimeseriesMetric;
  /** Number of people chatting per time chunk. */
  uniqueChatters: CreatorTimeseriesMetric;
  /** Number of unique people watching per time chunk. */
  uniqueViewers: CreatorTimeseriesMetric;
};

/** CreditChargeModel defines a charge model using non-FIAT currencies. */
export type CreditChargeModel = {
  __typename?: 'CreditChargeModel';
  /** The value of the credit. */
  amount: Scalars['Int'];
  /** The type of credit. */
  creditType: CreditType;
};

/** Types of non-fiat currencies. */
export enum CreditType {
  /** Indicates that there is no specific type of Credit in this model. */
  NoCreditType = 'NO_CREDIT_TYPE',
  /** A sub token type. */
  SubToken = 'SUB_TOKEN'
}

/** An enumeration of ISO 4217 currencies accepted by the API. */
export enum Currency {
  /** UAE Dirham currency. */
  Aed = 'AED',
  /** Afghani currency. */
  Afn = 'AFN',
  /** Lek currency. */
  All = 'ALL',
  /** Armenian Dram currency. */
  Amd = 'AMD',
  /** Netherlands Antillean Guilder currency. */
  Ang = 'ANG',
  /** Kwanza currency. */
  Aoa = 'AOA',
  /** Argentine Peso currency. */
  Ars = 'ARS',
  /** Australian Dollar currency. */
  Aud = 'AUD',
  /** Aruban Florin currency. */
  Awg = 'AWG',
  /** Azerbaijan Manat currency. */
  Azn = 'AZN',
  /** Convertible Mark currency. */
  Bam = 'BAM',
  /** Barbados Dollar currency. */
  Bbd = 'BBD',
  /** Taka currency. */
  Bdt = 'BDT',
  /** Bulgarian Lev currency. */
  Bgn = 'BGN',
  /** Bahraini Dinar currency. */
  Bhd = 'BHD',
  /** Burundi Franc currency. */
  Bif = 'BIF',
  /** Bermudian Dollar currency. */
  Bmd = 'BMD',
  /** Brunei Dollar currency. */
  Bnd = 'BND',
  /** Boliviano currency. */
  Bob = 'BOB',
  /** Mvdol currency. */
  Bov = 'BOV',
  /** Brazilian Real currency. */
  Brl = 'BRL',
  /** Bahamian Dollar currency. */
  Bsd = 'BSD',
  /** Ngultrum currency. */
  Btn = 'BTN',
  /** Pula currency. */
  Bwp = 'BWP',
  /** Belarusian Ruble currency. */
  Byn = 'BYN',
  /** Belize Dollar currency. */
  Bzd = 'BZD',
  /** Canadian Dollar currency. */
  Cad = 'CAD',
  /** Congolese Franc currency. */
  Cdf = 'CDF',
  /** WIR Euro currency. */
  Che = 'CHE',
  /** Swiss Franc currency. */
  Chf = 'CHF',
  /** WIR Franc currency. */
  Chw = 'CHW',
  /** Unidad de Fomento currency. */
  Clf = 'CLF',
  /** Chilean Peso currency. */
  Clp = 'CLP',
  /** Yuan Renminbi currency. */
  Cny = 'CNY',
  /** Colombian Peso currency. */
  Cop = 'COP',
  /** Unidad de Valor Real currency. */
  Cou = 'COU',
  /** Costa Rican Colon currency. */
  Crc = 'CRC',
  /** Peso Convertible currency. */
  Cuc = 'CUC',
  /** Cuban Peso currency. */
  Cup = 'CUP',
  /** Cabo Verde Escudo currency. */
  Cve = 'CVE',
  /** Czech Koruna currency. */
  Czk = 'CZK',
  /** Djibouti Franc currency. */
  Djf = 'DJF',
  /** Danish Krone currency. */
  Dkk = 'DKK',
  /** Dominican Peso currency. */
  Dop = 'DOP',
  /** Algerian Dinar currency. */
  Dzd = 'DZD',
  /** Egyptian Pound currency. */
  Egp = 'EGP',
  /** Nakfa currency. */
  Ern = 'ERN',
  /** Ethiopian Birr currency. */
  Etb = 'ETB',
  /** Euro currency. */
  Eur = 'EUR',
  /** Fiji Dollar currency. */
  Fjd = 'FJD',
  /** Falkland Islands Pound currency. */
  Fkp = 'FKP',
  /** Pound Sterling currency. */
  Gbp = 'GBP',
  /** Lari currency. */
  Gel = 'GEL',
  /** Ghana Cedi currency. */
  Ghs = 'GHS',
  /** Gibraltar Pound currency. */
  Gip = 'GIP',
  /** Dalasi currency. */
  Gmd = 'GMD',
  /** Guinean Franc currency. */
  Gnf = 'GNF',
  /** Quetzal currency. */
  Gtq = 'GTQ',
  /** Guyana Dollar currency. */
  Gyd = 'GYD',
  /** Hong Kong Dollar currency. */
  Hkd = 'HKD',
  /** Lempira currency. */
  Hnl = 'HNL',
  /** Kuna currency. */
  Hrk = 'HRK',
  /** Gourde currency. */
  Htg = 'HTG',
  /** Forint currency. */
  Huf = 'HUF',
  /** Rupiah currency. */
  Idr = 'IDR',
  /** New Israeli Sheqel currency. */
  Ils = 'ILS',
  /** Indian Rupee currency. */
  Inr = 'INR',
  /** Iraqi Dinar currency. */
  Iqd = 'IQD',
  /** Iranian Rial currency. */
  Irr = 'IRR',
  /** Iceland Krona currency. */
  Isk = 'ISK',
  /** Jamaican Dollar currency. */
  Jmd = 'JMD',
  /** Jordanian Dinar currency. */
  Jod = 'JOD',
  /** Yen currency. */
  Jpy = 'JPY',
  /** Kenyan Shilling currency. */
  Kes = 'KES',
  /** Som currency. */
  Kgs = 'KGS',
  /** Riel currency. */
  Khr = 'KHR',
  /** Comorian Franc currency. */
  Kmf = 'KMF',
  /** Won currency. */
  Krw = 'KRW',
  /** Kuwaiti Dinar currency. */
  Kwd = 'KWD',
  /** Cayman Islands Dollar currency. */
  Kyd = 'KYD',
  /** Tenge currency. */
  Kzt = 'KZT',
  /** Lao Kip currency. */
  Lak = 'LAK',
  /** Lebanese Pound currency. */
  Lbp = 'LBP',
  /** Sri Lanka Rupee currency. */
  Lkr = 'LKR',
  /** Liberian Dollar currency. */
  Lrd = 'LRD',
  /** Loti currency. */
  Lsl = 'LSL',
  /** Libyan Dinar currency. */
  Lyd = 'LYD',
  /** Moroccan Dirham currency. */
  Mad = 'MAD',
  /** Moldovan Leu currency. */
  Mdl = 'MDL',
  /** Malagasy Ariary currency. */
  Mga = 'MGA',
  /** Denar currency. */
  Mkd = 'MKD',
  /** Kyat currency. */
  Mmk = 'MMK',
  /** Tugrik currency. */
  Mnt = 'MNT',
  /** Pataca currency. */
  Mop = 'MOP',
  /** Ouguiya currency. */
  Mru = 'MRU',
  /** Mauritius Rupee currency. */
  Mur = 'MUR',
  /** Rufiyaa currency. */
  Mvr = 'MVR',
  /** Malawi Kwacha currency. */
  Mwk = 'MWK',
  /** Mexican Peso currency. */
  Mxn = 'MXN',
  /** Mexican Unidad de Inversion (UDI) currency. */
  Mxv = 'MXV',
  /** Malaysian Ringgit currency. */
  Myr = 'MYR',
  /** Mozambique Metical currency. */
  Mzn = 'MZN',
  /** Namibia Dollar currency. */
  Nad = 'NAD',
  /** Naira currency. */
  Ngn = 'NGN',
  /** Cordoba Oro currency. */
  Nio = 'NIO',
  /** Norwegian Krone currency. */
  Nok = 'NOK',
  /** Nepalese Rupee currency. */
  Npr = 'NPR',
  /** New Zealand Dollar currency. */
  Nzd = 'NZD',
  /** Rial Omani currency. */
  Omr = 'OMR',
  /** Balboa currency. */
  Pab = 'PAB',
  /** Sol currency. */
  Pen = 'PEN',
  /** Kina currency. */
  Pgk = 'PGK',
  /** Philippine Peso currency. */
  Php = 'PHP',
  /** Pakistan Rupee currency. */
  Pkr = 'PKR',
  /** Zloty currency. */
  Pln = 'PLN',
  /** Guarani currency. */
  Pyg = 'PYG',
  /** Qatari Rial currency. */
  Qar = 'QAR',
  /** Romanian Leu currency. */
  Ron = 'RON',
  /** Serbian Dinar currency. */
  Rsd = 'RSD',
  /** Russian Ruble currency. */
  Rub = 'RUB',
  /** Rwanda Franc currency. */
  Rwf = 'RWF',
  /** Saudi Riyal currency. */
  Sar = 'SAR',
  /** Solomon Islands Dollar currency. */
  Sbd = 'SBD',
  /** Seychelles Rupee currency. */
  Scr = 'SCR',
  /** Sudanese Pound currency. */
  Sdg = 'SDG',
  /** Swedish Krona currency. */
  Sek = 'SEK',
  /** Singapore Dollar currency. */
  Sgd = 'SGD',
  /** Saint Helena Pound currency. */
  Shp = 'SHP',
  /** Leone currency. */
  Sll = 'SLL',
  /** Somali Shilling currency. */
  Sos = 'SOS',
  /** Surinam Dollar currency. */
  Srd = 'SRD',
  /** South Sudanese Pound currency. */
  Ssp = 'SSP',
  /** Dobra currency. */
  Stn = 'STN',
  /** El Salvador Colon currency. */
  Svc = 'SVC',
  /** Lilangeni currency. */
  Szl = 'SZL',
  /** Baht currency. */
  Thb = 'THB',
  /** Somoni currency. */
  Tjs = 'TJS',
  /** Turkmenistan New Manat currency. */
  Tmt = 'TMT',
  /** Tunisian Dinar currency. */
  Tnd = 'TND',
  /** Pa’anga currency. */
  Top = 'TOP',
  /** Turkish Lira currency. */
  Try = 'TRY',
  /** Trinidad and Tobago Dollar currency. */
  Ttd = 'TTD',
  /** New Taiwan Dollar currency. */
  Twd = 'TWD',
  /** Tanzanian Shilling currency. */
  Tzs = 'TZS',
  /** Hryvnia currency. */
  Uah = 'UAH',
  /** Uganda Shilling currency. */
  Ugx = 'UGX',
  /** US Dollar currency. */
  Usd = 'USD',
  /** Uruguay Peso en Unidades Indexadas (UI) currency. */
  Uyi = 'UYI',
  /** Peso Uruguayo currency. */
  Uyu = 'UYU',
  /** Unidad Previsional currency. */
  Uyw = 'UYW',
  /** Uzbekistan Sum currency. */
  Uzs = 'UZS',
  /** Bolívar Soberano currency. */
  Ves = 'VES',
  /** Dong currency. */
  Vnd = 'VND',
  /** Vatu currency. */
  Vuv = 'VUV',
  /** Tala currency. */
  Wst = 'WST',
  /** CFA Franc BEAC currency. */
  Xaf = 'XAF',
  /** East Caribbean Dollar currency. */
  Xcd = 'XCD',
  /** CFA Franc BCEAO currency. */
  Xof = 'XOF',
  /** CFP Franc currency. */
  Xpf = 'XPF',
  /** Sucre currency. */
  Xsu = 'XSU',
  /** ADB Unit of Account currency. */
  Xua = 'XUA',
  /** Yemeni Rial currency. */
  Yer = 'YER',
  /** Rand currency. */
  Zar = 'ZAR',
  /** Zambian Kwacha currency. */
  Zmw = 'ZMW',
  /** Zimbabwe Dollar currency. */
  Zwl = 'ZWL'
}

/** CurrentPrimePayout is the detail breakdown of the payout that will be made in this specific payout cycle. */
export type CurrentPrimePayout = {
  __typename?: 'CurrentPrimePayout';
  /** pastCyclePayoutAmount is the part of the payout that was earned in previous payout cycle(s). */
  pastCyclePayoutAmount: Scalars['Int'];
  /** thisCyclePayoutAmount is the part of the payout that was earned in this payout cycle itself. */
  thisCyclePayoutAmount: Scalars['Int'];
  /** totalPayoutAmount is the total amount for this payout. */
  totalPayoutAmount: Scalars['Int'];
};

/** An action (and metadata about the action) which occurred for a channel's Dashboard Activity Feed. */
export type DashboardActivityFeedActivity = {
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Unique identifier for this activity. */
  id: Scalars['ID'];
  /** When this activity occurred. */
  timestamp: Scalars['Time'];
};

/** DashboardActivityFeedActivityAlertStatus are the possible alert statuses that an activity's corresponding alert can have. */
export enum DashboardActivityFeedActivityAlertStatus {
  /** The alert failed to be published. */
  Failed = 'FAILED',
  /** The alert was received when the channel was offline. */
  Offline = 'OFFLINE',
  /** The alert has been played and will not be seen again. */
  Played = 'PLAYED',
  /** The alert is currently being displayed. */
  Playing = 'PLAYING',
  /** The alert was purged from the alert queue by the broadcaster, after being queued originally. */
  Purged = 'PURGED',
  /** The alert is in the alert queue, but yet to be seen. */
  Queued = 'QUEUED',
  /** The alert was not queued and will not be displayed. */
  Rejected = 'REJECTED',
  /** The alert was being displayed, but was skipped by the broadcaster. */
  Skipped = 'SKIPPED'
}

/** When a user AutoHosts a channel. */
export type DashboardActivityFeedActivityAutoHosting = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityAutoHosting';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** User/Channel who is now AutoHosting the channel. */
  host?: Maybe<User>;
  /** Unique identifier for this AutoHosting action. */
  id: Scalars['ID'];
  /** When the host initiated the AutoHosting session. */
  timestamp: Scalars['Time'];
  /** Number of viewers from the host channel. */
  viewerCount: Scalars['Int'];
};

/** When a user uses Bits for or sends Bits to a channel. */
export type DashboardActivityFeedActivityBitsUsage = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityBitsUsage';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Bits spent. */
  amount: Scalars['Int'];
  /** Unique identifier for this Bits usage. */
  id: Scalars['ID'];
  /**
   * Whether the Cheer was anonymized to other users.
   * If true, then `user` is guaranteed to be null.
   */
  isAnonymous: Scalars['Boolean'];
  /** When the Bits were used. */
  timestamp: Scalars['Time'];
  /** Bits spender. */
  user?: Maybe<User>;
};

/** When a Boost completes for the given user. */
export type DashboardActivityFeedActivityBoostComplete = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityBoostComplete';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The progress made toward the goalTarget. */
  goalProgress: Scalars['Int'];
  /** The target size for the boost order. */
  goalTarget: Scalars['Int'];
  /** Unique identifier for this Boost event. */
  id: Scalars['ID'];
  /** The user who purchased the boost order. */
  purchaser?: Maybe<User>;
  /** The number of boosts in the order. */
  quantity: Scalars['Int'];
  /** When this Boost event occurred. */
  timestamp: Scalars['Time'];
};

/** When a Boost starts for the given user. */
export type DashboardActivityFeedActivityBoostStart = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityBoostStart';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The progress made toward the goalTarget. */
  goalProgress: Scalars['Int'];
  /** The target size for the boost order. */
  goalTarget: Scalars['Int'];
  /** Unique identifier for this Boost event. */
  id: Scalars['ID'];
  /** The user who purchased the boost order. */
  purchaser?: Maybe<User>;
  /** The number of boosts in the order. */
  quantity: Scalars['Int'];
  /** When this Boost event occurred. */
  timestamp: Scalars['Time'];
};

/** When a Celebration event occurs for the given user. */
export type DashboardActivityFeedActivityCelebrationPurchaseEvent = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityCelebrationPurchaseEvent';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The effect used for the celebration. */
  effect: CelebrationEffect;
  /** Unique identifier for this Celebration event. */
  id: Scalars['ID'];
  /** The intensity of the celebration. */
  intensity: CelebrationIntensity;
  /** The user who purchased the celebration. */
  purchasingUser?: Maybe<User>;
  /** When this Celebration event occurred. */
  timestamp: Scalars['Time'];
};

/** When a user redeems a community points reward on a channel. */
export type DashboardActivityFeedActivityCommunityPointsReward = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityCommunityPointsReward';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Unique identifier for this redemption. */
  id: Scalars['ID'];
  /** The user that redeemed the reward. */
  redeemingUser?: Maybe<User>;
  /** The redemption object itself. */
  redemption?: Maybe<CommunityPointsCustomRewardRedemption>;
  /** When the reward was redeemed. */
  timestamp: Scalars['Time'];
  /** The title of the reward. */
  title: Scalars['String'];
  /** The user's text input, if provided. */
  userInput?: Maybe<Scalars['String']>;
};

/** When a user gifts subscriptions to a community for a channel. */
export type DashboardActivityFeedActivityCommunitySubscriptionGifting = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityCommunitySubscriptionGifting';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Total subscriptions gifted by the gifter. */
  giftQuantity: Scalars['Int'];
  /** Total number of months the gifted subscription lasts for. */
  giftedMonths: Scalars['Int'];
  /** Subscription purchaser & gifter. */
  gifter?: Maybe<User>;
  /** Unique identifier for this gifting action. */
  id: Scalars['ID'];
  /**
   * Whether the subscription gifting was anonymized to other users.
   * If true, then `gifter` is guaranteed to be null.
   */
  isAnonymous: Scalars['Boolean'];
  /**
   * Users who received the gift.
   * Maximum count is currently 100.
   * @deprecated Use giftQuantity for total subscriptions
   */
  recipients?: Maybe<Array<User>>;
  /** The gifted subscription's tier. */
  tier: SubscriptionTier;
  /** When the subscriptions were gifted. */
  timestamp: Scalars['Time'];
};

/** Paginated list of past activities for a channel's Dashboard Activity Feed. */
export type DashboardActivityFeedActivityConnection = {
  __typename?: 'DashboardActivityFeedActivityConnection';
  /** Activity elements of the list. */
  edges: Array<DashboardActivityFeedActivityEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** When a Community Goal ends for the channel. */
export type DashboardActivityFeedActivityCopoGoalEnd = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityCopoGoalEnd';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The target number of points for the goal that has ended. */
  goalAmount: Scalars['Int'];
  /** The id of the goal that has ended. */
  goalID: Scalars['ID'];
  /** The current status of the goal that has ended. */
  goalStatus: CommunityPointsCommunityGoalStatus;
  /** The title of the goal that has ended. */
  goalTitle: Scalars['String'];
  /** The type of the goal that has ended. */
  goalType: CommunityPointsCommunityGoalType;
  /** Unique identifier for this goal end event. */
  id: Scalars['ID'];
  /** The number of points contributed towards the goal. */
  pointsContributed: Scalars['Int'];
  /** The name of the community points on the channel. */
  pointsName?: Maybe<Scalars['String']>;
  /** When this goal end event occurred. */
  timestamp: Scalars['Time'];
};

/** When a creator completes a drop quest and a drop can now be claimed by users/viewers. */
export type DashboardActivityFeedActivityDropClaimWindowOpen = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityDropClaimWindowOpen';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The community claimable drop which has been activated. */
  drop: DropObject;
  /** Unique identifier for this drop activity. */
  id: Scalars['ID'];
  /** When the quest was completed. */
  timestamp: Scalars['Time'];
};

/** Activity element in a list of past activities of a channel's Dashboard Activity Feed. */
export type DashboardActivityFeedActivityEdge = {
  __typename?: 'DashboardActivityFeedActivityEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** Activity that occurred. */
  node: DashboardActivityFeedActivity;
};

/** When a user newly follows or refollows a channel. */
export type DashboardActivityFeedActivityFollowing = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityFollowing';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** User who is now following the channel. */
  follower?: Maybe<User>;
  /** Unique identifier for this follow action. */
  id: Scalars['ID'];
  /** When the user followed the channel. */
  timestamp: Scalars['Time'];
};

/** When a user hosts a channel. */
export type DashboardActivityFeedActivityHosting = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityHosting';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** User/Channel who is now hosting the channel. */
  host?: Maybe<User>;
  /** Unique identifier for this hosting action. */
  id: Scalars['ID'];
  /** When the host initiated the hosting session. */
  timestamp: Scalars['Time'];
  /** Number of viewers from the host channel. */
  viewerCount?: Maybe<Scalars['Int']>;
};

/** When a HypeTrain event occurs for the given user. */
export type DashboardActivityFeedActivityHypeTrainEvent = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityHypeTrainEvent';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** The highest level completed on this HypeTrain. */
  completedLevel?: Maybe<Scalars['Int']>;
  /** Unique identifier of the Hype Train. */
  hypeTrainID: Scalars['ID'];
  /** Unique identifier for this HypeTrain event. */
  id: Scalars['ID'];
  /** When this HypeTrain event occurred. */
  timestamp: Scalars['Time'];
  /** The total amount of Bits contributed on this HypeTrain. */
  totalBitsAmount?: Maybe<Scalars['Int']>;
  /** The total count of subs and sub gifts contributed on this HypeTrain. */
  totalSubsCount?: Maybe<Scalars['Int']>;
  /** The type of this HypeTrain event. */
  type: HypeTrainEventType;
};

/** When a user gifts a single subscription to another individual user for a channel. */
export type DashboardActivityFeedActivityIndividualSubscriptionGifting = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityIndividualSubscriptionGifting';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Total number of months the gifted subscription lasts for. */
  giftedMonths: Scalars['Int'];
  /** Subscription purchaser & gifter. */
  gifter?: Maybe<User>;
  /** Unique identifier for this gifting action. */
  id: Scalars['ID'];
  /**
   * Whether the subscription gifting was anonymized to other users.
   * If true, then `gifter` is guaranteed to be null.
   */
  isAnonymous: Scalars['Boolean'];
  /** User that received the gift. */
  recipient?: Maybe<User>;
  /** The gifted subscription's tier. */
  tier: SubscriptionTier;
  /** When the subscription was gifted. */
  timestamp: Scalars['Time'];
};

/**
 * When an ingest session begins.
 * Deprecated type: no longer exists in activity feed.
 */
export type DashboardActivityFeedActivityIngestSessionStarting = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityIngestSessionStarting';
  /**
   * Status of the corresponding alert.
   * @deprecated ingest start has been removed from activity feed
   */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /**
   * Unique identifier for the start of this ingest session.
   * @deprecated ingest start has been removed from activity feed
   */
  id: Scalars['ID'];
  /**
   * Start time of the ingest session.
   * @deprecated ingest start has been removed from activity feed
   */
  timestamp: Scalars['Time'];
};

/** When a user resubscribes via Twitch Prime to a channel. */
export type DashboardActivityFeedActivityPrimeResubscribing = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityPrimeResubscribing';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Duration of the subscription. */
  durationMonths: Scalars['Int'];
  /** Unique identifier for the act of renewing the subscription. */
  id: Scalars['ID'];
  /**
   * Custom message submitted by the resubscribing user to share in chat.
   * @deprecated Use messageContent's fragments for enriching the text
   */
  message?: Maybe<Scalars['String']>;
  /**
   * Custom message submitted by the resubscribing user to share in chat.
   * Message is filtered for moderation and emotes are extracted as message fragments.
   */
  messageContent?: Maybe<MessageContent>;
  /** User who is renewing the subscription. */
  resubscriber?: Maybe<User>;
  /** When the subscription was renewed. */
  timestamp: Scalars['Time'];
};

/** When a user subscribes for the first time via Twitch Prime to a channel. */
export type DashboardActivityFeedActivityPrimeSubscribing = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityPrimeSubscribing';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Unique identifier for the act of subscribing. */
  id: Scalars['ID'];
  /** User who made the subscription. */
  subscriber?: Maybe<User>;
  /** When the subscription was made. */
  timestamp: Scalars['Time'];
};

/** When a user raids a channel. */
export type DashboardActivityFeedActivityRaiding = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityRaiding';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Unique identifier for this raiding action. */
  id: Scalars['ID'];
  /**
   * Number of users who participated in the raid.
   * @deprecated Renamed to viewerCount
   */
  partySize: Scalars['Int'];
  /** User/Channel who is now raiding the channel. */
  raider?: Maybe<User>;
  /** When the raid was initiated. */
  timestamp: Scalars['Time'];
  /** Number of users who participated in the raid. */
  viewerCount: Scalars['Int'];
};

/** When a user resubscribes (NOT via Twitch Prime) to a channel. */
export type DashboardActivityFeedActivityResubscribing = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivityResubscribing';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Duration of the subscription. */
  durationMonths: Scalars['Int'];
  /** Unique identifier for the act of renewing the subscription. */
  id: Scalars['ID'];
  /**
   * Custom message submitted by the resubscribing user to share in chat.
   * @deprecated Use messageContent's fragments for enriching the text
   */
  message?: Maybe<Scalars['String']>;
  /**
   * Custom message submitted by the resubscribing user to share in chat.
   * Message is filtered for moderation and emotes are extracted as message fragments.
   */
  messageContent?: Maybe<MessageContent>;
  /** Duration of the multi month subscription. */
  multiMonthDuration: Scalars['Int'];
  /** Tenure of the user's current multi month subscription. */
  multiMonthTenure: Scalars['Int'];
  /** User who is renewing the subscription. */
  resubscriber?: Maybe<User>;
  /** Subscription tier. */
  tier: SubscriptionTier;
  /** When the subscription was renewed. */
  timestamp: Scalars['Time'];
};

/** When a user subscribes for the first time (NOT via Twitch Prime) to a channel. */
export type DashboardActivityFeedActivitySubscribing = DashboardActivityFeedActivity & {
  __typename?: 'DashboardActivityFeedActivitySubscribing';
  /** Status of the corresponding alert. */
  alertStatus?: Maybe<DashboardActivityFeedActivityAlertStatus>;
  /** Unique identifier for the act of subscribing. */
  id: Scalars['ID'];
  /** Duration of the multi month subscription. */
  multiMonthDuration: Scalars['Int'];
  /** Tenure of the user's current multi month subscription. */
  multiMonthTenure: Scalars['Int'];
  /** User who made the subscription. */
  subscriber?: Maybe<User>;
  /** Subscription tier. */
  tier: SubscriptionTier;
  /** When the subscription was made. */
  timestamp: Scalars['Time'];
};

/** Paginated list of past activities for a channel's Dashboard Alert Queue. */
export type DashboardAlertQueueActivityConnection = {
  __typename?: 'DashboardAlertQueueActivityConnection';
  /** Activity elements of the list. */
  edges: Array<DashboardAlertQueueActivityEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Activity element in a list of past activities of a channel's Dashboard Alert Queue. */
export type DashboardAlertQueueActivityEdge = {
  __typename?: 'DashboardAlertQueueActivityEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** Activity that occurred. */
  node: DashboardActivityFeedActivity;
};

/** Preferences of a user controlling the types of dashboard alerts to be published. */
export type DashboardAlertQueuePreferences = {
  __typename?: 'DashboardAlertQueuePreferences';
  /** If true, cannot publish alerts to the user. */
  isDNDModeEnabled: Scalars['Boolean'];
  /** When the preferences were last modified. */
  lastModified?: Maybe<Scalars['Time']>;
  /** If true, cannot publish bits alerts to the user. */
  shouldHideBits: Scalars['Boolean'];
  /** If true, cannot publish follows alerts to the user. */
  shouldHideFollows: Scalars['Boolean'];
  /** If true, cannot publish subscription gift alerts to the user. */
  shouldHideGiftSubscriptions: Scalars['Boolean'];
  /** If true, cannot publish hosts alerts to the user. */
  shouldHideHosts: Scalars['Boolean'];
  /** If true, cannot publish raids alerts to the user. */
  shouldHideRaids: Scalars['Boolean'];
  /** If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown). */
  shouldHideSubscriptions: Scalars['Boolean'];
};

/** A shelf title token type that contains a date with various formatters. */
export type DateToken = {
  __typename?: 'DateToken';
  /** The date to display for this token. */
  time: Scalars['Time'];
};

/** The required input for a deactivateExtension mutation. */
export type DeactivateExtensionInput = {
  /** The composite ID of an extension installation <extensionID:version:channelID>. */
  extensionInstallationID: Scalars['ID'];
};

/** The resulting payload after a deactivateExtension mutation. */
export type DeactivateExtensionPayload = {
  __typename?: 'DeactivateExtensionPayload';
  /** The resulting extension installation record from the deactivate. */
  installedExtension: ExtensionInstallation;
};

/** Error associated with mutation DeclineOrganizationInvite. */
export type DeclineOrganizationInviteError = {
  __typename?: 'DeclineOrganizationInviteError';
  /** Error code. */
  code: DeclineOrganizationInviteErrorCode;
};

/** Client error code. */
export enum DeclineOrganizationInviteErrorCode {
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invitation not found. */
  NotFound = 'NOT_FOUND',
  /** Permission Denied. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Input to the DeclineOrganiztaionInvite mutation. */
export type DeclineOrganizationInviteInput = {
  /** ID of the invite to decline. */
  organizationInviteID: Scalars['ID'];
};

/** Output from the DeclineOrganizationInvite mutation. */
export type DeclineOrganizationInvitePayload = {
  __typename?: 'DeclineOrganizationInvitePayload';
  /** The possible error returned from service. */
  error?: Maybe<DeclineOrganizationInviteError>;
};

/** DefaultPanel is the normal panel type that displays text and images. */
export type DefaultPanel = Panel & {
  __typename?: 'DefaultPanel';
  /**
   * description is markdown-formatted text to be displayed below the title and image.
   * If the panel doesn't have a description this will be null.
   */
  description?: Maybe<Scalars['String']>;
  /** id is a unique identifier for the panel. */
  id: Scalars['ID'];
  /**
   * imageURL is a URL to an image to be displayed at the top of the panel (but below the header).
   * If the panel doesn't use an image this will be null.
   */
  imageURL?: Maybe<Scalars['String']>;
  /**
   * linkURL is the URL to navigate to when a user clicks on the image.
   * If the panel's image doesn't link anywhere this will be null.
   */
  linkURL?: Maybe<Scalars['String']>;
  /**
   * title is the header text to display in the panel.
   * If the panel doesn't have a title this will return null.
   */
  title?: Maybe<Scalars['String']>;
  /** type is `PanelType.DEFAULT`. */
  type: PanelType;
};

/** DeferredPrimePayout is the earning that has been deferred to future payout cycles. */
export type DeferredPrimePayout = {
  __typename?: 'DeferredPrimePayout';
  /** totalPayoutAmount is the total amount for this payout. */
  totalPayoutAmount: Scalars['Int'];
};

/** Inputs for deleting all videos by channel id mutation. */
export type DeleteAllChannelVideosInput = {
  /** The ID of the channel to delete all videos from. */
  channelID: Scalars['ID'];
};

/** The returned payload from the DeleteAllChannelVideos mutation. */
export type DeleteAllChannelVideosPayload = {
  __typename?: 'DeleteAllChannelVideosPayload';
  /** The status for this mutation. */
  status?: Maybe<DeleteAllChannelVideosStatus>;
};

/** Status associated with mutation DeleteAllChannelVideos. */
export type DeleteAllChannelVideosStatus = {
  __typename?: 'DeleteAllChannelVideosStatus';
  /** Error code. */
  code: DeleteAllChannelVideosStatusCode;
};

/** The status codes for this mutation. */
export enum DeleteAllChannelVideosStatusCode {
  /** User does not have permission to delete videos. */
  Forbidden = 'FORBIDDEN',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Deletion job was successful started. */
  Success = 'SUCCESS',
  /** Unknown Error. */
  Unknown = 'UNKNOWN'
}

/** The input for delete bits badge tier emoticon. */
export type DeleteBitsBadgeTierEmoticonInput = {
  /** channelID is the owner of the emoticon being deleted. */
  channelID: Scalars['ID'];
  /** emoteID is the unique identifier for the emote. */
  emoteID: Scalars['ID'];
  /**
   * The visual representation of the emote.
   * For example, "O_o" instead of "(O|o)_(o|O)".
   */
  text: Scalars['String'];
  /** threshold is the badge tier threshold associated with this emoticon. */
  threshold: Scalars['Int'];
};

/** Result of delete bits badge tier emoticon. */
export type DeleteBitsBadgeTierEmoticonPayload = {
  __typename?: 'DeleteBitsBadgeTierEmoticonPayload';
  /** Time that the emoticon got deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
};

/** Inputs for deleting a celebration. */
export type DeleteCelebrationInput = {
  /** ID of celebration to delete. */
  celebrationID: Scalars['ID'];
  /** ID of channel where the celebration to delete exists. */
  channelID: Scalars['ID'];
};

/** Outputs from the create celebration mutation. */
export type DeleteCelebrationPayload = {
  __typename?: 'DeleteCelebrationPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<CelebrationError>;
};

/** Errors that the mutation returns. */
export type DeleteChannelBlockedTermError = {
  __typename?: 'DeleteChannelBlockedTermError';
  /** The error code that the mutation returned. */
  code: DeleteChannelBlockedTermErrorCode;
};

/** The errors returned from this mutation. */
export enum DeleteChannelBlockedTermErrorCode {
  /** User does not have permission to delete blocked term in channel. */
  NoPermissions = 'NO_PERMISSIONS'
}

/** Inputs for the mutation. channel ID and a list of phrases to be deleted. */
export type DeleteChannelBlockedTermInput = {
  /** channelID is the owner of the term being deleted. */
  channelID: Scalars['ID'];
  /** phrases is the strings representation of the term being deleted. */
  phrases: Array<Scalars['String']>;
};

/** The returned payload from the mutation. */
export type DeleteChannelBlockedTermPayload = {
  __typename?: 'DeleteChannelBlockedTermPayload';
  /** The time term was deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** Mutation error caused by the user input. */
  error?: Maybe<DeleteChannelBlockedTermError>;
  /** The phrases that were deleted. */
  phrases: Array<Scalars['String']>;
};

/** Inputs for the deleting a channel's clip. */
export type DeleteChannelClipsInput = {
  /** channelID is the channel's ID. */
  channelID: Scalars['ID'];
};

/** The returned payload from the mutation. */
export type DeleteChannelClipsPayload = {
  __typename?: 'DeleteChannelClipsPayload';
  /** channelID is the channel's ID. */
  channelID: Scalars['ID'];
};

/** The errors returned from this mutation. */
export type DeleteChannelPermittedTermError = {
  __typename?: 'DeleteChannelPermittedTermError';
  /** Error code that was returned. */
  code: DeleteChannelPermittedTermErrorCode;
};

/** The possible error types returned from this mutation. */
export enum DeleteChannelPermittedTermErrorCode {
  /** User does not have permission to delete Permitted term in channel. */
  NoPermissions = 'NO_PERMISSIONS'
}

/** Inputs for the mutation. channel ID and a list of phrases to be deleted. */
export type DeleteChannelPermittedTermInput = {
  /** channelID is the ID of the owner of the permitted term being deleted. */
  channelID: Scalars['ID'];
  /** phrases is the string representation of the term being deleted. */
  phrases: Array<Scalars['String']>;
};

/** Returned payload of the mutation. */
export type DeleteChannelPermittedTermPayload = {
  __typename?: 'DeleteChannelPermittedTermPayload';
  /** The time term was deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** Mutation error caused by the user input. */
  error?: Maybe<DeleteChannelPermittedTermError>;
  /** The phrases that were deleted. */
  phrases: Array<Scalars['String']>;
};

/** The input for deleteChatMessage. */
export type DeleteChatMessageInput = {
  /** The channel the message was sent in. */
  channelID: Scalars['ID'];
  /** The UUID of the message to be deleted. */
  messageID: Scalars['ID'];
};

/** The returned payload for deleteChatMessage. */
export type DeleteChatMessagePayload = {
  __typename?: 'DeleteChatMessagePayload';
  /** The returned message. */
  message?: Maybe<DeletedMessage>;
  /** The response codes for this mutation. */
  responseCode: DeleteChatMessageStatusCode;
};

/** The response codes for this mutation. */
export enum DeleteChatMessageStatusCode {
  /** User does not have permission to delete messages. */
  Forbidden = 'FORBIDDEN',
  /** Deletion was successful. */
  Success = 'SUCCESS',
  /** Deletion was successful. Target user is staff. */
  SuccessStaff = 'SUCCESS_STAFF',
  /** Target is the broadcaster. */
  TargetIsBroadcaster = 'TARGET_IS_BROADCASTER',
  /** Target is another moderator. */
  TargetIsModerator = 'TARGET_IS_MODERATOR'
}

/** Error returned after attempting to delete a cheermote tier. */
export type DeleteCheermoteTierError = {
  __typename?: 'DeleteCheermoteTierError';
  /** The error code associated with this error. */
  code: DeleteCheermoteTierErrorCode;
};

/** Possible error codes for DeleteCheermoteTierError. */
export enum DeleteCheermoteTierErrorCode {
  /** The user is not allowed to delete this cheermote tier. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** The input for delete cheermote tier. */
export type DeleteCheermoteTierInput = {
  /** Threshold of the cheermote tier to be deleted. */
  tierThreshold: CheermoteTierThreshold;
  /** ID of the owner of the cheermote tier being deleted. */
  userID: Scalars['ID'];
};

/** Result of delete cheermote tier. */
export type DeleteCheermoteTierPayload = {
  __typename?: 'DeleteCheermoteTierPayload';
  /** Time that the cheermote tier got deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** Error returned after attempting to delete a cheermote tier. */
  error?: Maybe<DeleteCheermoteTierError>;
};

/**
 * DeleteClipsInput accepts either a list of slugs, a video id, or a broadcast id
 * to determine the clips to delete.
 */
export type DeleteClipsInput = {
  /** The id of the broadcast to delete clips from. */
  broadcastID?: InputMaybe<Scalars['ID']>;
  /** The list of clip slugs to be deleted. */
  slugs?: InputMaybe<Array<Scalars['ID']>>;
  /** The id of the video to delete clips from. */
  videoID?: InputMaybe<Scalars['ID']>;
};

/**
 * DeleteClipsPayload returns the deleted clips. Only the slug and id can be accessed
 * from the returned list of deleted clips.
 */
export type DeleteClipsPayload = {
  __typename?: 'DeleteClipsPayload';
  /** The clips that were deleted. Only Slug and ID can be accessed. */
  clips: Array<Maybe<Clip>>;
  /** The amount of clips that were deleted. */
  count: Scalars['Int'];
};

/** DeleteCollectionInput accepts a collection ID to delete a collection. */
export type DeleteCollectionInput = {
  /** The id of the collection to be deleted. */
  collectionID: Scalars['ID'];
};

/** DeleteCollectionPayload resolves the deleted collection. */
export type DeleteCollectionPayload = {
  __typename?: 'DeleteCollectionPayload';
  /** The collection that was just deleted. */
  collection: Collection;
};

/** Delete community goal error. */
export type DeleteCommunityPointsCommunityGoalError = {
  __typename?: 'DeleteCommunityPointsCommunityGoalError';
  /** The error code. */
  code: DeleteCommunityPointsCommunityGoalErrorCode;
};

/** Delete community goal error code. */
export enum DeleteCommunityPointsCommunityGoalErrorCode {
  /** The current user is not allowed to delete community goals for this channel. */
  Forbidden = 'FORBIDDEN',
  /** The goal was not found. */
  NotFound = 'NOT_FOUND',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Delete community goal input. */
export type DeleteCommunityPointsCommunityGoalInput = {
  /** The channel. */
  channelID: Scalars['ID'];
  /** The community goal. */
  goalID: Scalars['ID'];
};

/** Delete community goal payload. */
export type DeleteCommunityPointsCommunityGoalPayload = {
  __typename?: 'DeleteCommunityPointsCommunityGoalPayload';
  /** The error, if any. */
  error?: Maybe<DeleteCommunityPointsCommunityGoalError>;
  /** The community goal that was deleted. */
  goal?: Maybe<CommunityPointsCommunityGoal>;
};

/** An error from deleting a custom Community Points reward in a channel. */
export type DeleteCommunityPointsCustomRewardError = {
  __typename?: 'DeleteCommunityPointsCustomRewardError';
  /** An identifier for the error that occurred. */
  code: DeleteCommunityPointsCustomRewardErrorCode;
};

/** The possible reasons deleting a custom Community Points reward in a channel could fail. */
export enum DeleteCommunityPointsCustomRewardErrorCode {
  /** The current user is not allowed to delete a reward in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The reward was not found. */
  NotFound = 'NOT_FOUND',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for deleting a custom Community Points reward in a channel. */
export type DeleteCommunityPointsCustomRewardInput = {
  /** The channel ID that the reward is being deleted in. */
  channelID: Scalars['ID'];
  /** The ID of the reward being deleted. */
  rewardID: Scalars['ID'];
  /**
   * Rewards cannot be deleted while they have unfulfilled redemptions.
   * All unfulfilled redemptions will be set to this new state asynchronously after the reward is deleted.
   */
  unfulfilledRedemptionsNewStatus?: InputMaybe<CommunityPointsCustomRewardRedemptionStatus>;
};

/** The response from deleting a custom Community Points reward in a channel. */
export type DeleteCommunityPointsCustomRewardPayload = {
  __typename?: 'DeleteCommunityPointsCustomRewardPayload';
  /** An error that occurred while deleting a custom Community Points reward in a channel. */
  error?: Maybe<DeleteCommunityPointsCustomRewardError>;
  /** The now deleted reward. */
  reward?: Maybe<CommunityPointsCustomReward>;
};

/** Delete a Competition. */
export type DeleteCompetitionInput = {
  /** Unique Competition Id. */
  id: Scalars['ID'];
};

/** Result of the remove operation. */
export type DeleteCompetitionPayload = {
  __typename?: 'DeleteCompetitionPayload';
  /** The deleted competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Delete tags associated with CLIP, STREAM, or VOD with contentID. */
export type DeleteContentTagsInput = {
  /** ID of the channel owning the content. */
  authorID: Scalars['ID'];
  /** ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs. */
  contentID: Scalars['ID'];
  /** Type of content being returned. Can only be of values CLIP, STREAM, or VOD. */
  contentType: ContentType;
  /** List of tag IDs to be deleted from the content. */
  tagIDs: Array<Scalars['ID']>;
};

/** Result of mutation is the contentID. */
export type DeleteContentTagsPayload = {
  __typename?: 'DeleteContentTagsPayload';
  /** Content which tags have been deleted from. */
  content?: Maybe<TaggedContent>;
};

/** The input required when making a request to delete a user's default payment method for a given provider. */
export type DeleteDefaultPaymentMethodInput = {
  /** The payment provider we're deleting the payment method on. */
  provider: PaymentProvider;
  /** The user to delete default payment method for. */
  userID: Scalars['ID'];
};

/** Payload returned after deleting a default payment method for a given provider. */
export type DeleteDefaultPaymentMethodPayload = {
  __typename?: 'DeleteDefaultPaymentMethodPayload';
  /** Time when payment method was deleted. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User who had their default payment method deleted. */
  user?: Maybe<User>;
};

/** DeleteDeviceTokenInput accepts a token and user ID and deletes that pair from the database. */
export type DeleteDeviceTokenInput = {
  /** The token to be deleted. */
  deviceToken: Scalars['ID'];
  /** ID for the user associated with the device token. */
  userID: Scalars['ID'];
};

/** The response from deleting a push notification token from a user. */
export type DeleteDeviceTokenPayload = {
  __typename?: 'DeleteDeviceTokenPayload';
  /** The ID of the token that was deleted. */
  deviceToken: Scalars['ID'];
};

/** DeleteDropCampaignInput has fields required to delete a campaign. */
export type DeleteDropCampaignInput = {
  /** The id of the Drop campaign to be deleted. */
  campaignID: Scalars['ID'];
};

/** DeleteDropCampaignPayload returns the result of the deletion. */
export type DeleteDropCampaignPayload = {
  __typename?: 'DeleteDropCampaignPayload';
  /**
   * A potential error being thrown.
   * A mapped error returned by the drops management service.
   */
  error?: Maybe<DropsError>;
};

/** DeleteDropInput has fields required to delete a drop. */
export type DeleteDropInput = {
  /** The id of the Drop to be deleted. */
  dropID: Scalars['ID'];
};

/** DeleteDropPayload returns the result of the deletion. */
export type DeleteDropPayload = {
  __typename?: 'DeleteDropPayload';
  /**
   * A potential error being thrown.
   * A mapped error returned by the drops management service.
   */
  error?: Maybe<DropsError>;
};

/** Error returned after attempting to delete an emote. */
export type DeleteEmoteError = {
  __typename?: 'DeleteEmoteError';
  /** The error code associated with this error. */
  code: DeleteEmoteErrorCode;
};

/** Possible error codes for DeleteEmoteError. */
export enum DeleteEmoteErrorCode {
  /** The specified emote does not exist. */
  EmoteNotFound = 'EMOTE_NOT_FOUND',
  /** The user is not allowed to delete this emote. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** The input for delete emote. */
export type DeleteEmoteInput = {
  /** ID of the emote to be deleted. */
  id: Scalars['ID'];
};

/** Result of delete emote. */
export type DeleteEmotePayload = {
  __typename?: 'DeleteEmotePayload';
  /** Error returned after attempting to delete an emote. */
  error?: Maybe<DeleteEmoteError>;
};

/** Error types returned for the deleteExtension mutation. */
export enum DeleteExtensionError {
  /** Returned when the id specified could not be found. */
  ExtensionNotFound = 'EXTENSION_NOT_FOUND',
  /** Returned when the extension id was not specified. */
  MissingExtensionId = 'MISSING_EXTENSION_ID',
  /** Returned when the calling user does not have access to delete the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** DeleteExtensionImageError is an error associated with the deleteExtensionImage mutation. */
export enum DeleteExtensionImageError {
  /** Cannot find url in the manifest. */
  CannotFindUrlInManifest = 'CANNOT_FIND_URL_IN_MANIFEST',
  /** Invalid image url. */
  InvalidImageUrl = 'INVALID_IMAGE_URL',
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Information needed to delete images on extension. */
export type DeleteExtensionImageInput = {
  /** The extension:version the images are for. */
  extensionID: Scalars['ID'];
  /** Urls to be deleted. */
  urls: Array<Scalars['String']>;
};

/** DeleteExtensionImagePayload returns the update Extension manifest. */
export type DeleteExtensionImagePayload = {
  __typename?: 'DeleteExtensionImagePayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<DeleteExtensionImageError>;
  /** The updated extension manifest. */
  manifest?: Maybe<ExtensionManifest>;
};

/** Inputs for the deleteExtension mutation. */
export type DeleteExtensionInput = {
  /** ID for the extension being deleted. */
  id: Scalars['ID'];
};

/** The returned payload from the deleteExtension mutation. */
export type DeleteExtensionPayload = {
  __typename?: 'DeleteExtensionPayload';
  /**
   * Error response from the deleteExtension mutation.
   * null if the delete was successful.
   */
  error?: Maybe<DeleteExtensionError>;
};

/** DeleteExtensionImageError is an error associated with the deleteExtensionSecrets mutation. */
export enum DeleteExtensionSecretsError {
  /** User is unable to delete the extension secrets. */
  Unauthorized = 'UNAUTHORIZED'
}

/** The information we need to delete the extension's secrets. */
export type DeleteExtensionSecretsInput = {
  /** The extensionID whose secrets should be removed. */
  extensionID: Scalars['ID'];
};

/** Returns nothing but an error, should one occur. */
export type DeleteExtensionSecretsPayload = {
  __typename?: 'DeleteExtensionSecretsPayload';
  /** An useful error for the user. */
  error?: Maybe<DeleteExtensionSecretsError>;
};

/** Inputs for the mutation. Loyalty Badge to be deleted by channelID, badgeID, and channelTenureMethodID. */
export type DeleteLoyaltyBadgeInput = {
  /** badgeID correlated to the badge being deleted. */
  badgeID: Scalars['ID'];
  /** channelID correlated to the badge being deleted. */
  channelID: Scalars['ID'];
  /** channelTenureMethodID uniquely identifies the badge being deleted. */
  channelTenureMethodID: Scalars['ID'];
};

/** The returned payload from the mutation for Deleting a Loyalty Badge. */
export type DeleteLoyaltyBadgePayload = {
  __typename?: 'DeleteLoyaltyBadgePayload';
  /** LoyaltyBadge object that was deleted. */
  badge?: Maybe<LoyaltyBadge>;
};

/** Output from the DeleteModeratorComment mutation. */
export type DeleteModeratorCommentInput = {
  /** ID of the comment to be deleted. */
  ID: Scalars['ID'];
};

/** Output from the DeleteModeratorComment mutation. */
export type DeleteModeratorCommentPayload = {
  __typename?: 'DeleteModeratorCommentPayload';
  /** The deleted comment. */
  comment?: Maybe<ModLogsComment>;
};

/** Contains a list of IDs of content attributes that are to be deleted. */
export type DeleteMultiviewContentAttributesInput = {
  /** A list of content attribute IDs. */
  IDs: Array<Scalars['ID']>;
};

/** Contains the results from the delete request. */
export type DeleteMultiviewContentAttributesPayload = {
  __typename?: 'DeleteMultiviewContentAttributesPayload';
  /** Unprocessed content attributes. */
  failedDeletes: Array<MultiviewContentAttribute>;
  /** Processed content attributes. */
  succeededDeletes: Array<MultiviewContentAttribute>;
};

export type DeleteNotificationInput = {
  /** The notification to delete. */
  id: Scalars['ID'];
};

export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /** The notification that was deleted. Only the ID is accessible. */
  notification: OnsiteNotification;
};

export type DeletePanelInput = {
  id: Scalars['ID'];
};

export type DeletePanelPayload = {
  __typename?: 'DeletePanelPayload';
  panel: Panel;
};

export type DeletePostInput = {
  postID: Scalars['ID'];
};

export type DeletePostPayload = {
  __typename?: 'DeletePostPayload';
  post?: Maybe<Post>;
};

/** Data required to delete recommendation feedback. */
export type DeleteRecommendationFeedbackInput = {
  /** The id of the feedback. */
  feedbackID: Scalars['ID'];
  /** The page this event was fired from. */
  sourceItemPage: Scalars['String'];
};

/** Returns the created feedback item back to the client. */
export type DeleteRecommendationFeedbackPayload = {
  __typename?: 'DeleteRecommendationFeedbackPayload';
  /** The id of the feedback you just deleted. */
  feedbackID: Scalars['ID'];
};

export type DeleteRoomInput = {
  roomID: Scalars['ID'];
};

export type DeleteRoomMessageInput = {
  messageID: Scalars['ID'];
  roomID: Scalars['ID'];
};

export type DeleteRoomMessagePayload = {
  __typename?: 'DeleteRoomMessagePayload';
  message?: Maybe<RoomMessage>;
};

export type DeleteRoomPayload = {
  __typename?: 'DeleteRoomPayload';
  room?: Maybe<Room>;
};

/** The possible errors when deleting a schedule. */
export enum DeleteScheduleError {
  /** Not authorized to delete this user schedule. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** The input to delete a schedule. */
export type DeleteScheduleInput = {
  /** The channel ID. */
  channelID: Scalars['ID'];
  /** The schedule ID. */
  scheduleID: Scalars['ID'];
};

/** The payload returned after deleting a schedule. */
export type DeleteSchedulePayload = {
  __typename?: 'DeleteSchedulePayload';
  /** The channel with the deleted schedule. */
  channel?: Maybe<Channel>;
  /** The possible error. */
  error?: Maybe<DeleteScheduleError>;
};

/** The possible errors when deleting a schedule segment. */
export enum DeleteScheduleSegmentError {
  /** Not authorized to delete this segment. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** The input to delete a schedule segment. */
export type DeleteScheduleSegmentInput = {
  /** The schedule id. */
  scheduleID: Scalars['ID'];
  /** The segment id to delete. */
  segmentID: Scalars['ID'];
};

/** The returned payload when deleting a schedule segment. */
export type DeleteScheduleSegmentPayload = {
  __typename?: 'DeleteScheduleSegmentPayload';
  /** The possible error. */
  error?: Maybe<DeleteScheduleSegmentError>;
  /** The updated schedule without the deleted segment. */
  schedule?: Maybe<Schedule>;
};

/** Mutation input to delete a social media item by ID under the given channelID. */
export type DeleteSocialMediaInput = {
  /** The ID of the channel the social media belongs to. */
  channelID: Scalars['ID'];
  /** The ID of the social media item. */
  id: Scalars['ID'];
};

/** DeleteSocialMediaPayload returns an error, if any. */
export type DeleteSocialMediaPayload = {
  __typename?: 'DeleteSocialMediaPayload';
  /** The channel of the social media that was deleted. */
  channel?: Maybe<Channel>;
};

/** Errors from deleteSquadStreamInvitation mutation. */
export type DeleteSquadStreamInvitationError = {
  __typename?: 'DeleteSquadStreamInvitationError';
  /** Error from request to delete invitation. */
  code: DeleteSquadStreamInvitationErrorCode;
};

/** Possible errors that this mutation returns. */
export enum DeleteSquadStreamInvitationErrorCode {
  /** Invitation not in pending or rejected state cannot be deleted. */
  InvitationCannotBeDeleted = 'INVITATION_CANNOT_BE_DELETED',
  /** Invitation to be deleted does not exist. */
  InvitationNotFound = 'INVITATION_NOT_FOUND',
  /** Squad associated with the invitation does not exist. */
  SquadNotFound = 'SQUAD_NOT_FOUND',
  /** User does not have permissions to delete invitation. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Inputs to the deleteSquadStreamInvitation mutation. */
export type DeleteSquadStreamInvitationInput = {
  /** ID of the invitation to be deleted. */
  invitationID: Scalars['ID'];
};

/** Outputs from the deleteSquadStreamInvitation mutation. */
export type DeleteSquadStreamInvitationPayload = {
  __typename?: 'DeleteSquadStreamInvitationPayload';
  /** Error from mutation if exists. */
  error?: Maybe<DeleteSquadStreamInvitationError>;
  /** The deleted invitation. */
  invitation?: Maybe<SquadStreamInvitation>;
};

/** Error that may be returned by the DeleteStreamAuthorizedUser mutation. */
export type DeleteStreamAuthorizedUserError = {
  __typename?: 'DeleteStreamAuthorizedUserError';
  /** Type of mutation error. */
  code: DeleteStreamAuthorizedUserErrorCode;
};

/** DeleteStreamAuthorizedUserErrorCode is the client error type that occurred during the DeleteStreamAuthorizedUser mutation. */
export enum DeleteStreamAuthorizedUserErrorCode {
  /** The broadcaster is not found. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** Invalid argument to add an authorized user. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Maximum limit for adding authorized user is reached. */
  MaxAccountLimit = 'MAX_ACCOUNT_LIMIT',
  /** Permission denied to add an authorized user. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unable to assign the Targeted user to stream on behalf of the broadcaster. */
  TargetUserUnreturnable = 'TARGET_USER_UNRETURNABLE'
}

/** DeleteStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID. */
export type DeleteStreamAuthorizedUserInput = {
  /** authorizedUserID for an authorized user who was allowed to stream on behalf of broadcaster. */
  authorizedUserID: Scalars['ID'];
  /** channelID of the broadcaster. */
  channelID: Scalars['ID'];
};

/** DeleteStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users. */
export type DeleteStreamAuthorizedUserPayload = {
  __typename?: 'DeleteStreamAuthorizedUserPayload';
  /** The updated channel of broadcaster. */
  channel?: Maybe<Channel>;
  /** Error code. */
  error?: Maybe<AddStreamAuthorizedUserError>;
};

/** Inputs for the deleting clips made by user. */
export type DeleteUserClipsInput = {
  /** userID is the user's ID. */
  userID: Scalars['ID'];
};

/** The returned payload from the mutation. */
export type DeleteUserClipsPayload = {
  __typename?: 'DeleteUserClipsPayload';
  /** userID is the user's ID. */
  userID: Scalars['ID'];
};

/** Inputs for the DeleteUserColors mutation. */
export type DeleteUserColorsInput = {
  /** The ID of the user whose creator color is being deleted. */
  userID: Scalars['ID'];
};

/** The returned payload from the DeleteUserColors mutation. */
export type DeleteUserColorsPayload = {
  __typename?: 'DeleteUserColorsPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

export type DeleteVideoCommentPayload = {
  __typename?: 'DeleteVideoCommentPayload';
  /** The comment that was deleted. */
  comment: VideoComment;
};

/** Input information for deleting a thumbnail from a video. */
export type DeleteVideoThumbnailInput = {
  /** The thumbnail url path. */
  path: Scalars['String'];
  /** ID of the video the thumbnail will be deleted from. */
  videoID: Scalars['ID'];
};

/** Response to a request to delete a video thumbnail. */
export type DeleteVideoThumbnailPayload = {
  __typename?: 'DeleteVideoThumbnailPayload';
  /** Video representing the video from which a thumbnail was deleted. */
  video?: Maybe<Video>;
};

/** Inputs for the deleting videos by id mutation. */
export type DeleteVideosInput = {
  /** The IDs of the videos to be deleted. */
  videoIDs: Array<Scalars['ID']>;
};

/** The returned payload from the DeleteVideos mutation. */
export type DeleteVideosPayload = {
  __typename?: 'DeleteVideosPayload';
  /** The list of videos deleted. */
  videos?: Maybe<Array<Video>>;
};

/** A deleted message sent by a user to a stream chat. */
export type DeletedMessage = {
  __typename?: 'DeletedMessage';
  /** Content of the deleted message. */
  content: RoomMessageContent;
  /** UUID of the deleted message. */
  id: Scalars['ID'];
  /** Sender of the message. */
  sender?: Maybe<User>;
};

/** DeletedMessageDisplaySetting represents the possible settings for how deleted messages should be displayed. */
export enum DeletedMessageDisplaySetting {
  /** BRIEF removes all deleted messages and inserts a system message that reports the number of deleted messages. */
  Brief = 'BRIEF',
  /** DETAILED the deleted message is readable but strikethrough and grayed out. */
  Detailed = 'DETAILED',
  /** LEGACY hides deleted messages behind a clickable '<message_deleted>' chat line. */
  Legacy = 'LEGACY'
}

/** Defines ads management attributes for channel. */
export type Density = {
  __typename?: 'Density';
  /** Ad schedule for ads management. */
  adSchedule?: Maybe<Array<AdSlot>>;
  /** Duration of auto ads. */
  autoAdLengthSeconds?: Maybe<Scalars['Int']>;
  /** Period inbetween each auto ad. */
  autoAdPeriodMinutes?: Maybe<Scalars['Int']>;
  /** If channel is a custom contract partner. */
  isCCP: Scalars['Boolean'];
  /** Minutes elapsed since stream started. */
  minutesElapsed?: Maybe<Scalars['Int']>;
  /** If contract is enforced on this channel. */
  shouldEnforceContract: Scalars['Boolean'];
  /** Ad density target for a specific channel. */
  targetAdMinutes?: Maybe<Scalars['Int']>;
  /** Total amount of ad time. */
  totalAdSeconds?: Maybe<Scalars['Int']>;
};

export type DenyRejectedChatMessageInput = {
  id: Scalars['ID'];
};

export type DenyRejectedChatMessagePayload = {
  __typename?: 'DenyRejectedChatMessagePayload';
  message?: Maybe<RejectedChatMessage>;
};

/** Input to the denyRejectedCheer mutation. */
export type DenyRejectedCheerInput = {
  /**
   * Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
   * The server will reject any request with an ID that has already been used.
   */
  id: Scalars['ID'];
  /** ID of the user whose message is automodded. */
  targetUserID: Scalars['ID'];
};

/** Payload from the denyRejectedCheer mutation. */
export type DenyRejectedCheerPayload = {
  __typename?: 'DenyRejectedCheerPayload';
  /**
   * Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
   * The server will reject any request with an ID that has already been used.
   */
  id: Scalars['ID'];
};

/** Required input to deny an unban request on a channel. */
export type DenyUnbanRequestInput = {
  /** ID of the unban request to be resolved. */
  id: Scalars['ID'];
  /** Optional message from the resolver to be shown to the unban requester. */
  resolverMessage?: InputMaybe<Scalars['String']>;
};

/** Result of denying an unban request. */
export type DenyUnbanRequestPayload = {
  __typename?: 'DenyUnbanRequestPayload';
  /** Used for errors arising from resolving unban request. */
  error?: Maybe<UnbanRequestError>;
  /** The resolved unban request. */
  unbanRequest?: Maybe<UnbanRequest>;
};

/** Inputs for deselecting a channel badge. */
export type DeselectChannelBadgeInput = {
  /** ID of the channel this badge is selected on. */
  channelID: Scalars['ID'];
};

/** The output for the deselect channel badge mutation. */
export type DeselectChannelBadgePayload = {
  __typename?: 'DeselectChannelBadgePayload';
  /** The channel (user object of channel) this badge is deselected on. */
  user?: Maybe<User>;
};

/** The output for the deselect global badge mutation. */
export type DeselectGlobalBadgePayload = {
  __typename?: 'DeselectGlobalBadgePayload';
  /** The user (contains the badge status). */
  user?: Maybe<User>;
};

/** Defines AutoMod category levels for a Channel. */
export type DetailedAutoModConfiguration = {
  __typename?: 'DetailedAutoModConfiguration';
  /** This field will be a value between 0 and 4, inclusive. */
  ableismLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  aggressionLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  homophobiaLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  misogynyLevel?: Maybe<Scalars['Int']>;
  /**
   * DEPRECATED: nWordLevel is the level of "nWord" category. Will be deprecated when inference is upgraded to V4.
   * @deprecated No longer supported
   */
  nWordLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  nameCallingLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  profanityLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  racismLevel?: Maybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  sexualityLevel?: Maybe<Scalars['Int']>;
  /**
   * DEPRECATED: whiteNationalistLevel is the level of "whiteNationalist" category. Will be deprecated when inference is upgraded to V4.
   * @deprecated No longer supported
   */
  whiteNationalistLevel?: Maybe<Scalars['Int']>;
};

/** Defines AutoMod category levels for a Channel. */
export type DetailedAutoModLevelsInput = {
  /** This field will be a value between 0 and 4, inclusive. */
  ableismLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  aggressionLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  homophobiaLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  misogynyLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  nameCallingLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  profanityLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  racismLevel?: InputMaybe<Scalars['Int']>;
  /** This field will be a value between 0 and 4, inclusive. */
  sexualityLevel?: InputMaybe<Scalars['Int']>;
};

/** A Directory is a container of content – Streams, Videos, and Clips – on Twitch. */
export type Directory = {
  /**
   * URL to an avatar image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  avatarURL?: Maybe<Scalars['String']>;
  /** Number of broadcasters currently broadcasting in this directory. */
  broadcastersCount?: Maybe<Scalars['Int']>;
  /**
   * URL to a cover image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  coverURL?: Maybe<Scalars['String']>;
  /** The type of directory – community or game. */
  directoryType?: Maybe<DirectoryType>;
  /** The name to display for the directory. */
  displayName: Scalars['String'];
  /** Number of users that follow this directory. */
  followersCount?: Maybe<Scalars['Int']>;
  /** The directory's unique Twitch identifier. */
  id: Scalars['ID'];
  /** The canonical name of the directory. */
  name: Scalars['String'];
  /**
   * Get a page of live streams broadcasting in this directory.
   * If no language filters are provided all languages will be returned.
   * Tags are an array of tag ID as optional filters for streams.
   */
  streams?: Maybe<StreamConnection>;
  /** Number of viewers currently watching a stream which is in this directory. */
  viewersCount?: Maybe<Scalars['Int']>;
};


/** A Directory is a container of content – Streams, Videos, and Clips – on Twitch. */
export type DirectoryAvatarUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Directory is a container of content – Streams, Videos, and Clips – on Twitch. */
export type DirectoryCoverUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Directory is a container of content – Streams, Videos, and Clips – on Twitch. */
export type DirectoryStreamsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  languages?: InputMaybe<Array<Scalars['String']>>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * Paginated list of Directories.
 * Implements the Relay cursor connections specification.
 * See: https://facebook.github.io/relay/graphql/connections.htm.
 */
export type DirectoryConnection = {
  __typename?: 'DirectoryConnection';
  edges: Array<Maybe<DirectoryEdge>>;
  pageInfo: PageInfo;
};

/**
 * Contains information about a Directory's relationship to a given page (connection),
 * and the Directory itself.
 */
export type DirectoryEdge = {
  __typename?: 'DirectoryEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<Directory>;
};

/** The set of types of directory. */
export enum DirectoryType {
  /** A game. */
  Game = 'GAME'
}

/** Disable Prerolls Ability contains the properties used by the Disable Prerolls Feature. */
export type DisablePrerollsAbility = {
  __typename?: 'DisablePrerollsAbility';
  /** DisablePrerollsFreeTime define relation of midroll-length:preroll-free-time-earned on this channel. */
  disablePrerollsTimeEarned?: Maybe<Array<DisablePrerollsFreeTime>>;
  /** If "disable prerolls for midrolls" feature is accessible on this channel. */
  hasDisablePrerollsAbilityAccess?: Maybe<Scalars['Boolean']>;
  /** If "disable prerolls for midrolls" feature is enabled on this channel. */
  hasDisablePrerollsAbilityEnabled?: Maybe<Scalars['Boolean']>;
  /** If disable preroll notifications are enabled on this channel. */
  hasDisablePrerollsNotificationsEnabled?: Maybe<Scalars['Boolean']>;
  /** Maximum amount of preroll-free time (in seconds) that can be accumulated on this channel. */
  maxDisablePrerollsCapacity?: Maybe<Scalars['Int']>;
};

/** Disable Prerolls Free Time maps the relationship between a specific midroll length and amount of preroll-free time earned for a channel. */
export type DisablePrerollsFreeTime = {
  __typename?: 'DisablePrerollsFreeTime';
  /** The length (in seconds) of a midroll ad. */
  midrollLengthSeconds: Scalars['Int'];
  /** The amount of preroll-free time (in seconds) earned on this channel for running midroll of related length. */
  prerollFreeTimeSeconds: Scalars['Int'];
};

/** Error returned during a invalid user request. */
export type DisableTwoFactorError = {
  __typename?: 'DisableTwoFactorError';
  /** Error code returned by the backend. */
  code: DisableTwoFactorErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to disable two factor authentication. */
export enum DisableTwoFactorErrorCode {
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a disableTwoFactor mutation. */
export type DisableTwoFactorInput = {
  /** The ID of the user that is requesting to disable two factor authentication. */
  userID: Scalars['ID'];
};

/** The result of a disableTwoFactorPayload mutation. */
export type DisableTwoFactorPayload = {
  __typename?: 'DisableTwoFactorPayload';
  /** error code and localized error. */
  error?: Maybe<DisableTwoFactorError>;
};

/** Error type that DisableUserAccountPayload returns. */
export type DisableUserAccountError = {
  __typename?: 'DisableUserAccountError';
  /** Error Code, see DisableUserAccountErrorCode. */
  code: DisableUserAccountErrorCode;
};

/** DisableUserAccountErrorCode is an error while deleting a user. */
export enum DisableUserAccountErrorCode {
  /** User ID is invalid. */
  InvalidUserId = 'INVALID_USER_ID',
  /** Requester is not authorized to make the requested change. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Inputs to the disableUserAccount mutation. */
export type DisableUserAccountInput = {
  /** Reason for a user to disable their account. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Permanently delete account.
   * false means account will be disabled and can be reenabled in the future.
   * true means the account will be disabled and will be permanently deleted after a period of time.
   * default is false.
   */
  isDelete?: InputMaybe<Scalars['Boolean']>;
  /**
   * The ID of the user to disable or delete.
   * Only the requester's user ID is allowed.
   */
  userID: Scalars['ID'];
};

/** Output from the disableUserAccount mutation. */
export type DisableUserAccountPayload = {
  __typename?: 'DisableUserAccountPayload';
  /** Error if operation failed from user error. */
  error?: Maybe<DisableUserAccountError>;
  /** User that has been deleted or disabled. */
  user?: Maybe<User>;
};

/** DiscountBreakdown shows discounted pricing for a promotional offer. */
export type DiscountBreakdown = {
  __typename?: 'DiscountBreakdown';
  /** The numerical price of a discounted offer. */
  price: Scalars['Int'];
  /** The localized tax rate of a offer. */
  tax: Scalars['Int'];
  /** The total discounted price given price and tax. */
  total: Scalars['Int'];
};

/**
 * DEPRECATED: to be replaced by SubscriptionPromotionDiscountType.
 * Valid discount types for subscription products.
 */
export enum DiscountType {
  /** Percent discount type, eg. "50%". */
  PercentOff = 'PERCENT_OFF'
}

export type DismissFriendRecommendationInput = {
  /** The recommendation to the authenticated user to become friends with a user with ID targetID will be removed. */
  targetID: Scalars['ID'];
};

export type DismissFriendRecommendationPayload = {
  __typename?: 'DismissFriendRecommendationPayload';
  /** The user who was previously a friend recommendation to the target user. */
  user?: Maybe<User>;
};

export type DismissRitualTokenError = {
  __typename?: 'DismissRitualTokenError';
  code: DismissRitualTokenErrorCode;
};

export enum DismissRitualTokenErrorCode {
  /** Token is not in a status that can be dismissed. */
  TokenNotAvailable = 'TOKEN_NOT_AVAILABLE',
  /** Token does not exist. */
  TokenNotFound = 'TOKEN_NOT_FOUND'
}

/** DismissRitualTokenInput is the input when dismissing a ritual token. */
export type DismissRitualTokenInput = {
  /** The channel to dismiss the ritual token in. */
  channelID: Scalars['ID'];
  /** The type of ritual token to dismiss. */
  type: RitualTokenType;
};

/** DismissRitualTokenPayload is the response when dismissing a ritual token. */
export type DismissRitualTokenPayload = {
  __typename?: 'DismissRitualTokenPayload';
  error?: Maybe<DismissRitualTokenError>;
  token?: Maybe<RitualToken>;
};

/** Input for dismissing a video's suggested highlight. */
export type DismissVideoSuggestedHighlightInput = {
  /** VideoID of the video whos automated highlight suggestions were dismissed. */
  videoID: Scalars['ID'];
};

/** Ouput for dismissing a video's suggested highlight. */
export type DismissVideoSuggestedHighlightPayload = {
  __typename?: 'DismissVideoSuggestedHighlightPayload';
  /** Video whos automated highlight suggestions were dismissed. */
  video?: Maybe<Video>;
};

/** Contains all of the information about a Drop awarded to a user. */
export type Drop = {
  __typename?: 'Drop';
  /**
   * The game that awarded the Drop.
   * @deprecated No longer supported
   */
  game?: Maybe<Game>;
  /**
   * The assigned ID of this drop.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * The image URL of the Drop. Images are 80x80 pixels.
   * @deprecated No longer supported
   */
  imageURL: Scalars['String'];
  /**
   * The developer-provided name of the Drop.
   * @deprecated No longer supported
   */
  name: Scalars['String'];
};

/** A mapping of the client ID set to determine whether a user has set up account linking for the game. */
export type DropAccountLink = {
  __typename?: 'DropAccountLink';
  /**
   * The associated clientID for a game used to determine if users have an account link
   * created between tuid and in-game userID.
   */
  clientID: Scalars['ID'];
  /** The date when this clientID was first added. */
  updatedAt: Scalars['Time'];
};

/** Contains all of the information about a Drop's action stating what happens when a drop is triggered. //To be deprecated. */
export type DropAction = {
  __typename?: 'DropAction';
  /**
   * The time in seconds a user has to claim a drop after occurence.
   * @deprecated No longer supported
   */
  claimDurationSeconds: Scalars['Int'];
  /**
   * The description of this drop's action.
   * @deprecated No longer supported
   */
  description: Scalars['String'];
  /**
   * The Action ID.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * The type of action happening when a drop is triggered.
   * @deprecated No longer supported
   */
  type: DropActionType;
};

/** A list of all supported Action types. //To be deprecated. */
export enum DropActionType {
  /**
   * Returned in case the action type cannot be identified.
   * @deprecated No longer supported
   */
  UnknownActionType = 'UNKNOWN_ACTION_TYPE',
  /**
   * Returned in case the action starts a user claim flow.
   * @deprecated No longer supported
   */
  UserClaimFlow = 'USER_CLAIM_FLOW'
}

/** Data about the award of a drop to a user. // deprecated. */
export type DropAward = {
  __typename?: 'DropAward';
  /**
   * The timestamp when the Drop was awarded to the user.
   * @deprecated No longer supported
   */
  awardedAt?: Maybe<Scalars['Time']>;
  /**
   * The drop that was awarded to the user.
   * @deprecated No longer supported
   */
  node?: Maybe<Drop>;
  /**
   * The reason the Drop was awarded.
   * @deprecated No longer supported
   */
  reason?: Maybe<Scalars['String']>;
};

/** Contains all of the information about a Drop awarded to a user. */
export type DropBenefit = {
  __typename?: 'DropBenefit';
  /** The redirect URL where a user can link their account. */
  accountLinkURL: Scalars['String'];
  /** The time the benefit was created. */
  createdAt: Scalars['Time'];
  /**
   * The display description of this award object. //To be deprecated.
   * @deprecated No longer supported
   */
  description: Scalars['String'];
  /**
   * The limit of how often this benefit can globally be awarded to a user. Set to -1 if the drop can be entitled unlimited amounts.
   * The per drop entitlementLimit of a reward is on DropObject.Drop2BenefitObject.
   */
  entitlementLimit: Scalars['Int'];
  /** The game that awarded the Drop. */
  game?: Maybe<Game>;
  /** The ID of this reward object. */
  id: Scalars['ID'];
  /** An image asset for this reward object. */
  imageAssetURL: Scalars['String'];
  /** Specifies if this benefit is considered for a game that is available on iOS. */
  isIosAvailable: Scalars['Boolean'];
  /** The display name of this award object. */
  name: Scalars['String'];
  /**
   * The ID of the owner of the item for this reward.
   * @deprecated Use DropBenefit.ownerOrganization instead
   */
  owner: User;
  /** The (RBAC) Organization that owns the drop benefit. */
  ownerOrganization?: Maybe<Organization>;
};

/**
 * The DropBenefitEdge links a drop with a benefit and describes how many times that benefit
 * can be granted by this drop. A benefit can be granted multiple times by event based drops.
 * For example, a benefit could be granted every time the broadcaster gets a kill streak, up to
 * 3 times.
 */
export type DropBenefitEdge = {
  __typename?: 'DropBenefitEdge';
  /** The benefit description. */
  benefit: DropBenefit;
  /** The number of times a benefit has been claimed. */
  claimCount?: Maybe<Scalars['Int']>;
  /** A restriction of the benefit on how often it can be claimed within a drop. */
  entitlementLimit: Scalars['Int'];
};

/**
 * A campaign a developer is running to give drops away to viewers of their game
 * To be considered live, a campaign must be enabled with the current time
 * being after the start but before the end times
 * To apply to a particular channel a campaign must be live and additionally
 * the channel must be playing an applicable game and either must be one of the
 * applicable channels or the campaign must have an empty applicable channel list
 * (where an empty list specifically means all channels are eligible).
 */
export type DropCampaign = {
  __typename?: 'DropCampaign';
  /**
   * The URL users who aren't linked should click on to create a link that will
   * allow them create an account link for the developer of the game(s)
   * this campaign is for.
   */
  accountLinkURL: Scalars['String'];
  /** The only channels allowed to be eligible for the drop campaign. */
  allow?: Maybe<DropCampaignAcl>;
  /**
   * If isAvailableToAllChannels is false, applicableChannels is the list of
   * what channels this campaign is targeted to.  If the flag is true but the
   * list is empty, that means that all whitelisted users cannot be loaded.
   * An applicable channel must also be playing an applicable game for the
   * campaign to apply to the channel.
   * @deprecated No longer supported
   */
  applicableChannels?: Maybe<Array<User>>;
  /**
   * The games that this campaign is enabled on
   * A channel playing one of these games must be in the applicable channels
   * list or list must be empty for the campaign to apply to the channel.
   * @deprecated No longer supported
   */
  applicableGames?: Maybe<Array<Game>>;
  /**
   * The drops this campaign can award.
   * @deprecated No longer supported
   */
  awardableDrops?: Maybe<Array<Drop>>;
  /** The channels blocked from being eligible for the drop campaign. */
  block?: Maybe<DropCampaignAcl>;
  /**
   * The URL users who aren't linked should click on to create a link that will
   * allow them create an account link for the developer of the game(s)
   * this campaign is for.
   * @deprecated Use accountLinkURL instead
   */
  connectionURL: Scalars['String'];
  /** The description contains the full details about the campaign. */
  description: Scalars['String'];
  /** The URL that links to the details / marketing page for this campaign. */
  detailsURL: Scalars['String'];
  /**
   * The time this campaign ends
   * To be considered live, a campaign must be enabled with the current time
   * being after the start but before the end times.
   */
  endAt: Scalars['Time'];
  /** Drops triggered by in-game events. */
  eventBasedDrops?: Maybe<Array<EventBasedDrop>>;
  /** The Game associated with this campaign. */
  game?: Maybe<Game>;
  /** GUID identifying this campaign. */
  id: Scalars['ID'];
  /** An image asset for this campaign no larger than 160 x 160 pixels. */
  imageURL: Scalars['String'];
  /**
   * Indicates if this campaign is available to all channels or if only some.
   * If false, applicableChannels should contain the channels where the campaign
   * is available.
   * @deprecated No longer supported
   */
  isAvailableToAllChannels: Scalars['Boolean'];
  /**
   * If this campaign is enabled
   * To be considered live, a campaign must be enabled with the current time
   * being after the start but before the end times.
   * @deprecated No longer supported
   */
  isEnabled: Scalars['Boolean'];
  /** Drops that can be triggered by manual events. */
  manualTriggerBasedDrops?: Maybe<Array<ManualTriggerBasedDrop>>;
  /** The name of the campaign. */
  name: Scalars['String'];
  /** This is the Organization (RBAC) that has ownership of the campaign and attached drops. */
  owner?: Maybe<Organization>;
  /** User specific data for the campaign. */
  self: DropCampaignSelfEdge;
  /**
   * The time this campaign starts
   * To be considered live, a campaign must be enabled with the current time
   * being after the start but before the end times.
   */
  startAt: Scalars['Time'];
  /** The current status of the campaign. */
  status: DropCampaignStatus;
  /** Test viewers can participate in campaigns while the campaign is in the test status. */
  testViewers?: Maybe<Array<User>>;
  /** Drops triggered by accumulating minutes watched on a game. */
  timeBasedDrops?: Maybe<Array<TimeBasedDrop>>;
  /** The type of a campaign defines what type of drops are allowed to be added to the campaign. */
  type: CampaignType;
};

/** A toggleable access control list of channels given certain access to drop campaigns. */
export type DropCampaignAcl = {
  __typename?: 'DropCampaignACL';
  /** The channels that are either granted or denied access. */
  channels?: Maybe<Array<Channel>>;
  /** Whether the access list is currently in use. */
  isEnabled: Scalars['Boolean'];
};

/** DropCampaignSelfEdge returns user specific information about the drops campaign. */
export type DropCampaignSelfEdge = {
  __typename?: 'DropCampaignSelfEdge';
  /** Has the user linked their game account with the campaign. */
  isAccountConnected: Scalars['Boolean'];
};

/** Possible status of a drops campaign. */
export enum DropCampaignStatus {
  /** Drop campaign is currently active. */
  Active = 'ACTIVE',
  /** The drop campaign has been turned off. */
  Disabled = 'DISABLED',
  /** The drop campaign is past its end date. */
  Expired = 'EXPIRED',
  /** The drop campaign is currently in testing mode. */
  Test = 'TEST',
  /** The drop campaign is live but not yet past the start date. */
  Upcoming = 'UPCOMING'
}

/** Contains all of the information about the channel seetings for a Drop. */
export type DropChannelSetting = {
  __typename?: 'DropChannelSetting';
  /** UserAccountConnected is a boolean specifying if a streamer has a connected account link to the game required for the game developers to send drop related game data for this user. */
  isUserAccountConnected: Scalars['Boolean'];
};

/** The drop that is closest to completing for the current user that is actively earning progress. */
export type DropCurrentSession = {
  __typename?: 'DropCurrentSession';
  /** The channelID where Progresso is currently tracking progress. */
  channel?: Maybe<Channel>;
  /** The number of minutes that the user has accrued toward completing the drop. */
  currentMinutesWatched: Scalars['Int'];
  /** The ID for the Drop that we're currently tracking (not surfaced; used for fulfillment). */
  dropID: Scalars['ID'];
  /** The Game name that we're tracking for the currently-tracked drop. */
  game?: Maybe<Game>;
  /** The total number of minutes required in order to complete the drop. */
  requiredMinutesWatched: Scalars['Int'];
};

/** Contains all of the information about a Drop awarded to a user. */
export type DropEligibility = {
  __typename?: 'DropEligibility';
  /** The remaining time in which this reward can be claimed. */
  claimSecondsRemaining: Scalars['Int'];
  /**
   * Summary information for the drop the reward is claimed of.
   * @deprecated No longer supported. Use dropType instead.
   */
  drop: DropObject;
  /** The unique ID of this drop instance. */
  dropInstanceID: Scalars['ID'];
  /** A single Drop. This could be either an event or time based drop. */
  dropType: DropType;
  /** Rewards available to the user for this drop and their statuses. */
  rewards: Array<DropReward>;
  /** User eligibility for this drop instance. */
  status: DropInstanceEligibilityStatus;
};

/** Defines a condition that must be met for an in game event to trigger a drop. */
export type DropEventCondition = {
  __typename?: 'DropEventCondition';
  /** Specifies the event to look for in the event payload. */
  key: Scalars['String'];
  /** The comparator of the value to the event payload. */
  operator: DropEventConditionOperator;
  /** Specifies the value to compare the event payload to. */
  value: Scalars['String'];
};

/** A measurement against an in-game event to determine whether the drop should trigger. */
export type DropEventConditionInput = {
  /** The key of the in-game event that can trigger the drop. */
  key: Scalars['String'];
  /** The operator to apply to the event. */
  operator: DropEventConditionOperator;
  /** The value of the in-game event that the operator is compared to. */
  value: Scalars['String'];
};

/** The operator used to compare the in-game event. */
export enum DropEventConditionOperator {
  /** Equal. */
  Equal = 'EQUAL',
  /** Greater than. */
  Greater = 'GREATER',
  /** Greater than or equal. */
  GreaterEqual = 'GREATER_EQUAL',
  /** Less than. */
  Smaller = 'SMALLER',
  /** Less than or equal. */
  SmallerEqual = 'SMALLER_EQUAL',
  /** An unknown operator, only possible before the drop condition has been set. */
  Unknown = 'UNKNOWN'
}

/** DropImageType is the list of possible uses that an image can have for drops. */
export enum DropImageType {
  /** Image for showing a viewer what item a developer awarded as a drop. */
  Item = 'ITEM',
  /** Image for telling viewers that drops are available if they link accounts. */
  LinkNotification = 'LINK_NOTIFICATION'
}

/** DropImageUploadInput has the fields required to upload a drop's image asset. */
export type DropImageUploadInput = {
  /** The ownerID of the content owner. */
  ownerID: Scalars['ID'];
  /** The ID for the referenced scope item. */
  referenceID: Scalars['ID'];
  /** The scope of what the image gets uploaded for. */
  scope: Scope;
};

/** SetDropCampaignStatusPayload returns the result of the creation/update. */
export type DropImageUploadPayload = {
  __typename?: 'DropImageUploadPayload';
  /** The ID of the image once uploaded. */
  uploadID?: Maybe<Scalars['ID']>;
  /** The URL to upload the image to. */
  uploadURL?: Maybe<Scalars['String']>;
};

/** Status enums for a drop instance. */
export enum DropInstanceEligibilityStatus {
  /** User has already claimed this drop instance. */
  DropInstanceAlreadyClaimed = 'DROP_INSTANCE_ALREADY_CLAIMED',
  /** User can claim all rewards. */
  EligibleForAll = 'ELIGIBLE_FOR_ALL',
  /** User can not claim any of the rewards in this drop instance. */
  EntitlementLimitReached = 'ENTITLEMENT_LIMIT_REACHED',
  /** The claim duration has expired and user can no longer claim this drop instance. */
  Expired = 'EXPIRED',
  /** User can claim some rewards. */
  Limited = 'LIMITED',
  /** Unknown is returned if a status is returned from the backend that was not expected. */
  Unknown = 'UNKNOWN'
}

/** Contains all of the information about a Drop awardable to a user. // deprecated in favor of EventBasedDrop and TimeBasedDrop. */
export type DropObject = {
  __typename?: 'DropObject';
  /**
   * The redirect URL where a user can link their account.
   * @deprecated No longer supported
   */
  accountLinkURL: Scalars['String'];
  /**
   * The actions defining what happens after a drop is triggered.
   * @deprecated No longer supported
   */
  actions: Array<DropAction>;
  /**
   * The description of this drop.
   * @deprecated No longer supported
   */
  description: Scalars['String'];
  /**
   * The URL that links to the details / marketing page for this drop.
   * @deprecated No longer supported
   */
  detailsURL: Scalars['String'];
  /**
   * The date at which this drop can no longer occur.
   * @deprecated No longer supported
   */
  endDate: Scalars['Time'];
  /**
   * The game associated with this drop.
   * @deprecated No longer supported
   */
  game: Game;
  /**
   * The Drops ID.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * An image asset for this drop.
   * @deprecated No longer supported
   */
  imageURL: Scalars['String'];
  /**
   * The friendly name of this drop.
   * @deprecated No longer supported
   */
  name: Scalars['String'];
  /**
   * The OrganizationID of the owner of this drop.
   * @deprecated No longer supported
   */
  ownerID: Scalars['ID'];
  /**
   * The friendly name of the owner of this drop.
   * @deprecated No longer supported
   */
  ownerName: Scalars['String'];
  /**
   * The Quest name for this specific Drop.
   * @deprecated No longer supported
   */
  questName: Scalars['String'];
  /**
   * The rules defining what needs to happen to trigger this drop.
   * @deprecated No longer supported
   */
  rules: Array<DropRule>;
  /**
   * The date at which this drop can start to occur.
   * @deprecated No longer supported
   */
  startDate: Scalars['Time'];
};

/** DropPrecondition is the tuple of DropID and the DropPreconditionID, which is the drop that must be attained first. */
export type DropPrecondition = {
  /** The drop that can be claimed once the preconditions are met. */
  dropID: Scalars['ID'];
  /** The drop that must have been claimed before you can make progress on this drop. */
  dropPreconditionID: Scalars['ID'];
};

/** Contains all of the information about a Drop awarded to a user. */
export type DropReward = {
  __typename?: 'DropReward';
  /**
   * The URL where a user can link their account for this reward.
   * @deprecated use benefit.accountLinkURL
   */
  accountLinkURL: Scalars['String'];
  /** An availability enum for this reward. */
  availability: DropRewardAvailability;
  /** The DropBenefit that a user is claiming or get verified to. */
  benefit: DropBenefit;
  /**
   * The display description of this award object.
   * @deprecated no longer used
   */
  description: Scalars['String'];
  /**
   * The ID of this reward object.
   * @deprecated use benefit.id
   */
  id: Scalars['ID'];
  /**
   * An image asset for this reward object.
   * @deprecated use benefit.imageAssetURL
   */
  imageAssetURL: Scalars['String'];
  /**
   * Specifies if this reward is considered for a game that is available on iOS.
   * @deprecated use benefit.isIosAvailable
   */
  isIosAvailable: Scalars['Boolean'];
  /**
   * The display name of this award object.
   * @deprecated use benefit.name
   */
  name: Scalars['String'];
  /**
   * The ID of the owner of the item for this reward.
   * @deprecated use benefit.ownerOrganization.id
   */
  ownerID: Scalars['ID'];
  /**
   * The display name of item owner for this drop.
   * @deprecated use benefit.ownerOrganization.name
   */
  ownerName: Scalars['String'];
};

/** Availability enum for Drop Rewards. */
export enum DropRewardAvailability {
  /** User can claim this item. */
  Available = 'AVAILABLE',
  /** User has claimed this item already the maximum number of times. */
  LimitReached = 'LIMIT_REACHED',
  /** Unknown is returned when an unexpected status is received from the backend. */
  Unknown = 'UNKNOWN'
}

/** Contains all of the information about a Drop's rule stating what a broadcaster has to do to trigger a drop. //To be deprecated. */
export type DropRule = {
  __typename?: 'DropRule';
  /**
   * The description of this drop's rule.
   * @deprecated No longer supported
   */
  description: Scalars['String'];
  /**
   * The Rule ID.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
};

/** The type of drop rule you're creating. Event vs Minutes Watched. */
export enum DropRuleType {
  /** A drop that is triggered by an in-game event. */
  EventBased = 'EVENT_BASED',
  /** A drop that is triggered by an manual triggered event. */
  ManualTriggerBased = 'MANUAL_TRIGGER_BASED',
  /** A drop that is granted based on the user's minutes-watched of the drop's game. */
  TimeBased = 'TIME_BASED'
}

/** An interface to handle shared Drop data. The `Drop` type is already in use (although deprecated) so we can't use that name. */
export type DropType = {
  /** The rewards for this drop and how often those rewards can be awarded. */
  benefitEdges?: Maybe<Array<DropBenefitEdge>>;
  /** The campaign this drop belongs to. */
  campaign: DropCampaign;
  /** The time this drop becomes unavailable. */
  endAt: Scalars['Time'];
  /** A unique identifier. */
  id: Scalars['ID'];
  /** The name of this drop. */
  name: Scalars['String'];
  /** The time this drop becomes available. */
  startAt: Scalars['Time'];
};

/** An error that has been mapped from a DropsManagementService twirp error. Can sometimes include messages. */
export type DropsError = {
  __typename?: 'DropsError';
  /** The error code. */
  code: DropsErrorCode;
  /** The error message string. */
  message?: Maybe<Scalars['String']>;
};

/** Enum for Drops2 errors. */
export enum DropsErrorCode {
  /** The object you're trying to create, already exists. */
  AlreadyExists = 'ALREADY_EXISTS',
  /** The drops2 object is not in the right state to perform this operation. */
  FailedPrecondition = 'FAILED_PRECONDITION',
  /** A request field either was not present or did not meet validation requirements. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The object you wish to query / modify is not found. */
  NotFound = 'NOT_FOUND',
  /** The user is either not authenticated or not authorized to perform the request. */
  Unauthorized = 'UNAUTHORIZED',
  /** The error code is unknown. */
  Unknown = 'UNKNOWN'
}

/** ESRBRating for a given game. */
export enum EsrbRating {
  /** Game category that has ESRB Rating of AO. */
  Ao = 'AO',
  /** Game category that has ESRB Rating of E. */
  E = 'E',
  /** Game category that has ESRB Rating of E10. */
  E10 = 'E10',
  /** Game category that has ESRB Rating of EC. */
  Ec = 'EC',
  /** Game category that has ESRB Rating of M. */
  M = 'M',
  /** Game category that has ESRB Rating of Rating Pending (RP). */
  Rp = 'RP',
  /** Game category that has ESRB Rating of T. */
  T = 'T',
  /** Game category that has not set an ESRB Rating. */
  Unset = 'UNSET'
}

export type EditRoomMessageInput = {
  message: Scalars['String'];
  messageID: Scalars['ID'];
  roomID: Scalars['ID'];
};

export type EditRoomMessagePayload = {
  __typename?: 'EditRoomMessagePayload';
  message?: Maybe<RoomMessage>;
};

/** Paginated list of channels a user is an editor for. */
export type EditableChannelConnection = {
  __typename?: 'EditableChannelConnection';
  /** The elements of the list. */
  edges: Array<EditableChannelEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Points to a editable channel with the editor. */
export type EditableChannelEdge = {
  __typename?: 'EditableChannelEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The user whose channel has the editor. */
  node?: Maybe<User>;
};

/** Paginated list of editors of a channel. */
export type EditorConnection = {
  __typename?: 'EditorConnection';
  /** The elements of the list. */
  edges: Array<EditorEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Points to a user with the editor status, with metadata regarding the relationship. */
export type EditorEdge = {
  __typename?: 'EditorEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** Timestamp of when the editor status was granted. */
  grantedAt: Scalars['Time'];
  /** The user who has the editor status. */
  node?: Maybe<User>;
};

/** The list of payment methods that are supported for web checkout for a user. */
export type EligiblePaymentMethod = {
  __typename?: 'EligiblePaymentMethod';
  /** Availability status of the underlying payment gateway. */
  availabilityStatus: PaymentMethodAvailabilityStatus;
  /** Name of the payment method. */
  name: EligiblePaymentMethodName;
};

/** The list of names of payment methods that are supported for web checkout. */
export enum EligiblePaymentMethodName {
  /** Amazon Pay payment method. */
  AmazonPay = 'AMAZON_PAY',
  /** Credit card payment method. */
  CreditCard = 'CREDIT_CARD',
  /** Direct Debit payment method. */
  DirectDebit = 'DIRECT_DEBIT',
  /** Paypal payment method. */
  Paypal = 'PAYPAL',
  /** Twitch Wallet balance payment method. */
  Wallet = 'WALLET',
  /** Xsolla payment method. */
  Xsolla = 'XSOLLA'
}

/**
 * EmbeddedEmote is an encoding format used to describe an emote embedded in a string of text.
 *
 * Example:
 *   body = "hey KappaHD"
 *   from = 4
 *   to = 10
 *
 *   "KappaHD" will be replaced with the KappaHD emote image.
 */
export type EmbeddedEmote = {
  __typename?: 'EmbeddedEmote';
  /** The emote's identifier, for example "115847" -> KappaHD. */
  emoteID?: Maybe<Scalars['ID']>;
  /** from is the index of the string where replacement starts. */
  from?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['ID']>;
  /** setID is the identifier of the set this emote is in. */
  setID?: Maybe<Scalars['ID']>;
  /** to is the index of the string where replacement ends. */
  to?: Maybe<Scalars['Int']>;
};

/**
 * EmitCampaignDiscoveryEventInput contains the campaign objective type of the event being emitted
 * and the channelID from which this event is born.
 */
export type EmitCampaignDiscoveryEventInput = {
  /** The channelID from the channel this event is taking place on. */
  channelID: Scalars['ID'];
  /** The campaign objective type of the event. */
  discoveryType: CampaignDiscoveryEventType;
};

/** EmitCampaignDiscoveryEventPayload is the success response for emitting a campaign discovery event. */
export type EmitCampaignDiscoveryEventPayload = {
  __typename?: 'EmitCampaignDiscoveryEventPayload';
  /** Whether the call succeeded or not. */
  isSuccess: Scalars['Boolean'];
};

export type Emote = {
  __typename?: 'Emote';
  /** The type of image asset of the emote (static, animated, etc.). */
  assetType?: Maybe<EmoteAssetType>;
  /** The Bits Badge Tier metadata associated with this Bits Badge Tier Emote. Nil for other emote types. */
  bitsBadgeTierSummary?: Maybe<EmoteBitsBadgeTierSummary>;
  /** The timestamp at which this emote was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /**
   * The emote's identifier.
   * For example, "115847".
   */
  id?: Maybe<Scalars['ID']>;
  /** The list of modifiers a user is entitled to use for an emote. */
  modifiers?: Maybe<Array<EmoteModifier>>;
  /** A priority order for displaying this emote among others in the same group. */
  order?: Maybe<Scalars['Int']>;
  /** The user who owns the subscription product that this emote belongs to. */
  owner?: Maybe<User>;
  /** Identifies which set this emote belongs to. */
  setID?: Maybe<Scalars['ID']>;
  /** The state of an emote. Can be either active or pending. */
  state: EmoteState;
  /** The subscription product this emote belongs to. Nil for globals. */
  subscriptionProduct?: Maybe<SubscriptionProduct>;
  /** The subscription info for this emote (if the emote is obtainable via subscription). */
  subscriptionSummaries?: Maybe<Array<SubscriptionSummary>>;
  /**
   * This is very sparsely populated at present (only when subscription summaries are populated).
   * This is subscription tier that is associated with this emote (if one exists) and if the emote and subscription shares an owner.
   */
  subscriptionTier?: Maybe<SubscriptionSummaryTier>;
  /**
   * For subscription and bits badge tier emotes, this is the user generated suffix.
   * For example, for "lirikLUL" suffix would be "LUL".
   */
  suffix?: Maybe<Scalars['String']>;
  /**
   * The visual representation of the emote.
   * For example, "O_o" instead of "(O|o)_(o|O)".
   */
  text?: Maybe<Scalars['String']>;
  /**
   * The text token of the emote.
   * For example, "KappaHD".
   */
  token?: Maybe<Scalars['String']>;
  /**
   * The type of emote that this is.
   * For example, a global emote, a turbo emote, a prime emote, a sub emote, etc.
   */
  type?: Maybe<EmoteType>;
};

/** The asset type of the emote (static, animated, etc.). */
export enum EmoteAssetType {
  /** The emote's asset is animated (e.g. GIF). */
  Animated = 'ANIMATED',
  /** The emote's asset is static (e.g. PNG). */
  Static = 'STATIC',
  /** The emote's asset type is unknown. */
  Unknown = 'UNKNOWN'
}

/** Bits Badges Tier metadata for emotes. */
export type EmoteBitsBadgeTierSummary = {
  __typename?: 'EmoteBitsBadgeTierSummary';
  /** The Bits Badge Tier Summary data that is user-dependent. */
  self?: Maybe<EmoteBitsBadgeTierSummarySelfEdge>;
  /** The amount of bits any user must cheer to achieve this tier. */
  threshold: Scalars['Int'];
};

/** The Bits Badge Tier Summary data that is user-dependent. */
export type EmoteBitsBadgeTierSummarySelfEdge = {
  __typename?: 'EmoteBitsBadgeTierSummarySelfEdge';
  /** Is true if the user has unlocked this emote. */
  isUnlocked: Scalars['Boolean'];
  /** The number of bits that this user must use in order to unlock this emote. 0 if already unlocked. */
  numberOfBitsUntilUnlock: Scalars['Int'];
};

/** The possible emote group asset types. */
export enum EmoteGroupAssetType {
  /** ANIMATED type groups only contain animated emotes. */
  Animated = 'ANIMATED',
  /** STATIC type groups only contain static emotes. */
  Static = 'STATIC'
}

/** The ID, Size and AssetType of a previously uploaded emote. */
export type EmoteImageAssetInput = {
  /** The asset type of the image. */
  assetType: EmoteAssetType;
  /** Image ID generated by Mako for image. */
  id: Scalars['ID'];
  /** Size of the image. */
  size: EmoteImageSize;
};

/** Enum of supported image sizes. */
export enum EmoteImageSize {
  /** Lowest supported resolution. */
  Size_1X = 'SIZE_1X',
  /** Resolution used for kinda high density displays. */
  Size_2X = 'SIZE_2X',
  /** Highest density display support. */
  Size_4X = 'SIZE_4X',
  /** Original size, used for resizing functionality. */
  SizeOriginal = 'SIZE_ORIGINAL'
}

/** Represents the data needed to continue the upload of an emoticon image asset. */
export type EmoteImageUploadConfiguration = {
  __typename?: 'EmoteImageUploadConfiguration';
  /** The id used by upload service to publish updates via pubsub about the uploaded image. */
  uploadID?: Maybe<Scalars['ID']>;
  /** The url in s3 for where the front-end should post the image asset. */
  uploadURL?: Maybe<Scalars['String']>;
};

/** The name of an emote modifier and it's abbreviated code. */
export type EmoteModifier = {
  __typename?: 'EmoteModifier';
  /** The code to use the emote modifier in chat. */
  code: Scalars['String'];
  /** The name of the emote modifier. */
  name: PermanentEmoteModifier;
  /** Subscription tier associated with modifier (if known and applicable). */
  subscriptionTier?: Maybe<SubscriptionSummaryTier>;
};

/** A set of modifications to apply to a tier of emotes for a creator. */
export type EmoteModifierGroupInput = {
  /** The modifiers to set. */
  modifiers: Array<PermanentEmoteModifier>;
  /** The ID of the product to set the modifiers for. */
  productID: Scalars['ID'];
};

/** A set of modifiers that have been set on a tier of emotes for a creator. */
export type EmoteModifierGroupPayload = {
  __typename?: 'EmoteModifierGroupPayload';
  /** The modifiers that were set. */
  modifiers?: Maybe<Array<PermanentEmoteModifier>>;
  /** The product the modifiers were set for. */
  product?: Maybe<SubscriptionProduct>;
};

/** The new order for the specified emote in a particular emote group. */
export type EmoteOrder = {
  /** The ID of this emote. */
  emoteID: Scalars['ID'];
  /**
   * The ID of the group we are setting this emote's order in. When emotes can exist in multiple groups they may have different
   * order values in each group (as the other emotes in each group will be different) so we must specify which group we are operating on.
   */
  groupID: Scalars['ID'];
  /** The new order value for this emote. */
  order: Scalars['Int'];
};

/** Enum of supported resizing plans. */
export enum EmoteResizePlan {
  /** Resize a provided SIZE_ORIGINAL_IMAGE. */
  AutoResize = 'AUTO_RESIZE',
  /** Don't resize, use the image as is for 1x, 2x or 4x. */
  NoResize = 'NO_RESIZE'
}

/** Represents a group of emotes. */
export type EmoteSet = {
  __typename?: 'EmoteSet';
  /** The asset type of the emotes within the emote group. */
  assetType?: Maybe<EmoteGroupAssetType>;
  /** The list of emotes which belong to this set. */
  emotes?: Maybe<Array<Maybe<Emote>>>;
  /** The emote set's identifier. */
  id?: Maybe<Scalars['ID']>;
  /**
   * The channel associated with the emote set. Nil for emote sets not associated
   * with an owner (prime, fuel, rewards, etc.).
   */
  owner?: Maybe<User>;
};

/** Deprecated: Domains that emotes belong to. */
export enum EmoteSetDomain {
  /** Emotes that were granted via Twitch crates. */
  Crate = 'CRATE'
}

/** The state of an emote. */
export enum EmoteState {
  /** Emote has been approved and is active. */
  Active = 'ACTIVE',
  /** Emote is only available in the emote library. */
  Archived = 'ARCHIVED',
  /** Emote is inactive. */
  Inactive = 'INACTIVE',
  /** Emote has been uploaded and is awaiting approval. */
  Pending = 'PENDING',
  /** Emote has been uploaded into the emote library and is awaiting approval. */
  PendingArchived = 'PENDING_ARCHIVED',
  /** Emote has an unknown state. */
  Unknown = 'UNKNOWN'
}

/** Used to filter emotes by state. */
export enum EmoteStateFilter {
  /** Show only active emotes. */
  Active = 'ACTIVE',
  /** Show all emotes, including active and pending. */
  All = 'ALL'
}

export enum EmoteType {
  /** Emotes which have intentionally been given no associated feature because they are only available in the Emotes Library. */
  Archive = 'ARCHIVE',
  /** Emote is a bits badge tier reward. */
  BitsBadgeTiers = 'BITS_BADGE_TIERS',
  /** Emote is a channel points reward. */
  ChannelPoints = 'CHANNEL_POINTS',
  /** Emote is a global emote. */
  Globals = 'GLOBALS',
  /** Limited time emote from a hype train campaign. */
  HypeTrain = 'HYPE_TRAIN',
  /** Limited time emotes are from a limited window event like FUEL or Esports (like OWL or Heathstone). */
  LimitedTime = 'LIMITED_TIME',
  /** Limited time emote from a megacommmerce/megacheer campaign. */
  MegaCommerce = 'MEGA_COMMERCE',
  /** Emote is a Twitch Prime benefit. */
  Prime = 'PRIME',
  /** Emote is one of the robot, monkey, or glitch smilies sets. */
  Smilies = 'SMILIES',
  /** Emote is a subscription product benefit. */
  Subscriptions = 'SUBSCRIPTIONS',
  /** Emote is a Twitch Turbo benefit. */
  Turbo = 'TURBO',
  /** Two Factor authorization enabled reward emotes. */
  TwoFactor = 'TWO_FACTOR',
  /** Emote has an unknown type. */
  Unknown = 'UNKNOWN'
}

/** Represents an emote that is currently in the process of being uploaded. */
export type EmoteUploadConfiguration = {
  __typename?: 'EmoteUploadConfiguration';
  /** The relevant metadata for the 1X image asset. */
  imageUploadConfig1X?: Maybe<EmoteImageUploadConfiguration>;
  /** The relevant metadata for the 2X image asset. */
  imageUploadConfig2X?: Maybe<EmoteImageUploadConfiguration>;
  /** The relevant metadata for the 4X image asset. */
  imageUploadConfig4X?: Maybe<EmoteImageUploadConfiguration>;
};

/** Channels have emoticon prefixes. */
export type EmoticonPrefix = {
  __typename?: 'EmoticonPrefix';
  /** If the prefix can be edited or not. */
  isEditable: Scalars['Boolean'];
  /** Name of the prefix. */
  name: Scalars['String'];
  /** If the prefix has been approved or not. */
  state: EmoticonPrefixState;
};

/** State to track if the emote prefix is approved or not. */
export enum EmoticonPrefixState {
  /** Prefix is approved and active. */
  Active = 'ACTIVE',
  /** Prefix is waiting moderation by Twitch. */
  Pending = 'PENDING',
  /** Prefix was rejected by Twitch. */
  Rejected = 'REJECTED',
  /** Unknown. */
  Unknown = 'UNKNOWN',
  /** No prefix has been submitted. */
  Unset = 'UNSET'
}

/** The required input for an EndUseBitsInExtension mutation. */
export type EndUseBitsInExtensionInput = {
  /** The transaction ID of this bits spend event. */
  transactionID: Scalars['ID'];
};

/** The result of a EndUseBitsInExtension mutation. */
export type EndUseBitsInExtensionPayload = {
  __typename?: 'EndUseBitsInExtensionPayload';
  /** The user's new bits balance. */
  balance?: Maybe<Scalars['Int']>;
};

/** Paginated list of endorsed channels using the Relay cursor specification. */
export type EndorsedChannelConnection = {
  __typename?: 'EndorsedChannelConnection';
  /** The endorsed channels. */
  edges?: Maybe<Array<EndorsedChannelEdge>>;
  /** Pagination information for this connection. */
  pageInfo: PageInfo;
};

/** Element in a list of endorsed channels. */
export type EndorsedChannelEdge = {
  __typename?: 'EndorsedChannelEdge';
  /** Cursor identifying the position of this edge for future queries. */
  cursor: Scalars['Cursor'];
  /** The information about the endorsed channel. */
  node: Channel;
  /** Unique id per channel item, used by the client to attribute display/clicks of items. */
  trackingID: Scalars['ID'];
};

/**
 * EnhancedExperiencesClient is an OAuth app that is authorized to use
 * the Enhanced Experiences (E2) API for game integrations.
 */
export type EnhancedExperiencesClient = {
  __typename?: 'EnhancedExperiencesClient';
  /** The client ID of the OAuth app. */
  id: Scalars['ID'];
  /** The name of the client. */
  name: Scalars['String'];
  /** The timestamp when the the client was onboarded to the Enhanced Experiences (E2) API. */
  onboardedAt?: Maybe<Scalars['Time']>;
};

/** Episode metadata. */
export type EpisodeDetails = {
  __typename?: 'EpisodeDetails';
  /** Total length of the content. */
  durationSeconds?: Maybe<Scalars['Int']>;
  /** The episode number. */
  episode?: Maybe<Scalars['Int']>;
  /** The season number. */
  season?: Maybe<Scalars['Int']>;
  /** The name of the series. */
  series?: Maybe<Scalars['String']>;
};

/** EquipHeroAssetsError contains details about an error that occured when equipping assets. */
export type EquipHeroAssetsError = {
  __typename?: 'EquipHeroAssetsError';
  /** The type of error that occured when equipping hero assets. */
  code: EquipHeroAssetsErrorCode;
};

/** EquipHeroAssetsErrorCode defines a client error that occurs when equipping hero assets. */
export enum EquipHeroAssetsErrorCode {
  /** The requesting user did not have permission to equip the assets. */
  Forbidden = 'FORBIDDEN',
  /** One of the requested asset IDs was not valid. */
  InvalidAssetId = 'INVALID_ASSET_ID',
  /** Multiple assets were specified in a single asset type. */
  MultipleAssetsPerType = 'MULTIPLE_ASSETS_PER_TYPE',
  /** Some other unexpected error occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** EquipHeroAssetsInput contains the parameters to equip assets on a hero. */
export type EquipHeroAssetsInput = {
  /** The IDs of the assets to equip. */
  assetIDs: Array<Scalars['ID']>;
};

/** EquipHeroAssetsPayload is the response after equipping the assets on the hero. */
export type EquipHeroAssetsPayload = {
  __typename?: 'EquipHeroAssetsPayload';
  /**
   * The error that occured.
   * Null if the operation was successful.
   */
  error?: Maybe<EquipHeroAssetsError>;
  /** The hero after equipping - null if error. */
  hero?: Maybe<Hero>;
};

/** Drop triggered by an in-game event. */
export type EventBasedDrop = DropType & {
  __typename?: 'EventBasedDrop';
  /** The rewards for this drop and how often those rewards can be awarded. */
  benefitEdges?: Maybe<Array<DropBenefitEdge>>;
  /** The campaign this drop belongs to. */
  campaign: DropCampaign;
  /** Amount of time the viewer has to claim the drop after the rule is completed. */
  claimDurationSeconds: Scalars['Int'];
  /** The event conditions which must be met for this drop to be earned. */
  conditions: Array<DropEventCondition>;
  /** The time this drop becomes unavailable. */
  endAt: Scalars['Time'];
  /** A unique identifier. */
  id: Scalars['ID'];
  /** Describes how the event will be accomplished. */
  missionDescription: Scalars['String'];
  /** Name of the mission a streamer has to achieve. */
  missionName: Scalars['String'];
  /** The name of this drop. */
  name: Scalars['String'];
  /** The time this drop becomes available. */
  startAt: Scalars['Time'];
};

/** Settings for a given event. */
export type EventNotificationSetting = {
  __typename?: 'EventNotificationSetting';
  /** The setting category. */
  category: Scalars['String'];
  /** Settings for individual platforms. */
  platforms: Array<PlatformEventSetting>;
};

/**
 * Experimental properties that should NOT be used outside of experiments.
 * When your property is no longer in use, please mark as deprecated and then formally delete it.
 */
export type Experiment = {
  __typename?: 'Experiment';
  /** The selected promoted Stream for placement experiments. */
  promotedStream?: Maybe<Stream>;
};


/**
 * Experimental properties that should NOT be used outside of experiments.
 * When your property is no longer in use, please mark as deprecated and then formally delete it.
 */
export type ExperimentPromotedStreamArgs = {
  promoLocation: Scalars['Int'];
};

/** Data about an inactive subscription to a broadcaster. */
export type ExpiredSubscription = {
  __typename?: 'ExpiredSubscription';
  /** The channel that the expired subscription belongs to. */
  channelOwner?: Maybe<User>;
  /** The unique identifier. */
  id: Scalars['ID'];
  /** Resolves the product that the expired subscription is to. */
  product?: Maybe<SubscriptionProduct>;
  /** The total tenure of a user to a broadcaster. */
  tenure: SubscriptionTenure;
};

/** A paginated list of expired subscriptions. */
export type ExpiredSubscriptionConnection = {
  __typename?: 'ExpiredSubscriptionConnection';
  /** The list of expired subscriptions. */
  edges?: Maybe<Array<ExpiredSubscriptionEdge>>;
  /** Information about this page of expired subs. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of expired subscriptions. */
export type ExpiredSubscriptionEdge = {
  __typename?: 'ExpiredSubscriptionEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node?: Maybe<ExpiredSubscription>;
};

/** Input information for exporting a video to Youtube. */
export type ExportVideoToYoutubeInput = {
  /** The description of the exported video. */
  description?: InputMaybe<Scalars['String']>;
  /** Determines whether to split the video into smaller segments. */
  doSplit?: InputMaybe<Scalars['Boolean']>;
  /** Determines viewability of the video. */
  private?: InputMaybe<Scalars['Boolean']>;
  /** The tags of the exported video. */
  tags?: InputMaybe<Array<Scalars['String']>>;
  /** The title of the exported video. */
  title?: InputMaybe<Scalars['String']>;
  /** ID of the exported video. */
  videoID: Scalars['ID'];
};

/** Response to a request to export a video to Youtube. */
export type ExportVideoToYoutubePayload = {
  __typename?: 'ExportVideoToYoutubePayload';
  /** Video representing the exported video. */
  video?: Maybe<Video>;
};

/** Twitch Extension. */
export type Extension = {
  __typename?: 'Extension';
  /** The anchor point the extension expects to render into on the client. */
  anchor: ExtensionAnchor;
  /** A list of assets which the extension must have uploaded to the Twitch Extensions CDN. */
  assetURLs: Array<Scalars['String']>;
  /** The author of the extension as specified by the developer's extension manifest. */
  authorName: Scalars['String'];
  /** The bits support level required by the broadcaster for the extension to operate. */
  bitsSupportLevel: ExtensionBitsSupportLevel;
  /** The list of categories that the developer has set for the extension. */
  categories: Array<ExtensionCategory>;
  /** A single challenge condition associated with the specified extension. */
  challengeCondition?: Maybe<ChallengeCondition>;
  /** The list of challenge condition participants that are associated with this extension for a particular condition participant owner and condition owner. */
  challengeConditionParticipants?: Maybe<ExtensionChallengeConditionParticipantConnection>;
  /** The list of challenge conditions that are associated with this extension. */
  challengeConditions?: Maybe<ExtensionChallengeConditionConnection>;
  /** The client ID of the extension. Also used as the non-composite, non-unique ID of an extension internally. */
  clientID: Scalars['ID'];
  /**
   * The URL which is used to preset the configuration experience of the extension.
   * @deprecated configURL should be captured from the config ExtensionView: Extension.views.config.viewerURL
   */
  configURL: Scalars['String'];
  /** The list of games that an extension is content-matched to. This list is managed internally by Twitch. */
  contentMatchedGames?: Maybe<Array<Game>>;
  /**
   * The description of the extension specified by the developer's extension manifest
   * (max-length: 1024 characters).
   */
  description: Scalars['String'];
  /** The list of games that an extension is associated to. This list is managed by the extension developer. */
  games?: Maybe<Array<Game>>;
  /** Whether the extension developer has turned on chat support for this extension. */
  hasChatSupport: Scalars['Boolean'];
  /**
   * Represents whether or not the developer of the extension would like to provide users with
   * the ability to link their identity with the extension.
   */
  hasIdentityLinking: Scalars['Boolean'];
  /** The extension icon URLs used to visually represent the extension. */
  iconURLs: ExtensionIcons;
  /** The extension ID which is a composite form of <clientID>:<version>. */
  id: Scalars['ID'];
  /** Represents whether or not the extension supports bits monetization. */
  isBitsEnabled: Scalars['Boolean'];
  /**
   * The URL which is used to preset the live-dashboard experience of the extension.
   * @deprecated liveConfigURL should be captured from the liveConfig ExtensionView: Extension.views.liveConfig.viewerURL
   */
  liveConfigURL: Scalars['String'];
  /**
   * The name of the extension specified by the developer's extension manifest
   * (max-length: 40 characters).
   */
  name: Scalars['String'];
  /**
   * The panel height specified by the developer's extension manifest -or- 300.
   * @deprecated panelHeight should be captured from the panel ExtensionView: Extension.views.panel.height
   */
  panelHeight: Scalars['Int'];
  /** The link to the extension's privacy policy as specified by the developer's extension manifest. */
  privacyPolicyURL: Scalars['String'];
  /** Screenshots of the URL used to showcase the extension on extension details pages. */
  screenshotURLs: Array<Scalars['String']>;
  /** Represents whether the requesting user is able to install the extension. */
  self?: Maybe<ExtensionSelfConnection>;
  /** The sku of the extension for monetizable extensions. */
  sku: Scalars['String'];
  /** The current state of the extension in our approval process. */
  state: ExtensionState;
  /** The subscription support level required by the broadcaster for the extension to operate. */
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel;
  /**
   * The summary of the extension specified by the developer's extension manifest
   * (max-length: 140 characters).
   */
  summary: Scalars['String'];
  /** The support contact email as specified by the developer's extension manifest. */
  supportEmail: Scalars['String'];
  /** End-user license agreement terms of service URL. */
  termsURL: Scalars['String'];
  /** The vendor code of the extension for monetizable extensions. */
  vendorCode: Scalars['String'];
  /** The current version of the extension specified by the developer's extension manifest. */
  version: Scalars['String'];
  /**
   * The URL which is used to preset the viewer experience of the extension.
   * @deprecated viewerURL should be captured from the ExtensionView corresponding with the Extension's specified anchor
   */
  viewerURL: Scalars['String'];
  /** The UI configurations of each supported view of the extension. */
  views: ExtensionViews;
  /** The list of URLs an extension can link to while loaded in the configuration experience. */
  whitelistedConfigURLs: Array<Scalars['String']>;
  /** The list of URLs a panel extension can link to while loaded in the viewer experience. */
  whitelistedPanelURLs: Array<Scalars['String']>;
};


/** Twitch Extension. */
export type ExtensionChallengeConditionArgs = {
  input: ExtensionChallengeConditionByIdInput;
};


/** Twitch Extension. */
export type ExtensionChallengeConditionParticipantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  input: ExtensionChallengeConditionParticipantsInput;
};


/** Twitch Extension. */
export type ExtensionChallengeConditionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  input: ExtensionChallengeConditionsInput;
};

/** The current activation configuration for an installed extension. */
export type ExtensionActivationConfig = {
  __typename?: 'ExtensionActivationConfig';
  /**
   * The anchor that the installation has been activated into. If not activated into a slot,
   * the value will be null.
   */
  anchor?: Maybe<ExtensionAnchor>;
  /**
   * The slot that the installation has been activated into. If not activated into a slot,
   * the value will be null.
   */
  slot?: Maybe<Scalars['String']>;
  /** The activation state of the extension installation. */
  state: ActivationState;
  /**
   * The horizontal positioning of the left side of the component extension from the left side
   * of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
   */
  x?: Maybe<Scalars['Int']>;
  /**
   * The vertical positioning of the top side of the component extension from the top side
   * of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
   */
  y?: Maybe<Scalars['Int']>;
};

/**
 * Represents the action which should be taken on the provided installation ID. If no
 * anchor configuration is provided, the installation will be deactivated.
 */
export type ExtensionActivationInput = {
  /** The required activation input to apply activation state to a component anchor. */
  component?: InputMaybe<ComponentActivationInput>;
  /** The installation ID of the component extension you're attempting to activate. */
  installationID: Scalars['ID'];
  /** The required activation input to apply activation state to a panel anchor. */
  panel?: InputMaybe<PanelActivationInput>;
  /** The required activation input to apply activation state to a video overyla anchor. */
  videoOverlay?: InputMaybe<VideoOverlayActivationInput>;
};

/** The possible values for an Extension Anchor. */
export enum ExtensionAnchor {
  /** Component extension anchor. */
  Component = 'COMPONENT',
  /** Hidden extensions are used currently for load tests. */
  Hidden = 'HIDDEN',
  /** Panel extension anchor. */
  Panel = 'PANEL',
  /** Video overlay extension anchor. */
  VideoOverlay = 'VIDEO_OVERLAY'
}

/** ExtensionAssetManifest is data related to the assets of an extension. */
export type ExtensionAssetManifest = {
  __typename?: 'ExtensionAssetManifest';
  /** Hash of the asset zip file. */
  assetHash: Scalars['String'];
  /** Base URI used for extensions out of local test. */
  baseURI?: Maybe<Scalars['String']>;
  /** The name of the file that was uploaded. */
  fileName?: Maybe<Scalars['String']>;
  /** The size of the file that was uploaded. */
  fileSize?: Maybe<Scalars['String']>;
  /** The time that the assets were uploaded. */
  uploadedAt?: Maybe<Scalars['Time']>;
  /** The user that uploaded the assets. */
  uploader?: Maybe<User>;
};

/** ExtensionAssetManifestInput is data related to the assets of an extension. */
export type ExtensionAssetManifestInput = {
  /** Hash of the asset zip file. */
  assetHash: Scalars['String'];
};

/** The support levels for Bits features. */
export enum ExtensionBitsSupportLevel {
  /** This extension doesn't have any support for bit features. */
  None = 'NONE',
  /**
   * This extension has support for bit features but can operate in the event
   * the broadcaster disables the permissions.
   */
  Optional = 'OPTIONAL',
  /**
   * This extension requires support for bit features and cannot operate in the event
   * the broadcaster disables the permissions.
   */
  Required = 'REQUIRED'
}

/** ExtensionCapabilities contains data about what an Extension can do, in general, and at the time of interaction. */
export type ExtensionCapabilities = {
  __typename?: 'ExtensionCapabilities';
  /** The bit support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  bitsSupportLevel: ExtensionBitsSupportLevel;
  /** Location of configuration. */
  configurationLocation: ExtensionConfigurationLocation;
  /** Does this extension use bits. */
  hasBitsSupport: Scalars['Boolean'];
  /** Does this extension support chat. */
  hasChatSupport: Scalars['Boolean'];
  /** Required configuration string. */
  requiredConfiguration: Scalars['String'];
  /** The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel;
  /** Whitelists for restricting extension access and behavior. */
  whitelists?: Maybe<ExtensionWhitelists>;
  /** Will this extension request an identity link. */
  willRequestIdentityLink: Scalars['Boolean'];
};

/** ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction. */
export type ExtensionCapabilitiesInput = {
  /** The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  bitsSupportLevel?: InputMaybe<ExtensionBitsSupportLevel>;
  /** Location of configuration. */
  configurationLocation: ExtensionConfigurationLocation;
  /** Does this extension use bits. */
  hasBitsSupport: Scalars['Boolean'];
  /** Does this extension support chat. */
  hasChatSupport: Scalars['Boolean'];
  /** Required configuration string. */
  requiredConfiguration: Scalars['String'];
  /** The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  subscriptionsSupportLevel?: InputMaybe<ExtensionSubscriptionsSupportLevel>;
  /** Whitelists for restricting extension access and behavior. */
  whitelists: ExtensionWhitelistsInput;
  /** Will this extension request an identity link. */
  willRequestIdentityLink: Scalars['Boolean'];
};

/** An extension carousel. */
export type ExtensionCarousel = {
  __typename?: 'ExtensionCarousel';
  /** List of entries associated with the carousel. */
  entries: Array<ExtensionCarouselEntry>;
  /** Unique ID of the carousel. */
  id: Scalars['ID'];
};

/** An extension carousel entry. */
export type ExtensionCarouselEntry = {
  __typename?: 'ExtensionCarouselEntry';
  /** URL the user is directed to when clicking the carousel entry. */
  clickThroughURL: Scalars['String'];
  /** Unique ID of the entry. */
  id: Scalars['ID'];
  /** URL of the image to display for the carousel entry. */
  imageURL: Scalars['String'];
  /** Text associated with the carousel entry. */
  title: Scalars['String'];
};

/** An extension category. */
export type ExtensionCategory = {
  __typename?: 'ExtensionCategory';
  /** Description for what kind of extensions this category represents. */
  description: Scalars['String'];
  /** The paginated list of extensions in the category. */
  extensions?: Maybe<ExtensionConnection>;
  /** The category ID which is uniquely generated. */
  id: Scalars['ID'];
  /** Boolean value representing whether a category has been deleted. */
  isDeleted: Scalars['Boolean'];
  /** Denotes that no updates can be made to the category and no extensions can be added to it. */
  isReadOnly: Scalars['Boolean'];
  /** Boolean value representing whether this category should be hidden from listings. */
  isVisible: Scalars['Boolean'];
  /** Human readable name for the Category. */
  name: Scalars['String'];
  /** Display order for this category. Categories are returned in ascending order. */
  order: Scalars['Float'];
  /**
   * The URL-safe slug for the category. This slug may be used as the identifier to retrieve
   * categories from the root Query.
   */
  slug?: Maybe<Scalars['ID']>;
  /** Enumerated value specifying how this category's content should be ordered. Popularity, manual, etc. */
  sortKey: ExtensionCategorySortKey;
  /** Category Type which can be curated or developer. */
  type: ExtensionCategoryType;
};


/** An extension category. */
export type ExtensionCategoryExtensionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** A paginated list of extension categories, and their metadata. */
export type ExtensionCategoryConnection = {
  __typename?: 'ExtensionCategoryConnection';
  /** The list of extension categories in this page. */
  edges: Array<ExtensionCategoryEdge>;
  /** Information about this page of extension categories. */
  pageInfo: PageInfo;
  /** The total number of extension categories. */
  totalCount: Scalars['Int'];
};

/** An element in a paginated list of extension categories and its metadata. */
export type ExtensionCategoryEdge = {
  __typename?: 'ExtensionCategoryEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension category for the current edge. */
  node: ExtensionCategory;
};

/** Enumeration of the different sort keys to sort extensions within a category. */
export enum ExtensionCategorySortKey {
  /** Manual sort key refers to an arbitrary sorting of extensions. */
  Manual = 'MANUAL',
  /** Popularity sort key refers to sorting of extensions by popularity. */
  Popularity = 'POPULARITY',
  /** Time sort key refers to sorting of extensions from newest to latest. */
  Time = 'TIME'
}

/** Enumeration of the different category types that are currently supported. */
export enum ExtensionCategoryType {
  /** Curated Category Type is Twitch controlled. */
  Curated = 'CURATED',
  /** Developer Category Type is developer controlled. */
  Developer = 'DEVELOPER',
  /**
   * Pseudo Categories are categories whose extensions are generated. Slugs are required
   * on pseudo categories and are often the best way to retrieve them. Example pseudo categories
   * and slugs include "new-releases" and "whitelisted".
   */
  Pseudo = 'PSEUDO'
}

/** Parameters for filtering ChallengeConditionParticipants. */
export type ExtensionChallengeConditionByIdInput = {
  /** The ID of the condition for the specified owner. */
  conditionID: Scalars['ID'];
  /** TUID of condition participant's associated condition's owner. */
  conditionOwnerID: Scalars['ID'];
};

/** A paginated list of extension challenge conditions. */
export type ExtensionChallengeConditionConnection = {
  __typename?: 'ExtensionChallengeConditionConnection';
  /** The elements of the paginated list. */
  edges: Array<ExtensionChallengeConditionEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of extension challenge conditions. */
export type ExtensionChallengeConditionEdge = {
  __typename?: 'ExtensionChallengeConditionEdge';
  /** An opaque cursor identifying the edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node: ChallengeCondition;
};

/** A paginated list of extension challenge conditionParticipants. */
export type ExtensionChallengeConditionParticipantConnection = {
  __typename?: 'ExtensionChallengeConditionParticipantConnection';
  /** The elements of the paginated list. */
  edges: Array<ExtensionChallengeConditionParticipantEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of extension challenge conditionParticipants. */
export type ExtensionChallengeConditionParticipantEdge = {
  __typename?: 'ExtensionChallengeConditionParticipantEdge';
  /** An opaque cursor identifying the edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node: ChallengeConditionParticipant;
};

/** Parameters for filtering ChallengeConditionParticipants. */
export type ExtensionChallengeConditionParticipantsInput = {
  /** TUID of condition participant's associated condition's owner. */
  conditionOwnerID: Scalars['ID'];
  /** TUID of condition participant owner. */
  conditionParticipantOwnerID: Scalars['ID'];
  /** Filter condition participants with this state. */
  endState: ChallengeConditionParticipantEndState;
};

/** Parameters for filtering ChallengeConditions. */
export type ExtensionChallengeConditionsInput = {
  /** TUID of condition owner. This will typically be the broadcaster's user ID. */
  conditionOwnerID: Scalars['ID'];
  /** Filter conditions with this state. */
  state: ChallengeConditionState;
};

/** ExtensionClient is the authorization component of an extension. */
export type ExtensionClient = {
  __typename?: 'ExtensionClient';
  /** A organization member assigned as a billing manager for this extension. Null when extension is not an organization or the extension is not monetized. */
  assignedBillingManager?: Maybe<OrganizationMember>;
  /** CreatedAt is the timestamp at which this client was created. */
  createdAt: Scalars['Time'];
  /** ID is the OAuth ID representing the extension. */
  id: Scalars['ID'];
  /** Name is the name of the extension. */
  name: Scalars['String'];
  /** Organization is the Organization entity of the extension, it means which organization the extension belongs to. */
  organization?: Maybe<Organization>;
  /** RedirectURI is the URI used for client redirect on OAuth login. */
  redirectURI: Scalars['String'];
};

/** A paginated list of extension clients. */
export type ExtensionClientConnection = {
  __typename?: 'ExtensionClientConnection';
  /** The list of extension clients in this page. */
  edges: Array<ExtensionClientEdge>;
  /** Information about this page of extension clients. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of extension clients. */
export type ExtensionClientEdge = {
  __typename?: 'ExtensionClientEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension client for the current edge. */
  node: ExtensionClient;
};

/** ExtensionComment contains the data for the comment of an extension review. */
export type ExtensionComment = {
  __typename?: 'ExtensionComment';
  /** The review comment text provided by the user. */
  content: Scalars['String'];
  /** The ID of the recorded comment. */
  id: Scalars['ID'];
};

/** The hosted configuration for an extension that comes from config service. */
export type ExtensionConfiguration = {
  __typename?: 'ExtensionConfiguration';
  /** The broadcaster-set, per-channel segment of the extension configuration. */
  broadcaster?: Maybe<ExtensionConfigurationRecord>;
  /** The developer-set, per-channel segment of the extension configuration. */
  developer?: Maybe<ExtensionConfigurationRecord>;
  /** The id of the extension that this configuration document belongs to. */
  extensionID: Scalars['ID'];
  /**
   * The developer-set segment of the extension configuration that affects all
   * installs of the extension.
   */
  global?: Maybe<ExtensionConfigurationRecord>;
};

/** Possible locations for Extension Configuration to be hosted. */
export enum ExtensionConfigurationLocation {
  /** Custom/Own service hosted configuration. */
  Custom = 'CUSTOM',
  /** Configuration hosted by Twitch using Extensions Configuration service. */
  Hosted = 'HOSTED',
  /** Configuration not required for activation of this extension. */
  None = 'NONE'
}

/** A single segment from the extensions configuration service. */
export type ExtensionConfigurationRecord = {
  __typename?: 'ExtensionConfigurationRecord';
  /** The content of the configuration segment. */
  content: Scalars['String'];
  /** The version of the configuration segment. */
  version: Scalars['String'];
};

/** A paginated list of extensions, and its metadata. */
export type ExtensionConnection = {
  __typename?: 'ExtensionConnection';
  /** The list of extensions in this page. */
  edges: Array<ExtensionEdge>;
  /** Information about this page of extensions. */
  pageInfo: PageInfo;
  /** The total number of extensions in the larger collection. */
  totalCount: Scalars['Int'];
};

/** ExtensionDeveloperManifest is the developer specific extension data. */
export type ExtensionDeveloperManifest = {
  __typename?: 'ExtensionDeveloperManifest';
  /** Author email. */
  authorEmail: Scalars['String'];
  /** Time when an extension was created. */
  createdAt: Scalars['String'];
  /** Time when an extensions version was last transitioned. */
  lastTransitionedAt?: Maybe<Scalars['Time']>;
  /** Testing uri for extension development. */
  testingBaseURI: Scalars['String'];
  /** Current state of this version in the development timeline. */
  versionState: ExtensionState;
};

/** ExtensionDeveloperManifestInput is the developer specific extension data. */
export type ExtensionDeveloperManifestInput = {
  /** Author email. */
  authorEmail: Scalars['String'];
  /** Testing uri for extension development. */
  testingBaseURI: Scalars['String'];
};

/** Extension metadata used for discovery. */
export type ExtensionDiscoveryManifest = {
  __typename?: 'ExtensionDiscoveryManifest';
  /** Name of the extension author. */
  authorName: Scalars['String'];
  /** Extension categories. */
  categories: Array<ExtensionCategory>;
  /** Games that an extension is content-matched to. This list is managed internally by Twitch. */
  contentMatchedGames?: Maybe<Array<Game>>;
  /** Extension descriprion. 1024 character limit. */
  description: Scalars['String'];
  /** Games that an extension is associated to. This list is managed by the extension developer. */
  games: Array<Game>;
  /** Icon urls for extensions. */
  iconURLs?: Maybe<ExtensionIcons>;
  /** name of the extension. */
  name: Scalars['String'];
  /** Url to an extensions privacy policy. */
  privacyPolicyURL: Scalars['String'];
  /** Extension screenshot urls. */
  screenshotURLs: Array<Scalars['String']>;
  /** Extension summary. 140 character limit. */
  summary: Scalars['String'];
  /** Extension developers support email. */
  supportEmail: Scalars['String'];
  /** Extension eula/tos url. */
  termsURL: Scalars['String'];
  /** Extension viewer summary. */
  viewerSummary: Scalars['String'];
};

/** Extension metadata used for discovery. */
export type ExtensionDiscoveryManifestInput = {
  /** Name of the extension author. */
  authorName: Scalars['String'];
  /** Extension categories. */
  categories: Array<Scalars['ID']>;
  /** Extension descriprion. 1024 character limit. */
  description: Scalars['String'];
  /** games an extension is associated with. */
  games: Array<Scalars['ID']>;
  /** name of the extension. */
  name: Scalars['String'];
  /** Url to an extensions privacy policy. */
  privacyPolicyURL: Scalars['String'];
  /** Extension summary. 140 character limit. */
  summary: Scalars['String'];
  /** Extension developers support email. */
  supportEmail: Scalars['String'];
  /** Extension eula/tos url. */
  termsURL: Scalars['String'];
  /** A summary of the extension's functionality from a viewer's perspective. */
  viewerSummary?: InputMaybe<Scalars['String']>;
};

/** ExtensionDynamicManagementInput represents the game ID and whether it is dynamically managed or not on an extension. */
export type ExtensionDynamicManagementInput = {
  /** The discovery game ID. */
  gameID: Scalars['ID'];
  /** If the game has been marked as dynamically managed or not. */
  isManaged: Scalars['Boolean'];
};

/** An element in a paginated extensions of videos, and its metadata. */
export type ExtensionEdge = {
  __typename?: 'ExtensionEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension for the current edge. */
  node: Extension;
};

/** The complete set of potential icons provided by a developer to represent their Extension on the site. */
export type ExtensionIcons = {
  __typename?: 'ExtensionIcons';
  /** 300x200 splash image used in extension discovery & management. */
  discoverySplash: Scalars['String'];
  /** Square 24x24 icon used in video player taskbar. */
  square24: Scalars['String'];
  /** Square 100x100 icon used in extension discovery & management. */
  square100: Scalars['String'];
};

/** Url and UploadId provided by Upload Service. */
export type ExtensionImageUploadResponse = {
  __typename?: 'ExtensionImageUploadResponse';
  /** Upload ID. */
  uploadID: Scalars['ID'];
  /** Upload URL. */
  url: Scalars['String'];
};

/** Extension Installation are models which contain an Extension and it's associated installation metadata. */
export type ExtensionInstallation = {
  __typename?: 'ExtensionInstallation';
  /** The abilities this extension can use for the channel it is installed on. */
  abilities: ExtensionInstallationAbilities;
  /** The current activation metadata for the extension. */
  activationConfig: ExtensionActivationConfig;
  /** The extension which the installation record is for. */
  extension: Extension;
  /** The the composite extension installation ID in the form of <clientID>:<version>:<channelID>. */
  id: Scalars['ID'];
  /** The installer's decision whether to allow an extension to use a particular feature. */
  permittedFeatures: ExtensionInstallationFeatureFlags;
  /** The required, if any, for the installed extension after an activation. */
  requiredActions?: Maybe<Array<ExtensionRequiredAction>>;
  /** The self connection of the extension installation. */
  self?: Maybe<ExtensionInstallationSelfConnection>;
};

/** The set of abilities an extension is authorized to use. */
export type ExtensionInstallationAbilities = {
  __typename?: 'ExtensionInstallationAbilities';
  /** Whether the extension can use bits in the current context. */
  isBitsEnabled: Scalars['Boolean'];
  /** Whether the extension can send chat messages in the current context. */
  isChatEnabled: Scalars['Boolean'];
  /** Whether the extension has access to subscription status in the current context. */
  isSubscriptionStatusAvailable: Scalars['Boolean'];
};

/** The dynamic management setting for a content-matched game on an extension installation. */
export type ExtensionInstallationDynamicManagement = {
  __typename?: 'ExtensionInstallationDynamicManagement';
  /** The game that the setting is for. */
  game?: Maybe<Game>;
  /** Whether or not dynamic management is turned on for this extensions. */
  isManaged: Scalars['Boolean'];
};

/** The set of extension features an installer can opt in or out of. */
export type ExtensionInstallationFeatureFlags = {
  __typename?: 'ExtensionInstallationFeatureFlags';
  /** Whether the installer has granted the extension access to their subscriptions list. */
  canRetrieveSubscriptionStatus: Scalars['Boolean'];
  /** Whether the installer has opted in or out of chat capabilities in extensions. */
  canSendChat: Scalars['Boolean'];
  /** Whether the installer has opted in or out of bit capabilities in extensions. */
  canUseBits: Scalars['Boolean'];
  /** The dynamic management settings for the extension installation. */
  dynamicManagement?: Maybe<Array<ExtensionInstallationDynamicManagement>>;
};

/** The connection a user has to an Installed Extension. */
export type ExtensionInstallationSelfConnection = {
  __typename?: 'ExtensionInstallationSelfConnection';
  /** Represents whether the requesting user can activate the extension. */
  canActivate: Scalars['Boolean'];
};

/**
 * The data that links the active user with a particular extension
 * installation on a channel.
 */
export type ExtensionInstallationSelfEdge = {
  __typename?: 'ExtensionInstallationSelfEdge';
  /** Configurations set for this extension/user pair. */
  configuration?: Maybe<ExtensionConfiguration>;
  /** The extension installation. */
  installation?: Maybe<ExtensionInstallation>;
  /**
   * The time this response was issuedAt, so the client can set a timer for when
   * the token needs to be refreshed.
   */
  issuedAt?: Maybe<Scalars['Time']>;
  /** Authentication information that links the active user and the installation. */
  token?: Maybe<ExtensionToken>;
};

/** Extension Link User Error. */
export type ExtensionLinkUserError = {
  __typename?: 'ExtensionLinkUserError';
  /** The error code. */
  code?: Maybe<ExtensionLinkUserErrorCode>;
};

/** Extension Link User Error Code. */
export enum ExtensionLinkUserErrorCode {
  /** The request body was invalid. */
  BadRequest = 'BAD_REQUEST',
  /** The current user is not authorized to link / unlink this extension. */
  Unauthorized = 'UNAUTHORIZED',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/** The required input for an ExtensionLinkUser mutation. */
export type ExtensionLinkUserInput = {
  /** The id of the channel the extension is currently installed on. */
  channelID: Scalars['ID'];
  /** The ID of the extension that the user would like to link/unlink with. */
  extensionID: Scalars['ID'];
  /** The current extension jwt for the user being linked/unlinked. */
  jwt?: InputMaybe<Scalars['String']>;
  /** Whether to link or unlink the user from this extension. */
  showUser: Scalars['Boolean'];
};

/** The result of a ExtensionLinkUser mutation. */
export type ExtensionLinkUserPayload = {
  __typename?: 'ExtensionLinkUserPayload';
  /** Error from an Extension Link User Call. */
  error?: Maybe<ExtensionLinkUserError>;
  /** The user's new token reflecting their now linked/unlinked status. */
  token?: Maybe<ExtensionToken>;
};

/** ExtensionManifest is the data that represents an entire extension manfiest. */
export type ExtensionManifest = {
  __typename?: 'ExtensionManifest';
  /** ExtensionAssetManifest is data related to the assets of an extension. */
  assetManifest: ExtensionAssetManifest;
  /** Data about what an Extension can do, in general, and at the time of interaction. */
  capabilities: ExtensionCapabilities;
  /** ExtensionDeveloperManifest is the developer specific extension data. */
  developerManifest: ExtensionDeveloperManifest;
  /** Extension metadata used for discovery. */
  discoveryManifest: ExtensionDiscoveryManifest;
  /** Extension id. */
  id: Scalars['ID'];
  /** Extension version. */
  version: Scalars['String'];
  /** Extension views. */
  views: ExtensionViews;
};

/** A paginated list of extension manifests. */
export type ExtensionManifestConnection = {
  __typename?: 'ExtensionManifestConnection';
  /** The list of extension manifests in this page. */
  edges: Array<ExtensionManifestEdge>;
  /** Information about this page of extension manifests. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of extension manifests. */
export type ExtensionManifestEdge = {
  __typename?: 'ExtensionManifestEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension manifest for the current edge. */
  node?: Maybe<ExtensionManifest>;
};

/** A summary of extension state and the associated manifests. */
export type ExtensionManifestsSummary = {
  __typename?: 'ExtensionManifestsSummary';
  /** The global deleted state of the extension. */
  isDeleted: Scalars['Boolean'];
  /** The list of extension manifests. */
  manifests?: Maybe<ExtensionManifestConnection>;
};

/** ExtensionPanel is a placeholder in the panel list for arbitrary iframed content. */
export type ExtensionPanel = Panel & {
  __typename?: 'ExtensionPanel';
  /** id is a unique identifier for the panel. */
  id: Scalars['ID'];
  /** slotID is an identifier to map extensions content from `User.extensions` to the proper place in the `User.panels` list. */
  slotID: Scalars['ID'];
  /** type is `PanelType.EXTENSION`. */
  type: PanelType;
};

/** ExtensionRating contains the information of a user's rating of a Twitch extension. */
export type ExtensionRating = {
  __typename?: 'ExtensionRating';
  /** The ID of the recorded rating. */
  id: Scalars['ID'];
  /** Whether the user recommended the extension or not. */
  isRecommended: Scalars['Boolean'];
  /** Where the user submitted the rating. */
  location: ExtensionRatingLocation;
};

/** Enumerates where the user can submit an extension rating. */
export enum ExtensionRatingLocation {
  /** The global notifications popout. */
  Notification = 'NOTIFICATION'
}

/** A holder for the presigned S3 URL for an extension ratings report. */
export type ExtensionRatingsCsvReportPresignedUrl = {
  __typename?: 'ExtensionRatingsCSVReportPresignedURL';
  /** The presigned URL, if one is ready.  Otherwise empty string. */
  presignedURL?: Maybe<Scalars['String']>;
};

/** Extension recommendation. */
export type ExtensionRecommendation = {
  __typename?: 'ExtensionRecommendation';
  /** The recommended extension. */
  extension?: Maybe<Extension>;
};

/** The action a user must take to complete an activation of an extension installation. */
export type ExtensionRequiredAction = {
  __typename?: 'ExtensionRequiredAction';
  /**
   * On PROMPT_FOR_PERMISSIONS the redirectURI to load for OAuth.
   * @deprecated PROMPT_FOR_PERMISSIONS is no longer a valid required action
   */
  redirectURI?: Maybe<Scalars['String']>;
  /** The action the user must take in order to complete the activation. */
  type: ExtensionRequiredActionType;
};

/** The possible types of required actions after attempting to activate an extension. */
export enum ExtensionRequiredActionType {
  /** The user must accept the permissions in order to complete the activation. */
  PromptForPermissions = 'PROMPT_FOR_PERMISSIONS',
  /** The user must configure the extension in order to complete the activation. */
  RequiresConfiguration = 'REQUIRES_CONFIGURATION'
}

/** The shared secret between the extension and the extension validator service. */
export type ExtensionSecret = {
  __typename?: 'ExtensionSecret';
  /** When the secret was activated. */
  activeAt: Scalars['Time'];
  /** The actual content of the secret. */
  content: Scalars['String'];
  /** When the secret expires. */
  expiresAt: Scalars['Time'];
};

/** The extensions secrets information. */
export type ExtensionSecretsInfo = {
  __typename?: 'ExtensionSecretsInfo';
  /** A user-friendly error, should one occur. */
  error?: Maybe<GetExtensionSecretsError>;
  /** A list of secrets. */
  secrets?: Maybe<Array<ExtensionSecret>>;
};

/** The connection a user has to an Extension object. */
export type ExtensionSelfConnection = {
  __typename?: 'ExtensionSelfConnection';
  /** Represents whether the requesting user is able to install extensions. */
  canInstall: Scalars['Boolean'];
};

/** The possible values for ExtensionState. */
export enum ExtensionState {
  /** APPROVED extensions are ready to be released, at the developer's convenience. */
  Approved = 'APPROVED',
  /**
   * ASSETS_UPLOADED extensions have had their assets uploaded already to S3. This state mirrors
   * the existing READY_FOR_REVIEW state, but doesn't incur an implicit upload.
   */
  AssetsUploaded = 'ASSETS_UPLOADED',
  /** DELETED extensions have been deleted; this is a soft delete so we can undelete things. */
  Deleted = 'DELETED',
  /** DEPRECATED extensions were once released, but a newer version now exists. */
  Deprecated = 'DEPRECATED',
  /** IN_REVIEW extensions are being looked at by Twitch. */
  InReview = 'IN_REVIEW',
  /** IN_TEST extensions are currently being worked on by a developer. */
  InTest = 'IN_TEST',
  /** PENDING_ACTION extensions are ones that were reviewed by Twitch and returned to the developer for fixing. */
  PendingAction = 'PENDING_ACTION',
  /**
   * READY_FOR_REVIEW extensions are currently being examined by a developer for their readiness
   * to be reviewed (assets hosted on CDN).
   */
  ReadyForReview = 'READY_FOR_REVIEW',
  /** REJECTED extensions are permanently rejected; no action by the  developer will make them acceptable. */
  Rejected = 'REJECTED',
  /**
   * RELEASED extensions are currently available to users.  Only one version of an extension
   * can be in this state at any time.
   */
  Released = 'RELEASED',
  /** UPLOADING extensions are in the process of having their assets loaded onto S3. */
  Uploading = 'UPLOADING'
}

/** ExtensionStateFilter contains all the valid states to filter the list of extensions by. */
export enum ExtensionStateFilter {
  /** Released extension. */
  Released = 'RELEASED'
}

/** The support levels for subscriptions features. */
export enum ExtensionSubscriptionsSupportLevel {
  /** This extension doesn't have any support for subscriptions features. */
  None = 'NONE',
  /**
   * This extension has support for subscriptions features but can operate in the event
   * the broadcaster disables the permissions.
   */
  Optional = 'OPTIONAL'
}

/** The user-specific token for an installed extension on a channel. */
export type ExtensionToken = {
  __typename?: 'ExtensionToken';
  /** The ID of the extension associated with this token. */
  extensionID: Scalars['ID'];
  /** The JWT token for the requesting user. */
  jwt: Scalars['String'];
};

/** ExtensionVersionDiscoveryManifest is the data that represents an extension discovery manifest. */
export type ExtensionVersionDiscoveryManifest = {
  __typename?: 'ExtensionVersionDiscoveryManifest';
  /** Extension metadata used for discovery. */
  discoveryManifest: ExtensionDiscoveryManifest;
  /** Extension id. */
  id: Scalars['ID'];
  /** Extension version. */
  version: Scalars['String'];
};

/** ExtensionView is the interface which every anchor-specific extension view extends from. */
export type ExtensionView = {
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** The potential anchor-specific configurations and extension can have. */
export type ExtensionViews = {
  __typename?: 'ExtensionViews';
  /** The developer configuration of the extension as a component extension, if supported. */
  component?: Maybe<ComponentView>;
  /** The developer configuration of the extension's configuration view, if supported. */
  config?: Maybe<ConfigView>;
  /** The configuration for a hidden extension. The only hidden extension is used for load testing. */
  hidden?: Maybe<HiddenView>;
  /** The developer configuration of the extension's live configuration dashboard view, if supported. */
  liveConfig?: Maybe<LiveConfigView>;
  /** The developer configuration of the extension as a mobile extension, if supported. */
  mobile?: Maybe<MobileView>;
  /** The developer configuration of the extension as a panel extension, if supported. */
  panel?: Maybe<PanelView>;
  /** The developer configuration of the extension as a video overlay extension, if supported. */
  videoOverlay?: Maybe<VideoOverlayView>;
};

/** The potential anchor-specific configurations and extension can have. */
export type ExtensionViewsInput = {
  /** The developer configuration of the extension as a component extension, if supported. */
  component?: InputMaybe<ComponentViewInput>;
  /** The developer configuration of the extension's configuration view, if supported. */
  config?: InputMaybe<ConfigViewInput>;
  /** The developer configuration of the extension's live configuration dashboard view, if supported. */
  liveConfig?: InputMaybe<LiveConfigViewInput>;
  /** The developer configuration of the extension as a mobile extension, if supported. */
  mobile?: InputMaybe<MobileViewInput>;
  /** The developer configuration of the extension as a panel extension, if supported. */
  panel?: InputMaybe<PanelViewInput>;
  /** The developer configuration of the extension as a video overlay extension, if supported. */
  videoOverlay?: InputMaybe<VideoOverlayViewInput>;
};

/** Whitelists for restricting extension access and behavior. */
export type ExtensionWhitelists = {
  __typename?: 'ExtensionWhitelists';
  /**
   * List of broadcaster account IDs allowed to install an extension after release.
   * If this is empty or missing, all broadcasters can use this extension.
   */
  broadcasters: Array<Scalars['ID']>;
  /** URLs which are permitted to be opened from the configuration dialog. */
  configURLs: Array<Scalars['String']>;
  /** URLs which are permitted to be opened from an extension set as a panel. */
  panelURLs: Array<Scalars['String']>;
  /**
   * List of account IDs which should have access to a version of an extension.
   * Users in this list are ignored by the broadcaster whitelist check.
   */
  testers: Array<Scalars['ID']>;
};

/** ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior. */
export type ExtensionWhitelistsInput = {
  /**
   * List of broadcaster account IDs allowed to install an extension after release.
   * If this is empty or missing, all broadcasters can use this extension.
   */
  broadcasters: Array<Scalars['ID']>;
  /** URLs which are permitted to be opened from the configuration dialog. */
  configURLs: Array<Scalars['String']>;
  /** URLs which are permitted to be opened from an extension set as a panel. */
  panelURLs: Array<Scalars['String']>;
  /**
   * List of account IDs which should have access to a version of an extension.
   * Users in this list are ignored by the broadcaster whitelist check.
   */
  testers: Array<Scalars['ID']>;
};

/** Url and UploadId provided by Upload Service. */
export type ExtensionZipUploadResponse = {
  __typename?: 'ExtensionZipUploadResponse';
  /** Upload ID. */
  uploadID: Scalars['ID'];
  /** Upload URL. */
  url: Scalars['String'];
};

/** ExternalChargeModel defines a 3P managed SKU for a given offer. */
export type ExternalChargeModel = {
  __typename?: 'ExternalChargeModel';
  /** Externally managed default/static SKU identifier. This is specifically for discovery and preview flows. Use `self -> checkoutSKU` for purchase flows. */
  previewSKU: Scalars['String'];
  /** The provider for this externally managed SKU. */
  provider: Scalars['String'];
  /** The authenticated user's relationship with the external charge model. */
  self?: Maybe<ExternalChargeModelSelfEdge>;
  /**
   * Externally managed default/static SKU identifier. For mobile checkouts, use `self` for dynamically vended SKU for the user.
   * @deprecated Use 'previewSKU' instead
   */
  sku: Scalars['String'];
};

/** The authenticated user's relationship with the internal charge model. */
export type ExternalChargeModelSelfEdge = {
  __typename?: 'ExternalChargeModelSelfEdge';
  /** The final checkout SKU of this offer available for the authenticated user. */
  checkoutSKU: Scalars['String'];
};

export type FeatureFlags = {
  __typename?: 'FeatureFlags';
  /** @deprecated Enabled for everyone. */
  isPulseEnabled?: Maybe<Scalars['Boolean']>;
};

/** FeaturedContentSections contain the a set of FeaturedItems that should be shown together in a particular section of Twitch apps. */
export type FeaturedContentSection = {
  __typename?: 'FeaturedContentSection';
  /** A combination of the type and style for a given section, i.e. spotlight-previews. */
  id: Scalars['ID'];
  items?: Maybe<Array<FeaturedItem>>;
};

export type FeaturedItem = {
  __typename?: 'FeaturedItem';
  /** The featured item's content. */
  content?: Maybe<FeaturedItemContent>;
  /** An markdown description of the item, available when a item is featured. */
  description: Scalars['String'];
  /** ID used for tracking interactions. */
  id: Scalars['ID'];
  /** A URL for a special thumbnail image, when this item is featured. */
  imageURL: Scalars['String'];
  /** Is this item featured because it is scheduled? */
  isScheduled: Scalars['Boolean'];
  /** Is this item featured because it is sponsored? */
  isSponsored: Scalars['Boolean'];
  /** A lower priority level means the item is higher priority. */
  priorityLevel: Scalars['Int'];
  /** When featured, the title of the item. */
  title: Scalars['String'];
};

export type FeaturedItemContent = Stream | User | Video;

/** FeaturedStream contains extra metadata for presenting a featured Stream. */
export type FeaturedStream = {
  __typename?: 'FeaturedStream';
  /** The featured stream's broadcaster. */
  broadcaster?: Maybe<User>;
  /**
   * The featured channel.
   * @deprecated Use featuredStream.broadcaster instead.
   */
  channel?: Maybe<Channel>;
  /** A markdown description of the stream, available when a stream is featured. */
  description?: Maybe<Scalars['String']>;
  /**
   * An HTML description of the stream, available when a stream is featured.
   * @deprecated Use featuredStream.description instead
   */
  descriptionHTML?: Maybe<Scalars['String']>;
  /** A URL for a special thumbnail image, when this stream is featured. */
  imageURL?: Maybe<Scalars['String']>;
  /** Is this stream featured because it is scheduled? */
  isScheduled?: Maybe<Scalars['Boolean']>;
  /** Is this stream featured because it is sponsored? */
  isSponsored?: Maybe<Scalars['Boolean']>;
  /** A lower priority level means the stream is higher priority. */
  priorityLevel?: Maybe<Scalars['Int']>;
  /** The featured live steam. */
  stream?: Maybe<Stream>;
  /** When featured, the title of the stream. */
  title?: Maybe<Scalars['String']>;
};

/**
 * DEPRECATED: do not use, it is subject to change.
 * FeaturedVideo contains extra metadata for presenting a featured video.
 */
export type FeaturedVideo = {
  __typename?: 'FeaturedVideo';
  /** An markdown description of the video, available when a video is featured. */
  description: Scalars['String'];
  /** A URL for a special thumbnail image, when this video is featured. */
  imageURL: Scalars['String'];
  /** Is this video featured because it is scheduled? */
  isScheduled: Scalars['Boolean'];
  /** Is this video featured because it is sponsored? */
  isSponsored: Scalars['Boolean'];
  /** A lower priority level means the stream is higher priority. */
  priorityLevel: Scalars['Int'];
  /** When featured, the title of the video. */
  title: Scalars['String'];
  /** The featured video. */
  video?: Maybe<Video>;
};

/** Feed is twitch's pulse product of content a user may enjoy. */
export type Feed = {
  __typename?: 'Feed';
  id: Scalars['ID'];
  items?: Maybe<FeedItemConnection>;
};


/** Feed is twitch's pulse product of content a user may enjoy. */
export type FeedItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** FeedEmbed describes the types of items contained in a Feed. */
export type FeedEmbed = Clip | LinkOEmbed | PhotoOEmbed | RichOEmbed | Video | VideoOEmbed;

/**
 * FeedItem is the units of a feed.
 * They do not have an identifier because you cannot look them up by identifier.
 */
export type FeedItem = {
  __typename?: 'FeedItem';
  content?: Maybe<FeedItemContent>;
  reasons?: Maybe<Array<Maybe<FeedItemReason>>>;
  tracking?: Maybe<FeedItemTracking>;
};

export type FeedItemConnection = {
  __typename?: 'FeedItemConnection';
  edges?: Maybe<Array<Maybe<FeedItemEdge>>>;
  pageInfo?: Maybe<PageInfo>;
};

/** FeedItemContent is the supported content types that may appear in a feed. */
export type FeedItemContent = Clip | Post | Share | Stream | Video;

export type FeedItemEdge = {
  __typename?: 'FeedItemEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<FeedItem>;
};

/** FeedItemReason explains why an item is in your feed. */
export type FeedItemReason = {
  __typename?: 'FeedItemReason';
  reason?: Maybe<Scalars['String']>;
};

/** FeedItemTracking contains the tracking info of a feeditem. */
export type FeedItemTracking = {
  __typename?: 'FeedItemTracking';
  batchID?: Maybe<Scalars['String']>;
  cardImpressionID?: Maybe<Scalars['String']>;
  recGenerationID?: Maybe<Scalars['String']>;
  recGenerationIndex?: Maybe<Scalars['Int']>;
};

/** FinalizeCompetitionLobbyInput contains the inputs required to change a lobby's status to done. */
export type FinalizeCompetitionLobbyInput = {
  /** The competition id of the competition. */
  competitionID: Scalars['ID'];
  /** The lobbyID of the competition that we want to mark done. */
  lobbyID: Scalars['ID'];
  /** The phase id of the competition that this lobby belongs to. */
  phaseID: Scalars['ID'];
};

/** FinalizeCompetitionLobbyPayload is the success response for updating a lobby to done. */
export type FinalizeCompetitionLobbyPayload = {
  __typename?: 'FinalizeCompetitionLobbyPayload';
  /** The new state of competition after marking the lobby as done. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Settings specific to the first cheer tutorial. */
export type FirstCheerTutorial = {
  __typename?: 'FirstCheerTutorial';
  /** Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience. */
  hasAbandoned?: Maybe<Scalars['Boolean']>;
  /** Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button. */
  hasSkipped?: Maybe<Scalars['Boolean']>;
};

/** Information about the flagged track of copyrighted music. */
export type FlaggedTrack = {
  __typename?: 'FlaggedTrack';
  /** Title of the album of the flagged track. */
  albumTitle: Scalars['String'];
  /** The appeal for track's usage. */
  appeal?: Maybe<FlaggedTrackAppeal>;
  /** ID of the flagged track. */
  id: Scalars['ID'];
  /**
   * Duration in seconds of the mute. Standard length is 360 (6 mins).
   * This can be null if the flagged track was succesfully appealed.
   */
  muteDurationSeconds?: Maybe<Scalars['Int']>;
  /**
   * Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted.
   * This can be null if the flagged track was succesfully appealed.
   */
  muteOffsetSeconds?: Maybe<Scalars['Int']>;
  /** Performer of the flagged track. */
  performer: Scalars['String'];
  /** Title of the flagged track. */
  title: Scalars['String'];
};

/** The appeal information associated with the flagged track. */
export type FlaggedTrackAppeal = {
  __typename?: 'FlaggedTrackAppeal';
  /** ID of the track appeal. */
  id: Scalars['ID'];
  /** Reason for the track appeal. */
  reason: Scalars['String'];
  /** Status of the track appeal, ie. PENDING, RESOLVED, UNKNOWN. */
  status: FlaggedTrackAppealStatus;
};

/** The status of the track appeal. */
export enum FlaggedTrackAppealStatus {
  /** The track appeal has not yet been resolved. */
  Pending = 'PENDING',
  /** The track appeal has a resolved at time. */
  Resolved = 'RESOLVED'
}

/** Data about the relationship between one User and a User they are following. */
export type Follow = {
  __typename?: 'Follow';
  /** Whether to disable notifications for this relationship. */
  disableNotifications?: Maybe<Scalars['Boolean']>;
  /** Represents when this relationship was established. */
  followedAt?: Maybe<Scalars['Time']>;
  /** The user who is followed. */
  user?: Maybe<User>;
};

/** A paginated list of follows relationships. */
export type FollowConnection = {
  __typename?: 'FollowConnection';
  /** The elements of the paginated list. */
  edges?: Maybe<Array<Maybe<FollowEdge>>>;
  /** Information about this page. */
  pageInfo?: Maybe<PageInfo>;
  /** The total number of followers. */
  totalCount?: Maybe<Scalars['Int']>;
};

/**
 * An element in a paginated list of follows relationships.
 * Contains metadata about the follow relationship between two users.
 */
export type FollowEdge = {
  __typename?: 'FollowEdge';
  /** An opaque cursor identifying the edge's position in the paginted list. */
  cursor: Scalars['Cursor'];
  /**
   * Whether to disable notifications for this relationship.
   * @deprecated use notificationSettings.isEnabled instead.
   */
  disableNotifications?: Maybe<Scalars['Boolean']>;
  /** Represents when this relationship was established. */
  followedAt?: Maybe<Scalars['Time']>;
  /** The user who is followed. */
  node?: Maybe<User>;
  /** Notification settings for this relationship. */
  notificationSettings?: Maybe<ChannelNotificationSettings>;
};

export type FollowGameInput = {
  /** The identifier of the game to follow. */
  gameID: Scalars['ID'];
};

export type FollowGamePayload = {
  __typename?: 'FollowGamePayload';
  /** The game that was followed if the operation was successful. */
  game?: Maybe<Game>;
};

/** Information to communicate to the user about an error state. */
export type FollowUserError = {
  __typename?: 'FollowUserError';
  /** Error code. */
  code: FollowUserErrorCode;
};

/** Enum for follow errors. */
export enum FollowUserErrorCode {
  /** Used when fromUser is being blocked by targetUser. */
  Forbidden = 'FORBIDDEN',
  /** Used when user has reached their follow cap. */
  TooManyFollows = 'TOO_MANY_FOLLOWS'
}

export type FollowUserInput = {
  /**
   * disableNotifications, when true, prevents the followed user's stream from sending email and push notifications to
   * the authenticated user when it goes live.
   */
  disableNotifications: Scalars['Boolean'];
  targetID: Scalars['ID'];
};

export type FollowUserPayload = {
  __typename?: 'FollowUserPayload';
  /** Used for user blocked errors. */
  error?: Maybe<FollowUserError>;
  /** The new follow relationship. */
  follow?: Maybe<Follow>;
};

/** A list of followed games. */
export type FollowedGameConnection = {
  __typename?: 'FollowedGameConnection';
  /** The elements of the paginated list. */
  nodes?: Maybe<Array<Game>>;
};

export enum FollowedGamesType {
  /** All followed games. */
  All = 'ALL',
  /** Only games which are currently being streamed will be returned. */
  Live = 'LIVE'
}

/** A list of broadcasters followed by a user and hosting live broadcasters. */
export type FollowedHostConnection = {
  __typename?: 'FollowedHostConnection';
  /** The broadcasters. */
  nodes?: Maybe<Array<Maybe<User>>>;
};

/** A list of live-streaming broadcasters followed by a user. */
export type FollowedLiveUserConnection = {
  __typename?: 'FollowedLiveUserConnection';
  /** The live broadcasters. */
  edges: Array<Maybe<FollowedLiveUserEdge>>;
  /**
   * The live broadcasters.
   * @deprecated Use FollowedLiveUserConnection.edges instead for pagination support
   */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Pagination. */
  pageInfo: PageInfo;
};

/** A live streaming broadcaster with cursor. */
export type FollowedLiveUserEdge = {
  __typename?: 'FollowedLiveUserEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<User>;
};

/** A paginated list of followers relationships. */
export type FollowerConnection = {
  __typename?: 'FollowerConnection';
  /** The elements of the paginated list. */
  edges?: Maybe<Array<Maybe<FollowerEdge>>>;
  /** Metadata about this page. */
  pageInfo?: Maybe<PageInfo>;
  /** The total number of followers. */
  totalCount?: Maybe<Scalars['Int']>;
};

/**
 * An element in a paginated list of followers.
 * Contains metadata about the follower relationship between two users.
 */
export type FollowerEdge = {
  __typename?: 'FollowerEdge';
  /** An opaque cursor identifying the edge's position in the paginted list. */
  cursor: Scalars['Cursor'];
  /** Whether to disable notifications for this relationship. */
  disableNotifications?: Maybe<Scalars['Boolean']>;
  /** Represents when this relationship was established. */
  followedAt?: Maybe<Scalars['Time']>;
  /** The user who is a follower. */
  node?: Maybe<User>;
  /** Notification settings for this relationship. */
  notificationSettings?: Maybe<ChannelNotificationSettings>;
};

export enum FollowsFilter {
  /** All users the user is following. */
  All = 'ALL',
  /**
   * Users the user is following to which the user can subscribe.
   * this is authenticated so only a logged in user can filter by SUBBABLE.
   */
  Subbable = 'SUBBABLE'
}

/** The format type signifies the format the competition will run from. */
export enum FormatType {
  /** Custom format. */
  Custom = 'CUSTOM',
  /** Double elimination bracket format. */
  DoubleElim = 'DOUBLE_ELIM',
  /** Leaderboard format. */
  Leaderboard = 'LEADERBOARD',
  /** Round robin format. */
  RoundRobin = 'ROUND_ROBIN',
  /** Single elimination bracket format. */
  SingleElim = 'SINGLE_ELIM',
  /** Unknown format. */
  Unknown = 'UNKNOWN'
}

/** The details of different formats. Currently there is only 1 detail type. */
export type FormatTypeDetails = LeaderboardDetails;

/**
 * FragmentContent contains the parse content of a fragment, and can be an emote or a mention.
 * NOTE: should have been called RoomMessageFragmentContent.
 */
export type FragmentContent = AutoMod | CheermoteToken | Emote | RoomMessageGroupMention | User;

/** A list of a user's friend relationships. */
export type FriendConnection = {
  __typename?: 'FriendConnection';
  /** The friend elements of this list. */
  edges?: Maybe<Array<Maybe<FriendEdge>>>;
  /** The total number of friends this user has. */
  totalCount: Scalars['Int'];
};

/** The friendship between the authenticated user and another user. */
export type FriendEdge = {
  __typename?: 'FriendEdge';
  /** An action that a user or session is performing. */
  activity?: Maybe<Activity>;
  /** The computed state of a user or session. */
  availability: Availability;
  /** The last time the friend's availability or activity changed. */
  lastStatusChangeAt?: Maybe<Scalars['Time']>;
  /** The friend user. */
  node?: Maybe<User>;
};

/**
 * The friend-type relationship between the authenticated user and another user.
 *
 * If this field is a FriendEdge, the authenticated user and the other user are Friends.
 *
 * If it is an IncomingFriendRequestEdge, the other user has an open friend request with authenticated user.
 *
 * If it is an OutgoingFriendRequestEdge, the authenticated user has an open friend request with the other user.
 */
export type FriendRelationship = FriendEdge | IncomingFriendRequestEdge | OutgoingFriendRequestEdge;

/** Decides how to sort Friendship-related responses. */
export enum FriendSort {
  /** Sort from oldest to newest. */
  Asc = 'ASC',
  /** Sort from newest to oldest. */
  Desc = 'DESC'
}

/** GDPR Consent contains user consent on different tracking vendors. */
export type GdprConsent = {
  /** Whether Amazon has user GDPR consent. */
  allowAmazon?: InputMaybe<Scalars['Boolean']>;
  /** Whether Comscore has user GDPR consent. */
  allowComscore?: InputMaybe<Scalars['Boolean']>;
  /** Whether Google has user GDPR consent. */
  allowGoogle?: InputMaybe<Scalars['Boolean']>;
  /** Whether Nielson has user GDPR consent. */
  allowNielsen?: InputMaybe<Scalars['Boolean']>;
  /** Whether Salesforce has user GDPR consent. */
  allowSalesforce?: InputMaybe<Scalars['Boolean']>;
};

/** GDPR cookie vendors either support TCF Strings or dont, hence two types of GDPR Vendors. */
export type GdprCookieVendor = NonTcfCookieVendor | TcfCookieVendor;

/** List of GDPR cookie vendors. */
export type GdprVendorConsent = {
  __typename?: 'GDPRVendorConsent';
  /** status for vendors. */
  status: Array<GdprCookieVendor>;
};

/** A Game is often the subject of a Stream on Twitch. */
export type Game = Directory & {
  __typename?: 'Game';
  /**
   * What campaigns are active for this game.
   * @deprecated Functionality not supported in Drops 2.0
   */
  activeDropCampaigns?: Maybe<Array<DropCampaign>>;
  /**
   * URL to an avatar image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  avatarURL?: Maybe<Scalars['String']>;
  /**
   * URL to a box art image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  boxArtURL?: Maybe<Scalars['String']>;
  /** Number of broadcasters streaming this game. */
  broadcastersCount?: Maybe<Scalars['Int']>;
  /**
   * Number of channels currently streaming this game.
   * @deprecated Use broadcastersCount instead.
   */
  channelsCount?: Maybe<Scalars['Int']>;
  /**
   * A paginated list of clips featuring this game, ordered by view count descending.
   * When criteria is not specified, the default values are used.
   */
  clips?: Maybe<ClipConnection>;
  /**
   * URL to a cover image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  coverURL?: Maybe<Scalars['String']>;
  /** The game's description. */
  description?: Maybe<Scalars['String']>;
  /** The game's developers. */
  developers?: Maybe<Array<Scalars['String']>>;
  /** The type of directory – in this case, always GAME. */
  directoryType?: Maybe<DirectoryType>;
  /**
   * The translated game name used for display purposes.
   * Use name for tracking props or URLs.
   */
  displayName: Scalars['String'];
  /**
   * The associated clientID for a game used to determine if users have an account link
   * created between tuid and in-game userID as well as the timestamp of when this link was created.
   */
  dropAccountLink?: Maybe<DropAccountLink>;
  /**
   * A list of clients that use the Enhanced Experiences (E2) API for
   * Twitch integrations with this game.
   */
  enhancedExperiencesClients?: Maybe<Array<EnhancedExperiencesClient>>;
  /** The game's ESRB descriptions. */
  esrbDescriptions?: Maybe<Array<Scalars['String']>>;
  /** The game's ESRB rating. */
  esrbRating: EsrbRating;
  /** A list of extension recommendations, according to the game. */
  extensionRecommendations?: Maybe<Array<ExtensionRecommendation>>;
  /** Number of users that follow this game. */
  followersCount?: Maybe<Scalars['Int']>;
  /** The franchises the game belongs to. */
  franchises?: Maybe<Array<Scalars['String']>>;
  /**
   * The game's unique GiantBomb identifier.
   * @deprecated No longer supported
   */
  giantBombID?: Maybe<Scalars['ID']>;
  /**
   * The game's unique Twitch identifier.
   * It is used to associate games with product offers.
   */
  id: Scalars['ID'];
  /**
   * URL to a game logo image.
   * The image dimensions are specifiable via the `height` and `width` parameters.
   *
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  logoURL?: Maybe<Scalars['String']>;
  /**
   * The name of the game. This string is untranslated.
   * This field should only be used in limited occassions, like tracking and URLs.
   * You should use displayName for all all game names shown to the users.
   */
  name: Scalars['String'];
  /** The original release date of the game. Date string is formatted as yyyy-mm-ddThh:mm:ssZ. */
  originalReleaseDate?: Maybe<Scalars['String']>;
  /** The platforms the game is on. */
  platforms?: Maybe<Array<Scalars['String']>>;
  /** A measure of the games popularity. */
  popularityScore?: Maybe<Scalars['Int']>;
  /** The game's unique Presto identifier. */
  prestoID?: Maybe<Scalars['ID']>;
  /** The game's publishers. */
  publishers?: Maybe<Array<Scalars['String']>>;
  /** The authenticated user's relationship with this Game. */
  self?: Maybe<GameSelfConnection>;
  /**
   * Get a page of live streams broadcasting this game.
   * The languages param can be used to filter the streams. Otherwise all languages will be returned.
   * The filters param contains additional metadata filters, for example {hearthstoneGameMode: "arena"}.
   * The sort param can be used to change the default sorting, which sometimes is specific to specific games.
   * The tags param are an array of tag ID as optional filters for streams.
   * DEPRECATED field arguments: languages, requestID, sort, tags
   * Use GameStreamOptions instead.
   */
  streams?: Maybe<StreamConnection>;
  /** List of recommeded tags in the corresponding category. */
  tags?: Maybe<Array<Tag>>;
  /** A paginated list of top videos for this game. */
  videos?: Maybe<VideoConnection>;
  /** Number of viewers currently watching a stream which features this game. */
  viewersCount?: Maybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameAvatarUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameBoxArtUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameClipsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria?: InputMaybe<GameClipsInput>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameCoverUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameEnhancedExperiencesClientsArgs = {
  organizationID: Scalars['ID'];
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameLogoUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameStreamsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  filters?: InputMaybe<StreamMetadataFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  languages?: InputMaybe<Array<Scalars['String']>>;
  options?: InputMaybe<GameStreamOptions>;
  requestID?: InputMaybe<Scalars['ID']>;
  sort?: InputMaybe<StreamSort>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameTagsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  tagType: TagType;
};


/** A Game is often the subject of a Stream on Twitch. */
export type GameVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  languages?: InputMaybe<Array<Scalars['String']>>;
  sort?: InputMaybe<VideoSort>;
  types?: InputMaybe<Array<BroadcastType>>;
};

/** GameApplication is an application to associate a game with an organization. */
export type GameApplication = {
  __typename?: 'GameApplication';
  /** Creation time. */
  createdAt: Scalars['Time'];
  /** Game that is added in the application. */
  game: Game;
  /** ID of the game application, stored in RBAC. */
  id: Scalars['ID'];
  /** Organization that is going to be associated with the game. */
  organization: Organization;
};

/** Moment Details specific to a game change. */
export type GameChangeMomentDetails = {
  __typename?: 'GameChangeMomentDetails';
  /** The game that the user changed to. */
  game?: Maybe<Game>;
};

/** Filtering criteria for paginated game clips results. */
export type GameClipsInput = {
  /** The ID of the broadcaster to filter results by. */
  broadcasterID?: InputMaybe<Scalars['ID']>;
  /** The ID of the curator to filter results by. */
  curatorID?: InputMaybe<Scalars['ID']>;
  /** Overrides the period. if startAt is provided, but endAt isn't, the endAt value will be the day when the query was made. */
  endAt?: InputMaybe<Scalars['Time']>;
  /**
   * DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
   * A filter which restricts results.
   */
  filter?: InputMaybe<ClipsFilter>;
  /**
   * Clip results will be filtered by this language.
   * Omit this input field to get results by all languages.
   */
  languages?: InputMaybe<Array<Language>>;
  /** The time period to restrict clips based on creation time. */
  period?: InputMaybe<ClipsPeriod>;
  /** The sort order for the clips results. */
  sort?: InputMaybe<ClipsSort>;
  /** Overrides the period param. If endAt is provided, but startAt isn't, 2015-01-01 will be used for it. */
  startAt?: InputMaybe<Scalars['Time']>;
};

/**
 * Paginated list of Games.
 * Implements the Relay cursor connections specification.
 * See: https://facebook.github.io/relay/graphql/connections.htm.
 */
export type GameConnection = {
  __typename?: 'GameConnection';
  /** The list of games to display. */
  edges?: Maybe<Array<GameEdge>>;
  pageInfo: PageInfo;
};

/**
 * Contains information about a Game's relationship to a given page (connection),
 * and the Game itself.
 */
export type GameEdge = {
  __typename?: 'GameEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<Game>;
  /** Unique id per game response item, used by clients to attribute displays/clicks to items. */
  trackingID?: Maybe<Scalars['ID']>;
};

/** Game followed by a User. */
export type GameFollow = {
  __typename?: 'GameFollow';
  /** Represents when this relationship was established. */
  followedAt: Scalars['Time'];
  /** The game that is followed. */
  game?: Maybe<Game>;
  /** The user who is following. */
  user?: Maybe<User>;
};

/**
 * Optional input to filter categories.
 * Add any additional optional fields to this input.
 */
export type GameOptions = {
  /** The locale of the user. */
  locale?: InputMaybe<Scalars['String']>;
  /** If sorted by relevance, this provides additional context used to influence recommendations. */
  recommendationsContext?: InputMaybe<RecommendationsContext>;
  /** A GUID that is created by the caller for tracking. This should be globally unique per request and is required if sort=RELEVANCE. */
  requestID?: InputMaybe<Scalars['ID']>;
  /** The sort param can be used to change the default sorting of results. */
  sort?: InputMaybe<GameSort>;
  /** Tags are an array of tag IDs as optional filters for categories. */
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** Game that my viewers also like to watch. */
export type GameOverlap = {
  __typename?: 'GameOverlap';
  /** How much my viewers like to watch this game. */
  score: Scalars['Float'];
  /** Game that my viewers also like to watch. */
  viewersAlsoWatch?: Maybe<Game>;
};

/** The relationship between the authenticated user and a game. */
export type GameSelfConnection = {
  __typename?: 'GameSelfConnection';
  /** The current user's follow relationship with this game. */
  follow?: Maybe<GameFollow>;
  /**
   * Whether or not the current user has a link to this game that can be used
   * for Drops.
   */
  isDropsLinked?: Maybe<Scalars['Boolean']>;
};

/** Possible ways of sorting collections of categories. */
export enum GameSort {
  /** Sort by relevance to the current user. */
  Relevance = 'RELEVANCE',
  /** Sort by number of concurrent viewers, descending (most viewers first). */
  ViewerCount = 'VIEWER_COUNT'
}

/**
 * Optional input to filter game specific streams.
 * add additional optional fields to this input.
 */
export type GameStreamOptions = {
  /** Filter streams based on restriction types. */
  includeRestricted?: InputMaybe<Array<StreamRestrictionType>>;
  /**
   * Broadcaster languages to filter streams by.
   * Deprecated: use language tags instead.
   */
  languages?: InputMaybe<Array<Scalars['String']>>;
  /** The locale of the user. */
  locale?: InputMaybe<Scalars['String']>;
  /** If sorted by relevance, this provides additional context used to influence recommendations. */
  recommendationsContext?: InputMaybe<RecommendationsContext>;
  /** RequestID must be specified if sort=RELEVANCE. */
  requestID?: InputMaybe<Scalars['ID']>;
  /** The sort param can be used to change the default sorting, which sometimes is specific to specific games. */
  sort?: InputMaybe<StreamSort>;
  /** The tags param are an array of tag ID as optional filters for streams. */
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** Input to the animateEmote mutation. */
export type GenerateAnimatedEmoteInput = {
  /** The ID for the input image. Must be the 4x size. */
  image4xID: Scalars['ID'];
  /** The preset animation to apply on the provided static emote. */
  preset: AnimatedEmotePreset;
};

/** Payload from the animateEmote mutation. */
export type GenerateAnimatedEmotePayload = {
  __typename?: 'GenerateAnimatedEmotePayload';
  /** The animated emote assets. */
  animatedAssets?: Maybe<Array<AnimatedImageAsset>>;
  /** The ID of the generate request. Pubsub messages will contain this ID to match up the message with the generate request. */
  id?: Maybe<Scalars['ID']>;
};

/**
 * GenerateExtensionRatingsCSVInput takes an extensionID and some time range info for generating a CSV of extension ratings
 * data for an extension developer.
 * Authenticated on UserID via oauth token and OWL (via the ExtensionRatings backend).
 */
export type GenerateExtensionRatingsCsvReportInput = {
  /** endAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD. */
  endAt: Scalars['Time'];
  /** extensionID to generate a CSV of ratings data for. */
  extensionID: Scalars['ID'];
  /** startAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD. */
  startAt: Scalars['Time'];
};

/**
 * GenerateExtensionRatingsCSVPayload returns the filename that the CSV report will have when it is completed, and gives
 * the caller something to poll for.
 */
export type GenerateExtensionRatingsCsvReportPayload = {
  __typename?: 'GenerateExtensionRatingsCSVReportPayload';
  /** reportFilename is the filename for the generated report. */
  reportFilename?: Maybe<Scalars['String']>;
};

/** Error returned during a invalid user request. */
export type GenerateSecondFactorQrCodeError = {
  __typename?: 'GenerateSecondFactorQRCodeError';
  /** Error code returned by the backend. */
  code: GenerateSecondFactorQrCodeErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to generate a second factor QR code. */
export enum GenerateSecondFactorQrCodeErrorCode {
  /** The user does not have two factor enabled and cannot generate a QR code. */
  NoTwoFactor = 'NO_TWO_FACTOR',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** The user has requested too many second factor QR codes. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR',
  /** The user does not exist. */
  UserNotFound = 'USER_NOT_FOUND'
}

/** The required input for a generateSecondFactorQRCode mutation. */
export type GenerateSecondFactorQrCodeInput = {
  /** The ID of the user that is requesting a new second factor QR code. */
  userID: Scalars['ID'];
};

/** The result of a generateSecondFactorQRCode mutation. */
export type GenerateSecondFactorQrCodePayload = {
  __typename?: 'GenerateSecondFactorQRCodePayload';
  /** error code and localized error. */
  error?: Maybe<GenerateSecondFactorQrCodeError>;
  /** qrCode will be a base64 encoded png file. */
  qrCode?: Maybe<Scalars['String']>;
};

/**
 * GenerateSubscribersCSVInput takes a channelID to generate a CSV of subscribers for.
 * Authenticated on channelID.
 */
export type GenerateSubscribersCsvInput = {
  /** channelID to generate a CSV of subscribers for. */
  channelID: Scalars['String'];
};

/**
 * GenerateSubscribersCSVPayload returns the channelID it currently generating
 * a CSV for.
 */
export type GenerateSubscribersCsvPayload = {
  __typename?: 'GenerateSubscribersCSVPayload';
  /** channelID that a subscribers CSV is being generated for. */
  channelID: Scalars['ID'];
};

/** The input for getting upload config. */
export type GetEmoteUploadConfigInput = {
  /** The type of asset to be uploaded. */
  assetType?: InputMaybe<EmoteAssetType>;
  /** If the asset type is "animated", whether to generate the static versions from the first frame. */
  generateStaticVersionOfAnimatedAssets?: InputMaybe<Scalars['Boolean']>;
  /** Resizing plan to use. */
  resizePlan: EmoteResizePlan;
  /** Sizes to provide upload URLs for. */
  sizes?: InputMaybe<Array<EmoteImageSize>>;
};

/** Response payload. */
export type GetEmoteUploadConfigPayload = {
  __typename?: 'GetEmoteUploadConfigPayload';
  /**
   * Upload config for resizing/original.
   * @deprecated Use uploadConfigs instead.
   */
  uploadConfig?: Maybe<UploadConfig>;
  /**
   * Upload config for 1x image resouce.
   * @deprecated Use uploadConfigs instead.
   */
  uploadConfig1x?: Maybe<UploadConfig>;
  /**
   * Upload config for 2x image resource.
   * @deprecated Use uploadConfigs instead.
   */
  uploadConfig2x?: Maybe<UploadConfig>;
  /**
   * Upload config for 4x image resource.
   * @deprecated Use uploadConfigs instead.
   */
  uploadConfig4x?: Maybe<UploadConfig>;
  /** Upload configs for all sizes and asset types. */
  uploadConfigs?: Maybe<Array<UploadConfig>>;
};

/** An error describing why the issue happened, when relevant. */
export enum GetExtensionSecretsError {
  /** Something went wrong on our side that we need to fix. */
  Internal = 'INTERNAL',
  /** User has indicated an invalid extension id. */
  InvalidClient = 'INVALID_CLIENT',
  /** User is unable to read the extension secrets. */
  Unauthorized = 'UNAUTHORIZED'
}

/** GiftCardCode that can be claimed to add a monetary balance to a user's account. */
export type GiftCardCode = Claimable & {
  __typename?: 'GiftCardCode';
  /** A description of what is claimable for the code. */
  description: Scalars['String'];
  /** The ID of the Gift Card code. */
  id: Scalars['ID'];
  /** The field that gives us claim information for the logged in user. */
  self?: Maybe<SelfClaimEdge>;
  /** The type is `ClaimableType.GIFT_CARD_CODE`. */
  type: ClaimableType;
};

/** User edge relating the pin's status to the user. */
export type GiftCardCodeSelfClaimEdge = SelfClaimEdge & {
  __typename?: 'GiftCardCodeSelfClaimEdge';
  /** If the user is eligible to claim the key code. */
  canClaim: Scalars['Boolean'];
  /** Nullable field for the country where the user redeemed the claimable. */
  countryOfResidence?: Maybe<Scalars['String']>;
  /** The user ID that is claiming the code. */
  id: Scalars['ID'];
  /** Nullable status code for if the user cannot claim the key code. */
  statusCode?: Maybe<Scalars['String']>;
};

/** Types of a gift offer. */
export enum GiftType {
  /** A community gift type. */
  Community = 'COMMUNITY',
  /** A single recipient gift type. */
  SingleRecipient = 'SINGLE_RECIPIENT'
}

/** GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available. */
export type GlobalCheerConfig = {
  __typename?: 'GlobalCheerConfig';
  /**
   * The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
   * This includes things like the possible sizes, colors, backgrounds, and display order.
   */
  displayConfig: CheermoteDisplayConfig;
  /** The Cheermote Groups containing the Global Cheermotes. */
  groups: Array<CheermoteGroup>;
};

/** Analytics associated with a given notification. */
export type GoLiveNotification = {
  __typename?: 'GoLiveNotification';
  /** Custom notification text, e.g., "Summit1g playing Hearthstone today". */
  customText: Scalars['String'];
  /** Number of followers that engaged with the notification. */
  engagements: Scalars['Int'];
  /** Number of followers at the time the notification was sent. */
  followerCount: Scalars['Int'];
  /** Number of followers that were sent the notification. */
  followersNotified: Scalars['Int'];
  /** Time that the associated stream went live. */
  streamStartTime: Scalars['Time'];
};

/** GoLiveNotificationConnection represents GoLiveNotification edges and page metadata. */
export type GoLiveNotificationConnection = {
  __typename?: 'GoLiveNotificationConnection';
  /** Each GoLiveNotificationEdge contains the GoLiveNotification node and cursor data. */
  edges: Array<GoLiveNotificationEdge>;
  /** Page metadata includes hasNextPage/hasPreviousPage. */
  pageInfo: PageInfo;
};

/** GoLiveNotificationEdges are returned by a given GoLiveNotificationConnection. */
export type GoLiveNotificationEdge = {
  __typename?: 'GoLiveNotificationEdge';
  /** A GoLiveNotification cursor is represented by an exclusive stream start time. */
  cursor: Scalars['Cursor'];
  /** The actual GoLiveNotification payload associated with a given edge. */
  node?: Maybe<GoLiveNotification>;
};

/** Analytics associated with go live notification timeseries. */
export type GoLiveNotificationTimeseries = {
  __typename?: 'GoLiveNotificationTimeseries';
  /** Grouping of notification timeseries items with timestamp and engagements. */
  items?: Maybe<Array<GoLiveNotificationTimeseriesItem>>;
  /** Sum of all notification engagements for a given date range. */
  total: Scalars['Int'];
};

/** Single go live notification timeseries item. Represents day, or week/monthly aggregation. */
export type GoLiveNotificationTimeseriesItem = {
  __typename?: 'GoLiveNotificationTimeseriesItem';
  /** Number of engagements for a single set of go live notifications. */
  engagements: Scalars['Int'];
  /** First timestamp for a single set of go live notifications. */
  timestamp: Scalars['Time'];
};

/** GoRaidError is the error associated with a goRaid. */
export type GoRaidError = {
  __typename?: 'GoRaidError';
  /** The associated error code. */
  code: GoRaidErrorCode;
};

/** GoRaidErrorCode are the possible errors that this mutation returns. */
export enum GoRaidErrorCode {
  /** The request is missing valid channel parameters. */
  InvalidChannel = 'INVALID_CHANNEL',
  /** The user tries to unraid without an active raid. */
  NoActiveRaid = 'NO_ACTIVE_RAID'
}

/** Inputs to the goRaid mutation. */
export type GoRaidInput = {
  /** Source ID. */
  sourceID: Scalars['ID'];
};

/** Outputs from the goRaid mutation. */
export type GoRaidPayload = {
  __typename?: 'GoRaidPayload';
  /** The possible error returned from the service. */
  error?: Maybe<GoRaidError>;
  /** The raid then just went. */
  raid?: Maybe<Raid>;
};

/** Set based on the auth input type. */
export enum GrantType {
  /** Used for the initial flow after LWA, one-time usage. */
  AuthorizationCode = 'AUTHORIZATION_CODE',
  /** Used for follow up refreshes, can be used as many times as needed. */
  RefreshToken = 'REFRESH_TOKEN'
}

/** GrantVIPError contains details about a client error that occurred. */
export type GrantVipError = {
  __typename?: 'GrantVIPError';
  /** The type of error that occurred when granting VIP status. */
  code: GrantVipErrorCode;
};

/** GrantVIPErrorCode defines a client error that occurred while granting the VIP status. */
export enum GrantVipErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The granter does not have permission to grant VIP status in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The user who is to be granted the VIP status actually already has the VIP status. */
  GranteeAlreadyVip = 'GRANTEE_ALREADY_VIP',
  /** The user who is to be granted the VIP status is banned or timed out in this channel. */
  GranteeChatBanned = 'GRANTEE_CHAT_BANNED',
  /** The user who is to be granted the VIP status does not exist. */
  GranteeNotFound = 'GRANTEE_NOT_FOUND',
  /** The channel has reached the maximum number of users with the VIP status and cannot grant the status to any more users. */
  MaxVipsReached = 'MAX_VIPS_REACHED',
  /** The channel has not completed the VIP Achievement to unlock the VIP feature. */
  VipAchievementIncomplete = 'VIP_ACHIEVEMENT_INCOMPLETE'
}

/** GrantVIPInput contains the parameters to grant the VIP status to a user for a channel. */
export type GrantVipInput = {
  /** The channel for which the VIP status of a user will be granted. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user who will be granted the VIP status.
   * Either granteeID or granteeLogin must be provided.
   */
  granteeID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user who will be granted the VIP status.
   * Either granteeID or granteeLogin must be provided.
   */
  granteeLogin?: InputMaybe<Scalars['String']>;
};

/** GrantVIPPayload is the response after attemping to grant the VIP status to a user. */
export type GrantVipPayload = {
  __typename?: 'GrantVIPPayload';
  /** The channel for which the VIP status of the user was granted. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<GrantVipError>;
  /** The user who was granted the VIP status. */
  grantee?: Maybe<User>;
};

/** Different types of granularities supported. */
export enum Granularity {
  /** Bucketed by day intervals. */
  Day = 'DAY',
  /** Bucketed by five minute intervals. */
  FiveMinute = 'FIVE_MINUTE',
  /** Bucketed by forty minute intervals. */
  FortyMinute = 'FORTY_MINUTE',
  /** Bucketed by month intervals. */
  Month = 'MONTH',
  /** Bucketed by twenty minute intervals. */
  TwentyMinute = 'TWENTY_MINUTE',
  /** Bucketed by week intervals. */
  Week = 'WEEK'
}

/** The hearthstone game mode that was played. */
export type HearthsoneMomentGameMode = {
  __typename?: 'HearthsoneMomentGameMode';
  /** The game type (e.g. Ranked, Casual, Arena, Pack Opening, etc.). */
  type: Scalars['String'];
  /** The value for the game type (e.g. 0-11 for Arena, Priest vs Warlock for Ranked). */
  value?: Maybe<Scalars['String']>;
};

/** Moment Details specific to the hearthstone game. */
export type HearthstoneMomentDetails = {
  __typename?: 'HearthstoneMomentDetails';
  /** The broadcasters hero, can be null. */
  broadcasterHero?: Maybe<HearthstoneMomentHero>;
  /** The game mode that was played, can be null. */
  gameMode?: Maybe<HearthsoneMomentGameMode>;
  /** The oponents hero, can be null. */
  opponentHero?: Maybe<HearthstoneMomentHero>;
};

/** The hero that either the broadcaster or opponent played. */
export type HearthstoneMomentHero = {
  __typename?: 'HearthstoneMomentHero';
  /** The hero's (capitalized) class. */
  class: Scalars['String'];
  /** The hero's id. */
  id: Scalars['ID'];
  /** The hero's (capitalized) name. */
  name: Scalars['String'];
};

/** Represents the user's Hero. */
export type Hero = {
  __typename?: 'Hero';
  /** A unique ID for this hero. */
  id: Scalars['ID'];
  /** The URI to the pre-composited, full-resolution hero image. */
  imageURI: Scalars['String'];
  /** The configuration of that hero, to be used by the editor. */
  self?: Maybe<HeroConfiguration>;
};

/** Representation of a Hero asset. */
export type HeroAsset = {
  __typename?: 'HeroAsset';
  /** User colorization of the asset, if any. */
  color?: Maybe<Scalars['String']>;
  /** URI to the asset's color mask image. */
  colorMaskURI?: Maybe<Scalars['String']>;
  /** When does this asset expire. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Is this asset new to the requesting user. */
  isNew?: Maybe<Scalars['Boolean']>;
  /** URI to the asset's line art image. */
  lineArtURI?: Maybe<Scalars['String']>;
  /** What skeletons does this asset function properly on.  A NULL entry here indicates that the asset will function on all skeletons. */
  supportedSkeletons?: Maybe<Array<HeroSkeleton>>;
  /** The type of the asset. */
  type: HeroAssetType;
};

/** Represents the position of an asset relative to a skeleton. */
export type HeroAssetPosition = {
  __typename?: 'HeroAssetPosition';
  /** Which type of asset this position refers to. */
  assetType: HeroAssetType;
  /** x coordinate of the position. */
  x: Scalars['Int'];
  /** y coordinate of the position. */
  y: Scalars['Int'];
};

/** The complete list of asset types. */
export enum HeroAssetType {
  /** Background asset. */
  Background = 'BACKGROUND',
  /** Eyebrow asset. */
  Eyebrows = 'EYEBROWS',
  /** Eye asset. */
  Eyes = 'EYES',
  /** Facial hair asset. */
  FacialHair = 'FACIAL_HAIR',
  /** Freckles asset. */
  Freckles = 'FRECKLES',
  /** Glasses asset. */
  Glasses = 'GLASSES',
  /** Gloves asset. */
  Gloves = 'GLOVES',
  /** Hair asset. */
  Hair = 'HAIR',
  /** Hat asset. */
  Hat = 'HAT',
  /** Jacket asset. */
  Jacket = 'JACKET',
  /** Mouth asset. */
  Mouth = 'MOUTH',
  /** Nose asset. */
  Nose = 'NOSE',
  /** Pants asset. */
  Pants = 'PANTS',
  /** Shoes asset. */
  Shoes = 'SHOES',
  /** Socks asset. */
  Socks = 'SOCKS',
  /** Undershirt asset. */
  Undershirt = 'UNDERSHIRT'
}

/** Represents the user's Hero configuration. */
export type HeroConfiguration = {
  __typename?: 'HeroConfiguration';
  /** What assets the user has equipped. */
  assets?: Maybe<Array<HeroAsset>>;
  /** Which skeleton the user employed. */
  skeleton?: Maybe<HeroSkeleton>;
  /** What color was applied to that skeleton. */
  skeletonColor?: Maybe<Scalars['String']>;
};

/** The hero preset. */
export enum HeroPreset {
  /** The first preset. */
  Preset_1 = 'PRESET_1',
  /** The second preset. */
  Preset_2 = 'PRESET_2'
}

/** Represents a Hero skeleton. */
export type HeroSkeleton = {
  __typename?: 'HeroSkeleton';
  /** List of x,y offsets for the assets to be properly composited on this skeleton. */
  assetPositions: Array<HeroAssetPosition>;
  /** URI to the color mask for the skeleton. */
  colorMaskURI: Scalars['String'];
  /** The UUID for this skeleton. */
  id: Scalars['ID'];
  /** URI to the line art for the skeleton. */
  lineArtURI: Scalars['String'];
};

/** HiddenView holds the view configuration of an extension if it is a hidden load test extension. */
export type HiddenView = ExtensionView & {
  __typename?: 'HiddenView';
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** HiddenView holds the view configuration of an extension if it is a hidden load test extension. */
export type HiddenViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** Input to describe a single continuous time range of the source VOD to be included in the highlight. */
export type HighlightRange = {
  /** The end time offset in milliseconds into the VOD. */
  endMs: Scalars['Int'];
  /** The start time offset in milliseconds into the VOD. */
  startMs: Scalars['Int'];
  /** The ID of the source VOD to create a Highlight from. */
  vodID: Scalars['ID'];
};

/** An minimal version of a DONE CompetitionLobby focusing on the outcome of a lobby */
export type HistoricalCompetitionLobby = {
  __typename?: 'HistoricalCompetitionLobby';
  /** id is the unique id of the HistoricalCompetitionLobby. */
  id: Scalars['ID'];
  /** The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie. */
  winner?: Maybe<CompetitionLobbyParticipant>;
};

/** Paginated list of Users hosting a particular target User. */
export type HostConnection = {
  __typename?: 'HostConnection';
  /** Users hosting a target User. */
  edges?: Maybe<Array<HostEdge>>;
  /** Pagination information for this connection. */
  pageInfo: PageInfo;
  /** The total number of users hosting a target. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Edge between Users hosting a target. */
export type HostEdge = {
  __typename?: 'HostEdge';
  /** Unique identifier for each Users hosting. */
  cursor: Scalars['Cursor'];
  /** A User hosting. */
  node?: Maybe<User>;
};

/** HostTargetChannelError contains a error code. */
export type HostTargetChannelError = {
  __typename?: 'HostTargetChannelError';
  /** The type of error that occurred when trying to host. */
  code: HostTargetChannelErrorCode;
};

/** HostTargetChannelErrorCode are the list of thrown errors. */
export enum HostTargetChannelErrorCode {
  /** A channel cannot host itself. */
  CannotHostSelf = 'CANNOT_HOST_SELF',
  /** The target channel is already being hosted. */
  TargetChannelAlreadyHosted = 'TARGET_CHANNEL_ALREADY_HOSTED',
  /** The target channel is a TOS/DMCA/suspended channel and cannot be hosted. */
  TargetChannelInBadStanding = 'TARGET_CHANNEL_IN_BAD_STANDING',
  /** The target channel is unhostable because the target channel has ignored/banned the channel attempting to host, the target channel is blocked from hosting, etc. */
  UnhostableChannel = 'UNHOSTABLE_CHANNEL'
}

/** HostTargetChannelInput contains the necessary inputs to host a target channel. */
export type HostTargetChannelInput = {
  /** Channel ID where host was initiated on. */
  channelID: Scalars['ID'];
  /** Target channel ID to host. */
  targetID: Scalars['ID'];
};

/** HostTargetChannelPayload is the response after attempting to host. */
export type HostTargetChannelPayload = {
  __typename?: 'HostTargetChannelPayload';
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<HostTargetChannelError>;
  /** The channel that is hosting. */
  source?: Maybe<User>;
  /** The target channel that is hosted. */
  target?: Maybe<User>;
};

/** The wrapper structure that contains information regarding a Hype Train. */
export type HypeTrain = {
  __typename?: 'HypeTrain';
  /**
   * Configuration for Hype Trains for a channel, normally loaded this way when configuring the Hype Train from the
   * Broadcaster's perspective.
   */
  config?: Maybe<HypeTrainConfig>;
  /** Information pertaining to executions of Hype Trains in a channel. This is loaded on channel page load. */
  execution?: Maybe<HypeTrainExecution>;
};

/** The Hype Train reward that's a Badge. */
export type HypeTrainBadgeReward = HypeTrainReward & {
  __typename?: 'HypeTrainBadgeReward';
  /** The badge that is to be entitled. */
  badge?: Maybe<Badge>;
  /** The identifier of the reward. */
  id: Scalars['ID'];
  /** The type of reward, which will be HypeTrainRewardType.BADGE. */
  type: HypeTrainRewardType;
};

/** A conductor of the Hype Train. */
export type HypeTrainConductor = {
  __typename?: 'HypeTrainConductor';
  /** The participation that made them the Hype Train conductor. */
  participation: Array<HypeTrainParticipation>;
  /** The conductor source. */
  source: HypeTrainParticipationSource;
  /** The user object that is the conductor. */
  user: User;
};

/** The configured conductor rewards for a given participation source. */
export type HypeTrainConductorReward = {
  __typename?: 'HypeTrainConductorReward';
  /** The rewards entitled for being the conductor and contributing from this source. */
  rewards: Array<HypeTrainReward>;
  /** The source that the conductor participated from. */
  source: HypeTrainParticipationSource;
  /** The type of conductor that gets this reward. */
  type: HypeTrainConductorType;
};

/** The conductor type of the Hype Train reward. */
export enum HypeTrainConductorType {
  /** The current conductor of an active hype train. */
  Current = 'CURRENT',
  /** The former conductor of a hype train. */
  Former = 'FORMER',
  /** An unknown conductor type. */
  Unknown = 'UNKNOWN'
}

/** The Hype Train config for a channel. */
export type HypeTrainConfig = {
  __typename?: 'HypeTrainConfig';
  /** A custom setting that will be an emote that the user has chosen (or PogChamp if not set) to display in their Hype Train events. */
  calloutEmote?: Maybe<Emote>;
  /** The conductor rewards for a Hype Train successful execution. */
  conductorRewards: Array<HypeTrainConductorReward>;
  /** The cooldown period between Hype Train executions. */
  cooldownPeriodMinutes: Scalars['Int'];
  /** The difficulty of the Hype Train. */
  difficulty: HypeTrainDifficulty;
  /** The configured levels of the Hype Train. */
  difficultySettings: Array<HypeTrainDifficultySettings>;
  /** The identifier for the hype train. */
  id: Scalars['ID'];
  /** The boolean flag that denotes if the Hype Train is enabled or not. */
  isEnabled: Scalars['Boolean'];
  /** The structure that holds the parameters for tweaking how a Hype Train gets kicked off. */
  kickoff: HypeTrainKickoffConfig;
  /** The duration a Hype Train level executes for. */
  levelDurationSeconds: Scalars['Int'];
  /** The threshold for a notification to be displayed. */
  notificationThresholds: Array<HypeTrainNotificationThreshold>;
  /** The conversion rates for all the actions that contribute to Hype Train progress. */
  participationConversionRates: Array<HypeTrainParticipationConversionRate>;
  /** Hex color for the current hype train. Null if not enabled or no theme color is set. */
  primaryHexColor?: Maybe<Scalars['String']>;
  /** A boolean flag that indicates if the hype train settings should be personalized by Twitch. */
  shouldUsePersonalizedSettings: Scalars['Boolean'];
  /** A custom setting for using the creators color as the base color of hype trains. */
  willUseCreatorColor: Scalars['Boolean'];
};

/** The difficulty a Hype Train can be set to. */
export enum HypeTrainDifficulty {
  /** Easy, the easiest difficulty level. */
  Easy = 'EASY',
  /** Hard, the hard difficulty level. */
  Hard = 'HARD',
  /** Insane, the hardest difficulty level. */
  Insane = 'INSANE',
  /** Medium, the middle difficulty level. */
  Medium = 'MEDIUM',
  /** Super Hard, the harder difficulty level. */
  SuperHard = 'SUPER_HARD',
  /** An unknown difficulty. */
  Unknown = 'UNKNOWN'
}

/** A mapping between a difficulty and the levels that correspond. */
export type HypeTrainDifficultySettings = {
  __typename?: 'HypeTrainDifficultySettings';
  /** The difficulty of the level. */
  difficulty: HypeTrainDifficulty;
  /** The levels associated with the difficulty. */
  levels: Array<HypeTrainLevel>;
};

/** The Hype Train reward that's an Emote. */
export type HypeTrainEmoteReward = HypeTrainReward & {
  __typename?: 'HypeTrainEmoteReward';
  /** The emote that is to be entitled. */
  emote?: Maybe<Emote>;
  /** The identifier of the reward. */
  id: Scalars['ID'];
  /** The type of reward, which will be HypeTrainRewardType.EMOTE. */
  type: HypeTrainRewardType;
};

/** The enumerated end reasons for a Hype Train. */
export enum HypeTrainEndReason {
  /** The Hype Train was completed, which means that any level was completed. */
  Completed = 'COMPLETED',
  /** The Hype Train expired, which means that the Hype Train never completed level 1 after being started. */
  Expired = 'EXPIRED',
  /** The Hype Train is in progress, which means it has not ended. */
  InProgress = 'IN_PROGRESS',
  /** An unknown ending reason. */
  Unknown = 'UNKNOWN'
}

/** An enumeration of event types for Hype Train Activity Feeds. */
export enum HypeTrainEventType {
  /** Notification of when another Hype Train can start. */
  HypeTrainCoolDownExpired = 'HYPE_TRAIN_COOL_DOWN_EXPIRED',
  /** Event of when a Hype Train ended for the given channel. */
  HypeTrainEnded = 'HYPE_TRAIN_ENDED',
  /** Event of when a Hype Train started for the given channel. */
  HypeTrainStarted = 'HYPE_TRAIN_STARTED'
}

/** The structure that defines Hype Train Execution in a channel. */
export type HypeTrainExecution = {
  __typename?: 'HypeTrainExecution';
  /** The conductors of the Hype Train. */
  conductors: Array<HypeTrainConductor>;
  /** The Hype Train config that the train was started with. */
  config: HypeTrainConfig;
  /** The reason the Hype Train was ended, if it has been ended. */
  endReason?: Maybe<HypeTrainEndReason>;
  /** The time the Hype Train was ended, if the Hype Train was a previous execution. */
  endedAt?: Maybe<Scalars['Time']>;
  /** The time that the Hype Train will expire at. */
  expiresAt: Scalars['Time'];
  /** The identifier of the execution. */
  id: Scalars['ID'];
  /** Boolean flag that denotes if the Hype Train is active or not. */
  isActive: Scalars['Boolean'];
  /** The participation events in the Hype Train. */
  participations: Array<HypeTrainParticipation>;
  /** The progress structure that contains relevant information about how much progress the Hype Train acheived. */
  progress: HypeTrainProgress;
  /** The time that the Hype Train started. */
  startedAt: Scalars['Time'];
  /** The last time the Hype Train was updated. */
  updatedAt: Scalars['Time'];
};

/** The Hype Train kickoff configuration. */
export type HypeTrainKickoffConfig = {
  __typename?: 'HypeTrainKickoffConfig';
  /** What quantity of current commerce events can trigger a Hype Train. */
  eventsThreshold: Scalars['Int'];
  /** The minimum value of points that the combined events have to equal to kick off a Hype Train. */
  minPoints: Scalars['Int'];
  /** The period of time that is required for these commerce events to occur in to execute a Hype Train. */
  periodSeconds: Scalars['Int'];
};

/** HypeTrainKickoffInput specifies settings for kicking off hype trains. */
export type HypeTrainKickoffInput = {
  /** The number of qualifying events needed to kickoff a hype train. */
  eventsThreshold?: InputMaybe<Scalars['Int']>;
};

/** The Hype Train level configuration, which includes information about level completion and associated rewards. */
export type HypeTrainLevel = {
  __typename?: 'HypeTrainLevel';
  /** The value of participation that will take to complete the level. */
  goal: Scalars['Int'];
  /** The level ID. */
  id: Scalars['ID'];
  /** The associated rewards for completing the level. */
  rewards: Array<HypeTrainReward>;
  /** The value of the level, like Level 1, 2, etc. Can be configurable. */
  value: Scalars['Int'];
};

/** The notification threshold for an action / source combination. */
export type HypeTrainNotificationThreshold = {
  __typename?: 'HypeTrainNotificationThreshold';
  /** The action performed. */
  action: HypeTrainParticipationAction;
  /** The source of the action. */
  source: HypeTrainParticipationSource;
  /** The value that is the theshold for displaying a notification. */
  value: Scalars['Int'];
};

/** The Hype Train participation structure that contains relevant information about the participation event. */
export type HypeTrainParticipation = {
  __typename?: 'HypeTrainParticipation';
  /** The type of participation. */
  action: HypeTrainParticipationAction;
  /** The amount that the participation is valued in the Hype Train progress. */
  quantity: Scalars['Int'];
  /** The participation source. */
  source: HypeTrainParticipationSource;
};

/** The participation action of events in a Hype Train. */
export enum HypeTrainParticipationAction {
  /** A use of bits in extensions. */
  BitsOnExtension = 'BITS_ON_EXTENSION',
  /** A Cheer event. */
  Cheer = 'CHEER',
  /** A poll bits usage. */
  Polls = 'POLLS',
  /** A tier 1 sub gift. */
  Tier_1GiftedSub = 'TIER_1_GIFTED_SUB',
  /** A tier 1 sub purchase. */
  Tier_1Sub = 'TIER_1_SUB',
  /** A tier 2 sub gift. */
  Tier_2GiftedSub = 'TIER_2_GIFTED_SUB',
  /** A tier 2 sub purchase. */
  Tier_2Sub = 'TIER_2_SUB',
  /** A tier 3 sub gift. */
  Tier_3GiftedSub = 'TIER_3_GIFTED_SUB',
  /** A tier 3 sub purchase. */
  Tier_3Sub = 'TIER_3_SUB',
  /** An unkonwn action. */
  Unknown = 'UNKNOWN'
}

/** The participation conversion rate for what an action will count towards the Hype Train. */
export type HypeTrainParticipationConversionRate = {
  __typename?: 'HypeTrainParticipationConversionRate';
  /** The action performed. */
  action: HypeTrainParticipationAction;
  /** The source of the action. */
  source: HypeTrainParticipationSource;
  /** The rate that it will be converted as in the Hype Train progress calculations. */
  value: Scalars['Int'];
};

/** The Hype Train participation source that denotes the commerce types that can occur. */
export enum HypeTrainParticipationSource {
  /** Bits source, like cheering. */
  Bits = 'BITS',
  /** Subs source, like subbing to twitch.tv/michael on stream. */
  Subs = 'SUBS',
  /** An unknown source. */
  Unknown = 'UNKNOWN'
}

/** The structure that contains relevant information about the current progress in the Hype Train. */
export type HypeTrainProgress = {
  __typename?: 'HypeTrainProgress';
  /** The goal value that the Hype Train is trying to complete. */
  goal: Scalars['Int'];
  /** The Level that the Hype Train is currently on. */
  level: HypeTrainLevel;
  /** The current progression that the channel has made in the level. */
  progression: Scalars['Int'];
  /** The number of seconds left until this Hype Train execution ends. */
  remainingSeconds: Scalars['Int'];
  /** The total progression overall that has occurred in the Hype Train across all levels. */
  total: Scalars['Int'];
};

/** The hype train reward interface, which has to implement an identifier and the hype train reward type. */
export type HypeTrainReward = {
  /** The identifier of the reward. */
  id: Scalars['ID'];
  /** The type of reward that is entitled. */
  type: HypeTrainRewardType;
};

/** The enumerated types of rewards that can be entitled. */
export enum HypeTrainRewardType {
  /** Badge rewards. */
  Badge = 'BADGE',
  /** Emote rewards. */
  Emote = 'EMOTE',
  /** An unknown reward type. */
  Unknown = 'UNKNOWN'
}

/** IOSPaymentTrackingDataInput contains fields to pass in tracking data related to iOS payments. */
export type IosPaymentTrackingDataInput = {
  /** The user's device ID. */
  deviceID?: InputMaybe<Scalars['ID']>;
  /** The locale of the user. */
  locale?: InputMaybe<Scalars['String']>;
};

/** IOSReceiptDataInput contains the necessary fields to pass in iOS purchase receipt data. */
export type IosReceiptDataInput = {
  /** The external transaction ID. */
  extTransactionID: Scalars['ID'];
  /** The encrypted receipt of an iOS purchase, signed by Apple. Required to process any iOS payment. */
  signedReceipt: Scalars['String'];
};

export type Image = {
  __typename?: 'Image';
  /** The original height of the image in pixels. */
  height: Scalars['Int'];
  /**
   * The URL source of the image.
   * @deprecated Use the 'url' query instead.
   */
  imageURL: Scalars['String'];
  /** The URL source of the image. */
  url: Scalars['String'];
  /** The original width of the image in pixels. */
  width: Scalars['Int'];
};


export type ImageUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

export type ImageOptions = {
  /** The height of the image in pixels. */
  height?: InputMaybe<Scalars['Int']>;
  /** The width of the image in pixels. */
  width?: InputMaybe<Scalars['Int']>;
};

/** Friend requests sent from other users to this user. */
export type IncomingFriendRequestConnection = {
  __typename?: 'IncomingFriendRequestConnection';
  /** The friend request elements of this list. */
  edges: Array<IncomingFriendRequestEdge>;
  /**
   * The most recent incoming friend request received by this user, if any exist. This field is provided as a
   * convenience, as edges is not strictly time-ordered. The incoming friend request's presence in this field does not
   * prevent it from also occurring in edges.
   */
  newestEdge?: Maybe<IncomingFriendRequestEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** The total number of incoming friend requests. */
  totalCount: Scalars['Int'];
  /** The total number of unseen incoming friend requests. Use the ClearUnreadFriendRequests mutation to set this to 0. */
  totalUnreadCount: Scalars['Int'];
};

/** A friend request sent from another user to this user. */
export type IncomingFriendRequestEdge = {
  __typename?: 'IncomingFriendRequestEdge';
  /** The time at which the friend request was sent. */
  createdAt: Scalars['Time'];
  /** An opaque cursor identifying the edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The user who sent the friend request. */
  node?: Maybe<User>;
};

/** Determines what other channels can raid this channel. */
export enum IncomingRaidsPolicy {
  /** This user can be raided by anyone. */
  All = 'ALL',
  /** This user can be raided by other people in their network. */
  Network = 'NETWORK',
  /** This user cannot be radied by anyone. */
  None = 'NONE'
}

/** IngestFrameDrop represent an event where a video frame is dropped while ingesting a video stream. */
export type IngestFrameDrop = {
  __typename?: 'IngestFrameDrop';
  /** Duration of events in seconds. */
  durationSeconds: Scalars['Float'];
  /** Start time of the event. */
  startedAt: Scalars['Time'];
};

/** IngestSession is a set of stream metadata related to ingest events. */
export type IngestSession = {
  __typename?: 'IngestSession';
  /** Type of live stream. */
  broadcastFormat: BroadcastFormat;
  /** Staff-only field. Hostname for the session where ingest stream was received. */
  ingestHost?: Maybe<Scalars['String']>;
  /** Name of Ingest Server PoP that received the broadcast. Ex) IAD or PDX. */
  ingestProxy: Scalars['String'];
  /** How many seconds were intentionally delayed in stream as requested by the broadcaster. */
  streamDelaySeconds: Scalars['Int'];
  /** The time when the stream was ended. */
  streamDownAt?: Maybe<Scalars['Time']>;
  /** The time when the stream was started. */
  streamUpAt?: Maybe<Scalars['Time']>;
};

/** IngestStarvationEvent represent an event where an expected video frame from broadcaster does not arrive. */
export type IngestStarvationEvent = {
  __typename?: 'IngestStarvationEvent';
  /** Duration of events in seconds. */
  durationSeconds: Scalars['Float'];
  /** Starr time of the event. */
  startedAt: Scalars['Time'];
};

/** Set of codes to warn the broadcaster about what is wrong with the stream. */
export type IngestStreamHealth = {
  __typename?: 'IngestStreamHealth';
  /** Reasons why the stream is unstable. */
  reasons?: Maybe<Array<IngestStreamHealthReason>>;
  /** Indicate whether the stream is at okay, warning or unstable status. */
  status: IngestStreamHealthStatus;
};

/** Reason of why the stream is unstable. */
export enum IngestStreamHealthReason {
  /** Stream is behaving normally. */
  AllGood = 'ALL_GOOD',
  /** Some frames are being dropped by the broadcaster's encoder. */
  DroppedFrames = 'DROPPED_FRAMES',
  /** The stream is unstable due to high bitrate of the stream. */
  HighBitrate = 'HIGH_BITRATE',
  /** The interval between each key frame is too high. */
  HighKeyFrameInterval = 'HIGH_KEY_FRAME_INTERVAL',
  /** Broadcaster's encoder is sending an incompatible audio codec. */
  IncompAudioCodec = 'INCOMP_AUDIO_CODEC',
  /** Broadcaster's encoder is using a deprecated MP3 audio codec. */
  IncompMp3Deprecated = 'INCOMP_MP3_DEPRECATED',
  /** Broadcaster's encoder is sending an incompatible video codec. */
  IncompVideoCodec = 'INCOMP_VIDEO_CODEC',
  /** Ingest server expects video segments in sequence, but the server did not receive them from the client. */
  Starvation = 'STARVATION',
  /** Reason not set. */
  Unknown = 'UNKNOWN'
}

/** Health of the stream to inform the broadcaster. */
export enum IngestStreamHealthStatus {
  /** The stream is ingested okay. */
  Ok = 'OK',
  /** Health Status not set. */
  Unknown = 'UNKNOWN',
  /**
   * A misspelling of UNKNOWN.
   * @deprecated Use UNKNOWN instead
   */
  Unknwon = 'UNKNWON',
  /** The stream is unstable. */
  Unstable = 'UNSTABLE',
  /** The stream is at warning level. */
  Warn = 'WARN'
}

/** InstallExtensionError is wrapper for error associated with the installExtension mutation. */
export type InstallExtensionError = {
  __typename?: 'InstallExtensionError';
  /** Error code. */
  code: InstallExtensionErrorCode;
  /** The installation id if got EXTENSION_ALREADY_INSTALLED error. */
  installationID?: Maybe<Scalars['ID']>;
};

/** InstallExtensionErrorCode is an error code associated with InstallExtensionError. */
export enum InstallExtensionErrorCode {
  /** Channel id is invalid, for example, is empty. */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** The required input for an installExtension mutation. */
export type InstallExtensionInput = {
  /** The channelID the user is installing the extension on. */
  channelID: Scalars['ID'];
  /** The composite ID of an extension <extensionID:version>. */
  extensionID: Scalars['ID'];
};

/** The result of an installExtension mutation. */
export type InstallExtensionPayload = {
  __typename?: 'InstallExtensionPayload';
  /** The error when the mutation fails to install extension. */
  error?: Maybe<InstallExtensionError>;
  /** The resulting extension installation record from the install. */
  installedExtension?: Maybe<ExtensionInstallation>;
};

/** A shelf title token type that contains a number with various formatters. */
export type IntegerToken = {
  __typename?: 'IntegerToken';
  /** The numerical value to display for this token. */
  value: Scalars['Int'];
};

/** InternalChargeModel defines a 1P price identifier for the offer. */
export type InternalChargeModel = {
  __typename?: 'InternalChargeModel';
  /** The charge model plan. It will be omitted for consumable purchases (e.g. Bits). */
  plan?: Maybe<ChargeModelPlan>;
  /** Preview of the price. */
  previewPrice?: Maybe<PriceInfo>;
  /** The price identifier. */
  priceID: Scalars['ID'];
  /** The authenticated user's relationship with the internal charge model. */
  self?: Maybe<InternalChargeModelSelfEdge>;
};

/** The authenticated user's relationship with the internal charge model. */
export type InternalChargeModelSelfEdge = {
  __typename?: 'InternalChargeModelSelfEdge';
  /** Contains information on the final checkout price of this offer. */
  checkoutPrice?: Maybe<ProductPurchase>;
};


/** The authenticated user's relationship with the internal charge model. */
export type InternalChargeModelSelfEdgeCheckoutPriceArgs = {
  paymentProvider: PaymentProvider;
  quantity: Scalars['Int'];
};

/** InterruptScheduleBoundsError represents errors that are due to input being out of bounds. */
export type InterruptScheduleBoundsError = InterruptScheduleError & {
  __typename?: 'InterruptScheduleBoundsError';
  /** Error code. */
  code: InterruptScheduleErrorCode;
  /** If the error is related to an input out of service-defined bounds, provide the maximum allowed value. */
  maximum?: Maybe<Scalars['Int']>;
  /** If the error is related to an input out of service-defined bounds, provide the miniimum allowed value. */
  minimum?: Maybe<Scalars['Int']>;
};

/** InterruptScheduleError is a wrapper for error associated with the CreateScheduleSegment mutation. */
export type InterruptScheduleError = {
  /** Error code. */
  code: InterruptScheduleErrorCode;
};

/** The possible errors. */
export enum InterruptScheduleErrorCode {
  /** EndAt is too far in the future. */
  EndTooFarInFuture = 'END_TOO_FAR_IN_FUTURE',
  /** Not authorized to disable the schedule. */
  Forbidden = 'FORBIDDEN',
  /** The argument is invalid and does not map to a known error. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The schedule was not found. */
  NotFound = 'NOT_FOUND'
}

/** The input to interrupt a schedule. */
export type InterruptScheduleInput = {
  /** The end time when the schedule will no longer be disabled. */
  endAt: Scalars['Time'];
  /** The reason the schedule was disabled. */
  reason: ScheduleInterruptionReason;
  /** The id of the schedule. */
  scheduleID: Scalars['ID'];
  /** The start time when the schedule will be disabled. */
  startAt: Scalars['Time'];
  /** The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles". */
  timezone: Scalars['String'];
};

/** The payload returned when interrupting a schedule. */
export type InterruptSchedulePayload = {
  __typename?: 'InterruptSchedulePayload';
  /** The possible error. */
  error?: Maybe<InterruptScheduleError>;
  /** The updated stream schedule. */
  schedule?: Maybe<Schedule>;
};

/** InterruptScheduleStandardError represents general errors that are not related to bound errors. */
export type InterruptScheduleStandardError = InterruptScheduleError & {
  __typename?: 'InterruptScheduleStandardError';
  /** Error code. */
  code: InterruptScheduleErrorCode;
};

/** Arguments for the invalidation of all of a user's sessions. */
export type InvalidateAuthenticatedSessionsInput = {
  /** Session to keep alive. */
  keepSession?: InputMaybe<Scalars['String']>;
  /** Twitch user owner of the sessions. */
  userID: Scalars['ID'];
};

/** Payload after invalidating sessions. */
export type InvalidateAuthenticatedSessionsPayload = {
  __typename?: 'InvalidateAuthenticatedSessionsPayload';
  /** Twitch User. */
  user?: Maybe<User>;
};

/** InvalidateEmailAssociationPayload is input required to mark a user as not owning an email address. */
export type InvalidateEmailAssociationInput = {
  /** Email address that is incorrectly attributed to a user. */
  email: Scalars['String'];
  /** EmailAssociationOpaqueID is the OpaqueID of the association to the above email. */
  emailAssociationOpaqueID: Scalars['ID'];
};

/** InvalidateEmailAssociationPayload is the response payload. */
export type InvalidateEmailAssociationPayload = {
  __typename?: 'InvalidateEmailAssociationPayload';
  /** HasSucceeded indicates whether or not the request has succeeded. */
  hasSucceeded: Scalars['Boolean'];
};

/** Contains the inventory for a particular user, which consists of drops. */
export type Inventory = {
  __typename?: 'Inventory';
  /** The campaigns which have drops that the user is eligible for and has banked (or is currently earning) minutes-watched progress for. */
  dropCampaignsInProgress?: Maybe<Array<DropCampaign>>;
  /** The drops awarded to this user via Drops 1.0 and triggered by game publishers according to minutes watched data. */
  drops?: Maybe<UserDropAwardConnection>;
  /** The drops awarded to this user via Drops 2.0 and triggered by broadcaster's game events. */
  gameEventDrops?: Maybe<Array<Maybe<UserDropReward>>>;
};

/** Associated metrics for the "It Begins" quest. */
export type ItBegins = {
  __typename?: 'ItBegins';
  /** Image URL for the quest's badge. */
  badgeURL?: Maybe<Scalars['String']>;
  /** Time that this quest was completed. */
  completedAt?: Maybe<Scalars['Time']>;
  /** Whether or not the user has streamed before. */
  hasStreamed?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has updated their category before. */
  hasUpdatedCategory?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has updated their stream title before. */
  hasUpdatedStreamTitle?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has visited their stream manager. */
  hasVisitedDashboard?: Maybe<Scalars['Boolean']>;
};

export type JoinChannelRoomsInput = {
  channelID: Scalars['ID'];
};

export type JoinChannelRoomsPayload = {
  __typename?: 'JoinChannelRoomsPayload';
  channel?: Maybe<User>;
};

/** Inputs to the joinRaid mutation. */
export type JoinRaidInput = {
  /** The raid ID being joined by the user. */
  raidID: Scalars['ID'];
};

/** Outputs from the joinRaid mutation. */
export type JoinRaidPayload = {
  __typename?: 'JoinRaidPayload';
  /** The ID of the raid that was joined by the user. */
  raidID?: Maybe<Scalars['ID']>;
};

/** The connection of key batches for a given key pool. */
export type KeyBatchConnection = {
  __typename?: 'KeyBatchConnection';
  /** The list of key batch edges in the connection. */
  edges: Array<KeyBatchEdge>;
  /** The metadata about having more key batches to fetch, or if there is a previous page of key batches. */
  pageInfo: PageInfo;
  /** The total number of key batches for the key pool. */
  totalCount: Scalars['Int'];
};

/** The key batch edge which contains our cursor and node. */
export type KeyBatchEdge = {
  __typename?: 'KeyBatchEdge';
  /** The cursor of the edge, which is the key batch ID. */
  cursor: Scalars['Cursor'];
  /** The node of the edge, which contains all information about the key batch. */
  node?: Maybe<KeyBatchNode>;
};

/** The information associated with a given key batch. */
export type KeyBatchNode = {
  __typename?: 'KeyBatchNode';
  /** The key batch ID, which is unique for a given key pool. */
  id: Scalars['ID'];
  /** The number of keys in the batch. */
  numKeys: Scalars['Int'];
  /** The status of the batch. */
  status: KeyBatchStatus;
};

/** An enumeration of key batch statuses. */
export enum KeyBatchStatus {
  /** The key batch is active and keys generated from it can be claimed. */
  Active = 'ACTIVE',
  /** The key batch is inactive and keys generated from it cannot be claimed. */
  Inactive = 'INACTIVE',
  /** The key batch is invalid and keys generated from it are invalidated. */
  Invalidated = 'INVALIDATED'
}

/** The connection of key pools to a user. */
export type KeyPoolConnection = {
  __typename?: 'KeyPoolConnection';
  /** The list of key pool edges associated with the user. */
  edges: Array<KeyPoolEdge>;
  /** The metadata about having more key pools to fetch, or if there is a previous page of key pools. */
  pageInfo: PageInfo;
  /** The total number of key pools for the given user. */
  totalCount: Scalars['Int'];
};

/** The key pool edge which contains our cursor and node. */
export type KeyPoolEdge = {
  __typename?: 'KeyPoolEdge';
  /** The cursor of the edge, which is also the key pool ID. */
  cursor: Scalars['Cursor'];
  /** The node of the edge, which contains all information about the key pool. */
  node?: Maybe<KeyPoolNode>;
};

/** The information associated with a given key pool. */
export type KeyPoolNode = {
  __typename?: 'KeyPoolNode';
  /** The key batches that have been generated in the key pool. */
  batches?: Maybe<KeyBatchConnection>;
  /** The description of the key pool. */
  description: Scalars['String'];
  /** The key pool ID, which is unique. */
  id: Scalars['ID'];
  /** The product type associated with the key pool, which determines what kind of keys are generated. */
  productType: Scalars['String'];
  /** The SKU associated with the key pool, which is used to redeem content. */
  sku: Scalars['String'];
  /** Status of the key pool, which can be active, inactive, or invalidated. */
  status: KeyPoolStatus;
};


/** The information associated with a given key pool. */
export type KeyPoolNodeBatchesArgs = {
  after?: InputMaybe<Scalars['String']>;
};

/** An enumeration of key pool statuses. */
export enum KeyPoolStatus {
  /** The key pool is active and can generate more key batches. */
  Active = 'ACTIVE',
  /** The key pool is inactive and all batches are invalid. */
  Inactive = 'INACTIVE',
  /** The key pool is invalid and new batches cannot be made. */
  Invalidated = 'INVALIDATED'
}

/** Caller should store all of these fields. */
export type LwaToken = {
  __typename?: 'LWAToken';
  /** Access token to pass in on subsequent requests. */
  accessToken: Scalars['String'];
  /** TTL in seconds, default is 3600. */
  expiresIn: Scalars['Int'];
  /** Should be stored, though generally shouldn't change. */
  refreshToken: Scalars['String'];
};

/** An enumeration of broadcaster languages. */
export enum Language {
  /** Arabic. */
  Ar = 'AR',
  /** American Sign Language. */
  Asl = 'ASL',
  /** Bulgarian. */
  Bg = 'BG',
  /** Catalan. */
  Ca = 'CA',
  /** Czech. */
  Cs = 'CS',
  /** Danish. */
  Da = 'DA',
  /** German. */
  De = 'DE',
  /** Greek. */
  El = 'EL',
  /** English. */
  En = 'EN',
  /** Spanish. */
  Es = 'ES',
  /** Finnish. */
  Fi = 'FI',
  /** French. */
  Fr = 'FR',
  /** Hindi. */
  Hi = 'HI',
  /** Hungarian. */
  Hu = 'HU',
  /** Indonesian. */
  Id = 'ID',
  /** Italian. */
  It = 'IT',
  /** Japanese. */
  Ja = 'JA',
  /** Korean. */
  Ko = 'KO',
  /** Malay. */
  Ms = 'MS',
  /** Dutch. */
  Nl = 'NL',
  /** Norwegian. */
  No = 'NO',
  /** Other. */
  Other = 'OTHER',
  /** Polish. */
  Pl = 'PL',
  /** Portuguese. */
  Pt = 'PT',
  /** Romanian. */
  Ro = 'RO',
  /** Russian. */
  Ru = 'RU',
  /** Slovak. */
  Sk = 'SK',
  /** Swedish. */
  Sv = 'SV',
  /** Thai. */
  Th = 'TH',
  /** Tagalog. */
  Tl = 'TL',
  /** Turkish. */
  Tr = 'TR',
  /** Ukrainian. */
  Uk = 'UK',
  /** Vietnamese. */
  Vi = 'VI',
  /** Chinese. */
  Zh = 'ZH',
  /** Chinese (Hong Kong). */
  ZhHk = 'ZH_HK'
}

/** An enumeration of user language tags (shortened BCP 47) available on Twitch. This should not be confused with Language, which is broadcaster language. */
export enum LanguageTag {
  /** Arabic. */
  Ar = 'AR',
  /** Bulgarian. */
  Bg = 'BG',
  /** Czech. */
  Cs = 'CS',
  /** Danish. */
  Da = 'DA',
  /** German. */
  De = 'DE',
  /** Greek. */
  El = 'EL',
  /** English. */
  En = 'EN',
  /** English - Great Britain. */
  EnGb = 'EN_GB',
  /** Spanish. */
  Es = 'ES',
  /** Spanish - Mexico. */
  EsMx = 'ES_MX',
  /** Finnish. */
  Fi = 'FI',
  /** French. */
  Fr = 'FR',
  /** Hindi. */
  Hi = 'HI',
  /** Hungarian. */
  Hu = 'HU',
  /** Italian. */
  It = 'IT',
  /** Japanese. */
  Ja = 'JA',
  /** Korean. */
  Ko = 'KO',
  /** Dutch. */
  Nl = 'NL',
  /** Norwegian. */
  No = 'NO',
  /** Polish. */
  Pl = 'PL',
  /** Portuguese. */
  Pt = 'PT',
  /** Portuguese - Brazil. */
  PtBr = 'PT_BR',
  /** Romanian. */
  Ro = 'RO',
  /** Russian. */
  Ru = 'RU',
  /** Slovak. */
  Sk = 'SK',
  /** Swedish. */
  Sv = 'SV',
  /** Thai. */
  Th = 'TH',
  /** Turkish. */
  Tr = 'TR',
  /** Vietnamese. */
  Vi = 'VI',
  /** Chinese. */
  Zh = 'ZH',
  /** Chinese - China. */
  ZhCn = 'ZH_CN',
  /** Chinese - Taiwan. */
  ZhTw = 'ZH_TW'
}

/** The details of Leaderboard format. */
export type LeaderboardDetails = {
  __typename?: 'LeaderboardDetails';
  /** The max participant count for a lobby in phase. Valid values are 1-100. */
  lobbyMaxSize: Scalars['Int'];
  /** The number of phases to be created for the competition. Valid values are 1-20. */
  phaseCount: Scalars['Int'];
  /** A display string conveying how a Competition Organizer intends to resolve ties. */
  tiebreakerLabel?: Maybe<TiebreakerLabel>;
};

/** LeaderboardSet contains the set of leaderboards that are active on a channel. */
export type LeaderboardSet = {
  __typename?: 'LeaderboardSet';
  /** bits contains the leaderboard of top users by number of bits cheered for the channel. */
  bits?: Maybe<UserLeaderboard>;
  /** subGift contains the leaderboard of top users by number of sub gifts given in the channel. */
  subGift?: Maybe<UserLeaderboard>;
};

/** Partner dashboard settings for the bits cheering and sub gifting leaderboards. */
export type LeaderboardSettings = {
  __typename?: 'LeaderboardSettings';
  /** The default leaderboard the user wants to show. */
  defaultLeaderboard: LeaderboardType;
  /** Flag that is true if the user has bits cheering leaderboards turned on. */
  isCheerEnabled: Scalars['Boolean'];
  /** Flag that is true if the user has sub gifting leaderboards turned on. */
  isSubGiftEnabled: Scalars['Boolean'];
  /** The time period the user wants the leaderboard to be displayed as. */
  timePeriod: LeaderboardTimePeriodType;
};

/** LeaderboardTimePeriodType enumerates the various types of supported Leaderboards. */
export enum LeaderboardTimePeriodType {
  /** All time leaderboards are cumulative back to when Bits launched in June of 2016. */
  Alltime = 'ALLTIME',
  /** Daily leaderboards reset at midnight PT. */
  Day = 'DAY',
  /** Monthly leaderboards reset at midnight PT on the last day of the month. */
  Month = 'MONTH',
  /** Weekly leaderboards reset at midnight PT between Sunday and Monday. */
  Week = 'WEEK'
}

/** LeaderboardType enumerates the various types of supported Leaderboards. */
export enum LeaderboardType {
  /** Bits cheering leaderboards. */
  Cheer = 'CHEER',
  /** Sub gifting leaderboards. */
  Subgift = 'SUBGIFT'
}

export type LeaveChannelRoomsInput = {
  channelID: Scalars['ID'];
};

export type LeaveChannelRoomsPayload = {
  __typename?: 'LeaveChannelRoomsPayload';
  channel?: Maybe<User>;
};

/** Inputs to the leaveRaid mutation. */
export type LeaveRaidInput = {
  /** The raid ID being left by the user. */
  raidID: Scalars['ID'];
};

/** Outputs from the leaveRaid mutation. */
export type LeaveRaidPayload = {
  __typename?: 'LeaveRaidPayload';
  /** The ID of the raid that was joined by the user. */
  raidID?: Maybe<Scalars['ID']>;
};

/** LeaveSquadStreamError is the error associated with a leaveSquadStream. */
export type LeaveSquadStreamError = {
  __typename?: 'LeaveSquadStreamError';
  /** The associated error code. */
  code: LeaveSquadStreamErrorCode;
};

/** LeaveSquadStreamErrorCode are the possible errors that this mutation returns. */
export enum LeaveSquadStreamErrorCode {
  /** The operation is unauthorized. */
  Unauthorized = 'UNAUTHORIZED',
  /** The user is not in the squad specified. */
  UserNotInSquad = 'USER_NOT_IN_SQUAD'
}

/** Inputs to the leaveSquadStream mutation. */
export type LeaveSquadStreamInput = {
  /** The optional ID of a squad member that is leaving the squad (defaults to ID from auth token). */
  memberID: Scalars['ID'];
  /** The ID of the squad stream that the caller wants to leave. */
  squadStreamID: Scalars['ID'];
};

/** Outputs from the leaveSquadStream mutation. */
export type LeaveSquadStreamPayload = {
  __typename?: 'LeaveSquadStreamPayload';
  /** The possible error returned from the service. */
  error?: Maybe<LeaveSquadStreamError>;
  /** The updated squad stream. */
  squadStream?: Maybe<SquadStream>;
};

/** LinkOEmbed is a link oEmbed.  This looks strange being empty, but mirrors the oEmbed official spec most exactly. */
export type LinkOEmbed = OEmbed & {
  __typename?: 'LinkOEmbed';
  authorName?: Maybe<Scalars['String']>;
  authorURL?: Maybe<Scalars['String']>;
  cacheAge?: Maybe<Scalars['Int']>;
  inputURL: Scalars['String'];
  providerName?: Maybe<Scalars['String']>;
  providerURL?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<ThumbnailOEmbed>;
  title?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  version: Scalars['String'];
};

/** LinkSSOError is an error that occurs when account linking fails. */
export type LinkSsoError = {
  __typename?: 'LinkSSOError';
  /** The error code that describes why account linking failed. */
  code: LinkSsoErrorCode;
};

/** LinkSSOErrorCode enumerates the possible errors that can cause account linking to fail. */
export enum LinkSsoErrorCode {
  /** The user has already linked an SSO app of the same type to their account. */
  AlreadyLinked = 'ALREADY_LINKED',
  /** The activation code is expired. */
  CodeExpired = 'CODE_EXPIRED',
  /** The activation code is incorrect. */
  CodeIncorrect = 'CODE_INCORRECT'
}

/** LinkSSOInput links an SSO app to the authenticated user's account if the activation code is valid. */
export type LinkSsoInput = {
  /** The code that identifies the single sign-on (SSO) app that should be linked to the authenticated user's account. */
  code: Scalars['String'];
};

/** LinkSSOPayload returns the newly created link or an error if account linking failed. */
export type LinkSsoPayload = {
  __typename?: 'LinkSSOPayload';
  /** The error when an app cannot be linked to the user's account. */
  error?: Maybe<LinkSsoError>;
  /** The new SSO link. */
  link?: Maybe<SsoLink>;
};

/** The location that a piece of text should link to. */
export enum LinkType {
  /** Link to the categories directory (on web: https://www.twitch.tv/directory). */
  CategoriesDirectory = 'CATEGORIES_DIRECTORY',
  /** Do not link to anything. */
  NoLink = 'NO_LINK',
  /** Link to the streams directory (on web: https://www.twitch.tv/directory/all). */
  StreamsDirectory = 'STREAMS_DIRECTORY'
}

/** LiveConfigView holds the view configuration of an extension if the live config dashboard page is supported. */
export type LiveConfigView = ExtensionView & {
  __typename?: 'LiveConfigView';
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported. */
export type LiveConfigViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

export type LiveRecommendationConnection = {
  __typename?: 'LiveRecommendationConnection';
  /** The list of recommended streams with metadata to display. */
  edges?: Maybe<Array<StreamRecommendationEdge>>;
  /** Per-generation tracking id for identifying a recommendation model. */
  generationID: Scalars['String'];
  /**
   * The list of recommended streams to display.
   * @deprecated To be replaced by edges which also includes a required trackingID.
   */
  nodes: Array<Maybe<Stream>>;
  /** Unique tracking id per response. */
  responseID: Scalars['String'];
};

/** Information about the live up notification of a user. */
export type LiveUpNotificationInfo = {
  __typename?: 'LiveUpNotificationInfo';
  /** Whether the user's liveUpNotification field is the default value (i.e. "<user> went live!"). */
  isDefault?: Maybe<Scalars['Boolean']>;
  /**
   * The text that will be in the notification that sends when the user starts broadcasting.
   * The default value is currently a translated version of "<user> went live!" when the user has not set a custom value.
   */
  liveUpNotification?: Maybe<Scalars['String']>;
};

/** The lobby state signifies the progress in the competition. */
export enum LobbyState {
  /** Participants are currently playing in the lobby, they can be scored but cannot be swapped to different lobbies. */
  Active = 'ACTIVE',
  /** Participants are all scored and no longer playing. */
  Done = 'DONE',
  /** No participants are in lobby. */
  Prep = 'PREP',
  /** Participants have filled the lobby and can be swapped around different lobbies. */
  Ready = 'READY',
  /** Lobby state is unknown. */
  Unknown = 'UNKNOWN'
}

/** An error returned from the lockPredictionEvent mutation. */
export type LockPredictionEventError = {
  __typename?: 'LockPredictionEventError';
  /** Code describing the error. */
  code: LockPredictionEventErrorCode;
};

/** Possible error codes from the lockPredictionEvent mutation. */
export enum LockPredictionEventErrorCode {
  /** This Prediction Event is not currently in the ACTIVE state. */
  EventNotActive = 'EVENT_NOT_ACTIVE',
  /** The current user is forbidden from updating this Prediction Event. */
  Forbidden = 'FORBIDDEN',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for moving a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it. */
export type LockPredictionEventInput = {
  /** The unique identifier of the Prediction Event to move from ACTIVE to LOCKED. */
  id: Scalars['ID'];
};

/** Payload from closing a prediciton event to new predictions. */
export type LockPredictionEventPayload = {
  __typename?: 'LockPredictionEventPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<LockPredictionEventError>;
  /** The updated Prediction Event. */
  predictionEvent?: Maybe<PredictionEvent>;
};

/** Communicates a Loyalty Badge (usually during upload). */
export type LoyaltyBadge = {
  __typename?: 'LoyaltyBadge';
  /** Unique identifier the badges method of tenure by channelid and cumulative months. */
  channelTenureMethodID: Scalars['ID'];
  /** The channel's loyalty badge unique identifier. */
  id: Scalars['ID'];
  /** image1xURL to retrieve the 1x sized Badge. */
  image1xURL: Scalars['String'];
  /** Image1xURL to retrieve the 2x sized Badge. */
  image2xURL: Scalars['String'];
  /** image4xURL to retrieve the 4x sized Badge. */
  image4xURL: Scalars['String'];
  /** Identifies the amount of cumulative tenure months to acquire Badge. */
  requiredTenureMonths: Scalars['Int'];
  /**
   * A localized, human-friendly title for the badge.
   * Defaults to English if no translation exists for the requested locale.
   */
  title: Scalars['String'];
};

/** LoyaltyBadgeUploadConfig is the upload configuration for creating loyalty badges. */
export type LoyaltyBadgeUploadConfig = {
  __typename?: 'LoyaltyBadgeUploadConfig';
  /** The image ID of the badge image. */
  imageID?: Maybe<Scalars['ID']>;
  /** The resulting URL of the badge image. */
  imageURL?: Maybe<Scalars['String']>;
  /** The upload ID of the badge file. */
  uploadID?: Maybe<Scalars['ID']>;
  /** The URL to upload the badge image to. */
  uploadURL?: Maybe<Scalars['String']>;
};

/** Input for creating a batch download URL for key codes. */
export type MakeKeyBatchDownloadUrlInput = {
  /** The ID of the batch to download. */
  batchID: Scalars['String'];
};

/** The results of creating a key batch download. */
export type MakeKeyBatchDownloadUrlPayload = {
  __typename?: 'MakeKeyBatchDownloadURLPayload';
  /** The decryption key to decrypt the batch of keys. */
  decryptionKey: Scalars['String'];
  /** The URL created for downloading the batch of keys. */
  url: Scalars['String'];
};

/** An error returned from the makePrediction mutation. */
export type MakePredictionError = {
  __typename?: 'MakePredictionError';
  /** Code describing the error. */
  code: MakePredictionErrorCode;
  /** If the error code is MAX_POINTS_PER_EVENT, this will specify how many total points the user is allowed to spend. */
  maxPointsPerEvent?: Maybe<Scalars['Int']>;
  /** If the error code is MAX_POINTS_PER_EVENT, this will specify how many points the user has already spent. */
  userPointsSpent?: Maybe<Scalars['Int']>;
};

/** Possible error codes from the makePrediction mutation. */
export enum MakePredictionErrorCode {
  /** The user is restricted from full participation because their geographic location has a ban on Predictions for the specific game/category being played. */
  CategoryRegionLocked = 'CATEGORY_REGION_LOCKED',
  /** The client is retrying with a transaction id that has already been used. */
  DuplicateTransaction = 'DUPLICATE_TRANSACTION',
  /** The user is restricted from full participation because they have the ability to manage Predictions on this channel. */
  EventManager = 'EVENT_MANAGER',
  /** This Prediction Event is no longer actively accepting predictions. */
  EventNotActive = 'EVENT_NOT_ACTIVE',
  /** The current user is forbidden from making a Prediction on this Prediction Event. */
  Forbidden = 'FORBIDDEN',
  /** Making this prediction would bring the user's total amount spent on this prediction above the maximum. */
  MaxPointsPerEvent = 'MAX_POINTS_PER_EVENT',
  /** The user has already made a prediction on a different Outcome, so this prediction cannot be made. */
  MultipleOutcomes = 'MULTIPLE_OUTCOMES',
  /** The user must accept the Predictions Terms of Service. */
  MustAcceptTos = 'MUST_ACCEPT_TOS',
  /** The user does not have enough points to make this prediction. */
  NotEnoughPoints = 'NOT_ENOUGH_POINTS',
  /** The provided event ID or outcome ID does not exist. */
  NotFound = 'NOT_FOUND',
  /** The user's request was rate limited. They can try again after a few seconds. */
  RateLimited = 'RATE_LIMITED',
  /** The user is restricted from full participation because their geographic location has a blanket ban on Prediction participation. */
  RegionLocked = 'REGION_LOCKED',
  /** The user attempted to make a Prediction in Spectator Mode but has already made one on this Event. */
  SpectatorModeDuplicate = 'SPECTATOR_MODE_DUPLICATE',
  /** The user attempted to make a Prediction in Spectator Mode but is ineligible for that mode. */
  SpectatorModeIneligible = 'SPECTATOR_MODE_INELIGIBLE',
  /** The client is retrying with a transaction id that is currently being processed in another request. */
  TransactionInProgress = 'TRANSACTION_IN_PROGRESS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for making a Prediction. */
export type MakePredictionInput = {
  /** The unique identifier of the Prediction Event to make the prediction on. */
  eventID: Scalars['ID'];
  /** The unique identifier of the Prediction Outcome to make the prediction on. */
  outcomeID: Scalars['ID'];
  /** The number of points to spend on this Prediction. */
  points: Scalars['Int'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** Payload for making a prediction. */
export type MakePredictionPayload = {
  __typename?: 'MakePredictionPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<MakePredictionError>;
  /** The created or updated Prediction. */
  prediction?: Maybe<Prediction>;
};

/** A custom challenge created by the broadcaster. */
export type ManualChannelChallenge = ChannelChallenge & {
  __typename?: 'ManualChannelChallenge';
  /** Total bits amount contributed. */
  bitsAmount: Scalars['Int'];
  /** Time when challenge was created. */
  createdAt: Scalars['Time'];
  /** User that created the challenge. */
  createdBy?: Maybe<User>;
  /** Amount of seconds from when the challenge starts to when it ends. */
  durationSeconds: Scalars['Int'];
  /** ID of challenge. */
  id: Scalars['ID'];
  /** User who owns this challenge. The challenge will appear on their channel. */
  ownedBy?: Maybe<User>;
  /**
   * Amount of milliseconds before the challenge times out.
   * 0 when the challenge has timed out.
   */
  remainingDurationMilliseconds: Scalars['Int'];
  /**
   * The authenticated user's relationship with this challenge.
   * Main use case is to connect the user to a challenge to allow bit contributions.
   * Null if un-authenticated user is making this query.
   */
  self?: Maybe<ChannelChallengeSelfEdge>;
  /** The status of the challenge. */
  status: ChannelChallengeStatus;
  /** Title of the challenge. */
  title: Scalars['String'];
  /** Time when challenge was updated. */
  updatedAt: Scalars['Time'];
};

/** Drop manually triggered. */
export type ManualTriggerBasedDrop = DropType & {
  __typename?: 'ManualTriggerBasedDrop';
  /** The rewards for this drop and how often those rewards can be awarded. */
  benefitEdges?: Maybe<Array<DropBenefitEdge>>;
  /** The campaign this drop belongs to. */
  campaign: DropCampaign;
  /** Amount of time the viewer has to claim the drop after the rule is completed. */
  claimDurationSeconds: Scalars['Int'];
  /** The time this drop becomes unavailable. */
  endAt: Scalars['Time'];
  /** A unique identifier. */
  id: Scalars['ID'];
  /** The name of this drop. */
  name: Scalars['String'];
  /** The time this drop becomes available. */
  startAt: Scalars['Time'];
};

/** ManuallyTriggerDrop has fields required to update a campaign summary. */
export type ManuallyTriggerDropInput = {
  /** The id of the campaign that includes the drop to trigger. */
  campaignID: Scalars['ID'];
  /** The id of the drop to trigger. */
  dropID: Scalars['ID'];
  /** This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops. */
  ownerID: Scalars['ID'];
};

/** ManuallyTriggerDropPayload returns the result of the creation/update. */
export type ManuallyTriggerDropPayload = {
  __typename?: 'ManuallyTriggerDropPayload';
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
  /** Returns a list of channels the drop was tried to be triggered on and the trigger restult. */
  triggerResults?: Maybe<Array<TriggerResult>>;
};

/** The possible return status of a drop trigger try on a channel. */
export enum ManuallyTriggerDropResultStatus {
  /** Returned if the drop triggered returned an error for given channel. */
  Error = 'ERROR',
  /** Returned if the trigger try was successful. */
  Success = 'SUCCESS',
  /** Returned if the streamer is not eligible to have the drop triggered on it. */
  VerificationFailure = 'VERIFICATION_FAILURE'
}

/** Input for readAllCreatorNotifications mutation. */
export type MarkAllCreatorNotificationsAsReadInput = {
  /** The ID of the user performing the reading. */
  userID: Scalars['ID'];
};

/** The result of a readAllCreatorNotifications mutation. */
export type MarkAllCreatorNotificationsAsReadPayload = {
  __typename?: 'MarkAllCreatorNotificationsAsReadPayload';
  /** Whether the mutation succeeded. */
  hasSucceeded?: Maybe<Scalars['Boolean']>;
};

/** Input for readAllViewerNotifications mutation. */
export type MarkAllViewerNotificationsAsReadInput = {
  /** The ID of the user performing the reading. */
  userID: Scalars['ID'];
};

/** The result of a readAllViewerNotifications mutation. */
export type MarkAllViewerNotificationsAsReadPayload = {
  __typename?: 'MarkAllViewerNotificationsAsReadPayload';
  /** Whether the mutation succeeded. */
  hasSucceeded?: Maybe<Scalars['Boolean']>;
};

/** Revealed Metric types that the client can filter on. */
export enum MemberMetricsRevealedParams {
  /** Return all members. */
  None = 'NONE',
  /** Return all `RevenueRevealed` members. */
  Revenue = 'REVENUE',
  /** Return all `StatsRevealed` members. */
  Stats = 'STATS',
  /** Return users with both `StatsRevealed` and `RevenueRevealed`. */
  StatsAndRevenue = 'STATS_AND_REVENUE'
}

/** A message from a user. */
export type Message = {
  __typename?: 'Message';
  /** The text and emoticon content of a message. */
  content: MessageContent;
  /** Time the message was deleted or purged. Null if the message is not deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** UUID of the message. */
  id: Scalars['ID'];
  /** The message of the parent if this message is a reply. */
  parentMessage?: Maybe<Message>;
  /** Replies to this message. */
  replies?: Maybe<MessageReplyConnection>;
  /** The user that sent the message. */
  sender?: Maybe<User>;
  /** Time the message was sent. */
  sentAt: Scalars['Time'];
};

/**
 * MessageBody is a way of encoding emote annotated text.  The original text is included as content and the
 * parsed emotes are included which indicate the start and end indexes they should replace.
 */
export type MessageBody = {
  __typename?: 'MessageBody';
  /** The text content of the body. */
  content?: Maybe<Scalars['String']>;
  /** Collection of rune indexed emotes to be replaced clientside. */
  emotes?: Maybe<Array<Maybe<EmbeddedEmote>>>;
};

/** The content of a user's message to a channel's chat. */
export type MessageContent = {
  __typename?: 'MessageContent';
  /** Parsed list of fragments in the message, include emotes, mentions, and plaintext. */
  fragments: Array<MessageFragment>;
  /** String representation of the user message. */
  text: Scalars['String'];
};

/** One parsed part of a message, which may be an emote, mention, or plaintext. */
export type MessageFragment = {
  __typename?: 'MessageFragment';
  /** Contains an emote or a mentioned user depending on the text of the fragment. */
  content?: Maybe<FragmentContent>;
  /** Plaintext representation of the fragment. */
  text: Scalars['String'];
};

/** A list of messages. */
export type MessageReplyConnection = {
  __typename?: 'MessageReplyConnection';
  /** Nodes is the list of replies to a message. */
  nodes: Array<Message>;
  /** The total number of replies to a message. */
  totalCount: Scalars['Int'];
};

/**
 * Milestone is a construct is used within a tournament. For a given threshold, when the user
 * cheers at or past this amount, they are able to claim a reward for cheering at this level.
 * Rewards can be fulfilled by different platforms.
 * Types of milestones:
 * - **Global milestone**: for a given threshold, this milestone is reached when cheers from all
 *   users on the channel is greater than or equal to the threshold.
 *   This unlocks a reward for all users who have cheered.
 * - **Individual milestone**: for a given threshold, this milestone is reached when an individual
 *   user's total cheers in the channel is greater than or equal to the threshold.
 *   This unlocks a reward for the individual user who cheered.
 * - **Team milestone**: for a given threshold, this milestone is reached when an individual cheers
 *   for a specific team in total is greater than or equal to the threshold.
 *   This unlocks a reward for the individual user who cheered.
 *
 * NOTE: Should have been named CheeringTournamentMilestone.
 */
export type Milestone = {
  __typename?: 'Milestone';
  /**
   * End date for when a milestone is no longer active.
   * @deprecated No longer supported
   */
  endDate: Scalars['String'];
  /**
   * GraphQL ID of the milestone.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * Whether the milestone is for prime users only.
   * @deprecated No longer supported
   */
  isPrimeOnly: Scalars['Boolean'];
  /**
   * The type of milestone this is for. e.g INDIVIDUAL or GLOBAL.
   * @deprecated No longer supported
   */
  objectiveTag: Scalars['String'];
  /**
   * Threshold that needs to be cheered by an individual to claim reward.
   * @deprecated No longer supported
   */
  participationThreshold: Scalars['Int'];
  /**
   * The subs that this milestone’s completion requires.
   * @deprecated No longer supported
   */
  requiredSubscriptions?: Maybe<Array<SubscriptionProduct>>;
  /**
   * The rewards associated with milestones.
   * @deprecated No longer supported
   */
  rewards: Array<TournamentReward>;
  /**
   * Start date for when a milestone is active.
   * @deprecated No longer supported
   */
  startDate: Scalars['String'];
  /**
   * Threshold that needs to be cheered to claim reward.
   * @deprecated No longer supported
   */
  threshold: Scalars['Int'];
};

/** MobileAdIdentityInput contains mobile device information. */
export type MobileAdIdentityInput = {
  /** deviceInfo is a MobileAdDeviceInfo contains a certain number of attributes required by TIFA. */
  deviceInfo: MobileDeviceInfo;
  /** lmt is limit ad tracking signal read from mobile device. */
  lmt: Scalars['Boolean'];
  /** mAID is the mobile ad identifier. */
  mAID: Scalars['ID'];
  /** platform is an enum that describes the device platform. */
  platform: AdPlatform;
  /** userAgent is a string sent by mobile clients. */
  userAgent: Scalars['String'];
};

/** MobileDeviceInfo contains attributes required by TIFA. */
export type MobileDeviceInfo = {
  /** Hardware brand name, ex. samsung. */
  make: Scalars['String'];
  /** Hardware model, ex: "Galaxy S10". */
  model: Scalars['String'];
  /** Hardware os: ex. "Android". */
  os: Scalars['String'];
  /** Os version number. */
  osVersion: Scalars['String'];
};

/** MobileView holds the view configuration of an extension if mobile is supported. */
export type MobileView = ExtensionView & {
  __typename?: 'MobileView';
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** MobileViewInput holds the view configuration of an extension if mobile is supported. */
export type MobileViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** Paginated list of moderators of a channel. */
export type ModConnection = {
  __typename?: 'ModConnection';
  /** The elements of the list. */
  edges: Array<ModEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Element in a list of moderators of a channel. */
export type ModEdge = {
  __typename?: 'ModEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** Timestamp of when the moderator status was granted. */
  grantedAt: Scalars['Time'];
  /** Whether the moderator is connected to the channel's chat. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** The user that is a moderator. */
  node: User;
};

/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModLogs = {
  __typename?: 'ModLogs';
  /** The comments left by moderators on a specified user on the given channel. */
  comments?: Maybe<ModLogsCommentConnection>;
  /** The chat history for an specified user on a given channel. */
  messagesBySender?: Maybe<ModLogsMessageConnection>;
  /** The chat moderation history on a specified user on the given channel. */
  targetedModActions?: Maybe<ModLogsTargetedModActionsConnection>;
};


/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModLogsCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
  targetID: Scalars['ID'];
};


/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModLogsMessagesBySenderArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAutoModCaughtMessages?: InputMaybe<Scalars['Boolean']>;
  includeMessageCount?: InputMaybe<Scalars['Boolean']>;
  includeTargetedActions?: InputMaybe<Scalars['Boolean']>;
  order?: InputMaybe<SortOrder>;
  senderID: Scalars['ID'];
};


/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModLogsTargetedModActionsArgs = {
  actionType: ModLogsAction;
  targetID: Scalars['ID'];
};

/** ModLogsAccess defines the access level of a channel role to the channel's moderator logs. */
export type ModLogsAccess = {
  __typename?: 'ModLogsAccess';
  /** The access level to moderator logs. */
  accessLevel: ModLogsAccessLevel;
  /** The user role. */
  channelRole: ChannelUserRole;
};

/** Access levels to moderator logs. */
export enum ModLogsAccessLevel {
  /** User cannot read moderator logs or create new entries. */
  None = 'NONE',
  /** User can read moderator log entries. */
  Read = 'READ',
  /** User can read and create moderator log entries. */
  Write = 'WRITE'
}

/** ModLogsAction represents the recorded actions a channel moderator takes on a channel. */
export enum ModLogsAction {
  /** Channel Mod approves an automod caught message. */
  AllowMessage = 'ALLOW_MESSAGE',
  /** Channel Mod chat bans a user. */
  BanUser = 'BAN_USER',
  /** Channel Mod changes. */
  ChangeChannelRules = 'CHANGE_CHANNEL_RULES',
  /** Channel Mod creates a mod comment about a user. */
  Comment = 'COMMENT',
  /** Channel Mod denies an automod caught message. */
  DenyMessage = 'DENY_MESSAGE',
  /** Default Action. */
  InvalidAction = 'INVALID_ACTION',
  /** Channel Mod sets chat mode. */
  SetChannelMode = 'SET_CHANNEL_MODE',
  /** Channel Mod chat timeouts a user. */
  TimeoutUser = 'TIMEOUT_USER',
  /** Channel Mod chat unbans a user. */
  UnbanUser = 'UNBAN_USER',
  /** Channel Mod chat untimeouts a user. */
  UntimeoutUser = 'UNTIMEOUT_USER',
  /** Channel Mod updates mod terms. */
  UpdateModeratedTerms = 'UPDATE_MODERATED_TERMS'
}

/** ModLogsCommentsEntry defines an entry of a user's moderation history on a channel. */
export type ModLogsComment = {
  __typename?: 'ModLogsComment';
  /** Author is the moderator that created the comment. */
  author?: Maybe<User>;
  /** Channel is where the moderator comment was created. */
  channel?: Maybe<User>;
  /** Details about the moderator comment. */
  details?: Maybe<ModLogsCommentDetails>;
  /** UUID of the moderator comment. */
  id: Scalars['ID'];
  /** Target is the target user of the moderator comment. */
  target?: Maybe<User>;
  /** Timestamp when comment was created. */
  timestamp: Scalars['Time'];
};

/** Paginated list of moderator comments on a user in a channel. */
export type ModLogsCommentConnection = {
  __typename?: 'ModLogsCommentConnection';
  /** The elements of the list. */
  edges?: Maybe<Array<ModLogsCommentEdge>>;
  /** Information about this page of mod logs. */
  pageInfo: PageInfo;
};

/** ModLogsCommentDetails contains the details of a moderator comment. */
export type ModLogsCommentDetails = {
  __typename?: 'ModLogsCommentDetails';
  /** Body of the comment. */
  text?: Maybe<Scalars['String']>;
};

/** Element in a list of moderator comments on a user in a channel. */
export type ModLogsCommentEdge = {
  __typename?: 'ModLogsCommentEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A moderator comment on a user in a channel. */
  node?: Maybe<ModLogsComment>;
};

/** A message sent from a user to a room. */
export type ModLogsMessage = {
  __typename?: 'ModLogsMessage';
  /** The text and emoticon content of a message. */
  content: ModLogsMessageContent;
  /** UUID of the message. */
  id: Scalars['ID'];
  /** The user that sent the message. */
  sender?: Maybe<User>;
  /** Time the message was sent. */
  sentAt: Scalars['Time'];
};

/** Paginated list of messages from a single sender in a channel. */
export type ModLogsMessageConnection = {
  __typename?: 'ModLogsMessageConnection';
  /** The elements of the list. */
  edges: Array<ModLogsMessageEdge>;
  /**
   * The partial count of messages (up to 1000).
   * Empty if includeMessageCount was not set when the query was requested.
   */
  messageCount?: Maybe<Scalars['Int']>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** The content of a user's message to a room. */
export type ModLogsMessageContent = {
  __typename?: 'ModLogsMessageContent';
  /** Parsed list of fragments in the message, include emotes, mentions, and plaintext. */
  fragments: Array<ModLogsMessageFragment>;
  /** String representation of the user message. */
  text: Scalars['String'];
};

/** Element in a list of messages. */
export type ModLogsMessageEdge = {
  __typename?: 'ModLogsMessageEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The message or targeted moderation action. */
  node?: Maybe<ModLogsMessageResult>;
};

/** One parsed part of a message, which may be an emote, mention, or plaintext. */
export type ModLogsMessageFragment = {
  __typename?: 'ModLogsMessageFragment';
  /** Contains an emote or a mentioned user depending on the text of the fragment. */
  content?: Maybe<FragmentContent>;
  /** Plaintext representation of the fragment. */
  text: Scalars['String'];
};

/** ModLogsMessageResult defines the types of entries that appear as mod log messages: Mod Logs (Chat) Messages and Targeted Mod Actions. */
export type ModLogsMessageResult = AutoModCaughtMessage | ModLogsMessage | ModLogsTargetedModActionsEntry;

/** Paginated list of mod logs of a user on a channel. */
export type ModLogsTargetedModActionsConnection = {
  __typename?: 'ModLogsTargetedModActionsConnection';
  /**
   * The partial count of targeted mod actions (bans or timeouts), up to 100.
   * Does not count undo actions (unbans or untimeouts).
   */
  actionCount: Scalars['Int'];
  /** The elements of the list. */
  edges?: Maybe<Array<ModLogsTargetedModActionsEdge>>;
  /** Information about this page of mod logs. */
  pageInfo: PageInfo;
};

/** Element in a list of mod logs of a user on a channel. */
export type ModLogsTargetedModActionsEdge = {
  __typename?: 'ModLogsTargetedModActionsEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** A mod log of the user. */
  node?: Maybe<ModLogsTargetedModActionsEntry>;
};

/** ModLogsTargetedModActionsEntry defines an entry of a user's moderation history on a channel. */
export type ModLogsTargetedModActionsEntry = {
  __typename?: 'ModLogsTargetedModActionsEntry';
  /** Action is the mod action of the entry. */
  action: ModLogsAction;
  /** Channel is where the mod action was taken. */
  channel?: Maybe<User>;
  /** Details about the mod action. */
  details?: Maybe<TargetedModActionDetails>;
  /** The UUID of the entry. */
  id: Scalars['ID'];
  /** Target is the target user of the mod action. */
  target?: Maybe<User>;
  /** Timestamp when entry was created. */
  timestamp: Scalars['Time'];
  /** User is the mod that created the action. */
  user?: Maybe<User>;
};

/** ModUserError contains details about a client error that occurred. */
export type ModUserError = {
  __typename?: 'ModUserError';
  /** The enum indicating what error has occurred. */
  code: ModUserErrorCode;
};

/** ModUserErrorCode defines a client error that occurred while adding a moderator. */
export enum ModUserErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The requesting user does not have permission to add a moderator in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The target user is already a moderator. */
  TargetAlreadyMod = 'TARGET_ALREADY_MOD',
  /** The target user is banned or timed out in this channel. */
  TargetIsChatBanned = 'TARGET_IS_CHAT_BANNED',
  /** The target user does not exist or has a suspended account. */
  TargetNotFound = 'TARGET_NOT_FOUND'
}

/** ModUserInput contains the parameters to add a user as a moderator to a channel. */
export type ModUserInput = {
  /** The channel that the user will be added as a moderator to. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user that will be added as a moderator.
   * Either targetID or targetLogin must be provided.
   */
  targetID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user that will be added as a moderator.
   * Either targetID or targetLogin must be provided.
   */
  targetLogin?: InputMaybe<Scalars['String']>;
};

/** ModUserPayload is the response when adding a user as a moderator. */
export type ModUserPayload = {
  __typename?: 'ModUserPayload';
  /** The channel that the user is added as a moderator to. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<ModUserError>;
  /** The user that is added as a moderator. */
  target?: Maybe<User>;
};

/** ModViewNewsfeedEntry is an entry that displays content for the Mod View page's "What's New" feed. */
export type ModViewNewsfeedEntry = {
  __typename?: 'ModViewNewsfeedEntry';
  /** content is localized text content for the changelog entry. */
  content: Scalars['String'];
  /** iconURL is the url for the entry's icon image. */
  iconURL?: Maybe<Scalars['String']>;
  /** id is a unique human readable slug for the entry e.g. "squad-stream". */
  id: Scalars['ID'];
  /** linkText is the text that the linkURL should display. */
  linkText?: Maybe<Scalars['String']>;
  /** linkURL is an optional link for more content for this changelog entry. */
  linkURL?: Maybe<Scalars['String']>;
  /** position is where entry should be located within changelog entries of the same date. */
  position: Scalars['Int'];
  /** publishedAt is the timestamp that the changelog entry was published. */
  publishedAt?: Maybe<Scalars['Time']>;
  /** title is the localized title of the changelog entry. */
  title: Scalars['String'];
};

/** Settings for Mod View Page. */
export type ModViewSettings = {
  __typename?: 'ModViewSettings';
  /** Date that tuorial was SEEN (nullable when tutorial is dismissed or unseen). */
  tutorialSeenAt?: Maybe<Scalars['Time']>;
  /** Setting to store whether the user has completed the mod view tutorial. */
  tutorialState?: Maybe<TutorialState>;
};

/** ModerationAction represents the recorded actions a channel moderator takes on a channel. */
export enum ModerationAction {
  /** Moderator allows message caught by Automod. */
  AllowMessage = 'ALLOW_MESSAGE',
  /** Moderator approves unban request. */
  ApproveUnbanRequest = 'APPROVE_UNBAN_REQUEST',
  /** Moderator changes Automod settings levels. */
  AutomodLevelChange = 'AUTOMOD_LEVEL_CHANGE',
  /** Moderator bans a user. */
  BanUser = 'BAN_USER',
  /** Moderator adds terms to Automod blocked list. */
  BlockedTermAdd = 'BLOCKED_TERM_ADD',
  /** Moderator removes terms to Automod blocked list. */
  BlockedTermRemove = 'BLOCKED_TERM_REMOVE',
  /** Moderator clears chat. */
  ChatClear = 'CHAT_CLEAR',
  /** Moderator creates a mod comment about a user. */
  Comment = 'COMMENT',
  /** Moderator deletes a chat message. */
  DeleteMessage = 'DELETE_MESSAGE',
  /** Moderator denies message caught by Automod. */
  DenyMessage = 'DENY_MESSAGE',
  /** Moderator denies unban request. */
  DenyUnbanRequest = 'DENY_UNBAN_REQUEST',
  /** Moderator turns emotes only chat off. */
  EmotesOnlyOff = 'EMOTES_ONLY_OFF',
  /** Moderator turns chat to motes only. */
  EmotesOnlyOn = 'EMOTES_ONLY_ON',
  /** Moderator turns followers only chat off. */
  FollowersOnlyOff = 'FOLLOWERS_ONLY_OFF',
  /** Moderator turns chat to followers only. */
  FollowersOnlyOn = 'FOLLOWERS_ONLY_ON',
  /** Moderator hosts another channel. */
  Host = 'HOST',
  /** Default Action. */
  InvalidAction = 'INVALID_ACTION',
  /** Moderator mods a user. */
  ModUser = 'MOD_USER',
  /** Moderator adds terms to Automod permitted list. */
  PermittedTermAdd = 'PERMITTED_TERM_ADD',
  /** Moderator removes terms to Automod permitted list. */
  PermittedTermRemove = 'PERMITTED_TERM_REMOVE',
  /** Moderator raids another channel. */
  Raid = 'RAID',
  /** Moderator turns slow off in chat. */
  SlowOff = 'SLOW_OFF',
  /** Moderator slows chat. */
  SlowOn = 'SLOW_ON',
  /** Moderator turns subscribers only chat off. */
  SubsOnlyOff = 'SUBS_ONLY_OFF',
  /** Moderator turns chat to subscribers only. */
  SubsOnlyOn = 'SUBS_ONLY_ON',
  /** Moderator timeouts a user. */
  TimeoutUser = 'TIMEOUT_USER',
  /** Moderator unbans a user. */
  UnbanUser = 'UNBAN_USER',
  /** Moderator unhosts another channel. */
  Unhost = 'UNHOST',
  /** Moderator turns unique only chat off. */
  UniqueOff = 'UNIQUE_OFF',
  /** Moderator turns unique only chat on. */
  UniqueOn = 'UNIQUE_ON',
  /** Moderator unmods a user. */
  UnmodUser = 'UNMOD_USER',
  /** Moderator unraids another channel. */
  Unraid = 'UNRAID',
  /** Moderator untimeouts a user. */
  UntimeoutUser = 'UNTIMEOUT_USER',
  /** Moderator makes user not vip. */
  UnvipUser = 'UNVIP_USER',
  /** Moderator makes user vip. */
  VipUser = 'VIP_USER'
}

/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModerationLogs = {
  __typename?: 'ModerationLogs';
  /** The moderation actions that have been take in the given channel. */
  actions?: Maybe<ChannelModerationActionConnection>;
};


/** An interface to query subsets of the moderation logs information for a given channel. */
export type ModerationLogsActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
};

/** Movie metadata. */
export type MovieDetails = {
  __typename?: 'MovieDetails';
  /** Total length of the content. */
  durationSeconds?: Maybe<Scalars['Int']>;
};

/** A multiplayer ad offer is an ad offer. */
export type MultiplayerAdOffer = {
  __typename?: 'MultiplayerAdOffer';
  /** The duration of the ad in seconds. */
  adDurationSeconds: Scalars['Int'];
  /** The name of the brand associated with the ad. */
  brandName?: Maybe<Scalars['String']>;
  /** The message to be display to the broadcaster. */
  broadcasterMessage?: Maybe<Scalars['String']>;
  /** How much preroll free time will be credited to the creator for running this ad offer. */
  creditDurationSeconds?: Maybe<Scalars['Int']>;
  /** When the offer expires. */
  expiresAt: Scalars['Time'];
  /** The offer's unique identifier. */
  id: Scalars['ID'];
  /** If offer has reward, the max rate for reward. (e.g. vote per bits for polling). */
  rewardsMaxRate?: Maybe<Scalars['Float']>;
  /** If offer has reward, the min rate for reward. (e.g. vote per bits for polling). */
  rewardsMinRate?: Maybe<Scalars['Float']>;
};

/**
 * Multi-view content attribute(s) are used to augment the multi-view experience.
 * they are used for filterings and groupings of chanlets to help viewers find content that they are interested in.
 */
export type MultiviewContentAttribute = {
  __typename?: 'MultiviewContentAttribute';
  /** childIDs is an optional list of child content attribute ids. */
  childIDs?: Maybe<Array<Scalars['ID']>>;
  /** Time when this content attribute is created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** id is a unique identifier generated on the server side. */
  id: Scalars['ID'];
  /** URL to the image (icon) of the content attribute. */
  imageURL?: Maybe<Scalars['String']>;
  /** key is a grouping identifier for content attributes of the same type. */
  key: Scalars['String'];
  /** name is a human-readable string of the content attribute type. */
  name: Scalars['String'];
  /** ownerChannel is the channel that this content attribute is created under. */
  ownerChannel?: Maybe<Channel>;
  /** parentID is an optional pointer to specify the parent attribute. */
  parentID?: Maybe<Scalars['ID']>;
  /** parentKey is an optional pointer to specifiy the key of the parent attribute. */
  parentKey?: Maybe<Scalars['String']>;
  /** Time when this content attribute is last modified. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** value is the human-readble value of the attribute value. */
  value: Scalars['String'];
  /** valueShortName is an optional abbreviation of value. */
  valueShortName?: Maybe<Scalars['String']>;
};

/** Contains all information to create a new content attribute. */
export type MultiviewContentAttributeParams = {
  /** Optional list of child content attribute ids. */
  childIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Unique identifier. */
  id?: InputMaybe<Scalars['ID']>;
  /** Optional an URL to the icon of this content attribute. */
  imageURL?: InputMaybe<Scalars['String']>;
  /** Indicates the type of the attribute. */
  key: Scalars['String'];
  /** Human-readable name of the attribute. */
  name: Scalars['String'];
  /** The channel that the content attribute is created under. */
  ownerChannelID?: InputMaybe<Scalars['ID']>;
  /** Optional pointer to a parent content attribute instance. */
  parentID?: InputMaybe<Scalars['ID']>;
  /** Optional pointer to a parent content attribute key. */
  parentKey?: InputMaybe<Scalars['String']>;
  /** value of the attribute. */
  value: Scalars['String'];
  /** Optional abbreviation of value. */
  valueShortName?: InputMaybe<Scalars['String']>;
};

/** Operations to update data in the Twitch API. */
export type Mutation = {
  __typename?: 'Mutation';
  /** acceptFriendRequest accepts a friend request from the target user to the authenticated user, creating a new Friend relationship. */
  acceptFriendRequest?: Maybe<AcceptFriendRequestPayload>;
  /** AcceptOrganizationInvite accepts an invite to an organization and the user is added as member to that organization. */
  acceptOrganizationInvite?: Maybe<AcceptOrganizationInvitePayload>;
  /** Accept program agreement during payout onboarding. */
  acceptProgramAgreement?: Maybe<AcceptProgramAgreementPayload>;
  /**
   * acceptSquadStreamInvitation allows a user that has recieved a squad stream invitation to accept and join
   * the squad stream.
   */
  acceptSquadStreamInvitation?: Maybe<AcceptSquadStreamInvitationPayload>;
  /**
   * Acknowledge the result of a Prediction. Only the user who made the Prediction can acknowledge the result.
   * This should be triggered automatically when the result of a Prediction is displayed on screen, either from a
   * User Notice or by viewing the Channel Points panel. Because this has the potential to trigger a thundering herd, as
   * every participant in a Prediction Event will see the results at the same time, clients should automatically jitter
   * this call by waiting a random duration between 0-60 seconds before making this mutation.
   */
  acknowledgePredictionResult?: Maybe<AcknowledgePredictionResultPayload>;
  /** acknowledgeSubscriptionState allow to apply Acknowledged status to the provided subscription. */
  acknowledgeSubscriptionState?: Maybe<AcknowledgeSubscriptionStatePayload>;
  /**
   * acknowledgeUnbanRequest allows a user to acknowledge their unban request has been approved, and can now
   * rejoin a channel's chat after being unbanned.
   */
  acknowledgeUnbanRequest?: Maybe<AcknowledgeUnbanRequestPayload>;
  /**
   * Activate an extension which has been installed on a channel.
   * @deprecated Should use applyExtensionActivations instead
   */
  activateExtension?: Maybe<ActivateExtensionPayload>;
  /** Adds to a user's list of channelIDs to autohost. */
  addAutohostChannels?: Maybe<AddAutohostChannelsPayload>;
  /**
   * addBrowserPushSubscription adds a browser push subscription for receiving browser (desktop) push notifications.
   * The client must retrieve the input fields from the browser's push notification API. Client's will
   * call this when the user opts-in. A browser push subscription is tied to a user's browser (device).
   * Twitch will use these push subscriptions to send browser push notifications.
   *
   * Spec: https://www.w3.org/TR/push-api/#push-subscription.
   */
  addBrowserPushSubscription?: Maybe<AddBrowserPushSubscriptionPayload>;
  /** Adds a blocked term to a channel. */
  addChannelBlockedTerm?: Maybe<AddChannelBlockedTermPayload>;
  /** Adds a permitted term to a channel. */
  addChannelPermittedTerm?: Maybe<AddChannelPermittedTermPayload>;
  /** addCollectionItem adds an item to a collection. */
  addCollectionItem?: Maybe<AddCollectionItemPayload>;
  /** Add CompetitionPhase to a competition. */
  addCompetitionPhase?: Maybe<AddCompetitionPhasePayload>;
  /** Add CompetitionPlayer to a competition. */
  addCompetitionPlayer?: Maybe<AddCompetitionPlayerPayload>;
  /** Add CompetitionTeam to a competition. */
  addCompetitionTeam?: Maybe<AddCompetitionTeamPayload>;
  /** addDeviceToken associates a new push notification token to the given user. */
  addDeviceToken?: Maybe<AddDeviceTokenPayload>;
  /** addDropToCampaign allows an organization to add a new drop record to an existing campaign. */
  addDropToCampaign?: Maybe<AddDropToCampaignPayload>;
  /** Grant a user the editor status for a given channel. */
  addEditor?: Maybe<AddEditorPayload>;
  /** Register a radio content play start. */
  addRadioRecentlyPlayed?: Maybe<AddRadioRecentlyPlayedPayload>;
  /**
   * addReaction allows a user to create a reaction for any reactable item in a feed.
   * @deprecated No longer supported
   */
  addReaction?: Maybe<AddReactionPayload>;
  /** addRecommendationFeedback allows a user to add feedback about a recommendation they've received. */
  addRecommendationFeedback?: Maybe<AddRecommendationFeedbackPayload>;
  /** Adds a user to stream on behalf of broadcaster. */
  addStreamAuthorizedUser?: Maybe<AddStreamAuthorizedUserPayload>;
  /** Allocates product keys that a broadcaster may need to complete the bounty. */
  allocateKeysForBounty?: Maybe<AllocateKeysForBountyPayload>;
  /** Allows a message rejected on a channel chat. */
  allowRejectedChatMessage?: Maybe<AllowRejectedChatMessagePayload>;
  /**
   * Allows a cheer rejected on a channel chat.
   * @deprecated logic handled by allowRejectedChatMessage
   */
  allowRejectedCheer?: Maybe<AllowRejectedCheerPayload>;
  /**
   * Apply activation state to a subset of installed extensions. In order to deactivate an installed extension,
   * simply pass a null value in the anchor.
   */
  applyExtensionActivations?: Maybe<ApplyExtensionActivationsPayload>;
  /** Approve a request to be unbanned from a channel-banned user. */
  approveUnbanRequest?: Maybe<ApproveUnbanRequestPayload>;
  /** Archives a chanlet to remove the chanlet from the parent channel. */
  archiveChanlet?: Maybe<ArchiveChanletPayload>;
  /** archiveCommunityPointsCommunityGoal archives a Community Points Community Goal. */
  archiveCommunityPointsCommunityGoal?: Maybe<ArchiveCommunityPointsCommunityGoalPayload>;
  /** Archive a poll with the given poll id. */
  archivePoll?: Maybe<ArchivePollPayload>;
  /** Archive the current poll in a channel. */
  archivePollInChannel?: Maybe<ArchivePollInChannelPayload>;
  /** Assign an emote to a bits tier. */
  assignEmoteToBitsTier?: Maybe<AssignEmoteToBitsTierPayload>;
  /** Assign an emote to a subscription product. */
  assignEmoteToSubscriptionProduct?: Maybe<AssignEmoteToSubscriptionProductPayload>;
  /**
   * Assign a billing manager to an extension.
   * The billing manager is the organization's Owner or member with Billing_Manager role that is ready to receive
   * payments for the monetized extension within an organization.
   */
  assignExtensionBillingManager?: Maybe<AssignExtensionBillingManagerPayload>;
  /** Bans a user from chat room permanently or for an specified period of time. */
  banUserFromChatRoom?: Maybe<BanUserFromChatRoomPayload>;
  /** banVideoCommenter bans a user from commenting on a video. */
  banVideoCommenter?: Maybe<BanVideoCommenterPayload>;
  /** beginUseBitsInExtension starts a bits transaction in an extension. */
  beginUseBitsInExtension?: Maybe<BeginUseBitsInExtensionPayload>;
  /** Blocks target user from communicating with the current user. */
  blockUser?: Maybe<BlockUserPayload>;
  /** Approve a list of unban requests on a channel. */
  bulkApproveUnbanRequest?: Maybe<BulkApproveUnbanRequestPayload>;
  /** Deny a list of unban requests on a channel. */
  bulkDenyUnbanRequest?: Maybe<BulkDenyUnbanRequestPayload>;
  /** Cancel all active boosts on a channel. */
  cancelActiveBoostOrders?: Maybe<CancelActiveBoostOrdersPayload>;
  /**
   * cancelBounty allows a user to cancel a claimed bounty.
   * If the user has not met the requirements to cancel the bounty, an error will be returned.
   */
  cancelBounty?: Maybe<CancelBountyPayload>;
  /** cancelFriendRequest destroys a friend request relationship from the authenticated user to the target user. */
  cancelFriendRequest?: Maybe<CancelFriendRequestPayload>;
  /** Cancel a current payout onboarding workflow. */
  cancelPayoutOnboardingWorkflow?: Maybe<CancelPayoutOnboardingWorkflowPayload>;
  /** Cancel a Prediction Event. */
  cancelPredictionEvent?: Maybe<CancelPredictionEventPayload>;
  /** Cancel a raid. */
  cancelRaid?: Maybe<CancelRaidPayload>;
  /** cancelSubscriptionGift allows the current user to cancel their gifted subscription to a channel. */
  cancelSubscriptionGift?: Maybe<CancelSubscriptionGiftPayload>;
  /** cancelUnbanRequest allows the user to cancel their provided unban request. */
  cancelUnbanRequest?: Maybe<CancelUnbanRequestPayload>;
  /** changeUsername allows a user to update their username(login). */
  changeUsername?: Maybe<ChangeUsernamePayload>;
  /**
   * claimBounty allows a user to claim a bounty from a campaign (e.g. Stream a Game Campaign).
   * If the user has not met the requirements to claim it, an error will be returned.
   */
  claimBounty?: Maybe<ClaimBountyPayload>;
  /**
   * claimCommunityPoints allows a user to claim community points that they have available in a channel.
   * If the user does not have a claim available, an error will be returned.
   */
  claimCommunityPoints?: Maybe<ClaimCommunityPointsPayload>;
  /** claimDropRewards allows a user to attempt to claim their rewards from a Drops 2.0 drop. */
  claimDropRewards?: Maybe<ClaimDropRewardsPayload>;
  /** claimPrimeOffer allows a user to create their entitlement to the given offer/content. */
  claimPrimeOffer?: Maybe<ClaimPrimeOfferPayload>;
  /** clearUnreadFriendRequests marks all friend requests for the authenticated user as read. */
  clearUnreadFriendRequests?: Maybe<ClearUnreadFriendRequestsPayload>;
  /** cloneExtensionDiscoveryData copies the discovery data of an extension from one version to another. */
  cloneExtensionDiscoveryData?: Maybe<CloneExtensionDiscoveryDataPayload>;
  /** cloneExtensionManifest creates a new version of an extension that is a clone of a previous version. */
  cloneExtensionManifest?: Maybe<CloneExtensionManifestPayload>;
  /** connectAdIdentity creates an Amazon ad identity for the authenticated user. */
  connectAdIdentity?: Maybe<ConnectAdIdentityPayload>;
  /** contributeCommunityPointsCommunityGoal contributes Community Points towards a Community Goal. */
  contributeCommunityPointsCommunityGoal?: Maybe<ContributeCommunityPointsCommunityGoalPayload>;
  /** contributeToChallenge allows the user to contribute Bits towards a Challenge. */
  contributeToChallenge?: Maybe<ContributeToChallengePayload>;
  /** createArchivedEmote creates an archived emote object, which is not associated with any products, and associates that emote with a set of image assets. */
  createArchivedEmote?: Maybe<CreateArchivedEmotePayload>;
  /** createBadgeFlair creates a custom badge flair asset for a creator's channel and specified tier. */
  createBadgeFlair?: Maybe<CreateBadgeFlairPayload>;
  /** createBitsChallengeConditionForExtension creates a Bits condition on behalf of a user by an extension. */
  createBitsChallengeConditionForExtension?: Maybe<CreateBitsChallengeConditionForExtensionPayload>;
  /** createBitsChallengeConditionParticipantForExtension creates a Bits condition participant on behalf of a user by an extension. */
  createBitsChallengeConditionParticipantForExtension?: Maybe<CreateBitsChallengeConditionParticipantForExtensionPayload>;
  /** createBountyCampaign creates a campaign for Bounty Board. */
  createBountyCampaign?: Maybe<CreateBountyCampaignPayload>;
  /** createBountyCampaignUploadConfig creates a upload configuration for assets for bounty campaigns. */
  createBountyCampaignUploadConfig?: Maybe<CreateBountyCampaignUploadConfigPayload>;
  /** createCelebration creates a new celebration for a channel. */
  createCelebration?: Maybe<CreateCelebrationPayload>;
  /** createChanlet creates a new chanlet for a Channel. */
  createChanlet?: Maybe<CreateChanletPayload>;
  /** createClip creates a new clip with the authenticated user as the curator. */
  createClip?: Maybe<CreateClipPayload>;
  /** createCollection creates a collection with a provided collection name. */
  createCollection?: Maybe<CreateCollectionPayload>;
  /** createCommunityPointsCommunityGoal creates a Community Points Community Goal. */
  createCommunityPointsCommunityGoal?: Maybe<CreateCommunityPointsCommunityGoalPayload>;
  /** Create a custom Community Points reward in a channel. */
  createCommunityPointsCustomReward?: Maybe<CreateCommunityPointsCustomRewardPayload>;
  /**
   * Generate image upload information (URL and upload ID) for uploading a Community Points image.
   * Can upoload a new Community Points icon, an automatic reward icon, or a custom reward icon.
   */
  createCommunityPointsImageUploadInfo?: Maybe<CreateCommunityPointsImageUploadInfoPayload>;
  /** Create a Competition. */
  createCompetition?: Maybe<CreateCompetitionPayload>;
  /** createContentTags creates the tags specified and associates it with the piece of content specified. */
  createContentTags?: Maybe<CreateContentTagsPayload>;
  /** Creates a new custom Mosaic layout with the specified properties for the current user. */
  createDashboardViewMosaicLayout?: Maybe<CreateDashboardViewMosaicLayoutPayload>;
  /** createDropBenefit creates a benefit that can be used within a drop campaign. */
  createDropBenefit?: Maybe<CreateDropBenefitPayload>;
  /** createDropCampaign creates a Drop Campaign owned by an organization. */
  createDropCampaign?: Maybe<CreateDropCampaignPayload>;
  /**
   * createDropImageUploadURL creates and returns a url to use on the client side to upload drops images.
   * @deprecated use dropImageUpload
   */
  createDropImageUploadURL?: Maybe<CreateDropImageUploadUrlPayload>;
  /** createExtensionClient creates an extension with a provided name. */
  createExtensionClient?: Maybe<CreateExtensionClientPayload>;
  /** createExtensionImageUploadInfo creates and returns a url and uploadId to use on the client side to upload extension logo, taskbar, discovery and screenshot images. */
  createExtensionImageUploadInfo?: Maybe<CreateExtensionImageUploadInfoPayload>;
  /** createExtensionZipUploadInfo creates and returns a url and uploadId to use on the client side to upload zip files. */
  createExtensionZipUploadInfo?: Maybe<CreateExtensionZipUploadInfoPayload>;
  /** createFriendRequest creates a friend request relationship between the authenticated user and the target user. */
  createFriendRequest?: Maybe<CreateFriendRequestPayload>;
  /** createGameApplication creates an application request to add game to a certain organization. */
  createGameApplication?: Maybe<CreateGameApplicationPayload>;
  /** createGameBoxArtUploadURL returns a URL that can be used to upload the game box art asset, for developers with access to the game box art image. */
  createGameBoxArtUploadURL?: Maybe<CreateGameBoxArtUploadUrlPayload>;
  /** CreateLoyaltyBadge creates a new badge with these settings. */
  createLoyaltyBadge?: Maybe<CreateLoyaltyBadgePayload>;
  /** createLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to. */
  createLoyaltyBadgeUploadConfig?: Maybe<CreateLoyaltyBadgeUploadConfigPayload>;
  /**
   * createModeratorComment creates and returns a comment on the target user in the given channel.
   * Requester must be a moderator or higher in the channel.
   */
  createModeratorComment?: Maybe<CreateModeratorCommentPayload>;
  /** createMultiVideoHighlight creates a video of type Highlight with multi-segment support from an Archive type video. */
  createMultiVideoHighlight?: Maybe<CreateMultiVideoHighlightPayload>;
  /** createMultiviewContentAttributeImageUploadConfig creates and returns a upload configuration for uploading and retrieving content attribute images. */
  createMultiviewContentAttributeImageUploadConfig?: Maybe<CreateMultiviewContentAttributeImageUploadConfigPayload>;
  /** createMultiviewContentAttributes creates new content attributes with server assigned IDs. */
  createMultiviewContentAttributes?: Maybe<CreateMultiviewContentAttributesPayload>;
  /** CreateOrganizationApplicaton creates a new Twitch Developer Organization application with the authenticated user as the submitter. */
  createOrganizationApplication?: Maybe<CreateOrganizationApplicationPayload>;
  /** CreateOrganizationInvite creates a new invitation to join an existing Twitch Developer Organization. */
  createOrganizationInvite?: Maybe<CreateOrganizationInvitePayload>;
  /** Creates JWT to be used in subsequent drops calls. */
  createOrganizationJWT?: Maybe<CreateOrganizationJwtPayload>;
  /** Adds a user to a developer organization. */
  createOrganizationMember?: Maybe<CreateOrganizationMemberPayload>;
  /** createPanel removes a panel. */
  createPanel?: Maybe<CreatePanelPayload>;
  /** Creates the url that a panel image gets uploaded to. */
  createPanelImageUploadInfo?: Maybe<CreatePanelImageUploadInfoPayload>;
  /** createPartnershipApplication allows a user to create partnership application. */
  createPartnershipApplication?: Maybe<CreatePartnershipApplicationPayload>;
  /** createPoll creates a poll. */
  createPoll?: Maybe<CreatePollPayload>;
  /**
   * createPost creates a new post.
   * @deprecated No longer supported
   */
  createPost?: Maybe<CreatePostPayload>;
  /** Create a new Prediction Event. */
  createPredictionEvent?: Maybe<CreatePredictionEventPayload>;
  /** Create a raid. */
  createRaid?: Maybe<CreateRaidPayload>;
  /** createRewardedVideoToken creates a token used to initialize the truex client application. */
  createRewardedVideoToken?: Maybe<CreateRewardedVideoTokenPayload>;
  /**
   * Creates a new chatroom.
   * @deprecated No longer supported
   */
  createRoom?: Maybe<CreateRoomPayload>;
  /** Create a new schedule. */
  createSchedule?: Maybe<CreateSchedulePayload>;
  /** Create a new schedule segment. */
  createScheduleSegment?: Maybe<CreateScheduleSegmentPayload>;
  /** createSocialMedia creates new social media items for a Channel. */
  createSocialMedia?: Maybe<CreateSocialMediaPayload>;
  /** Creates an invitation to a new or existing squad stream. */
  createSquadStreamInvitation?: Maybe<CreateSquadStreamInvitationPayload>;
  /** createStucco allows a user to create a stucco. */
  createStucco?: Maybe<CreateStuccoPayload>;
  /** createStuccoPack allows the creation a new stucco pack for the channel. */
  createStuccoPack?: Maybe<CreateStuccoPackPayload>;
  /** createUnbanRequest allows a channel-banned user to submit a request to channel moderators to be unbanned. */
  createUnbanRequest?: Maybe<CreateUnbanRequestPayload>;
  /** createVideoAppeal creates an appeal for the tracks that have been flagged for copyrighted music in the video. */
  createVideoAppeal?: Maybe<CreateVideoAppealPayload>;
  /** createVideoBookmark creates a video bookmark. */
  createVideoBookmark?: Maybe<CreateVideoBookmarkPayload>;
  /** createVideoComment creates a video comment. */
  createVideoComment?: Maybe<CreateVideoCommentPayload>;
  /** createVideoHighlight creates a video of type Highlight from an Archive type video. */
  createVideoHighlight?: Maybe<CreateVideoHighlightPayload>;
  /** createVideoThumbnailUploadRequest creates a thumbnail upload request url. */
  createVideoThumbnailUploadRequest?: Maybe<CreateVideoThumbnailUploadRequestPayload>;
  /**
   * Deactivate an extension which has been installed on a channel.
   * @deprecated Should use applyExtensionActivations instead
   */
  deactivateExtension?: Maybe<DeactivateExtensionPayload>;
  /** DeclineOrganizationInvite declines an invite to an organization and the invitation is deleted. */
  declineOrganizationInvite?: Maybe<DeclineOrganizationInvitePayload>;
  /** deleteAllChannelVideos deletes all videos for a given channel id for the authenticated users. */
  deleteAllChannelVideos?: Maybe<DeleteAllChannelVideosPayload>;
  /** Deletes a bits badge tier emoticon. */
  deleteBitsBadgeTierEmoticon?: Maybe<DeleteBitsBadgeTierEmoticonPayload>;
  /** Deletes a celebration from the channel. */
  deleteCelebration?: Maybe<DeleteCelebrationPayload>;
  /** Deletes a blocked term from a channel. */
  deleteChannelBlockedTerm?: Maybe<DeleteChannelBlockedTermPayload>;
  /** Deletes clips from a channel. */
  deleteChannelClips?: Maybe<DeleteChannelClipsPayload>;
  /** Deletes a permitted term from a channel. */
  deleteChannelPermittedTerm?: Maybe<DeleteChannelPermittedTermPayload>;
  /** deleteChatMessage deletes a single message from stream chat. */
  deleteChatMessage?: Maybe<DeleteChatMessagePayload>;
  /** Deletes a custom cheermote tier from a channel. */
  deleteCheermoteTier?: Maybe<DeleteCheermoteTierPayload>;
  /**
   * deleteClips allows a user to delete clips by slugs, video id, or broadcast id.
   * Only the slug and id can be accessed from the list of deleted clips.
   */
  deleteClips?: Maybe<DeleteClipsPayload>;
  /** deleteCollection performs a delete on the collection with the provided ID. */
  deleteCollection?: Maybe<DeleteCollectionPayload>;
  /** deleteCommunityPointsCommunityGoal deletes a Community Points Community Goal. */
  deleteCommunityPointsCommunityGoal?: Maybe<DeleteCommunityPointsCommunityGoalPayload>;
  /** Deletes a custom Community Points reward from a channel. */
  deleteCommunityPointsCustomReward?: Maybe<DeleteCommunityPointsCustomRewardPayload>;
  /** Delete a Competition. */
  deleteCompetition?: Maybe<DeleteCompetitionPayload>;
  /** deleteContentTags removes the tags specified and associates it with the piece of content specified. */
  deleteContentTags?: Maybe<DeleteContentTagsPayload>;
  /**
   * Deletes the default payment method for a user.
   * Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers.
   */
  deleteDefaultPaymentMethod?: Maybe<DeleteDefaultPaymentMethodPayload>;
  /** deleteDeviceToken deletes a previously added device token by user and device token ID. */
  deleteDeviceToken?: Maybe<DeleteDeviceTokenPayload>;
  /** deleteDrop allows a drop organization owner to delete a drop from their organization. */
  deleteDrop?: Maybe<DeleteDropPayload>;
  /** deleteDropCampaign allows a drop campaign owner to delete a drop campaign. */
  deleteDropCampaign?: Maybe<DeleteDropCampaignPayload>;
  /** Deletes a specified emote. */
  deleteEmote?: Maybe<DeleteEmotePayload>;
  /** deleteExtension allows an extension owner to delete an extension. */
  deleteExtension?: Maybe<DeleteExtensionPayload>;
  /** deleteExtensionImage delete extension image assets of the given urls. */
  deleteExtensionImage?: Maybe<DeleteExtensionImagePayload>;
  /**
   * Delete all secrets associated with an extension; this will immediately break all clients until
   * both a new secret rotate is executed and the clients manually refresh themselves. Only use this
   * if a secret is compromised and must be immediately removed from circulation.
   */
  deleteExtensionSecrets?: Maybe<DeleteExtensionSecretsPayload>;
  /** Deletes a Loyalty Badge of a Channel. */
  deleteLoyaltyBadge?: Maybe<DeleteLoyaltyBadgePayload>;
  /**
   * deleteModeratorComment deletes a moderator comment with the given ID.
   * The comment must have been created on the requester's channel.
   */
  deleteModeratorComment?: Maybe<DeleteModeratorCommentPayload>;
  /** deleteMultiviewContentAttributes deletes content attributes with the provided IDs. */
  deleteMultiviewContentAttributes?: Maybe<DeleteMultiviewContentAttributesPayload>;
  /** deleteNotification deletes an onsite notification of the authenticated user. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** deletePanel removes a panel. */
  deletePanel?: Maybe<DeletePanelPayload>;
  /**
   * deletePost deletes a old post.
   * @deprecated No longer supported
   */
  deletePost?: Maybe<DeletePostPayload>;
  /** deleteRecommendationFeedback deletes all the recommendation feedback that matches the given input. */
  deleteRecommendationFeedback?: Maybe<DeleteRecommendationFeedbackPayload>;
  /**
   * Deletes a chatroom.
   * @deprecated No longer supported
   */
  deleteRoom?: Maybe<DeleteRoomPayload>;
  /** Deletes an existing message in a chatroom. */
  deleteRoomMessage?: Maybe<DeleteRoomMessagePayload>;
  /** Delete the entire schedule of a user. */
  deleteSchedule?: Maybe<DeleteSchedulePayload>;
  /** Delete a segment of a schedule of a user. */
  deleteScheduleSegment?: Maybe<DeleteScheduleSegmentPayload>;
  /** deleteSocialMedia deletes a social media item for a Channel. */
  deleteSocialMedia?: Maybe<DeleteSocialMediaPayload>;
  /** deleteSquadStreamInvitation allows a squad stream member to delete a squad stream invitation. */
  deleteSquadStreamInvitation?: Maybe<DeleteSquadStreamInvitationPayload>;
  /** Deletes an authorized user who was allowed to stream on behalf of broadcaster. */
  deleteStreamAuthorizedUser?: Maybe<DeleteStreamAuthorizedUserPayload>;
  /** Deletes clips made by user. */
  deleteUserClips?: Maybe<DeleteUserClipsPayload>;
  /** Deletes a user's creator colors. */
  deleteUserColors?: Maybe<DeleteUserColorsPayload>;
  /**
   * deleteVideoComment performs a delete on the video comment with the provided comment ID.
   * NOTE: this should use an input argument, not define the commentID right here.
   */
  deleteVideoComment?: Maybe<DeleteVideoCommentPayload>;
  /** deleteVideoThumbnail deletes a thumbnail from a video. */
  deleteVideoThumbnail?: Maybe<DeleteVideoThumbnailPayload>;
  /** deleteVideos performs a delete on the list of video ids. */
  deleteVideos?: Maybe<DeleteVideosPayload>;
  /** Denies a message rejected on a channel chat. */
  denyRejectedChatMessage?: Maybe<DenyRejectedChatMessagePayload>;
  /**
   * Denies a cheer rejected on a channel chat.
   * @deprecated logic handled by denyRejectedChatMessage
   */
  denyRejectedCheer?: Maybe<DenyRejectedCheerPayload>;
  /** Deny an unban request from a channel-banned user. */
  denyUnbanRequest?: Maybe<DenyUnbanRequestPayload>;
  /** Deselect channel badge (default to global badge). */
  deselectChannelBadge?: Maybe<DeselectChannelBadgePayload>;
  /** Deselect global badge (default to no badge). */
  deselectGlobalBadge?: Maybe<DeselectGlobalBadgePayload>;
  /** Disables Two Factor Authentication for a Twitch user. Requires sudo authentication. */
  disableTwoFactor?: Maybe<DisableTwoFactorPayload>;
  /** Allows the current user to disable or permanently delete their own account. */
  disableUserAccount?: Maybe<DisableUserAccountPayload>;
  /**
   * dismissFriendRecommendation removes a friend recommendation to the authenticated user without creating a friend
   * request.
   */
  dismissFriendRecommendation?: Maybe<DismissFriendRecommendationPayload>;
  /** Permanently dismiss a ritual token without redeeming it. */
  dismissRitualToken?: Maybe<DismissRitualTokenPayload>;
  /** dismissVideoSuggestedHighlight dismisses the automated highlight suggestion for a video. */
  dismissVideoSuggestedHighlight?: Maybe<DismissVideoSuggestedHighlightPayload>;
  /**
   * dropImageUpload makes a request for a url to upload an image to. The caller can then use the URL to upload an image
   * of their choice for either a drop or a benefit.
   */
  dropImageUpload?: Maybe<DropImageUploadPayload>;
  /**
   * Edits an existing message in a chatroom.
   * @deprecated No longer supported
   */
  editRoomMessage?: Maybe<EditRoomMessagePayload>;
  /**
   * emitCampaignDiscoveryEvent updates a user's progress towards a discovery objective in applicable campaigns.
   * @deprecated No longer supported
   */
  emitCampaignDiscoveryEvent?: Maybe<EmitCampaignDiscoveryEventPayload>;
  /** endUseBitsInExtension completes the bit usage transaction in an extension. */
  endUseBitsInExtension?: Maybe<EndUseBitsInExtensionPayload>;
  /** equipHeroAssets adds the specified assets to a user's hero. */
  equipHeroAssets?: Maybe<EquipHeroAssetsPayload>;
  /** exportVideoToYoutube allows a user to export a video to Youtube. */
  exportVideoToYoutube?: Maybe<ExportVideoToYoutubePayload>;
  /** extensionLinkUser enables or disables the user's identity sharing with an extension. */
  extensionLinkUser?: Maybe<ExtensionLinkUserPayload>;
  /** finalizeCompetitionLobby update's a lobby's state to DONE and progresses the competition. */
  finalizeCompetitionLobby?: Maybe<FinalizeCompetitionLobbyPayload>;
  /** followGame allows a user to follow a game. */
  followGame?: Maybe<FollowGamePayload>;
  /**
   * followUser creates a follow relationship between the authenticated user and
   * the target user.
   */
  followUser?: Maybe<FollowUserPayload>;
  /**
   * generateAnimatedEmote kicks off the generation of animated .gif assets from a given animation preset and static image ids.
   * The user will be notified of success or failure on pubsub.
   */
  generateAnimatedEmote?: Maybe<GenerateAnimatedEmotePayload>;
  /**
   * generateExtensionRatingsCSVReport  asks the ExtensionRatings backend to generate a report and return a filename
   * for that report.  The filename can then be used in follow-up calls to getReportPresignedURL to poll for its
   * completion.  Authenticated on userID:extensionID via OWL in the ExtensionRatings backend.
   */
  generateExtensionRatingsCSVReport?: Maybe<GenerateExtensionRatingsCsvReportPayload>;
  /**
   * generateSecondFactorQRCode generates a new second factor QR code so it can be used to generate OTP for authentication.
   * The mutation requires sudo privilege to be successful.
   */
  generateSecondFactorQRCode?: Maybe<GenerateSecondFactorQrCodePayload>;
  /**
   * generateSubscribersCSV kicks off a background job that will generate a csv containing a list
   * of the channel's subscribers and then will alert the frontend that the csv is ready to
   * download using pubsub. Authenticated on the channelID.
   */
  generateSubscribersCSV?: Maybe<GenerateSubscribersCsvPayload>;
  /** getEmoteUploadConfig makes a request to mako to get emote upload configuration for a user to upload a new emote with. */
  getEmoteUploadConfig?: Maybe<GetEmoteUploadConfigPayload>;
  /** Start a raid. */
  goRaid?: Maybe<GoRaidPayload>;
  /** Grant the VIP status to a user for a channel. */
  grantVIP?: Maybe<GrantVipPayload>;
  /** Host a target channel from a channel. */
  hostTargetChannel?: Maybe<HostTargetChannelPayload>;
  /** Install an extension onto a specific channel. */
  installExtension?: Maybe<InstallExtensionPayload>;
  /** Disable the schedule of a user. */
  interruptSchedule?: Maybe<InterruptSchedulePayload>;
  /** Invalidates authenticated sessions. */
  invalidateAuthenticatedSessions?: Maybe<InvalidateAuthenticatedSessionsPayload>;
  /** Invalidates an association to an email. */
  invalidateEmailAssociation?: Maybe<InvalidateEmailAssociationPayload>;
  /**
   * Joins the channel's chatrooms.
   * @deprecated No longer supported
   */
  joinChannelRooms?: Maybe<JoinChannelRoomsPayload>;
  /** Add a viewer to a source channel's raid. The viewer will be redirected to the target channel when the raid starts. */
  joinRaid?: Maybe<JoinRaidPayload>;
  /**
   * Leaves the channel's chatrooms.
   * @deprecated No longer supported
   */
  leaveChannelRooms?: Maybe<LeaveChannelRoomsPayload>;
  /** Leave a raid for a viewer. */
  leaveRaid?: Maybe<LeaveRaidPayload>;
  /**
   * leaveSquadStream allows a member of a squad stream to leave the squad.  Their stream will be
   * removed from the viewer experience, and they will be free to start/join another squad stream.
   */
  leaveSquadStream?: Maybe<LeaveSquadStreamPayload>;
  /**
   * Link a single sign-on (SSO) app to a user's account.
   * @deprecated Service has been shutdown
   */
  linkSSO?: Maybe<LinkSsoPayload>;
  /** Update a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it. */
  lockPredictionEvent?: Maybe<LockPredictionEventPayload>;
  /** Makes a download URL for an authorized user to download a batch of keys. */
  makeKeyBatchDownloadURL?: Maybe<MakeKeyBatchDownloadUrlPayload>;
  /** Make a prediction on an active Prediction Event. */
  makePrediction?: Maybe<MakePredictionPayload>;
  /** Manually triggers drop in Drops 2.0 system. */
  manuallyTriggerDrop?: Maybe<ManuallyTriggerDropPayload>;
  /** ReadAllCreatorNotifications marks all creator notifications as read. */
  markAllCreatorNotificationsAsRead?: Maybe<MarkAllCreatorNotificationsAsReadPayload>;
  /** ReadAllViewerNotifications marks all viewer notifications as read. */
  markAllViewerNotificationsAsRead?: Maybe<MarkAllViewerNotificationsAsReadPayload>;
  /** Make a user a moderator for a channel. */
  modUser?: Maybe<ModUserPayload>;
  /**
   * orderPanels updates the sort order of the provided panels, the input must be a list of panel ids
   * all of which are owned by the acting user otherwise the request will fail and a generic GraphQL
   * error will be returned.
   */
  orderPanels?: Maybe<OrderPanelsPayload>;
  /**
   * Presign and return a secure S3 URL to download a CSV report for a GAME or EXTENSION.
   * The generated CSV report contains rows for every day after 2018-01-31.
   */
  presignDevInsightsReportURL?: Maybe<PresignDevInsightsReportUrlPayload>;
  /**
   * processAndroidPayment processes an off-platform Android payment (user was charged outside the Twitch platform).
   * See also: processIOSPayment (iOS purchases) and purchaseOffer (on-platform purchases).
   */
  processAndroidPayment?: Maybe<ProcessAndroidPaymentPayload>;
  /**
   * processIOSPayment processes an off-platform iOS payment (user was charged outside the Twitch platform).
   * See also: processAndroidPayment (Android purchases) and purchaseOffer (on-platform purchases).
   */
  processIOSPayment?: Maybe<ProcessIosPaymentPayload>;
  /** publishClip allows a user to permanently edit and update their default clip, viewable to the public. */
  publishClip?: Maybe<PublishClipPayload>;
  /** Publishes a competition to make it visible on the esports page. */
  publishCompetition?: Maybe<PublishCompetitionPayload>;
  /** Publishes a subscription emote to become available with a subscription product. */
  publishSubscriptionEmote?: Maybe<PublishSubscriptionEmotePayload>;
  /**
   * purchaseOffer completes the purchase of an offer made inside the Twitch platform.
   * See also: processAndroidPayment (Android purchases) and processIOSPayment.
   */
  purchaseOffer?: Maybe<PurchaseOfferPayload>;
  /** Submit a rating for a Twitch extension. */
  rateExtension?: Maybe<RateExtensionPayload>;
  /** readNotifications sets the read state to true for one or more onsite notifications of the authenticated user. */
  readNotifications?: Maybe<ReadNotificationsPayload>;
  /** Record an ad event. */
  recordAdEvent?: Maybe<RecordAdEventPayload>;
  /** Redeem a claimable code, like a bits key code to add bits to your account, etc. */
  redeemClaimable?: Maybe<RedeemClaimablePayload>;
  /** Redeem a Community Points custom reward in a channel. */
  redeemCommunityPointsCustomReward?: Maybe<RedeemCommunityPointsCustomRewardPayload>;
  /** Redeem a set of creator gift subscriptions. */
  redeemCreatorGifts?: Maybe<RedeemCreatorGiftsPayload>;
  /**
   * Redeem an available ritual token. Currently, tokens are redeemed by sending
   * a special message to a channel's chat.
   */
  redeemRitualToken?: Maybe<RedeemRitualTokenPayload>;
  /** Submit a Subscription Redemption. */
  redeemSubscription?: Maybe<RedeemSubscriptionPayload>;
  /**
   * redeemTrueXAd processes the result of watching an ad to earn bits.
   * This action can only be taken if an OAuth token is supplied with the request.
   */
  redeemTrueXAd?: Maybe<RedeemTrueXAdPayload>;
  /** refreshExtensionToken is used by our client on a timer to ensure the token doesn't expire while the user is using the site. */
  refreshExtensionToken?: Maybe<RefreshExtensionTokenPayload>;
  /** regenerateStreamKey generates a new stream key for the broadcaster and returns the newly generated stream key. */
  regenerateStreamKey?: Maybe<RegenerateStreamKeyPayload>;
  /** regenerateVerificationCode generates a new verification code and resends the verification message with the new code. */
  regenerateVerificationCode?: Maybe<RegenerateVerificationCodePayload>;
  /** Register payout information during payout onboarding. */
  registerPayoutInformation?: Maybe<RegisterPayoutInformationPayload>;
  /** Starts the registration for second factor authentication for a twitch user. Requires sudo authentication. */
  registerTwoFactor?: Maybe<RegisterTwoFactorPayload>;
  /** Finishes the registration for second factor authentication for a twitch user. Requires sudo authentication. */
  registerTwoFactorConfirmation?: Maybe<RegisterTwoFactorConfirmationPayload>;
  /** rejectFriendRequest destroys a friend request relationship from the target user to the authenticated user. */
  rejectFriendRequest?: Maybe<RejectFriendRequestPayload>;
  /** rejectSquadStreamInvitation allows a user to decline an invitation to join a squad stream. */
  rejectSquadStreamInvitation?: Maybe<RejectSquadStreamInvitationPayload>;
  /** rejectSquadStreamOutOfNetworkInvitations allows a user to decline all out-of-network invitations to join a squad stream. */
  rejectSquadStreamOutOfNetworkInvitations?: Maybe<RejectSquadStreamOutOfNetworkInvitationsPayload>;
  /** Removes channels from a user's AutoHost list. */
  removeAutohostChannels?: Maybe<RemoveAutohostChannelsPayload>;
  /** removeCollectionItem removes an item from a collection. */
  removeCollectionItem?: Maybe<RemoveCollectionItemPayload>;
  /** Remove a phase from a Competition. */
  removeCompetitionPhase?: Maybe<RemoveCompetitionPhasePayload>;
  /** Remove CompetitionPlayer from a competition. */
  removeCompetitionPlayer?: Maybe<RemoveCompetitionPlayerPayload>;
  /** Remove a competition team from a Competition. */
  removeCompetitionTeam?: Maybe<RemoveCompetitionTeamPayload>;
  /** Revoke the editor status from a user for a given channel. */
  removeEditor?: Maybe<RemoveEditorPayload>;
  /** Remove an emote from its assigned group. */
  removeEmoteFromGroup?: Maybe<RemoveEmoteFromGroupPayload>;
  /** Removes a rbac user from a developer organization. */
  removeOrganizationMember?: Maybe<RemoveOrganizationMemberPayload>;
  /**
   * removeReaction removes a reaction created with addReaction.
   * @deprecated No longer supported
   */
  removeReaction?: Maybe<RemoveReactionPayload>;
  /** removeSquadStreamMember allows the owner of a squad stream to remove a member from the squad stream. */
  removeSquadStreamMember?: Maybe<RemoveSquadStreamMemberPayload>;
  /** removeStucco allows the owner of a stucco to remove an inactive stucco from their library. */
  removeStucco?: Maybe<RemoveStuccoPayload>;
  /** reorderCollectionItem reorders an item's position in a collection. */
  reorderCollectionItem?: Maybe<ReorderCollectionItemPayload>;
  /** reportContent allows a user to report content on the site as infringing of our terms of service. */
  reportContent?: Maybe<ReportContentPayload>;
  /** Reports a user for bad behavior in a whisper thread. */
  reportWhisper?: Maybe<ReportWhisperPayload>;
  /**
   * Reports a whisper thread as spam.
   * @deprecated Use reportWhisper
   */
  reportWhisperThread?: Maybe<ReportWhisperThreadPayload>;
  /** Request a ritual token to be issued to the user. */
  requestRitualToken?: Maybe<RequestRitualTokenPayload>;
  /** resendVerificationEmail resends a verification email to the current user. */
  resendVerificationEmail?: Maybe<ResendVerificationEmailPayload>;
  /** resetUsername allows a user to update their flagged username. */
  resetUsername?: Maybe<ResetUsernamePayload>;
  /** Resolve a Prediction Event by specifying the winning option. */
  resolvePredictionEvent?: Maybe<ResolvePredictionEventPayload>;
  /** Respond to a team invitation by accepting or declining. */
  respondToTeamInvitation?: Maybe<RespondToTeamInvitationPayload>;
  /** Enable the schedule of a user. */
  resumeSchedule?: Maybe<ResumeSchedulePayload>;
  /** Revoke the VIP status of a user from a channel. */
  revokeVIP?: Maybe<RevokeVipPayload>;
  /**
   * Request a new extension secret; automatically rotates any current secrets out of service
   * with enough time for extension clients to gracefully switch over.  This function should
   * only be called when you are ready to install the new set of secrets it will return; use
   * GET to view secrets without rotating them.
   */
  rotateExtensionSecrets?: Maybe<RotateExtensionSecretsPayload>;
  /** Runs multiplayer ads on a channel. */
  runMultiplayerAds?: Maybe<RunMultiplayerAdsPayload>;
  /** saveExtensionManifest allows a user to update the manifest for an extension in development. */
  saveExtensionManifest?: Maybe<SaveExtensionManifestPayload>;
  /** Give a competition participant a seed value. */
  seedCompetitionParticipant?: Maybe<SeedCompetitionParticipantPayload>;
  /** Select a user's channel badge for a channel. */
  selectChannelBadge?: Maybe<SelectChannelBadgePayload>;
  /** Select a user's global badge. */
  selectGlobalBadge?: Maybe<SelectGlobalBadgePayload>;
  /** Send a chat message through subscribers-only mode with Channel Points. */
  sendChatMessageThroughSubscriberMode?: Maybe<SendChatMessageThroughSubscriberModePayload>;
  /**
   * sendCheer sends a chat message that contains cheermotes. The message will
   * be processed, bits deducted from the authenticated user's balance, and then the
   * message will be passed on to the chat service (client shouldn't send the message itself).
   * This action can only be taken if an OAuth token is supplied with the request.
   */
  sendCheer?: Maybe<SendCheerPayload>;
  /** Sends a pubsub message on behalf of an Extension. */
  sendExtensionMessage?: Maybe<SendExtensionMessagePayload>;
  /** Send a highlighted chat message with Channel Points. */
  sendHighlightedChatMessage?: Maybe<SendHighlightedChatMessagePayload>;
  /**
   * Sends a message to a chatroom.
   * @deprecated No longer supported
   */
  sendRoomMessage?: Maybe<SendRoomMessagePayload>;
  /** Sends a whisper message to the target user. */
  sendWhisper?: Maybe<SendWhisperPayload>;
  /** Set values for length and period of ads for channel ads management. */
  setAutoAdDensity?: Maybe<SetAutoAdDensityPayload>;
  /** Sets the user's auto refill settings. */
  setAutoRefillSettings?: Maybe<SetAutoRefillSettingsPayload>;
  /** Sets the user's list of channelIDs to autohost. */
  setAutohostChannels?: Maybe<SetAutohostChannelsPayload>;
  /** setBitsUserSettings sets a Bits users settings such as skipping the tutorial. */
  setBitsUserSettings?: Maybe<SetBitsUserSettingsPayload>;
  /**
   * Set value for channel_feed_enabled.
   * @deprecated No longer supported
   */
  setChannelFeedEnabled?: Maybe<SetChannelFeedEnabledPayload>;
  /** setChannelNotificationSetting allows a user to set a notification setting. */
  setChannelNotificationSetting?: Maybe<SetChannelNotificationSettingPayload>;
  /**
   * Set a channel's trailer.
   * A channel trailer can only be modified by its corresponding user, a channel editor, or a Twitch admin.
   */
  setChannelTrailer?: Maybe<SetChannelTrailerPayload>;
  /** Set a user's Chat Pause setting. */
  setChatPauseSetting?: Maybe<SetChatPauseSettingPayload>;
  /** setContentTags updates the tags specified and associates it with the piece of content specified. */
  setContentTags?: Maybe<SetContentTagsPayload>;
  /**
   * setCreatorBadgeFlair updates the channel-wide setting for a user that determines what
   * type of subscriber badge flair is available to eligible subscribers to that channel.
   */
  setCreatorBadgeFlair?: Maybe<SetCreatorBadgeFlairPayload>;
  /** setDashboardAlertQueueActivityStatus updates the specified activity's status for the dashboard alert queue. */
  setDashboardAlertQueueActivityStatus?: Maybe<SetDashboardAlertQueueActivityStatusPayload>;
  /** setDashboardAlertQueuePreference updates the preference specified for the dashboard alert queue. */
  setDashboardAlertQueuePreference?: Maybe<SetDashboardAlertQueuePreferencePayload>;
  /**
   * Sets the default payment method for a user.
   * Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers
   * This is the final step of the payment method management flow. (User.paymentMethods -> User.paymentMethodConfigs -> this mutation).
   */
  setDefaultPaymentMethod?: Maybe<SetDefaultPaymentMethodPayload>;
  /** Set a user's Deleted Message Display Chat UI setting. */
  setDeletedMessageDisplaySetting?: Maybe<SetDeletedMessageDisplaySettingPayload>;
  /** SetDropBenefitOnDrop adds a benefit to a drop within a drop campaign. */
  setDropBenefitsOnDrop?: Maybe<SetDropBenefitsOnDropPayload>;
  /** setDropCampaignAccess updates who can or cannot access a campaign's drops. */
  setDropCampaignAccess?: Maybe<SetDropCampaignAccessPayload>;
  /** setDropCampaignStatus transitions a campaign between states. */
  setDropCampaignStatus?: Maybe<SetDropCampaignStatusPayload>;
  /** setDropCampaignSummary allows organizations in the devconsole to update a previously created campaign's summary. */
  setDropCampaignSummary?: Maybe<SetDropCampaignSummaryPayload>;
  /** setDropEventRule updates a drops's rule to be an event based rule. */
  setDropEventRule?: Maybe<SetDropEventRulePayload>;
  /** setDropSummary allows organizations to update a drop's summary data. */
  setDropSummary?: Maybe<SetDropSummaryPayload>;
  /** setDropTimeBasedRule updates a drops's rule to be a minutes watched based rule. */
  setDropTimeBasedRule?: Maybe<SetDropTimeBasedRulePayload>;
  /** Set a user's emote animations UI setting. */
  setEmoteAnimationsEnabled?: Maybe<SetEmoteAnimationsEnabledPayload>;
  /** Set a user's emote animations callout dismissed setting. */
  setEmoteAnimationsSettingCalloutDismissed?: Maybe<SetEmoteAnimationsSettingCalloutDismissedPayload>;
  /** Sets the emote modifier groups for a user. */
  setEmoteModifierGroups?: Maybe<SetEmoteModifierGroupsPayload>;
  /** Sets the configuration for an extension version. */
  setExtensionConfiguration?: Maybe<SetExtensionConfigurationPayload>;
  /** Sets the feature flag options on a specified extension installation. */
  setExtensionFeatureFlags?: Maybe<SetExtensionFeatureFlagsPayload>;
  /** Set the OAuth token for an installation which is retrieved and used for Helix requests from extensions. */
  setExtensionInstallationOAuth?: Maybe<SetExtensionInstallationOAuthPayload>;
  /** SetGameDropAccountLinkClient sets the client ID on a game which is used to verify that users have connected their game accounts. */
  setGameDropAccountLinkClient?: Maybe<SetGameDropAccountLinkClientPayload>;
  /** Sets the user's current hero to their profile picture. */
  setHeroAsAvatar?: Maybe<SetHeroAsAvatarPayload>;
  /** Set access permission to the channel's moderator logs for a given role. */
  setModLogsAccess?: Maybe<SetModLogsAccessPayload>;
  /** Set a user's mod view page tutorial seen state & time. */
  setModViewSettings?: Maybe<SetModViewSettingsPayload>;
  /** setNotificationSetting allows a user to set a notification setting. */
  setNotificationSetting?: Maybe<SetNotificationSettingPayload>;
  /** setOverwatchLeagueTeamPreference allows a user to set their preferred Overwatch team. */
  setOverwatchLeagueTeamPreference?: Maybe<SetOverwatchLeagueTeamPreferencePayload>;
  /** Set a user's preferred language tag. */
  setPreferredLanguageTag?: Maybe<SetPreferredLanguageTagPayload>;
  /** Set radio track information currently being played. */
  setRadioCurrentlyPlaying?: Maybe<SetRadioCurrentlyPlayingPayload>;
  /** Set a user's readable chat colors UI setting. */
  setReadableChatColorsEnabled?: Maybe<SetReadableChatColorsEnabledPayload>;
  /** setResourceRestriction can create or update a restriction on a resource. */
  setResourceRestriction?: Maybe<SetResourceRestrictionPayload>;
  /** setScheduleReminder toggles on or off a user's set reminder for a given scheduled event. */
  setScheduleReminder?: Maybe<SetScheduleReminderPayload>;
  /**
   * setSessionStatus sets the user's status for this session, which influences how they appear ("online", "idle",
   * "watching SnarfyBobo") to friends and related users. To maintain a session status, setSessionStatus needs to be sent
   * periodically. The amount of time your application should wait between these status heartbeats is included in the
   * response payload.
   */
  setSessionStatus?: Maybe<SetSessionStatusPayload>;
  /** Set the ID of the primary player in a squad stream that the user currently has in the primary position. */
  setSquadStreamPrimaryPlayer?: Maybe<SetSquadStreamPrimaryPlayerPayload>;
  /** setUnbanRequestsSettings allows a user to set their channel's unban requests settings. */
  setUnbanRequestsSettings?: Maybe<SetUnbanRequestsSettingsPayload>;
  /** Set user's country of residence. */
  setUserResidence?: Maybe<SetUserResidencePayload>;
  /** Spend Twitch Prime monthly subscription credit. */
  spendSubscriptionCredit?: Maybe<SpendSubscriptionCreditPayload>;
  /** Start a new ad break. */
  startAd?: Maybe<StartAdPayload>;
  /**
   * startBounty allows a user to start a bounty for tracking (e.g. track the viewers CCU for meeting the bounty's requirements).
   * If the user has not provided a title or met the other requirements to start the bounty, it will return an error.
   */
  startBounty?: Maybe<StartBountyPayload>;
  /** Starts a cloud broadcast. */
  startCloudBroadcast?: Maybe<StartCloudBroadcastPayload>;
  /** Start a new payout onboarding workflow. */
  startPayoutOnboardingWorkflow?: Maybe<StartPayoutOnboardingWorkflowPayload>;
  /** Start a Prime Video Watch Party. */
  startWatchParty?: Maybe<StartWatchPartyPayload>;
  /** stopBounty allows a user to stop tracking progress for a bounty. */
  stopBounty?: Maybe<StopBountyPayload>;
  /** Stops a cloud broadcast. */
  stopCloudBroadcast?: Maybe<StopCloudBroadcastPayload>;
  /** Stop a Prime Video Watch Party. */
  stopWatchParty?: Maybe<StopWatchPartyPayload>;
  /** Submit CSAT (customer satisfaction) feedback. */
  submitCSATFeedback?: Maybe<SubmitCsatFeedbackPayload>;
  /**
   * Submit a new emote prefix for a given channel. Each channel has a single prefix.
   * Submitting more than once overrides the previously set prefix.
   */
  submitEmotePrefix?: Maybe<SubmitEmotePrefixPayload>;
  /**
   * Submit a new emoticon prefix for a given channel. Each channel has a single prefix. Submitting
   * more than once simply overrides the previously set prefix and putting it in a pending state.
   * @deprecated Use 'submitEmotePrefix' instead
   */
  submitEmoticonPrefix?: Maybe<SubmitEmoticonPrefixPayload>;
  /** Submit feedback for a Twitch extension. */
  submitExtensionFeedback?: Maybe<SubmitExtensionFeedbackPayload>;
  /** Swap competition lobby participants within a competition phase. */
  swapCompetitionLobbyParticipants?: Maybe<SwapCompetitionLobbyParticipantsPayload>;
  /**
   * Syncs the current game data with the game data stored by the DropsManagementService. The DropsManagementService
   * purposefully does not autosync when a Game is updated so that a change to the Game's account link client ID
   * doesn't get overwritten without running this command.
   */
  syncGameOnDropCampaign?: Maybe<SyncGameOnDropCampaignPayload>;
  /** Terminates the poll with the given poll id. */
  terminatePoll?: Maybe<TerminatePollPayload>;
  /** Terminates the current poll in a channel. */
  terminatePollInChannel?: Maybe<TerminatePollInChannelPayload>;
  /** toggleRitualsEnabled allows a user to toggle the rituals feature for their channel. */
  toggleRitualsEnabled?: Maybe<ToggleRitualsEnabledPayload>;
  /**
   * Transitions the state for an existing extension.
   * Only allowed for the owner of the extension.
   */
  transitionExtensionState?: Maybe<TransitionExtensionStatePayload>;
  /** Removes a ban imposed on a user for a specified chat room. */
  unbanUserFromChatRoom?: Maybe<UnbanUserFromChatRoomPayload>;
  /** Removes block from target user. */
  unblockUser?: Maybe<UnblockUserPayload>;
  /** undoRecommendationFeedback allows a user to removes a single piece of feedback. */
  undoRecommendationFeedback?: Maybe<UndoRecommendationFeedbackPayload>;
  /** unfollowGame allows a user to unfollow a game. */
  unfollowGame?: Maybe<UnfollowGamePayload>;
  /**
   * unfollowUser destroys the follow relationship between the authenticated user and
   * the target user.
   */
  unfollowUser?: Maybe<UnfollowUserPayload>;
  /** unfriendUser destroys a friend relationship from the target user to the authenticated user. */
  unfriendUser?: Maybe<UnfriendUserPayload>;
  /** Unhost from a channel. */
  unhost?: Maybe<UnhostPayload>;
  /** Uninstall an extension from a specific channel. */
  uninstallExtension?: Maybe<UninstallExtensionPayload>;
  /** Unlink an authenticated user's amazon connection. */
  unlinkAmazonConnection?: Maybe<UnlinkAmazonConnectionPayload>;
  /** Unlink a user's account connection to Riot. */
  unlinkRiotConnection?: Maybe<UnlinkRiotConnectionPayload>;
  /**
   * Unlink an SSO app from a user's account.
   * @deprecated Service has been shutdown
   */
  unlinkSSO?: Maybe<UnlinkSsoPayload>;
  /** Unlock a chosen modified subscriber emote using Community Points. */
  unlockChosenModifiedSubscriberEmote?: Maybe<UnlockChosenModifiedSubscriberEmotePayload>;
  /** Unlock a chosen subscriber emote using Community Points. */
  unlockChosenSubscriberEmote?: Maybe<UnlockChosenSubscriberEmotePayload>;
  /** Unlock a random subscriber emote using Community Points. */
  unlockRandomSubscriberEmote?: Maybe<UnlockRandomSubscriberEmotePayload>;
  /** Remove moderator status from a user in a channel. */
  unmodUser?: Maybe<UnmodUserPayload>;
  /** unsetHypeTrainConfig allows a user to unset the channel's custom hype train configurations. */
  unsetHypeTrainConfig?: Maybe<UnsetHypeTrainConfigPayload>;
  /** unsubscribeEmail unsubscribes a given user from a given email campaign. */
  unsubscribeEmail?: Maybe<UnsubscribeEmailPayload>;
  /** Updates a user's ad settings for their channel. */
  updateAdProperties?: Maybe<UpdateAdPropertiesPayload>;
  /** Updates all a channels vidoes to the provided viewability. */
  updateAllChannelVideosViewability?: Maybe<UpdateAllChannelVideosViewabilityPayload>;
  /** Updates all of a user's whisper threads. */
  updateAllWhisperThreads?: Maybe<UpdateAllWhisperThreadsPayload>;
  /** Set individual automod categories (i.e. set identity to level 3 but profanity to 0). */
  updateAutoModLevels?: Maybe<UpdateAutoModLevelsPayload>;
  /** Set individual automod categories (i.e. set identity to level 3 but profanity to 0) - based on Sift categories, to be deprecated. */
  updateAutoModProperties?: Maybe<UpdateAutoModPropertiesPayload>;
  /** Update a user's autohost settings. */
  updateAutohostSettings?: Maybe<UpdateAutohostSettingsPayload>;
  /** Updates bits badge tier notification. */
  updateBitsBadgeTierNotification?: Maybe<UpdateBitsBadgeTierNotificationPayload>;
  /** Updates bits badge tiers. */
  updateBitsBadgeTiers?: Maybe<UpdateBitsBadgeTiersPayload>;
  /** Updates boost settings. */
  updateBoostSettings?: Maybe<UpdateBoostSettingsPayload>;
  /** updateBroadcastSettings allows the user to update their broadcast setting. */
  updateBroadcastSettings?: Maybe<UpdateBroadcastSettingsPayload>;
  /** Update a channels celebration. */
  updateCelebration?: Maybe<UpdateCelebrationPayload>;
  /** Update a channels celebration config. */
  updateCelebrationConfig?: Maybe<UpdateCelebrationConfigPayload>;
  /** Update a channel's celebration product config. */
  updateCelebrationProductConfig?: Maybe<UpdateCelebrationProductConfigPayload>;
  /** Update a user's celebration user settings. */
  updateCelebrationUserSettings?: Maybe<UpdateCelebrationUserSettingsPayload>;
  /** updateChangelogReadTime marks the changelog as read for a user. */
  updateChangelogReadTime?: Maybe<UpdateChangelogReadTimePayload>;
  /** updateChanletContentAttributes allows users to make changes to the multi-view content attributes on a chanlet. */
  updateChanletContentAttributes?: Maybe<UpdateChanletContentAttributesPayload>;
  /**
   * updateChannelClipsSetting allows a channel owner to enable/disable creation
   * of Clips on their channel.
   */
  updateChannelClipsSetting?: Maybe<UpdateChannelClipsSettingPayload>;
  /** updateChannelHomePreferences updates a streamer's channel home preferences. */
  updateChannelHomePreferences?: Maybe<UpdateChannelHomePreferencesPayload>;
  /** Update a channel's Prediction Settings. */
  updateChannelPredictionSettings?: Maybe<UpdateChannelPredictionSettingsPayload>;
  /** Updates a user's chat color. */
  updateChatColor?: Maybe<UpdateChatColorPayload>;
  /** Set different chat settings (i.e. disable globalBannedWordsOptOut). */
  updateChatSettings?: Maybe<UpdateChatSettingsPayload>;
  /** Update the user's partner settings regarding bits. */
  updateCheerPartnerSettings?: Maybe<UpdateCheerPartnerSettingsPayload>;
  /** Updates the image assets for a broadcaster's particular cheermote tier. */
  updateCheermoteTier?: Maybe<UpdateCheermoteTierPayload>;
  /** updateClip allows a user to update the metadata of a clip. */
  updateClip?: Maybe<UpdateClipPayload>;
  /**
   * updateClipViewCount allows a user to increment the viewcount of a clip.
   * @deprecated Will eventually be replaced by different viewcounting method
   */
  updateClipViewCount?: Maybe<UpdateClipViewCountPayload>;
  /** updateCollection performs an update on the collection with the provided ID and updated attributes. */
  updateCollection?: Maybe<UpdateCollectionPayload>;
  /** Update an automatic Community Points reward in a channel. */
  updateCommunityPointsAutomaticReward?: Maybe<UpdateCommunityPointsAutomaticRewardPayload>;
  /** Update a channel's Community Points channel settings. */
  updateCommunityPointsChannelSettings?: Maybe<UpdateCommunityPointsChannelSettingsPayload>;
  /** updateCommunityPointsCommunityGoal updates a Community Points Community Goal. */
  updateCommunityPointsCommunityGoal?: Maybe<UpdateCommunityPointsCommunityGoalPayload>;
  /** Update a custom Community Points reward in a channel. */
  updateCommunityPointsCustomReward?: Maybe<UpdateCommunityPointsCustomRewardPayload>;
  /** Update the status of a Community Points redemption (for example, from unfulfilled to fulfilled). */
  updateCommunityPointsCustomRewardRedemptionStatus?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusPayload>;
  /** Update the status of all Community Points redemptions for a channel. */
  updateCommunityPointsCustomRewardRedemptionStatusesByChannel?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload>;
  /** Update the status of the Community Points redemptions from the provided list. */
  updateCommunityPointsCustomRewardRedemptionStatusesByRedemptions?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload>;
  /** Update the status of all Community Points redemptions for a reward. */
  updateCommunityPointsCustomRewardRedemptionStatusesByReward?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload>;
  /**
   * Allows users to sign up for or remove themselves from the Community Points early access program.
   * @deprecated Early access period is over.
   */
  updateCommunityPointsEarlyAccessSettings?: Maybe<UpdateCommunityPointsEarlyAccessSettingsPayload>;
  /** Update the last viewed timestamp of a user for Community Points content. */
  updateCommunityPointsLastViewedContent?: Maybe<UpdateCommunityPointsLastViewedContentPayload>;
  /** Update an automatic Community Points reward cost acknowledgements. */
  updateCommunityPointsSmartCostsAcknowledgements?: Maybe<UpdateCommunityPointsSmartCostsAcknowledgementsPayload>;
  /** Update Competition. */
  updateCompetition?: Maybe<UpdateCompetitionPayload>;
  /** Update CompetitionPlayer in a competition. */
  updateCompetitionPlayer?: Maybe<UpdateCompetitionPlayerPayload>;
  /** Update  a Team in a Competition. */
  updateCompetitionTeam?: Maybe<UpdateCompetitionTeamPayload>;
  /** Update a consent status or create a new consent status. */
  updateConsent?: Maybe<UpdateConsentPayload>;
  /**
   * updateContentTags updates the tags specified and associates it with the piece of content specified.
   * @deprecated Use setContentTags instead
   */
  updateContentTags?: Maybe<UpdateContentTagsPayload>;
  /** Updates a Mosaic layout with the specified id for the current user. */
  updateDashboardViewMosaicLayout?: Maybe<UpdateDashboardViewMosaicLayoutPayload>;
  /** updateDropBenefit updates a benefit owned by an organization. The benefit can be used in drop campaigns. */
  updateDropBenefit?: Maybe<UpdateDropBenefitPayload>;
  /** updateDropBenefitOnDrop sets a benefit on a drop and how often that benefit can be claimed. */
  updateDropBenefitOnDrop?: Maybe<UpdateDropBenefitOnDropPayload>;
  /** updateDropPreconditions updates the drops that must be claimed before a drop can be claimed. */
  updateDropPreconditions?: Maybe<UpdateDropPreconditionsPayload>;
  /** updateDropsOptOutStatus allows the user to update their drops opt-out status. */
  updateDropsOptOutStatus?: Maybe<UpdateDropsOptOutStatusPayload>;
  /** updateEmoteOrders allows a broadcaster to reorder the emotes within the emote groups they own. */
  updateEmoteOrders?: Maybe<UpdateEmoteOrdersPayload>;
  /** updateExtensionDiscoveryData allows a user to update the discovery data for an extension. */
  updateExtensionDiscoveryData?: Maybe<UpdateExtensionDiscoveryDataPayload>;
  /**
   * updateExtensionManifest allows a user to update the manifest for an extension in development.
   * @deprecated Switching to saveExtensionManifest
   */
  updateExtensionManifest?: Maybe<UpdateExtensionManifestPayload>;
  /** updateHypeTrainConfig allows a user to update the channel's hype train configurations. */
  updateHypeTrainConfig?: Maybe<UpdateHypeTrainConfigPayload>;
  /** Changes the user's activity sharing setting. A user's activity is one part of their status. */
  updateIsSharingActivity?: Maybe<UpdateIsSharingActivityPayload>;
  /** Exchanges an LWA token for an Amazon OAuth token. */
  updateLWAToken?: Maybe<UpdateLwaTokenPayload>;
  /** Update the user's partner settings regarding leaderboards. */
  updateLeaderboardSettings?: Maybe<UpdateLeaderboardSettingsPayload>;
  /** Changes the user's activity sharing setting. A user's activity is one part of their status. */
  updateLiveUpNotification?: Maybe<UpdateLiveUpNotificationPayload>;
  /** Updates a lobby participant who is a competition player's or competition team's score. */
  updateLobbyParticipantScore?: Maybe<UpdateLobbyParticipantScorePayload>;
  /** Modifies multi-view content attributes. */
  updateMultiviewContentAttributes?: Maybe<UpdateMultiviewContentAttributesPayload>;
  /**
   * updateOnboardingSkippedChannels updates skipped channel IDs during onboarding for a given user.
   * @deprecated This feature is retired
   */
  updateOnboardingSkippedChannels?: Maybe<UpdateOnboardingSkippedChannelsPayload>;
  /** updateOrganizationMemberRole updates the role of an organization member (Twitch Developers). */
  updateOrganizationMemberRole?: Maybe<UpdateOrganizationMemberRolePayload>;
  /** updateOwnerChanletAttributes updates/creates a new set of owner chanlet attributes for a Channel. */
  updateOwnerChanletAttributes?: Maybe<UpdateOwnerChanletAttributesPayload>;
  /** updatePanel updates the data for a given panel. */
  updatePanel?: Maybe<UpdatePanelPayload>;
  /**
   * Starts the process for associating a phone number to a twitch account. Requires sudo authentication.
   * A one time password (valid for 10 minutes) will be sent via SMS to the phone number provided. The one time password will need to be verified via updatePhoneNumberConfirmation to complete the update.
   */
  updatePhoneNumber?: Maybe<UpdatePhoneNumberPayload>;
  /**
   * Completes the process for associating a phone number to a twitch account. Requires sudo authentication.
   * The one time password issued using updatePhoneNumber will be verified to make sure user contols the phone number.
   */
  updatePhoneNumberConfirmation?: Maybe<UpdatePhoneNumberConfirmationPayload>;
  /** updatePrimeOfferStatus allows a user to update their status in respect to an offer. (e.g. UNSEEN, SEEN, CLAIMED). */
  updatePrimeOfferStatus?: Maybe<UpdatePrimeOfferStatusPayload>;
  /**
   * updatePrimeSettings allows the user to enable or disable chat notifications when spending a Prime Credit,
   * and allows the user to set the type of Smilies (Turbos, Robots, or Monkeys) they want for Prime/Turbo Emoticons.
   */
  updatePrimeSettings?: Maybe<UpdatePrimeSettingsPayload>;
  /** Update a user's raid settings. */
  updateRaidSettings?: Maybe<UpdateRaidSettingsPayload>;
  /**
   * Updates an existing chatroom.
   * @deprecated No longer supported
   */
  updateRoom?: Maybe<UpdateRoomPayload>;
  /**
   * Updates the room modes (slow mode, emotes only mode, etc.) for the room.
   * @deprecated No longer supported
   */
  updateRoomModes?: Maybe<UpdateRoomModesPayload>;
  /**
   * Update's a user's room view for a chatroom.
   * @deprecated No longer supported
   */
  updateRoomView?: Maybe<UpdateRoomViewPayload>;
  /** Update a schedule segment. */
  updateScheduleSegment?: Maybe<UpdateScheduleSegmentPayload>;
  /** UpdateSeenCreatorOnboardingContent updates the list of streamer onboarding content that a user has seen. */
  updateSeenCreatorOnboardingContent?: Maybe<UpdateSeenCreatorOnboardingContentPayload>;
  /** updateSocialMedia updates an existing social media item for a Channel. */
  updateSocialMedia?: Maybe<UpdateSocialMediaPayload>;
  /** updateSquadInvitePolicy allows a broadcaster to update their squad stream invite policy. */
  updateSquadInvitePolicy?: Maybe<UpdateSquadInvitePolicyPayload>;
  /** updateSquadStream allows an owner of a squad stream to update the squad stream. */
  updateSquadStream?: Maybe<UpdateSquadStreamPayload>;
  /** updateStucco allows a user to update a stucco (that is currently not active). */
  updateStucco?: Maybe<UpdateStuccoPayload>;
  /** updateStuccoPack allows the updating of a channel's stucco pack. (activating stuccos). */
  updateStuccoPack?: Maybe<UpdateStuccoPackPayload>;
  /** updateSubscriptionProduct allows a user to update their subscription product settings. */
  updateSubscriptionProduct?: Maybe<UpdateSubscriptionProductPayload>;
  /** updateUser updates a user's displayname, description, email or delete a phone number. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a user's creator colors. */
  updateUserColors?: Maybe<UpdateUserColorsPayload>;
  /** Set a user's privacy preference for registration date. */
  updateUserCreateDateHidden?: Maybe<UpdateUserCreateDateHiddenPayload>;
  /** Set a user's directory hidden field. */
  updateUserDirectoryHidden?: Maybe<UpdateUserDirectoryHiddenPayload>;
  /** Set a user's email reuse field. */
  updateUserEmailReusable?: Maybe<UpdateUserEmailReusablePayload>;
  /** updateUserIsEmailRevertSuccess sets/resets a user's Email revert success flag. */
  updateUserIsEmailRevertSuccess?: Maybe<UpdateUserIsEmailRevertSuccessPayload>;
  /** Update a user's Prediction Settings. */
  updateUserPredictionSettings?: Maybe<UpdateUserPredictionSettingsPayload>;
  /** updateUserSubscriptionSettings updates the subscription preferences for the authenticated user. */
  updateUserSubscriptionSettings?: Maybe<UpdateUserSubscriptionSettingsPayload>;
  /** updateUserTeamMembership updates the team membership preferences for target user. */
  updateUserTeamMembership?: Maybe<UpdateUserTeamMembershipPayload>;
  /** updateUserVideoShelves adds/removes/reorders for a user's video shelves. */
  updateUserVideoShelves?: Maybe<UpdateUserVideoShelvesPayload>;
  /** updateUserViewedVideo updates a resume watching entry for a specified user and video. */
  updateUserViewedVideo?: Maybe<UpdateUserViewedVideoPayload>;
  /** updateVideo updates a video identified by provided video ID. */
  updateVideo?: Maybe<UpdateVideoPayload>;
  /** updateVideoComment updates a video comment identified by provided comment ID. */
  updateVideoComment?: Maybe<UpdateVideoCommentPayload>;
  /** updateVideoStreamSettings updates the broadcaster's video stream settings such as latency mode. */
  updateVideoStreamSettings?: Maybe<UpdateVideoStreamSettingsPayload>;
  /** UpdateVideosViewability updates videos to being published or unpublished. */
  updateVideosViewability?: Maybe<UpdateVideosViewabilityPayload>;
  /**
   * Changes the user's visibility setting. This is an account-level setting that will cause the user's availability to
   * appear differently to other users, despite what sessions are reporting. See the VisibilityInput enum for details on
   * the effects of each value.
   *
   * Because this is an account-level setting, it should only be used in response to the user expressing clear intention
   * to change their visibility. Setting a status for an individual session should be done using setSessionStatus.
   */
  updateVisibility?: Maybe<UpdateVisibilityPayload>;
  /** Updates Whisper settings for the authenticated user. */
  updateWhisperSettings?: Maybe<UpdateWhisperSettingsPayload>;
  /** Updates a whisper thread. */
  updateWhisperThread?: Maybe<UpdateWhisperThreadPayload>;
  /** uploadCompetitionImage generates a url for a user to upload an image to for a competition. */
  uploadCompetitionImage?: Maybe<UploadCompetitionImagePayload>;
  /** Uses a chat notification token. */
  useChatNotificationToken?: Maybe<UseChatNotificationTokenPayload>;
  /** validateVerificationCode validates a given code and sets the address to verified if it matches. */
  validateVerificationCode?: Maybe<ValidateVerificationCodePayload>;
  /** verifyContactMethod verifies a user contact method from an opaque ID. */
  verifyContactMethod?: Maybe<VerifyContactMethodPayload>;
  /** verifyOneTimePassword verifies a one time password for a user for authentication. Requires sudo authentication. */
  verifyOneTimePassword?: Maybe<VerifyOneTimePasswordPayload>;
  /** verifyRewardedVideoEligibilityCaptcha verifies a users captcha with the rewarded video system. */
  verifyRewardedVideoEligibilityCaptcha?: Maybe<VerifyRewardedVideoEligibilityCaptchaPayload>;
  /** viewedNotifications updates when the authenticated user last saw onsite notifications. */
  viewedNotifications?: Maybe<ViewedNotificationsPayload>;
  /** visitStreamManager updates when the authenticated user visits their stream manager for the first time. */
  visitStreamManager?: Maybe<VisitStreamManagerPayload>;
  /** Casts a vote for a specific choice in an ad poll. */
  voteInAdPoll?: Maybe<VoteInAdPollPayload>;
  /** Casts a vote for a specific choice in a poll. */
  voteInPoll?: Maybe<VoteInPollPayload>;
  /** Casts a vote for a specific choice in a poll, by index and channelID. */
  voteInPollByChoiceIndex?: Maybe<VoteInPollByChoiceIndexPayload>;
};


/** Operations to update data in the Twitch API. */
export type MutationAcceptFriendRequestArgs = {
  input: AcceptFriendRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcceptOrganizationInviteArgs = {
  input: AcceptOrganizationInviteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcceptProgramAgreementArgs = {
  input: AcceptProgramAgreementInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcceptSquadStreamInvitationArgs = {
  input: AcceptSquadStreamInvitationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcknowledgePredictionResultArgs = {
  input: AcknowledgePredictionResultInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcknowledgeSubscriptionStateArgs = {
  input: AcknowledgeSubscriptionStateInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAcknowledgeUnbanRequestArgs = {
  input: AcknowledgeUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationActivateExtensionArgs = {
  input: ActivateExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddAutohostChannelsArgs = {
  input: AddAutohostChannelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddBrowserPushSubscriptionArgs = {
  input: AddBrowserPushSubscriptionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddChannelBlockedTermArgs = {
  input: AddChannelBlockedTermInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddChannelPermittedTermArgs = {
  input: AddChannelPermittedTermInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddCollectionItemArgs = {
  input: AddCollectionItemInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddCompetitionPhaseArgs = {
  input: AddCompetitionPhaseInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddCompetitionPlayerArgs = {
  input: AddCompetitionPlayerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddCompetitionTeamArgs = {
  input: AddCompetitionTeamInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddDeviceTokenArgs = {
  input: AddDeviceTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddDropToCampaignArgs = {
  input: AddDropToCampaignInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddEditorArgs = {
  input: AddEditorInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddRadioRecentlyPlayedArgs = {
  input: AddRadioRecentlyPlayedInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddReactionArgs = {
  input: AddReactionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddRecommendationFeedbackArgs = {
  input: AddRecommendationFeedbackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAddStreamAuthorizedUserArgs = {
  input: AddStreamAuthorizedUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAllocateKeysForBountyArgs = {
  input: AllocateKeysForBountyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAllowRejectedChatMessageArgs = {
  input: AllowRejectedChatMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAllowRejectedCheerArgs = {
  input: AllowRejectedCheerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationApplyExtensionActivationsArgs = {
  input: ApplyExtensionActivationsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationApproveUnbanRequestArgs = {
  input: ApproveUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationArchiveChanletArgs = {
  input: ArchiveChanletInput;
};


/** Operations to update data in the Twitch API. */
export type MutationArchiveCommunityPointsCommunityGoalArgs = {
  input: ArchiveCommunityPointsCommunityGoalInput;
};


/** Operations to update data in the Twitch API. */
export type MutationArchivePollArgs = {
  input: ArchivePollInput;
};


/** Operations to update data in the Twitch API. */
export type MutationArchivePollInChannelArgs = {
  input: ArchivePollInChannelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAssignEmoteToBitsTierArgs = {
  input: AssignEmoteToBitsTierInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAssignEmoteToSubscriptionProductArgs = {
  input: AssignEmoteToSubscriptionProductInput;
};


/** Operations to update data in the Twitch API. */
export type MutationAssignExtensionBillingManagerArgs = {
  input: AssignExtensionBillingManagerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBanUserFromChatRoomArgs = {
  input: BanUserFromChatRoomInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBanVideoCommenterArgs = {
  input: BanVideoCommenterInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBeginUseBitsInExtensionArgs = {
  input: BeginUseBitsInExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBlockUserArgs = {
  input: BlockUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBulkApproveUnbanRequestArgs = {
  input: BulkApproveUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationBulkDenyUnbanRequestArgs = {
  input: BulkDenyUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelActiveBoostOrdersArgs = {
  input: CancelActiveBoostOrdersInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelBountyArgs = {
  input: CancelBountyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelFriendRequestArgs = {
  input: CancelFriendRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelPayoutOnboardingWorkflowArgs = {
  input: CancelPayoutOnboardingWorkflowInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelPredictionEventArgs = {
  input: CancelPredictionEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelRaidArgs = {
  input: CancelRaidInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelSubscriptionGiftArgs = {
  input: CancelSubscriptionGiftInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCancelUnbanRequestArgs = {
  input: CancelUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationChangeUsernameArgs = {
  input: ChangeUsernameInput;
};


/** Operations to update data in the Twitch API. */
export type MutationClaimBountyArgs = {
  input: ClaimBountyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationClaimCommunityPointsArgs = {
  input: ClaimCommunityPointsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationClaimDropRewardsArgs = {
  input: ClaimDropRewardsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationClaimPrimeOfferArgs = {
  input: ClaimPrimeOfferInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCloneExtensionDiscoveryDataArgs = {
  input: CloneExtensionDiscoveryDataInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCloneExtensionManifestArgs = {
  input: CloneExtensionManifestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationConnectAdIdentityArgs = {
  input: ConnectAdIdentityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationContributeCommunityPointsCommunityGoalArgs = {
  input: ContributeCommunityPointsCommunityGoalInput;
};


/** Operations to update data in the Twitch API. */
export type MutationContributeToChallengeArgs = {
  input: ContributeToChallengeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateArchivedEmoteArgs = {
  input: CreateArchivedEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateBadgeFlairArgs = {
  input: CreateBadgeFlairInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateBitsChallengeConditionForExtensionArgs = {
  input: CreateBitsChallengeConditionForExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateBitsChallengeConditionParticipantForExtensionArgs = {
  input: CreateBitsChallengeConditionParticipantForExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateBountyCampaignArgs = {
  input: CreateBountyCampaignInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateBountyCampaignUploadConfigArgs = {
  input: CreateBountyCampaignUploadConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCelebrationArgs = {
  input: CreateCelebrationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateChanletArgs = {
  input: CreateChanletInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateClipArgs = {
  input: CreateClipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCommunityPointsCommunityGoalArgs = {
  input: CreateCommunityPointsCommunityGoalInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCommunityPointsCustomRewardArgs = {
  input: CreateCommunityPointsCustomRewardInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCommunityPointsImageUploadInfoArgs = {
  input: CreateCommunityPointsImageUploadInfoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateCompetitionArgs = {
  input: CreateCompetitionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateContentTagsArgs = {
  input: CreateContentTagsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateDashboardViewMosaicLayoutArgs = {
  input: CreateDashboardViewMosaicLayoutInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateDropBenefitArgs = {
  input: CreateDropBenefitInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateDropCampaignArgs = {
  input: CreateDropCampaignInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateDropImageUploadUrlArgs = {
  input: CreateDropImageUploadUrlInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateExtensionClientArgs = {
  input: CreateExtensionClientInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateExtensionImageUploadInfoArgs = {
  input: CreateExtensionImageUploadInfoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateExtensionZipUploadInfoArgs = {
  input: CreateExtensionZipUploadInfoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateFriendRequestArgs = {
  input: CreateFriendRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateGameApplicationArgs = {
  input: CreateGameApplicationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateGameBoxArtUploadUrlArgs = {
  input: CreateGameBoxArtUploadUrlInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateLoyaltyBadgeArgs = {
  input: CreateLoyaltyBadgeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateLoyaltyBadgeUploadConfigArgs = {
  input: CreateLoyaltyBadgeUploadConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateModeratorCommentArgs = {
  input: CreateModeratorCommentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateMultiVideoHighlightArgs = {
  input: CreateMultiVideoHighlightInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateMultiviewContentAttributeImageUploadConfigArgs = {
  input: CreateMultiviewContentAttributeImageUploadConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateMultiviewContentAttributesArgs = {
  input: CreateMultiviewContentAttributesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateOrganizationApplicationArgs = {
  input: CreateOrganizationApplicationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateOrganizationInviteArgs = {
  input: CreateOrganizationInviteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateOrganizationJwtArgs = {
  input: CreateOrganizationJwtInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateOrganizationMemberArgs = {
  input: CreateOrganizationMemberInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePanelArgs = {
  input: CreatePanelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePanelImageUploadInfoArgs = {
  input: CreatePanelImageUploadInfoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePartnershipApplicationArgs = {
  input: CreatePartnershipApplicationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePollArgs = {
  input: CreatePollInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreatePredictionEventArgs = {
  input: CreatePredictionEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateRaidArgs = {
  input: CreateRaidInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateRewardedVideoTokenArgs = {
  input: CreateRewardedVideoTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateRoomArgs = {
  input: CreateRoomInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateScheduleArgs = {
  input: CreateScheduleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateScheduleSegmentArgs = {
  input: CreateScheduleSegmentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateSocialMediaArgs = {
  input: CreateSocialMediaInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateSquadStreamInvitationArgs = {
  input: CreateSquadStreamInvitationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateStuccoArgs = {
  input: CreateStuccoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateStuccoPackArgs = {
  input: CreateStuccoPackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateUnbanRequestArgs = {
  input: CreateUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateVideoAppealArgs = {
  input: CreateVideoAppealInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateVideoBookmarkArgs = {
  input: CreateVideoBookmarkInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateVideoCommentArgs = {
  input: CreateVideoCommentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateVideoHighlightArgs = {
  input: CreateVideoHighlightInput;
};


/** Operations to update data in the Twitch API. */
export type MutationCreateVideoThumbnailUploadRequestArgs = {
  input: CreateVideoThumbnailUploadRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeactivateExtensionArgs = {
  input: DeactivateExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeclineOrganizationInviteArgs = {
  input: DeclineOrganizationInviteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteAllChannelVideosArgs = {
  input?: InputMaybe<DeleteAllChannelVideosInput>;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteBitsBadgeTierEmoticonArgs = {
  input: DeleteBitsBadgeTierEmoticonInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCelebrationArgs = {
  input: DeleteCelebrationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteChannelBlockedTermArgs = {
  input: DeleteChannelBlockedTermInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteChannelClipsArgs = {
  input: DeleteChannelClipsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteChannelPermittedTermArgs = {
  input: DeleteChannelPermittedTermInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteChatMessageArgs = {
  input: DeleteChatMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCheermoteTierArgs = {
  input: DeleteCheermoteTierInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteClipsArgs = {
  input: DeleteClipsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCollectionArgs = {
  input: DeleteCollectionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCommunityPointsCommunityGoalArgs = {
  input: DeleteCommunityPointsCommunityGoalInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCommunityPointsCustomRewardArgs = {
  input?: InputMaybe<DeleteCommunityPointsCustomRewardInput>;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteCompetitionArgs = {
  input: DeleteCompetitionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteContentTagsArgs = {
  input: DeleteContentTagsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteDefaultPaymentMethodArgs = {
  input: DeleteDefaultPaymentMethodInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteDeviceTokenArgs = {
  input: DeleteDeviceTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteDropArgs = {
  input: DeleteDropInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteDropCampaignArgs = {
  input: DeleteDropCampaignInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteEmoteArgs = {
  input: DeleteEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteExtensionArgs = {
  input: DeleteExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteExtensionImageArgs = {
  input: DeleteExtensionImageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteExtensionSecretsArgs = {
  input: DeleteExtensionSecretsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteLoyaltyBadgeArgs = {
  input: DeleteLoyaltyBadgeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteModeratorCommentArgs = {
  input: DeleteModeratorCommentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteMultiviewContentAttributesArgs = {
  input: DeleteMultiviewContentAttributesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeletePanelArgs = {
  input: DeletePanelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeletePostArgs = {
  input: DeletePostInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteRecommendationFeedbackArgs = {
  input: DeleteRecommendationFeedbackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteRoomArgs = {
  input: DeleteRoomInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteRoomMessageArgs = {
  input: DeleteRoomMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteScheduleArgs = {
  input: DeleteScheduleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteScheduleSegmentArgs = {
  input: DeleteScheduleSegmentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteSocialMediaArgs = {
  input: DeleteSocialMediaInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteSquadStreamInvitationArgs = {
  input: DeleteSquadStreamInvitationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteStreamAuthorizedUserArgs = {
  input: DeleteStreamAuthorizedUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteUserClipsArgs = {
  input: DeleteUserClipsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteUserColorsArgs = {
  input: DeleteUserColorsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteVideoCommentArgs = {
  commentID: Scalars['ID'];
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteVideoThumbnailArgs = {
  input: DeleteVideoThumbnailInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeleteVideosArgs = {
  input: DeleteVideosInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDenyRejectedChatMessageArgs = {
  input: DenyRejectedChatMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDenyRejectedCheerArgs = {
  input: DenyRejectedCheerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDenyUnbanRequestArgs = {
  input: DenyUnbanRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDeselectChannelBadgeArgs = {
  input: DeselectChannelBadgeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDisableTwoFactorArgs = {
  input: DisableTwoFactorInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDisableUserAccountArgs = {
  input: DisableUserAccountInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDismissFriendRecommendationArgs = {
  input: DismissFriendRecommendationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDismissRitualTokenArgs = {
  input: DismissRitualTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDismissVideoSuggestedHighlightArgs = {
  input: DismissVideoSuggestedHighlightInput;
};


/** Operations to update data in the Twitch API. */
export type MutationDropImageUploadArgs = {
  input: DropImageUploadInput;
};


/** Operations to update data in the Twitch API. */
export type MutationEditRoomMessageArgs = {
  input: EditRoomMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationEmitCampaignDiscoveryEventArgs = {
  input: EmitCampaignDiscoveryEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationEndUseBitsInExtensionArgs = {
  input: EndUseBitsInExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationEquipHeroAssetsArgs = {
  input: EquipHeroAssetsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationExportVideoToYoutubeArgs = {
  input: ExportVideoToYoutubeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationExtensionLinkUserArgs = {
  input: ExtensionLinkUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationFinalizeCompetitionLobbyArgs = {
  input: FinalizeCompetitionLobbyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationFollowGameArgs = {
  input: FollowGameInput;
};


/** Operations to update data in the Twitch API. */
export type MutationFollowUserArgs = {
  input: FollowUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGenerateAnimatedEmoteArgs = {
  input: GenerateAnimatedEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGenerateExtensionRatingsCsvReportArgs = {
  input: GenerateExtensionRatingsCsvReportInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGenerateSecondFactorQrCodeArgs = {
  input: GenerateSecondFactorQrCodeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGenerateSubscribersCsvArgs = {
  input: GenerateSubscribersCsvInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGetEmoteUploadConfigArgs = {
  input: GetEmoteUploadConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGoRaidArgs = {
  input: GoRaidInput;
};


/** Operations to update data in the Twitch API. */
export type MutationGrantVipArgs = {
  input: GrantVipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationHostTargetChannelArgs = {
  input: HostTargetChannelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationInstallExtensionArgs = {
  input: InstallExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationInterruptScheduleArgs = {
  input: InterruptScheduleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationInvalidateAuthenticatedSessionsArgs = {
  input: InvalidateAuthenticatedSessionsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationInvalidateEmailAssociationArgs = {
  input: InvalidateEmailAssociationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationJoinChannelRoomsArgs = {
  input: JoinChannelRoomsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationJoinRaidArgs = {
  input: JoinRaidInput;
};


/** Operations to update data in the Twitch API. */
export type MutationLeaveChannelRoomsArgs = {
  input: LeaveChannelRoomsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationLeaveRaidArgs = {
  input: LeaveRaidInput;
};


/** Operations to update data in the Twitch API. */
export type MutationLeaveSquadStreamArgs = {
  input: LeaveSquadStreamInput;
};


/** Operations to update data in the Twitch API. */
export type MutationLinkSsoArgs = {
  input: LinkSsoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationLockPredictionEventArgs = {
  input: LockPredictionEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationMakeKeyBatchDownloadUrlArgs = {
  input: MakeKeyBatchDownloadUrlInput;
};


/** Operations to update data in the Twitch API. */
export type MutationMakePredictionArgs = {
  input: MakePredictionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationManuallyTriggerDropArgs = {
  input: ManuallyTriggerDropInput;
};


/** Operations to update data in the Twitch API. */
export type MutationMarkAllCreatorNotificationsAsReadArgs = {
  input: MarkAllCreatorNotificationsAsReadInput;
};


/** Operations to update data in the Twitch API. */
export type MutationMarkAllViewerNotificationsAsReadArgs = {
  input?: InputMaybe<MarkAllViewerNotificationsAsReadInput>;
};


/** Operations to update data in the Twitch API. */
export type MutationModUserArgs = {
  input: ModUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationOrderPanelsArgs = {
  input: OrderPanelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationPresignDevInsightsReportUrlArgs = {
  input: PresignDevInsightsReportUrlInput;
};


/** Operations to update data in the Twitch API. */
export type MutationProcessAndroidPaymentArgs = {
  input: ProcessAndroidPaymentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationProcessIosPaymentArgs = {
  input: ProcessIosPaymentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationPublishClipArgs = {
  input: PublishClipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationPublishCompetitionArgs = {
  input: PublishCompetitionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationPublishSubscriptionEmoteArgs = {
  input: PublishSubscriptionEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationPurchaseOfferArgs = {
  input: PurchaseOfferInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRateExtensionArgs = {
  input: RateExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationReadNotificationsArgs = {
  input: ReadNotificationsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRecordAdEventArgs = {
  input: RecordAdEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemClaimableArgs = {
  input: RedeemClaimableInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemCommunityPointsCustomRewardArgs = {
  input: RedeemCommunityPointsCustomRewardInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemCreatorGiftsArgs = {
  input: RedeemCreatorGiftsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemRitualTokenArgs = {
  input: RedeemRitualTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemSubscriptionArgs = {
  input: RedeemSubscriptionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRedeemTrueXAdArgs = {
  input: RedeemTrueXAdInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRefreshExtensionTokenArgs = {
  input: RefreshExtensionTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRegenerateStreamKeyArgs = {
  input: RegenerateStreamKeyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRegenerateVerificationCodeArgs = {
  input: RegenerateVerificationCodeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRegisterPayoutInformationArgs = {
  input: RegisterPayoutInformationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRegisterTwoFactorArgs = {
  input: RegisterTwoFactorInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRegisterTwoFactorConfirmationArgs = {
  input: RegisterTwoFactorConfirmationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRejectFriendRequestArgs = {
  input: RejectFriendRequestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRejectSquadStreamInvitationArgs = {
  input: RejectSquadStreamInvitationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRejectSquadStreamOutOfNetworkInvitationsArgs = {
  input: RejectSquadStreamOutOfNetworkInvitationsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveAutohostChannelsArgs = {
  input: RemoveAutohostChannelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveCollectionItemArgs = {
  input: RemoveCollectionItemInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveCompetitionPhaseArgs = {
  input: RemoveCompetitionPhaseInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveCompetitionPlayerArgs = {
  input: RemoveCompetitionPlayerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveCompetitionTeamArgs = {
  input: RemoveCompetitionTeamInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveEditorArgs = {
  input: RemoveEditorInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveEmoteFromGroupArgs = {
  input: RemoveEmoteFromGroupInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveOrganizationMemberArgs = {
  input: RemoveOrganizationMemberInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveReactionArgs = {
  input: RemoveReactionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveSquadStreamMemberArgs = {
  input: RemoveSquadStreamMemberInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRemoveStuccoArgs = {
  input: RemoveStuccoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationReorderCollectionItemArgs = {
  input: ReorderCollectionItemInput;
};


/** Operations to update data in the Twitch API. */
export type MutationReportContentArgs = {
  input: ReportContentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationReportWhisperArgs = {
  input: ReportWhisperInput;
};


/** Operations to update data in the Twitch API. */
export type MutationReportWhisperThreadArgs = {
  input: ReportWhisperThreadInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRequestRitualTokenArgs = {
  input: RequestRitualTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationResendVerificationEmailArgs = {
  input: ResendVerificationEmailInput;
};


/** Operations to update data in the Twitch API. */
export type MutationResetUsernameArgs = {
  input: ResetUsernameInput;
};


/** Operations to update data in the Twitch API. */
export type MutationResolvePredictionEventArgs = {
  input: ResolvePredictionEventInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRespondToTeamInvitationArgs = {
  input: RespondToTeamInvitationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationResumeScheduleArgs = {
  input: ResumeScheduleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRevokeVipArgs = {
  input: RevokeVipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRotateExtensionSecretsArgs = {
  input: RotateExtensionSecretsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationRunMultiplayerAdsArgs = {
  input: RunMultiplayerAdsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSaveExtensionManifestArgs = {
  input: SaveExtensionManifestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSeedCompetitionParticipantArgs = {
  input: SeedCompetitionParticipantInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSelectChannelBadgeArgs = {
  input: SelectChannelBadgeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSelectGlobalBadgeArgs = {
  input: SelectGlobalBadgeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendChatMessageThroughSubscriberModeArgs = {
  input: SendChatMessageThroughSubscriberModeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendCheerArgs = {
  input: SendCheerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendExtensionMessageArgs = {
  input: SendExtensionMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendHighlightedChatMessageArgs = {
  input: SendHighlightedChatMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendRoomMessageArgs = {
  input: SendRoomMessageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSendWhisperArgs = {
  input: SendWhisperInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetAutoAdDensityArgs = {
  input: SetAutoAdDensityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetAutoRefillSettingsArgs = {
  input: SetAutoRefillSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetAutohostChannelsArgs = {
  input: SetAutohostChannelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetBitsUserSettingsArgs = {
  input: SetBitsUserSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetChannelFeedEnabledArgs = {
  input: SetChannelFeedEnabledInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetChannelNotificationSettingArgs = {
  input: SetChannelNotificationSettingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetChannelTrailerArgs = {
  input: SetChannelTrailerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetChatPauseSettingArgs = {
  input: SetChatPauseSettingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetContentTagsArgs = {
  input: SetContentTagsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetCreatorBadgeFlairArgs = {
  input: SetCreatorBadgeFlairInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDashboardAlertQueueActivityStatusArgs = {
  input: SetDashboardAlertQueueActivityStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDashboardAlertQueuePreferenceArgs = {
  input: SetDashboardAlertQueuePreferenceInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDefaultPaymentMethodArgs = {
  input: SetDefaultPaymentMethodInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDeletedMessageDisplaySettingArgs = {
  input: SetDeletedMessageDisplaySettingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropBenefitsOnDropArgs = {
  input: SetDropBenefitsOnDropInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropCampaignAccessArgs = {
  input: SetDropCampaignAccessInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropCampaignStatusArgs = {
  input: SetDropCampaignStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropCampaignSummaryArgs = {
  input: SetDropCampaignSummaryInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropEventRuleArgs = {
  input: SetDropEventRuleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropSummaryArgs = {
  input: SetDropSummaryInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetDropTimeBasedRuleArgs = {
  input: SetDropTimeBasedRuleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetEmoteAnimationsEnabledArgs = {
  input: SetEmoteAnimationsEnabledInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetEmoteAnimationsSettingCalloutDismissedArgs = {
  input: SetEmoteAnimationsSettingCalloutDismissedInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetEmoteModifierGroupsArgs = {
  input: SetEmoteModifierGroupsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetExtensionConfigurationArgs = {
  input: SetExtensionConfigurationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetExtensionFeatureFlagsArgs = {
  input: SetExtensionFeatureFlagsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetExtensionInstallationOAuthArgs = {
  input: SetExtensionInstallationOAuthInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetGameDropAccountLinkClientArgs = {
  input: SetGameDropAccountLinkClientInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetHeroAsAvatarArgs = {
  input: SetHeroAsAvatarInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetModLogsAccessArgs = {
  input: SetModLogsAccessInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetModViewSettingsArgs = {
  input: SetModViewSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetNotificationSettingArgs = {
  input: SetNotificationSettingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetOverwatchLeagueTeamPreferenceArgs = {
  input: SetOverwatchLeagueTeamPreferenceInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetPreferredLanguageTagArgs = {
  input: SetPreferredLanguageTagInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetRadioCurrentlyPlayingArgs = {
  input: SetRadioCurrentlyPlayingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetReadableChatColorsEnabledArgs = {
  input: SetReadableChatColorsEnabledInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetResourceRestrictionArgs = {
  input: SetResourceRestrictionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetScheduleReminderArgs = {
  input: SetScheduleReminderInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetSessionStatusArgs = {
  input: SetSessionStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetSquadStreamPrimaryPlayerArgs = {
  input: SetSquadStreamPrimaryPlayerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetUnbanRequestsSettingsArgs = {
  input: SetUnbanRequestsSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSetUserResidenceArgs = {
  input: SetUserResidenceInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSpendSubscriptionCreditArgs = {
  input: SpendSubscriptionCreditInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStartAdArgs = {
  input: StartAdInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStartBountyArgs = {
  input: StartBountyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStartCloudBroadcastArgs = {
  input: StartCloudBroadcastInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStartPayoutOnboardingWorkflowArgs = {
  input: StartPayoutOnboardingWorkflowInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStartWatchPartyArgs = {
  input: StartWatchPartyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStopBountyArgs = {
  input: StopBountyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStopCloudBroadcastArgs = {
  input: StopCloudBroadcastInput;
};


/** Operations to update data in the Twitch API. */
export type MutationStopWatchPartyArgs = {
  input: StopWatchPartyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSubmitCsatFeedbackArgs = {
  input: SubmitCsatFeedbackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSubmitEmotePrefixArgs = {
  input: SubmitEmotePrefixInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSubmitEmoticonPrefixArgs = {
  input: SubmitEmoticonPrefixInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSubmitExtensionFeedbackArgs = {
  input: SubmitExtensionFeedbackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSwapCompetitionLobbyParticipantsArgs = {
  input: SwapCompetitionLobbyParticipantsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationSyncGameOnDropCampaignArgs = {
  input: SyncGameOnDropCampaignInput;
};


/** Operations to update data in the Twitch API. */
export type MutationTerminatePollArgs = {
  input: TerminatePollInput;
};


/** Operations to update data in the Twitch API. */
export type MutationTerminatePollInChannelArgs = {
  input: TerminatePollInChannelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationToggleRitualsEnabledArgs = {
  input: ToggleRitualsEnabledInput;
};


/** Operations to update data in the Twitch API. */
export type MutationTransitionExtensionStateArgs = {
  input: TransitionExtensionStateInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnbanUserFromChatRoomArgs = {
  input: UnbanUserFromChatRoomInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnblockUserArgs = {
  input: UnblockUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUndoRecommendationFeedbackArgs = {
  input: UndoRecommendationFeedbackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnfollowGameArgs = {
  input: UnfollowGameInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnfollowUserArgs = {
  input: UnfollowUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnfriendUserArgs = {
  input: UnfriendUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnhostArgs = {
  input: UnhostInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUninstallExtensionArgs = {
  input: UninstallExtensionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlinkAmazonConnectionArgs = {
  input: UnlinkAmazonConnectionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlinkRiotConnectionArgs = {
  input: UnlinkRiotConnectionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlinkSsoArgs = {
  input: UnlinkSsoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlockChosenModifiedSubscriberEmoteArgs = {
  input: UnlockChosenModifiedSubscriberEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlockChosenSubscriberEmoteArgs = {
  input: UnlockChosenSubscriberEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnlockRandomSubscriberEmoteArgs = {
  input: UnlockRandomSubscriberEmoteInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnmodUserArgs = {
  input: UnmodUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnsetHypeTrainConfigArgs = {
  input: UnsetHypeTrainConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUnsubscribeEmailArgs = {
  input: UnsubscribeEmailInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAdPropertiesArgs = {
  input: UpdateAdPropertiesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAllChannelVideosViewabilityArgs = {
  input: UpdateAllChannelVideosViewabilityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAllWhisperThreadsArgs = {
  input: UpdateAllWhisperThreadsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAutoModLevelsArgs = {
  input: UpdateAutoModLevelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAutoModPropertiesArgs = {
  input: UpdateAutoModPropertiesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateAutohostSettingsArgs = {
  input: UpdateAutohostSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateBitsBadgeTierNotificationArgs = {
  input: UpdateBitsBadgeTierNotificationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateBitsBadgeTiersArgs = {
  input: UpdateBitsBadgeTiersInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateBoostSettingsArgs = {
  input: UpdateBoostSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateBroadcastSettingsArgs = {
  input: UpdateBroadcastSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCelebrationArgs = {
  input: UpdateCelebrationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCelebrationConfigArgs = {
  input: UpdateCelebrationConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCelebrationProductConfigArgs = {
  input: UpdateCelebrationProductConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCelebrationUserSettingsArgs = {
  input: UpdateCelebrationUserSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChanletContentAttributesArgs = {
  input: UpdateChanletContentAttributesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChannelClipsSettingArgs = {
  input: UpdateChannelClipsSettingInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChannelHomePreferencesArgs = {
  input: UpdateChannelHomePreferencesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChannelPredictionSettingsArgs = {
  input: UpdateChannelPredictionSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChatColorArgs = {
  input: UpdateChatColorInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateChatSettingsArgs = {
  input: UpdateChatSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCheerPartnerSettingsArgs = {
  input: UpdateCheerPartnerSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCheermoteTierArgs = {
  input: UpdateCheermoteTierInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateClipArgs = {
  input: UpdateClipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateClipViewCountArgs = {
  input: UpdateClipViewCountInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCollectionArgs = {
  input: UpdateCollectionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsAutomaticRewardArgs = {
  input: UpdateCommunityPointsAutomaticRewardInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsChannelSettingsArgs = {
  input: UpdateCommunityPointsChannelSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCommunityGoalArgs = {
  input: UpdateCommunityPointsCommunityGoalInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCustomRewardArgs = {
  input: UpdateCommunityPointsCustomRewardInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCustomRewardRedemptionStatusArgs = {
  input: UpdateCommunityPointsCustomRewardRedemptionStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCustomRewardRedemptionStatusesByChannelArgs = {
  input: UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsArgs = {
  input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsCustomRewardRedemptionStatusesByRewardArgs = {
  input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsEarlyAccessSettingsArgs = {
  input: UpdateCommunityPointsEarlyAccessSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsLastViewedContentArgs = {
  input: UpdateCommunityPointsLastViewedContentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCommunityPointsSmartCostsAcknowledgementsArgs = {
  input: UpdateCommunityPointsSmartCostsAcknowledgementsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCompetitionArgs = {
  input: UpdateCompetitionInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCompetitionPlayerArgs = {
  input: UpdateCompetitionPlayerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateCompetitionTeamArgs = {
  input: UpdateCompetitionTeamInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateConsentArgs = {
  input: UpdateConsentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateContentTagsArgs = {
  input: UpdateContentTagsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateDashboardViewMosaicLayoutArgs = {
  input: UpdateDashboardViewMosaicLayoutInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateDropBenefitArgs = {
  input: UpdateDropBenefitInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateDropBenefitOnDropArgs = {
  input: UpdateDropBenefitOnDropInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateDropPreconditionsArgs = {
  input: UpdateDropPreconditionsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateDropsOptOutStatusArgs = {
  input: UpdateDropsOptOutStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateEmoteOrdersArgs = {
  input: UpdateEmoteOrdersInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateExtensionDiscoveryDataArgs = {
  input: UpdateExtensionDiscoveryDataInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateExtensionManifestArgs = {
  input: UpdateExtensionManifestInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateHypeTrainConfigArgs = {
  input: UpdateHypeTrainConfigInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateIsSharingActivityArgs = {
  input: UpdateIsSharingActivityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateLwaTokenArgs = {
  input: UpdateLwaTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateLeaderboardSettingsArgs = {
  input: UpdateLeaderboardSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateLiveUpNotificationArgs = {
  input: UpdateLiveUpNotificationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateLobbyParticipantScoreArgs = {
  input: UpdateLobbyParticipantScoreInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateMultiviewContentAttributesArgs = {
  input: UpdateMultiviewContentAttributesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateOnboardingSkippedChannelsArgs = {
  input: UpdateOnboardingSkippedChannelsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateOrganizationMemberRoleArgs = {
  input: UpdateOrganizationMemberRoleInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateOwnerChanletAttributesArgs = {
  input: UpdateOwnerChanletAttributesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdatePanelArgs = {
  input: UpdatePanelInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdatePhoneNumberArgs = {
  input: UpdatePhoneNumberInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdatePhoneNumberConfirmationArgs = {
  input: UpdatePhoneNumberConfirmationInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdatePrimeOfferStatusArgs = {
  input: UpdatePrimeOfferStatusInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdatePrimeSettingsArgs = {
  input: UpdatePrimeSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateRaidSettingsArgs = {
  input: UpdateRaidSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateRoomArgs = {
  input: UpdateRoomInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateRoomModesArgs = {
  input: UpdateRoomModesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateRoomViewArgs = {
  input: UpdateRoomViewInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateScheduleSegmentArgs = {
  input: UpdateScheduleSegmentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateSeenCreatorOnboardingContentArgs = {
  input: UpdateSeenCreatorOnboardingContentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateSocialMediaArgs = {
  input: UpdateSocialMediaInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateSquadInvitePolicyArgs = {
  input: UpdateSquadInvitePolicyInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateSquadStreamArgs = {
  input: UpdateSquadStreamInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateStuccoArgs = {
  input: UpdateStuccoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateStuccoPackArgs = {
  input: UpdateStuccoPackInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateSubscriptionProductArgs = {
  input: UpdateSubscriptionProductInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserColorsArgs = {
  input: UpdateUserColorsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserCreateDateHiddenArgs = {
  input: UpdateUserCreateDateHiddenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserDirectoryHiddenArgs = {
  input: UpdateUserDirectoryHiddenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserEmailReusableArgs = {
  input: UpdateUserEmailReusableInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserIsEmailRevertSuccessArgs = {
  input: UpdateUserIsEmailRevertSuccessInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserPredictionSettingsArgs = {
  input: UpdateUserPredictionSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserSubscriptionSettingsArgs = {
  input: UpdateUserSubscriptionSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserTeamMembershipArgs = {
  input: UpdateUserTeamMembershipInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserVideoShelvesArgs = {
  input: UpdateUserVideoShelvesInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateUserViewedVideoArgs = {
  input: UpdateUserViewedVideoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateVideoArgs = {
  input: UpdateVideoInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateVideoCommentArgs = {
  input: UpdateVideoCommentInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateVideoStreamSettingsArgs = {
  input: UpdateVideoStreamSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateVideosViewabilityArgs = {
  input: UpdateVideosViewabilityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateVisibilityArgs = {
  input: UpdateVisibilityInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateWhisperSettingsArgs = {
  input: UpdateWhisperSettingsInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUpdateWhisperThreadArgs = {
  input: UpdateWhisperThreadInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUploadCompetitionImageArgs = {
  input: UploadCompetitionImageInput;
};


/** Operations to update data in the Twitch API. */
export type MutationUseChatNotificationTokenArgs = {
  input: UseChatNotificationTokenInput;
};


/** Operations to update data in the Twitch API. */
export type MutationValidateVerificationCodeArgs = {
  input: ValidateVerificationCodeInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVerifyContactMethodArgs = {
  input: VerifyContactMethodInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVerifyOneTimePasswordArgs = {
  input: VerifyOneTimePasswordInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVerifyRewardedVideoEligibilityCaptchaArgs = {
  input: VerifyRewardedVideoEligibilityCaptchaInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVisitStreamManagerArgs = {
  input: VisitStreamManagerInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVoteInAdPollArgs = {
  input: VoteInAdPollInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVoteInPollArgs = {
  input: VoteInPollInput;
};


/** Operations to update data in the Twitch API. */
export type MutationVoteInPollByChoiceIndexArgs = {
  input: VoteInPollByChoiceIndexInput;
};

/** GDPR cookie vendors for vendors that dont support TCF strings, for a user. */
export type NonTcfCookieVendor = {
  __typename?: 'NonTCFCookieVendor';
  /** User content status for each vendor. */
  consentStatus: ConsentStatus;
  /** If it’s an advertising, analytics, or essential cookie. */
  cookieVendorType: CookieVendorType;
  /** A flag that shows if the consent is given by the user or by consent service as default value. */
  hasUserSetConsent: Scalars['Boolean'];
  /** A flag that shows if the vendor should be visible to management page. */
  isVisible: Scalars['Boolean'];
  /** Vendor name. */
  name: VendorName;
  /** Url to the Vendor's privacy policy. */
  policyURL: Scalars['String'];
};

/** Information about a registered developer OAuth application. */
export type OAuthApp = {
  __typename?: 'OAuthApp';
  /** The category that describes the app's type. */
  category?: Maybe<OAuthAppCategory>;
  /** The timestamp when the app was created. */
  createdAt: Scalars['Time'];
  /** The ID of the app. It is the value of the `Client-ID` header when the app makes API requests. */
  id: Scalars['ID'];
  /** The name of the app. */
  name: Scalars['String'];
  /** The user-provided description of the app's type. Used if `Category` is Other. */
  otherDescription?: Maybe<Scalars['String']>;
  /** Owner is the user that owns this app. */
  owner?: Maybe<User>;
  /** The URI to which users should be redirected after authorizing the app. */
  redirectURI: Scalars['String'];
  /** The client secret of the app. */
  secret: Scalars['String'];
  /** The timestamp when the app was last updated. */
  updatedAt: Scalars['Time'];
  /** Whether the app's OAuth tokens expire. */
  willTokensExpire: Scalars['Boolean'];
};

/** Possible categories of developer apps. */
export enum OAuthAppCategory {
  /** Analytics tool category. */
  AnalyticsTool = 'ANALYTICS_TOOL',
  /** Application integration category. */
  ApplicationIntegration = 'APPLICATION_INTEGRATION',
  /** Broadcaster suite category. */
  BroadcasterSuite = 'BROADCASTER_SUITE',
  /** Browser extension category. */
  BrowserExtension = 'BROWSER_EXTENSION',
  /** Chat bot category. */
  ChatBot = 'CHAT_BOT',
  /** Game integration category. */
  GameIntegration = 'GAME_INTEGRATION',
  /** Giveaway loyalty tool category. */
  GiveawayLoyaltyTool = 'GIVEAWAY_LOYALTY_TOOL',
  /** Category for when the other categories do not describe. */
  Other = 'OTHER',
  /** Website integration category. */
  WebsiteIntegration = 'WEBSITE_INTEGRATION'
}

/** A list of applications. */
export type OAuthAppConnection = {
  __typename?: 'OAuthAppConnection';
  /** The applications. */
  edges: Array<OAuthAppEdge>;
  /** Pagination. */
  pageInfo: PageInfo;
};

/** A broadcaster user with cursor. */
export type OAuthAppEdge = {
  __typename?: 'OAuthAppEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the app for the current edge. */
  node: OAuthApp;
};

/** OEmbed is a universal spec converted to GraphQL from http://oembed.com/. */
export type OEmbed = {
  authorName?: Maybe<Scalars['String']>;
  authorURL?: Maybe<Scalars['String']>;
  cacheAge?: Maybe<Scalars['Int']>;
  /**
   * The inputURL is the URL that we are trying to resolve via oEmbed.  It is not part
   * of the official spec, but GQL implementations practically need to use it.
   */
  inputURL: Scalars['String'];
  providerName?: Maybe<Scalars['String']>;
  providerURL?: Maybe<Scalars['String']>;
  /**
   * The description of thumbnail from the oembed spec fits with an optional thumbnail
   * type with required parameters.
   */
  thumbnail?: Maybe<ThumbnailOEmbed>;
  title?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  version: Scalars['String'];
};

/** Offer describes something that is purchasable. */
export type Offer = {
  __typename?: 'Offer';
  /** Details of the user's eligibility to purchase the Offer. */
  eligibility: OfferEligibility;
  /** The time at which this Offer ceases to be valid for purchase. If null, this Offer will never expire. */
  endAt?: Maybe<Scalars['Time']>;
  /** The type of the gift offer (will be omitted if the Offer is not a gift). */
  giftType?: Maybe<GiftType>;
  /** Unique identifier for an Offer. */
  id: Scalars['ID'];
  /** A listing describing the charge model and cancellation policy for the Offer. */
  listing?: Maybe<OfferListing>;
  /** The platform on which the Offer is eligible for purchase. */
  platform: OfferPlatform;
  /** A Promotion object describes the promotion to be applied on an Offer (if any). */
  promotion?: Maybe<OfferPromotion>;
  /** Quantity is the configured purchase quantity restrictions. */
  quantity?: Maybe<Range>;
  /** The authenticated user's relationship with the Offer. */
  self?: Maybe<OfferSelfEdge>;
  /** The time at which this Offer becomes valid for purchase. */
  startAt: Scalars['Time'];
  /** Tag bindings provide static and dynamic bindings of the attributes on an Offer. */
  tagBindings: Array<OfferTagBinding>;
  /** Tenant product line registry to which this Offer belongs. */
  tplr: Scalars['String'];
};

/** Contains an offer ID and offer status. */
export type OfferAndStatus = {
  /** Unique Identifier for an offer. */
  offerID: Scalars['ID'];
  /** The status to set the offer to for the specified user. */
  status: Scalars['String'];
};

/** Deliver method type for Prime Offers entitlements. */
export enum OfferDeliveryMethod {
  /** The entitlement will be delivered as a claim code, which can be used to get the entitlement. */
  ClaimCode = 'CLAIM_CODE',
  /** The entitlement will be directly delivered. */
  DirectEntitlement = 'DIRECT_ENTITLEMENT',
  /**
   * Misspelling of EXTERNAL_OFFER.
   * @deprecated Use EXTERNAL_OFFER instead
   */
  External = 'EXTERNAL',
  /** The entitlement will be delivered via external means. */
  ExternalOffer = 'EXTERNAL_OFFER',
  /** The entitlement will be directly delivered and a Twitch account is not needed for the offer. */
  SesEntitlement = 'SES_ENTITLEMENT'
}

/** OfferEligibility describes user's eligibility to purchase an Offer. */
export type OfferEligibility = {
  __typename?: 'OfferEligibility';
  /**
   * If the user is eligible for the Offer, then this is set to the
   * time at which the user's benefits would expire if the
   * Offer is purchased. If null, the benefits never expire.
   */
  benefitsEndAt?: Maybe<Scalars['Time']>;
  /**
   * If the user is eligible for the Offer, then this is set to the
   * time at which the user's benefits would become available if the
   * Offer is purchased.
   */
  benefitsStartAt?: Maybe<Scalars['Time']>;
  /** A boolean that is true when the user is eligible for the Offer. */
  isEligible: Scalars['Boolean'];
  /**
   * Allows tenants to override the maximum purchasable quantity for an offer
   * within a checkout session (used in purchase velocity cases).
   */
  maxQuantityOverride?: Maybe<Scalars['Int']>;
  /** Provides extra contextual details for the type of purchase. */
  purchaseType: OfferPurchaseType;
  /**
   * If the user is ineligible for the Offer, then this code is set
   * as the reason why the user is ineligible.
   */
  reasonCode?: Maybe<OfferIneligibilityReasonCode>;
};

/** OfferIneligibilityReasonCode indicates why a user isn't eligible. */
export enum OfferIneligibilityReasonCode {
  /** Not eligible because the user has already purchased this offer. */
  AlreadyPurchased = 'ALREADY_PURCHASED',
  /** Not eligible because something about the transaction could not be verified. */
  CouldNotVerify = 'COULD_NOT_VERIFY',
  /** Offer would exceed user's max token balance. */
  MaxTokenBalance = 'MAX_TOKEN_BALANCE',
  /** No ineligibility reason was given. */
  None = 'NONE',
  /** The reason for ineligibility could not be resolved. */
  Other = 'OTHER'
}

/** OfferListing defines the charge model for a given listing. */
export type OfferListing = {
  __typename?: 'OfferListing';
  /** The conditions around a user's cancellation of their purchase (e.g. refund policy). */
  cancellationPolicy: CancellationPolicyType;
  /** FIAT/non-FIAT based charge model OR 3P managed SKU. */
  chargeModel: ChargeModel;
};

/** The platform on which the Offer is valid. */
export enum OfferPlatform {
  /** The Android app. */
  Android = 'ANDROID',
  /** The desktop app. */
  Desktop = 'DESKTOP',
  /** The iOS app. */
  Ios = 'IOS',
  /** The web site. */
  Web = 'WEB'
}

/** Promotion is a modifier to an Offer. */
export type OfferPromotion = {
  __typename?: 'OfferPromotion';
  /** End time of a promotion (empty if evergreen promotion). */
  endAt?: Maybe<Scalars['Time']>;
  /** Unique identifier for a Promotion. */
  id: Scalars['ID'];
  /**
   * The OfferListing associated with this Promotion.
   * @deprecated No longer used, currently left for backwards compatibility
   */
  listing: OfferListing;
  /** Unique name for a Promotion. */
  name: Scalars['String'];
  /** Describes the priority of the Promotion (the higher the priorty, the more important the promo). */
  priority: Scalars['Int'];
  /** Describe the Promotions metadata to display to the client. */
  promoDisplay: PromotionDisplay;
  /** Start time of a promotion. */
  startAt: Scalars['Time'];
};

/** OfferPUrchaseType provides extra contextual details for the type of purchase. */
export enum OfferPurchaseType {
  /** This offer is a default, standard purchase. */
  DefaultPurchase = 'DEFAULT_PURCHASE',
  /** This offer being purchased will be a tier downgrade from their current active tier. */
  DowngradeRecurringSubTier = 'DOWNGRADE_RECURRING_SUB_TIER',
  /** This offer being purchased is future-dated. */
  FuturePurchase = 'FUTURE_PURCHASE',
  /** This offer being purchased will be a tier upgrade from their current active tier. */
  UpgradeRecurringSubTier = 'UPGRADE_RECURRING_SUB_TIER'
}

/** The authenticated user's relationship with the offer. */
export type OfferSelfEdge = {
  __typename?: 'OfferSelfEdge';
  /** Returns any fraud-related checkout actions that the client must invoke. */
  checkoutActions?: Maybe<Array<CheckoutAction>>;
  /** Configs that initiate the user's checkout flow for this Offer. */
  checkoutConfiguration?: Maybe<CheckoutConfiguration>;
  /** Provides a list of eligible payment methods that the user can select for this offer. */
  eligiblePaymentMethods?: Maybe<Array<EligiblePaymentMethod>>;
};


/** The authenticated user's relationship with the offer. */
export type OfferSelfEdgeCheckoutActionsArgs = {
  paymentSession?: InputMaybe<PaymentSession>;
  quantity: Scalars['Int'];
};

/** Enum indicating the current live state of a given Prime Gaming content offer. */
export enum OfferState {
  /** The offer is no longer live and has expired. */
  Expired = 'EXPIRED',
  /** The offer will be live in the future. */
  Future = 'FUTURE',
  /** The offer is currently live. */
  Live = 'LIVE'
}

/** Enum indicating the visual status of the offer to the user. */
export enum OfferStatus {
  /** The user has claimed this offer. */
  Claimed = 'CLAIMED',
  /** The user has dismissed this offer card from the Crown and can no longer see it. */
  Dismissed = 'DISMISSED',
  /** The user's offer status is in a errored state. */
  Error = 'ERROR',
  /** A previous SEEN or DISMISSED status has been overridden to allow the offer card to be visible on the Crown. */
  Overridden = 'OVERRIDDEN',
  /** The user has seen this offer card on the Crown. */
  Seen = 'SEEN',
  /** The user has not seen this offer card on the Crown. */
  Unseen = 'UNSEEN'
}

/** OfferTagBinding defines a key-value pair. */
export type OfferTagBinding = {
  __typename?: 'OfferTagBinding';
  /** The key of the tag. */
  key: Scalars['String'];
  /** The value of the tag. */
  value: Scalars['String'];
};

/** OfferTagBindingInput defines a key-value pair. */
export type OfferTagBindingInput = {
  /** The key of the tag. */
  key: Scalars['String'];
  /** The value of the tag. */
  value: Scalars['String'];
};

/** Current state of the user in the onboarding process. */
export type Onboarding = {
  __typename?: 'Onboarding';
  /**
   * Retrieves a list of streams that have been selected for onboarding based on a user's followed games.
   * `first` is the number of streams PER FOLLOWED GAME to fetch.
   * `locale` is a language code that will filter streams by if there are viewers with that language code (ex. "en-US", "es-ES", or "de-AT").
   * `languages` is list of language codes that will be used to filter streams by the broadcaster language. (ex. [EN, KO]).
   * `games` are a list of game ids that would replace the user's followed games for fetching the streams.
   * @deprecated This feature has been sunset.
   */
  onboardingStreams?: Maybe<Array<Maybe<Stream>>>;
  /**
   * List of channel IDs skipped by a user during onboarding.
   * @deprecated This feature is retired
   */
  skippedChannelIDs?: Maybe<Array<Scalars['ID']>>;
};


/** Current state of the user in the onboarding process. */
export type OnboardingOnboardingStreamsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  games?: InputMaybe<Array<Scalars['String']>>;
  languages?: InputMaybe<Array<Language>>;
  locale?: InputMaybe<Scalars['String']>;
};

export type OnsiteNotification = {
  __typename?: 'OnsiteNotification';
  /** Actions of the notification. */
  actions: Array<OnsiteNotificationAction>;
  /** Body of the notification in Markdown format. */
  body: Scalars['String'];
  /** Category of the notification (only for dart ones). */
  category?: Maybe<Scalars['String']>;
  /** When this notification was created. */
  createdAt: Scalars['Time'];
  /** List of users that created this notification. */
  creators: Array<Maybe<User>>;
  /**
   * Destination type to route users to when they interact with the notification on non-web clients.
   * Values include Homepage, ChannelPage, NotificationSettingsPage, and BroadcasterDashboard.
   */
  destinationType?: Maybe<Scalars['String']>;
  /** Determines where the notification will be displayed at front end. */
  displayType: OnsiteNotificationDisplayType;
  /**
   * Optional extra notification content.
   * When type is "vodupload", extra is Video.
   * When type is "hotclipfollower", extra is Clip.
   * When type is "hotclip", extra is Clip.
   * When type is "subgiftreceived", extra is User.
   * When type is "vodcomment", extra is VideoComment.
   * When type is "vodcommentmod", extra is VideoComment.
   * When type is "vodcommentreply", extra is VideoComment.
   * When destination is "ChannelPage", extra is User.
   * When destination is "BrowseGame", extra is Game.
   * When destination is "ExternalLink", extra is OnsiteNotificationExternalLink.
   */
  extra?: Maybe<OnsiteNotificationContent>;
  /** ID of the notification. */
  id: Scalars['ID'];
  /** Whether this notification is read. */
  isRead: Scalars['Boolean'];
  /** Type of onsite render style. */
  renderStyle: OnsiteNotificationRenderStyle;
  /** A URL to a thumbnail image. */
  thumbnailURL: Scalars['String'];
  /** Type of notification. */
  type: Scalars['String'];
  /** When notification was last updated. */
  updatedAt: Scalars['Time'];
};

export type OnsiteNotificationAction = {
  __typename?: 'OnsiteNotificationAction';
  /** Body of the notification action in plain text. */
  body: Scalars['String'];
  /** ID of the action. */
  id: Scalars['ID'];
  /** Label of the action. */
  label: Scalars['String'];
  /** ID of the modal that will open on click, if it is a modal CTA. */
  modalID: Scalars['ID'];
  /** Type of the notification action. */
  type: Scalars['String'];
  /** URL of the notification action. */
  url: Scalars['String'];
};

export type OnsiteNotificationConnection = {
  __typename?: 'OnsiteNotificationConnection';
  /** List of notifications. */
  edges?: Maybe<Array<OnsiteNotificationEdge>>;
  /** Information about pagination in this connection. */
  pageInfo?: Maybe<PageInfo>;
  /** Notifications summary. */
  summary?: Maybe<OnsiteNotificationsSummary>;
};

/** Extra onsite notification content. */
export type OnsiteNotificationContent = Clip | Game | OnsiteNotificationExternalLink | User | Video | VideoComment;

/** Determines where the notification will be displayed at front end. */
export enum OnsiteNotificationDisplayType {
  /** Notifications that will be displayed in the "My Channel" tab. */
  Creator = 'CREATOR',
  /** Notifications that will be displayed in the "My Twitch" tab. */
  Viewer = 'VIEWER'
}

export type OnsiteNotificationEdge = {
  __typename?: 'OnsiteNotificationEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The notification. */
  node: OnsiteNotification;
};

/** Extra onsite notification content returned when the notification links to an external site. */
export type OnsiteNotificationExternalLink = {
  __typename?: 'OnsiteNotificationExternalLink';
  /** The link that the notification opens when clicked. */
  url: Scalars['String'];
};

/** Used to determine how to render the onsite notification. */
export enum OnsiteNotificationRenderStyle {
  /** The default render style with no buttons and a single click CTA. */
  Default = 'DEFAULT',
  /** Rendered with two CTA buttons. */
  TwoButtons = 'TWO_BUTTONS'
}

/** Capabilities that a mobile client has for displaying onsite notifications. */
export enum OnsiteNotificationsCapability {
  /** Pushy notification type affiliateinvite. */
  AffiliateInvite = 'AFFILIATE_INVITE',
  /** Mobile destination type BroadcasterDashboard. */
  BroadcasterDashboard = 'BROADCASTER_DASHBOARD',
  /** Mobile destination type BrowseGame. */
  BrowseGame = 'BROWSE_GAME',
  /** Mobile destination type ChannelPage. */
  ChannelPage = 'CHANNEL_PAGE',
  /** Pushy notification type communityguidelineschange. */
  CommunityGuidelinesChange = 'COMMUNITY_GUIDELINES_CHANGE',
  /** Pushy notification type dropsavailable. */
  DropsAvailable = 'DROPS_AVAILABLE',
  /** Mobile destination type ExternalLink. */
  ExternalLink = 'EXTERNAL_LINK',
  /** Mobile destination type FriendRequest. */
  FriendRequest = 'FRIEND_REQUEST',
  /** Mobile destination type Homepage. */
  Homepage = 'HOMEPAGE',
  /** Pushy notification type hotclip. */
  HotClip = 'HOT_CLIP',
  /** Pushy notification type hotclipfollower. */
  HotClipFollower = 'HOT_CLIP_FOLLOWER',
  /** Mobile destination type NotificationSettingsPage. */
  NotificationSettingsPage = 'NOTIFICATION_SETTINGS_PAGE',
  /** Pushy notification type smartannouncement. */
  SmartAnnouncement = 'SMART_ANNOUNCEMENT',
  /** Pushy notification type subgiftreceived. */
  SubGiftReceived = 'SUB_GIFT_RECEIVED',
  /** Pushy notification type vodcomment. */
  VodComment = 'VOD_COMMENT',
  /** Pushy notification type vodcommentmod. */
  VodCommentMod = 'VOD_COMMENT_MOD',
  /** Pushy notification type vodcommentreply. */
  VodCommentReply = 'VOD_COMMENT_REPLY',
  /** Pushy notification type vodupload. */
  VodUpload = 'VOD_UPLOAD',
  /** Mobile destination type WebOnly. */
  WebOnly = 'WEB_ONLY',
  /** Mobile destination type WhisperThread. */
  WhisperThread = 'WHISPER_THREAD'
}

export type OnsiteNotificationsSummary = {
  __typename?: 'OnsiteNotificationsSummary';
  /** Unread summary for creator display type. */
  creatorUnreadSummary?: Maybe<OnsiteNotificationsUnreadSummary>;
  /** Last time notifications were seen. */
  lastSeenAt?: Maybe<Scalars['Time']>;
  /** Number of unseen notifications. */
  unseenCount: Scalars['Int'];
  /** Unread summary for viewer display type. */
  viewerUnreadSummary?: Maybe<OnsiteNotificationsUnreadSummary>;
};

/** Contains summary for unread infomation. */
export type OnsiteNotificationsUnreadSummary = {
  __typename?: 'OnsiteNotificationsUnreadSummary';
  /** Last time user marked all as read. */
  lastReadAllAt?: Maybe<Scalars['Time']>;
  /** Number of unread notifications. */
  unreadCount: Scalars['Int'];
};

export type OrderPanelsInput = {
  ids: Array<Scalars['ID']>;
};

export type OrderPanelsPayload = {
  __typename?: 'OrderPanelsPayload';
  /** List of panels in their new order. */
  panels?: Maybe<Array<Maybe<Panel>>>;
};

/** A developer organization. */
export type Organization = {
  __typename?: 'Organization';
  /** The bounty board campaigns that the company owns. */
  bountyCampaigns?: Maybe<BountyCampaignConnection>;
  /** The brand portal settings for the company. */
  brandPortalSettings?: Maybe<BrandPortalSettings>;
  /** ID of the Company in the CurseForge Infrastructure. */
  curseCompanyID?: Maybe<Scalars['ID']>;
  /**
   * Drop Campaigns developed by the organization.
   * @deprecated Use Organization.drops instead
   */
  dropCampaigns?: Maybe<Array<DropCampaign>>;
  /** Drop 2.0 Campaigns and Benefits configured for the organization. */
  drops: OrganizationDrops;
  /** The estimated viewer reach for the pool of broadcasters this company is considering targeting. */
  estimatedBroadcasterViewerReach?: Maybe<BroadcasterViewerReach>;
  /**
   * The games associated with the company. Optionally include games that a company can use for Bounty Board
   * campaigns (ie. "Just Chatting" for trailer campaigns).
   */
  games?: Maybe<Array<Game>>;
  /** The company's unique identifier. */
  id: Scalars['ID'];
  /** List of pending invites. */
  invites?: Maybe<OrganizationInviteConnection>;
  /** Legacy Companies need to agree to the Drops Terms. */
  isCampaignsEnabled: Scalars['Boolean'];
  /** Legacy Companies are required to sign the Contract. */
  isContractSigned: Scalars['Boolean'];
  /** Indicates if the Company is a Legacy Company from the first iteration of the DevSite. */
  isLegacy: Scalars['Boolean'];
  /** A list of rbac users who are apart of an organization. */
  members?: Maybe<OrganizationMemberConnection>;
  /** The human-readable name of the company. */
  name: Scalars['String'];
  /** Attributes related to the current user. */
  self?: Maybe<OrganizationSelfEdge>;
  /** Indicates if company is a developer, publisher or other. */
  type: OrganizationType;
  /** The Company URL for their Corporate Website. */
  url: Scalars['String'];
};


/** A developer organization. */
export type OrganizationBountyCampaignsArgs = {
  campaignID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<BountyCampaignStatus>;
};


/** A developer organization. */
export type OrganizationEstimatedBroadcasterViewerReachArgs = {
  countries?: InputMaybe<Array<Scalars['String']>>;
  gameNames: Array<Scalars['String']>;
  streamLengthSeconds?: InputMaybe<Scalars['Int']>;
  targetAllBroadcasters: Scalars['Boolean'];
  targetAllCountries?: InputMaybe<Scalars['Boolean']>;
  targetAllGames?: InputMaybe<Scalars['Boolean']>;
  targetVarietyBroadcasters: Scalars['Boolean'];
};


/** A developer organization. */
export type OrganizationGamesArgs = {
  includeBountyBoardGames?: InputMaybe<Scalars['Boolean']>;
};


/** A developer organization. */
export type OrganizationInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** A developer organization. */
export type OrganizationMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  input?: InputMaybe<OrganizationMembersInput>;
};

/** Status of company applications. */
export enum OrganizationAppilcationStatus {
  /** Application has been approved. */
  Approved = 'APPROVED',
  /** Application has been deleted. */
  Deleted = 'DELETED',
  /** Application is pending. */
  Pending = 'PENDING',
  /** Application has been rejected. */
  Rejected = 'REJECTED'
}

/** OrganizationApplication is the application for requesting an organization be added to Twitch Developer Organizations. */
export type OrganizationApplication = {
  __typename?: 'OrganizationApplication';
  /**
   * Email of the person creating the application.
   * Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
   * @deprecated No longer collecting contact email.
   */
  contactEmail?: Maybe<Scalars['String']>;
  /** The name of applying organization. */
  organizationName: Scalars['String'];
  /** Current status of the company application. */
  status: OrganizationAppilcationStatus;
};

/**
 * OrganizationDrop links organizations to the campaigns it has configured
 * and the benefits that it has created.
 */
export type OrganizationDrops = {
  __typename?: 'OrganizationDrops';
  /** The benefits created for this organization that can be added to the organization's drops. */
  benefits?: Maybe<Array<DropBenefit>>;
  /** The campaigns configued for this organizaiton. */
  campaigns?: Maybe<Array<DropCampaign>>;
};

/** An invitation to join a developer organization under a given role. */
export type OrganizationInvite = {
  __typename?: 'OrganizationInvite';
  /** When the invitation was created. */
  createdAt: Scalars['Time'];
  /** The date and time the invite will expire. */
  expiresAt: Scalars['Time'];
  /** The invites's unique identifier. */
  id: Scalars['ID'];
  /** User the invitation if for. */
  invitee?: Maybe<User>;
  /** User who created the invitation. */
  inviter?: Maybe<User>;
  /** ID of the organization the invitation is for. */
  organizationID: Scalars['ID'];
  /** Name of the organization the invitation is for. */
  organizationName: Scalars['String'];
  /** Role the invitation is for. */
  role: OrganizationMemberRole;
};

/** Paginated list of organization invites in an organization. */
export type OrganizationInviteConnection = {
  __typename?: 'OrganizationInviteConnection';
  /** The elements of the paginated list. */
  edges: Array<OrganizationInviteEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** The total number of Organization invites. */
  totalCount: Scalars['Int'];
};

/**
 * An element in a paginated list of organization invites.
 * Contains metadata about the organization invites.
 */
export type OrganizationInviteEdge = {
  __typename?: 'OrganizationInviteEdge';
  /** An opaque cursor identifying the edge's position in the paginted list. */
  cursor: Scalars['Cursor'];
  /** The organization invite. */
  node: OrganizationInvite;
};

/** Paginated list of organization invites for in a user. */
export type OrganizationInviteUserConnection = {
  __typename?: 'OrganizationInviteUserConnection';
  /** The elements of the paginated list. */
  edges: Array<OrganizationInviteEdge>;
  /** Whether or not the user is under the limit of allowed organization memberships. */
  isWithinOrganizationMembershipLimit?: Maybe<Scalars['Boolean']>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** The total number of Organization invites. */
  totalCount: Scalars['Int'];
};

/** A RBAC user. */
export type OrganizationMember = {
  __typename?: 'OrganizationMember';
  /** Users email. */
  email: Scalars['String'];
  /** Users first name. */
  firstName: Scalars['String'];
  /** Twitch user id. */
  id: Scalars['ID'];
  /** Users last name. */
  lastName: Scalars['String'];
  /** Users role. */
  role: OrganizationMemberRole;
  /** Users title. */
  title: Scalars['String'];
  /** The Twitch user associated with the RBAC user. */
  user?: Maybe<User>;
};

/** A paginated list of organization member relationships. */
export type OrganizationMemberConnection = {
  __typename?: 'OrganizationMemberConnection';
  /** The elements of the paginated list. */
  edges: Array<OrganizationMemberEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** The total number of Organization members. */
  totalCount: Scalars['Int'];
};

/**
 * An element in a paginated list of organization member relationships.
 * Contains metadata about the follow relationship between two users.
 */
export type OrganizationMemberEdge = {
  __typename?: 'OrganizationMemberEdge';
  /** An opaque cursor identifying the edge's position in the paginted list. */
  cursor: Scalars['Cursor'];
  /** Date user joined organization. */
  joinedAt: Scalars['Time'];
  /** The user who is organization members. */
  node: OrganizationMember;
};

/** Role for an organization member. */
export enum OrganizationMemberRole {
  /** Adiministrator role. */
  Administrator = 'ADMINISTRATOR',
  /** Billing Manager Role. */
  BillingManager = 'BILLING_MANAGER',
  /** Developer role. */
  Developer = 'DEVELOPER',
  /** Manager role. */
  Manager = 'MANAGER',
  /** Marketer role. */
  Marketer = 'MARKETER',
  /** Owner Role. */
  Owner = 'OWNER',
  /** Shadow Account Role. */
  ShadowAccount = 'SHADOW_ACCOUNT'
}

/** Parameters for filtering OrganizationMembers. */
export type OrganizationMembersInput = {
  /** Filter members with this role. */
  role?: InputMaybe<OrganizationMemberRole>;
};

/** The relationship between the authenticated user and a game. */
export type OrganizationSelfEdge = {
  __typename?: 'OrganizationSelfEdge';
  /** Whether or not the current user is able to add another to the organization. */
  canAddMember: Scalars['Boolean'];
  /** Whether or not the current user is able to leave the organization. */
  canLeaveOrganization: Scalars['Boolean'];
  /** Whether or not the current user is able to remove a member from the organization. */
  canRemoveMember: Scalars['Boolean'];
  /** Date user joined organization. */
  joinedAt: Scalars['Time'];
  /** The current users role in the organization. */
  role: OrganizationMemberRole;
};

/** Type of work an organization does. */
export enum OrganizationType {
  /** Organization that works in brands/advertsing. */
  BrandsAdvertising = 'BRANDS_ADVERTISING',
  /** Organization that works with broadcaster tools. */
  BroadcasterTools = 'BROADCASTER_TOOLS',
  /** Organization that developes games. */
  GameDeveloper = 'GAME_DEVELOPER',
  /** Organization that publishes games. */
  GamePublisher = 'GAME_PUBLISHER',
  /** Organization that does other work. */
  Other = 'OTHER'
}

/** Friend requests sent from this user to other users. */
export type OutgoingFriendRequestConnection = {
  __typename?: 'OutgoingFriendRequestConnection';
  /** The friend request elements of this list. */
  edges?: Maybe<Array<OutgoingFriendRequestEdge>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** The total number of outgoing friend requests. */
  totalCount: Scalars['Int'];
};

/** A friend request sent from this user to another user. */
export type OutgoingFriendRequestEdge = {
  __typename?: 'OutgoingFriendRequestEdge';
  /** The time at which the friend request was sent. */
  createdAt: Scalars['Time'];
  /** An opaque cursor identifying the edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The user to whom the friend request was sent. */
  node?: Maybe<User>;
};

/** Contains Overwatch League Team preferences. */
export type OverwatchLeagueTeamPreference = {
  __typename?: 'OverwatchLeagueTeamPreference';
  /** Set of available teams for selection. */
  availableTeamsSet?: Maybe<Array<OverwatchTeamPreferenceOption>>;
  /** Unique identifier for this set of Overwatch team preferences. */
  id: Scalars['ID'];
  /** The preferred team. */
  selectedTeam?: Maybe<OverwatchTeamPreferenceOption>;
};

/** Moment Details specific to the overwatch game. */
export type OverwatchMomentDetails = {
  __typename?: 'OverwatchMomentDetails';
  /** One of "game_start" or "hero_change". */
  event: Scalars['String'];
  /** The hero the broadcaster is playing. */
  heroName: Scalars['String'];
  /** The role the broadcaster is playing. */
  role: Scalars['String'];
};

/** Contains an Overwatch team option to choose as the preferred team. */
export type OverwatchTeamPreferenceOption = {
  __typename?: 'OverwatchTeamPreferenceOption';
  /** Unique identifier for this Overwatch team preference. */
  id: Scalars['ID'];
  /** The rewards associated with this team preference. */
  rewards?: Maybe<Array<TournamentReward>>;
  /** The name of the team. */
  teamName: Scalars['String'];
};

/** OwnerChanletAttributes store configuration flags for child chanlets the channel owns. */
export type OwnerChanletAttributes = {
  __typename?: 'OwnerChanletAttributes';
  /** Whether to show the child chanlets. */
  isChanletFeatureEnabled: Scalars['Boolean'];
};

/** Moment Details specific to the PUBG game. */
export type PubgMomentDetails = {
  __typename?: 'PUBGMomentDetails';
  /** bucket is the player count bucket for aggregations. */
  bucket: Scalars['Int'];
  /** One of "game_start" or "player_count". */
  event: Scalars['String'];
  /** The game mode for the moment. */
  gameMode: Scalars['String'];
  /** The maximum player count in this period. */
  maxPlayerCount: Scalars['Int'];
  /** The minimum player count in this period. */
  minPlayerCount: Scalars['Int'];
};

/**
 * PageInfo is a special field which contains information about the page,
 * specifically the cursors which the page starts and ends, and whether or
 * not the client can forward-paginate or backward-paginate.
 *
 * This is part of the Relay Cursor Connections Specification:
 * https://facebook.github.io/relay/graphql/connections.htm.
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

/**
 * Data about a paid upgrade for a subscription.
 * ie. a user upgrades a 1-month gift to a recurring subscription.
 */
export type PaidUpgrade = {
  __typename?: 'PaidUpgrade';
  /** The id of the paid upgrade purchase. Used to cancel the paid upgrade. */
  originID: Scalars['ID'];
  /**
   * The formatted price of the paid upgrade in USD.
   * @deprecated Transitioning to priceInfo instead
   */
  price: Scalars['String'];
  /** PriceInfo holds the paid upgrade's pricing information such as currency, cost, and tax information. */
  priceInfo: PriceInfo;
  /** The date the paid upgrade begins. */
  startsAt: Scalars['Time'];
  /** Tier of upgraded product. */
  tier: Scalars['String'];
};


/**
 * Data about a paid upgrade for a subscription.
 * ie. a user upgrades a 1-month gift to a recurring subscription.
 */
export type PaidUpgradePriceInfoArgs = {
  taxCountry?: InputMaybe<Scalars['String']>;
};

/** Panel is information about a single info panel for a channel. */
export type Panel = {
  /** id is a unique identifier for the panel. */
  id: Scalars['ID'];
  /** type is the kind of panel. */
  type: PanelType;
};

/** The required configuration to activate a panel extension. */
export type PanelActivationInput = {
  /** The slot name of where the component extension should be displayed. */
  slot: Scalars['String'];
};

/** PanelType is the kind of panel. */
export enum PanelType {
  /** DEFAULT panels contain one or more of the content values in `Panel` to display. */
  Default = 'DEFAULT',
  /** EXTENSION panels are placeholders for extension content. */
  Extension = 'EXTENSION'
}

/** PanelView holds the view configuration of an extension if the panel anchor is supported. */
export type PanelView = ExtensionView & {
  __typename?: 'PanelView';
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /** The extension developer configured height of the panel extension. */
  height: Scalars['Int'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** PanelViewInput holds the view configuration of an extension if the panel anchor is supported. */
export type PanelViewInput = {
  /** The extension developer configured height of the panel extension. */
  height: Scalars['Int'];
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** DEPRECATED. */
export type Partnership = {
  __typename?: 'Partnership';
  /** @deprecated No longer supported */
  isPartner?: Maybe<Scalars['Boolean']>;
};

/** PartnershipApplication is a submitted partnership application. */
export type PartnershipApplication = {
  __typename?: 'PartnershipApplication';
  /**
   * ID of the user that submitted the application,
   * provided purely for the convenience of invalidating GraphQL client caches.
   */
  id: Scalars['ID'];
  /**
   * A submitted application currently can only be unresolved or resolved:
   *
   * - A null resolvedAt timestamp means that the application is unresolved and may be under review.
   *
   * - A non-null resolvedAt means that the application has been resolved, either approved or rejected.
   *   A user with an approved application may now start the partnership on-boarding flow.
   */
  resolvedAt?: Maybe<Scalars['Time']>;
};

/** PasswordStatus determines the current state of the users password. */
export enum PasswordStatus {
  /** The users password does not meet requirements. */
  Invalid = 'INVALID',
  /** The users password has never been evaluated. */
  NotEvaluated = 'NOT_EVALUATED',
  /** Unknown password status. */
  Unknown = 'UNKNOWN',
  /** The users password meets requirements. */
  Valid = 'VALID'
}

/** Associated metrics for the "Path to Affiliate" quest. */
export type PathToAffiliate = {
  __typename?: 'PathToAffiliate';
  /** Current state of the user's affiliate invitation. */
  affiliateInvitationStatus?: Maybe<AffiliateInvitationStatus>;
  /** Average viewers needed to complete the quest. */
  averageViewers?: Maybe<QuestGoalFloat>;
  /** Image URL for the quest's badge. */
  badgeURL?: Maybe<Scalars['String']>;
  /** Time that this quest was completed. */
  completedAt?: Maybe<Scalars['Time']>;
  /** Number of followers needed to complete the quest. Evaluated at a 6 month period. All other metrics are evaluated in 30 day periods. */
  followers?: Maybe<QuestGoalInt>;
  /** Number of hours streamed needed to complete the quest. */
  hoursStreamed?: Maybe<QuestGoalFloat>;
  /** Number of unique days needed to complete the quest. */
  uniqueDaysStreamed?: Maybe<QuestGoalInt>;
};

/** Associated metrics for the "Path to Partner" quest. */
export type PathToPartner = {
  __typename?: 'PathToPartner';
  /** Average viewers needed to complete the quest. */
  averageViewers?: Maybe<QuestGoalFloat>;
  /** Image URL for the quest's badge. */
  badgeURL?: Maybe<Scalars['String']>;
  /** Time that this quest was completed. */
  completedAt?: Maybe<Scalars['Time']>;
  /** Number of hours streamed needed to complete the quest. */
  hoursStreamed?: Maybe<QuestGoalFloat>;
  /** Time period that's being evaluated for the metrics/goals. */
  questEvaluationInterval?: Maybe<QuestEvaluationInterval>;
  /** Number of unique days needed to complete the quest. */
  uniqueDaysStreamed?: Maybe<QuestGoalInt>;
};

export type PayWithAmazonConfigs = {
  __typename?: 'PayWithAmazonConfigs';
  /** Used to configure PWA gateway and identify requests to Amazon. */
  clientID: Scalars['ID'];
  /** Frontend only has access to production PWA environment so this helps QA. */
  isProduction: Scalars['Boolean'];
  /** Also known as merchant ID, which identifies the account accepting payments. */
  sellerID: Scalars['ID'];
};

/** Payout Status is the payout status of the creator for all non-earnings related issues. */
export type PayableStatus = {
  __typename?: 'PayableStatus';
  /** Whether or not the user is able to be paid out. */
  isPayable: Scalars['Boolean'];
};

/** Types of credit cards supported. */
export enum PaymentCardType {
  /** American Express. */
  AmericanExpress = 'AMERICAN_EXPRESS',
  /** Discover. */
  Discover = 'DISCOVER',
  /** Mastercard. */
  Mastercard = 'MASTERCARD',
  /** Visa. */
  Visa = 'VISA'
}

/**
 * A monthly rollup of metrics that are relevant to incentive-based contracts for
 * some partnered streamers.
 */
export type PaymentIncentiveMetricsRollup = {
  __typename?: 'PaymentIncentiveMetricsRollup';
  /**
   * A measure of how much advertising time broadcasters have during their live
   * streams.
   */
  advertisingDensity: Scalars['Float'];
  /** The number of live hours the user streamed for the month. */
  liveHoursBroadcast: Scalars['Float'];
  /** The number of live minutes watched for the month. */
  liveMinutesWatched: Scalars['Float'];
  /**
   * The start time for the monthly rollup. These times are in the Pacific Time
   * Zone and the monthly rollups begin in this time zone. Rather than
   * converting to local time, clients should inform end users of this timing
   * quirk and perform custom parsing on these values to show the current year
   * and month in Pacific Time.
   */
  timestamp?: Maybe<Scalars['Time']>;
  /** The number of VOD minutes watched the user has for the month. */
  vodMinutesWatched: Scalars['Float'];
};

/** Payment instrument used through the payment provider. */
export enum PaymentInstrumentType {
  /** Pay with Amazon. */
  Amazon = 'AMAZON',
  /** Pay with Apple In-App Purchase. */
  AppleIap = 'APPLE_IAP',
  /** Credit or debit card. */
  CreditCard = 'CREDIT_CARD',
  /** Pay with bank account. */
  DirectDebit = 'DIRECT_DEBIT',
  /** Pay with Google In-App Billing. */
  GoogleIab = 'GOOGLE_IAB',
  /** Pay with Paypal. */
  Paypal = 'PAYPAL',
  /** Xsolla only. */
  Skrill = 'SKRILL',
  /** Xsolla default. */
  Unknown = 'UNKNOWN',
  /** Pay with Wallet. */
  Wallet = 'WALLET',
  /** Xsolla only. */
  Webmoney = 'WEBMONEY',
  /** Xsolla only. */
  Yandex = 'YANDEX'
}

/** Type of payment method a user has used to buy products on Twitch, such as subs. */
export type PaymentMethod = {
  __typename?: 'PaymentMethod';
  /** Country (ISO-3166) associated to the billing info for the customer's payment method. */
  billingCountry?: Maybe<Scalars['String']>;
  /** Email associated with customer's Amazon/Paypal account. */
  billingEmail?: Maybe<Scalars['String']>;
  /** If payment type is card, then the type of card used is shown here. */
  cardType?: Maybe<PaymentCardType>;
  /** ID of the payment method that can be referenced by other systems. */
  chargeInstrumentID: Scalars['ID'];
  /** Credit card expiration month, if paymentType is CREDIT_CARD. */
  expirationMonth?: Maybe<Scalars['Int']>;
  /** Credit card expiration year, if paymentType is CREDIT_CARD. */
  expirationYear?: Maybe<Scalars['Int']>;
  /**
   * External payment method ID (the ID recorded by the payment provider)
   * We can guarantee its uniqueness since it is external from our systems.
   */
  extMethodID?: Maybe<Scalars['ID']>;
  /** Whether or not payment method has restrictions. */
  isRestricted: Scalars['Boolean'];
  /** Credit card last four digits, if paymentType is CREDIT_CARD. */
  lastFour?: Maybe<Scalars['String']>;
  /** The payment scheme used by this payment method. */
  paymentScheme?: Maybe<PaymentScheme>;
  /** Payment type used via the payment provider. */
  paymentType: PaymentInstrumentType;
  /** One of the payment providers that Twitch currently supports. */
  provider: PaymentProvider;
  /** List of purchase profiles associated with this payment method. */
  purchaseProfiles?: Maybe<Array<PurchaseProfile>>;
  /**
   * List of recurring payments associated with this payment method.
   * New schema to eventually replace purchase profiles.
   */
  recurringPaymentDetails?: Maybe<Array<RecurringPaymentDetail>>;
};

/** The list of availability statuses for a payment method. */
export enum PaymentMethodAvailabilityStatus {
  /** Available status. */
  Available = 'AVAILABLE',
  /** Degraded status. */
  Degraded = 'DEGRADED',
  /** Full outage status. */
  FullOutage = 'FULL_OUTAGE'
}

/** Type of payment providers. */
export enum PaymentProvider {
  /** Apple In-App Purchases for iOS transactions. */
  AppleIap = 'APPLE_IAP',
  /** Google In-App Billing, for Android transactions. */
  GoogleIab = 'GOOGLE_IAB',
  /** (Deprecated) Paypal payment provider now a payment method provided by Recurly. */
  Paypal = 'PAYPAL',
  /** (Deprecated) Paypal payment provider. */
  PaypalRt = 'PAYPAL_RT',
  /** Twitch Prime used to buy product on Twitch. */
  Prime = 'PRIME',
  /** Recurly payment provider, allows payments with credit card, amazon, paypal. */
  Recurly = 'RECURLY',
  /** Sub tokens, which can be redeemed for channel subscriptions. */
  SubToken = 'SUB_TOKEN',
  /** Unknown payment provider. */
  Unknown = 'UNKNOWN',
  /** Xsolla payment provider, usually provides Iframe for users to go through checkout process. */
  Xsolla = 'XSOLLA',
  /** (Deprecated) Xsolla payment provider, usually provides Iframe for users to go through checkout process. */
  XsollaV3 = 'XSOLLA_V3',
  /** Zuora payment provider, supports credit card payments. */
  Zuora = 'ZUORA'
}

export type PaymentProviderConfigs = {
  __typename?: 'PaymentProviderConfigs';
  /** Configs to initiate Recurly library for the user for purchase checkout or payment method update. */
  recurly: RecurlyConfigs;
  /** Xsolla configs include the iframe URL for purchase checkout or payment method update. */
  xsolla: XsollaConfigs;
  /** Configs for initiating Zuora credit card payments or payment method update. */
  zuora: ZuoraConfigs;
};

/** The payment scheme supported. */
export enum PaymentScheme {
  /** BACS. */
  Bacs = 'BACS',
  /** SEPA. */
  Sepa = 'SEPA'
}

/** Inputs for PaymentSession. */
export type PaymentSession = {
  /** Payment's Tracking Checkout ID. */
  checkoutSessionID?: InputMaybe<Scalars['ID']>;
  /** User's device ID. */
  deviceID?: InputMaybe<Scalars['ID']>;
  /** Twilight's storage device ID. */
  localStorageDeviceID?: InputMaybe<Scalars['ID']>;
  /** Offer Session ID. */
  offerSessionID?: InputMaybe<Scalars['ID']>;
  /** Twilight's Page Session ID. */
  pageSessionID?: InputMaybe<Scalars['ID']>;
  /** Twilight's Tab Session ID. */
  tabSessionID?: InputMaybe<Scalars['ID']>;
};

/**
 * There are legacy and new data sources that contain similar payment transaction data. This type aims to merge several
 * data sources into one to expose a consistent payment history for each Twitch user.
 */
export type PaymentTransaction = {
  __typename?: 'PaymentTransaction';
  /** Currency for the price. */
  currency?: Maybe<Scalars['String']>;
  /** Price in smallest subunit for the currency, such as 499. */
  grossAmount?: Maybe<Scalars['Int']>;
  /** The divisor used to derive the gross amount. */
  grossAmountDivisor?: Maybe<Scalars['Int']>;
  /** Payment ID such as PPT321281 or POPT3278183712. */
  id: Scalars['ID'];
  /** Whether this payment transaction was made to purchase a gift for someone else or not. */
  isGift: Scalars['Boolean'];
  /** The payment method that was used to generate this payment transaction. */
  paymentMethod: PaymentMethod;
  /** Payment transaction purchased product details. */
  product: PaymentTransactionProduct;
  /** PurchaseOrderID for the payment. */
  purchaseOrderID?: Maybe<Scalars['ID']>;
  /** Time the purchase payment was recognized at. */
  purchasedAt: Scalars['Time'];
  /** Quantity of the purchase. */
  quantity: Scalars['Int'];
  /** The recipient Twitch user of the product purchased by the payment transaction, if applicable. */
  recipient?: Maybe<User>;
};

/** A paginated list of payment transactions, and its metadata. */
export type PaymentTransactionConnection = {
  __typename?: 'PaymentTransactionConnection';
  /** The list of payment transactions on this page. */
  edges?: Maybe<Array<PaymentTransactionEdge>>;
  /** The payment date of the earliest PaymentTransaction among all possible pages. */
  firstPurchasedAt?: Maybe<Scalars['Time']>;
  /** The payment date of the latest PaymentTransaction among all possible pages. */
  lastPurchasedAt?: Maybe<Scalars['Time']>;
  /** Information about this page of payment transactions. */
  pageInfo: PageInfo;
  /** The total number of payment transactions in the overall collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Filter and sorting options for querying all transactions for a Twitch purchaser. */
export type PaymentTransactionConnectionCriteriaInput = {
  /** Only show transactions purchased after this date. */
  purchasedAfter?: InputMaybe<Scalars['Time']>;
  /** Only show transactions purchased before this date. */
  purchasedBefore?: InputMaybe<Scalars['Time']>;
  /** Sort transactions by... defaults to date desc. */
  sortBy?: InputMaybe<PaymentTransactionSort>;
  /** Only show transactions that purchased products of a certain type, defaults to ALL. */
  type?: InputMaybe<PaymentTransactionTypeFilter>;
  /** Purchaser ID. */
  userID: Scalars['ID'];
};

/** An element in a paginated list of payment transactions, and its metadata. */
export type PaymentTransactionEdge = {
  __typename?: 'PaymentTransactionEdge';
  /** Offset acting as a cursor. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node?: Maybe<PaymentTransaction>;
};

/** Payment transaction purchased product details. */
export type PaymentTransactionProduct = {
  __typename?: 'PaymentTransactionProduct';
  /** Number of digital goods wrapped into a product. */
  bundleSize: Scalars['Int'];
  /** The name of the product. */
  name: Scalars['String'];
  /** Some products have owners. For example, the owner of the `Lirik - Tier 1 Subscription` product is Lirik. */
  owner?: Maybe<User>;
  /** Some products have tiers, such as subs. */
  tier?: Maybe<Scalars['String']>;
  /** What type of product the payment was made for. */
  type: PaymentTransactionType;
};

/** Possible sort orders for lists of payment transactions. */
export enum PaymentTransactionSort {
  /** Sort the payment transactions ascending by price. */
  PriceAsc = 'PRICE_ASC',
  /** Sort the payment transactions descending by price. */
  PriceDesc = 'PRICE_DESC',
  /** Sort by purchase date ascending. */
  PurchaseDateAsc = 'PURCHASE_DATE_ASC',
  /** Sort by purchase date descending. */
  PurchaseDateDesc = 'PURCHASE_DATE_DESC'
}

/** Payment transaction type. */
export enum PaymentTransactionType {
  /** Transaction for a bits type. */
  Bits = 'BITS',
  /** Transaction for celebration. */
  Celebration = 'CELEBRATION',
  /** Transaction for gift cards. */
  GiftCard = 'GIFT_CARD',
  /** Transaction for a subscription type. */
  Subscription = 'SUBSCRIPTION',
  /** Transaction for a sub token. */
  SubToken = 'SUB_TOKEN',
  /** Transaction for an unknown type. */
  Unknown = 'UNKNOWN'
}

/** Select the kind of transactions. */
export enum PaymentTransactionTypeFilter {
  /** The default filter (no filter). */
  All = 'ALL',
  /** Only return payment transactions that associated with subscription products. */
  Subscriptions = 'SUBSCRIPTIONS',
  /** Only return payment transactions that are associated with subtoken purchases and redemptions. */
  SubToken = 'SUB_TOKEN'
}

/** Payout Information. */
export type Payout = {
  __typename?: 'Payout';
  /** Payout History Information. */
  history?: Maybe<PayoutHistory>;
};

/** Payout Balance is the amount accrued by the user since their last Payout. */
export type PayoutBalance = {
  __typename?: 'PayoutBalance';
  /** Currency for the user. */
  currency: Scalars['String'];
  /** Amount of total earnings accrued since last payout for user. */
  currentPayoutBalanceAmount: Scalars['Float'];
  /** Month for the current payout balance. */
  month: Scalars['Int'];
  /** Year for the current payout balance. */
  year: Scalars['Int'];
};

/** Enumerates valid payout categories. */
export enum PayoutCategory {
  /** Assigned if the user has a payout plan for the affiliate program. */
  Affiliate = 'AFFILIATE',
  /** Assigned if the user has a payout plan for the extensions developer program. */
  ExtensionsDeveloper = 'EXTENSIONS_DEVELOPER',
  /** Assigned if the user has a payout plan for the partner program. */
  Partner = 'PARTNER'
}

/** Payout History Information. */
export type PayoutHistory = {
  __typename?: 'PayoutHistory';
  /** Url for Tipalti payout history iframe. */
  iframeURL?: Maybe<Scalars['String']>;
};

/** PayoutInvite describes a user's invite to a payout program. */
export type PayoutInvite = {
  __typename?: 'PayoutInvite';
  /** The payout program category the user has been invited to. */
  category?: Maybe<PayoutOnboardingCategory>;
  /** A PayoutInvite's unique ID. */
  id: Scalars['ID'];
  /** Whether or not this payout invite is for the affiliate program. */
  isForAffiliate: Scalars['Boolean'];
  /** Whether or not this payout invite is for the extensions developer program. */
  isForExtensionsDeveloper: Scalars['Boolean'];
  /** Whether or not this payout invite is for the partner program. */
  isForPartner: Scalars['Boolean'];
  /** Whether or not the payout invite was created through the legacy onboarding flow. */
  isLegacy: Scalars['Boolean'];
  /** The payout onboarding workflow for this payout invite. */
  workflow?: Maybe<PayoutOnboardingWorkflow>;
};

/** PayoutOnboardingCategory enumerates valid categories for payout onboarding. */
export enum PayoutOnboardingCategory {
  /** Assigned for payout onboarding flows to enroll a user into the affiliate program. */
  Affiliate = 'AFFILIATE',
  /** Assigned for payout onboarding flows to enroll a user into the partner program with a "custom" payout plan. */
  CustomPartner = 'CUSTOM_PARTNER',
  /** Assigned for payout onboarding flows to enroll a user into the extensions developer program. */
  ExtensionsDeveloper = 'EXTENSIONS_DEVELOPER',
  /** Assigned for payout onboarding flows to enroll a user into the partner program with the "premium" payout plan. */
  PremiumPartner = 'PREMIUM_PARTNER',
  /** Assigned for payout onboarding flows to enroll a user into the partner program with the "standard" payout plan. */
  StandardPartner = 'STANDARD_PARTNER',
  /** Assigned for payout onboarding flows to enroll a user into an unpaid partner program. */
  UnpaidPartner = 'UNPAID_PARTNER'
}

/** PayoutOnboardingStep enumerates valid payout onboarding steps. */
export enum PayoutOnboardingStep {
  /** User needs to agree to their payout agreement. */
  AgreementNotStarted = 'AGREEMENT_NOT_STARTED',
  /** User has a pending upgrade to their payout agreement. */
  AgreementPendingUpgrade = 'AGREEMENT_PENDING_UPGRADE',
  /** User has canceled their payout onboarding workflow. */
  Canceled = 'CANCELED',
  /** User has completed their payout onboarding. */
  Completed = 'COMPLETED',
  /** User neeeds to setup how they want to get paid out. */
  PayoutMethodNotStarted = 'PAYOUT_METHOD_NOT_STARTED',
  /** User submitted their payout method and is waiting for it to be accepted. */
  PayoutMethodPending = 'PAYOUT_METHOD_PENDING',
  /** User needs to complete their registration step. */
  RegistrationNotStarted = 'REGISTRATION_NOT_STARTED',
  /** User is waiting for a final approval from the payout onboarding reviewers. */
  ReviewPending = 'REVIEW_PENDING',
  /** User submitted their royalty tax interview but additional action by the user is required before completion. */
  RoyaltyTaxInterviewActionRequired = 'ROYALTY_TAX_INTERVIEW_ACTION_REQUIRED',
  /** User submitted their royalty tax interview and received errors while it was processed. */
  RoyaltyTaxInterviewFailed = 'ROYALTY_TAX_INTERVIEW_FAILED',
  /** User submitted their royalty tax interview and received mismatch errors. */
  RoyaltyTaxInterviewMismatch = 'ROYALTY_TAX_INTERVIEW_MISMATCH',
  /** User needs to submit their royalty tax interview. */
  RoyaltyTaxInterviewNotStarted = 'ROYALTY_TAX_INTERVIEW_NOT_STARTED',
  /** User submitted their royalty tax interview and is waiting for it to be accepted. */
  RoyaltyTaxInterviewPending = 'ROYALTY_TAX_INTERVIEW_PENDING',
  /** User submitted their service tax interview but additional action by the user is required before completion. */
  ServiceTaxInterviewActionRequired = 'SERVICE_TAX_INTERVIEW_ACTION_REQUIRED',
  /** User submitted their service tax interview and received errors while it was processed. */
  ServiceTaxInterviewFailed = 'SERVICE_TAX_INTERVIEW_FAILED',
  /** User submitted their service tax interview and received mismatch errors. */
  ServiceTaxInterviewMismatch = 'SERVICE_TAX_INTERVIEW_MISMATCH',
  /** User has completed their royalty tax interview and needs to complete their service tax interview. */
  ServiceTaxInterviewNotStarted = 'SERVICE_TAX_INTERVIEW_NOT_STARTED',
  /** User submitted their service tax interview and is waiting for it to be accepted. */
  ServiceTaxInterviewPending = 'SERVICE_TAX_INTERVIEW_PENDING'
}

/** PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program. */
export type PayoutOnboardingWorkflow = {
  __typename?: 'PayoutOnboardingWorkflow';
  /** The current step at which this workflow is at. */
  currentStep: PayoutOnboardingStep;
  /** A PayoutOnboardingWorkflow's unique ID. */
  id: Scalars['ID'];
  /**
   * The URL for a user to update their payout settings. A redirectURL is the URL
   * where the user will be redirected to after updating their payout settings.
   */
  payoutSettingsURL: Scalars['String'];
  /** The registration information submitted by the user for this workflow. */
  registration?: Maybe<PayoutRegistration>;
  /** Describes a user's tax interview information while completing their payout onboarding. */
  taxInterview?: Maybe<TaxInterview>;
  /** Lists the fields that were mismatched during the registration and tax interview steps. */
  taxMismatchErrors?: Maybe<Array<TaxMismatchError>>;
  /** The timestamp when the workflow was most recently updated. */
  timestamp: Scalars['Time'];
};


/** PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program. */
export type PayoutOnboardingWorkflowPayoutSettingsUrlArgs = {
  redirectURL?: InputMaybe<Scalars['String']>;
};


/** PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program. */
export type PayoutOnboardingWorkflowTaxInterviewArgs = {
  returnURL: Scalars['String'];
  type: TaxInterviewType;
};

/** Describes the payout plan a user has when enrolled into a payout program. */
export type PayoutPlan = {
  __typename?: 'PayoutPlan';
  /** The category applied for this payout plan. */
  category: PayoutCategory;
  /** Describes whether or not this payout plan is receiving revenue. */
  isReceivingRevenue: Scalars['Boolean'];
  /** Lists tags to further describe this type of payout plan. */
  tags?: Maybe<Array<PayoutPlanTag>>;
};

/** Enumerates valid payout plan tags. */
export enum PayoutPlanTag {
  /** Assigned if the user has the "custom" payout plan. */
  Custom = 'CUSTOM',
  /** Assigned if user has an esports payout plan. Twitch pays them lump sum when they get rewarded from competing in a Twtich sponsored event. */
  Esports = 'ESPORTS',
  /** Assigned if the user has a payout plan created through the legacy onboarding flow. */
  Legacy = 'LEGACY',
  /** Assigned if the user has the "premium" payout plan. */
  Premium = 'PREMIUM',
  /** Assigned if the user has the "standard" payout plan. */
  Standard = 'STANDARD'
}

/** PayoutRegistration describes the personal information a user submitted while onboarding into a payout program. */
export type PayoutRegistration = {
  __typename?: 'PayoutRegistration';
  /** Birthdate submitted by the user while registering into a payout program. */
  birthdate: Scalars['Time'];
  /** City submitted by the user while registering into a payout program. */
  city: Scalars['String'];
  /** Company Name submitted by the user while registering into a payout program. */
  companyName?: Maybe<Scalars['String']>;
  /** Country Code (ISO-3166) submitted by the user while registering into a payout program. */
  countryCode: Scalars['String'];
  /** Email submitted by the user while registering into a payout program. */
  email: Scalars['String'];
  /** First Name submitted by the user while registering into a payout program. */
  firstName: Scalars['String'];
  /** Last Name submitted by the user while registering into a payout program. */
  lastName: Scalars['String'];
  /** Middle Name submitted by the user while registering into a payout program. */
  middleName?: Maybe<Scalars['String']>;
  /** Parent Email submitted by the under age user while registering into a payout program. */
  parentEmail?: Maybe<Scalars['String']>;
  /** Parent Name submitted by the under age user while registering into a payout program. */
  parentName?: Maybe<Scalars['String']>;
  /** Postal submitted by the user while registering into a payout program. */
  postal?: Maybe<Scalars['String']>;
  /** State Code submitted by the user while registering into a payout program. */
  stateCode?: Maybe<Scalars['String']>;
  /** Primary Address submitted by the user while registering into a payout program. */
  streetAddress: Scalars['String'];
  /** Secondary Address submitted by the user while registering into a payout program. */
  streetAddress2?: Maybe<Scalars['String']>;
};

/** Denotes the type of pending subscription. */
export enum PendingSubType {
  /** This pending subscription was a conversion from a DNRd sub to a one month sub. */
  DnrToResubNonrecurring = 'DNR_TO_RESUB_NONRECURRING',
  /** This pending subscription was a conversion from a DNRd sub to a renewing sub. */
  DnrToResubRecurring = 'DNR_TO_RESUB_RECURRING',
  /** This pending subscription was a conversion from a gift sub to a paid sub. */
  GiftToPaid = 'GIFT_TO_PAID',
  /** This pending subscription was a conversion from a prime sub to a paid sub. */
  PrimeToPaid = 'PRIME_TO_PAID'
}

/**
 * Data about a pending future subscription.
 * ie. a user turns a 1-month gift into a recurring subscription.
 */
export type PendingSubscription = {
  __typename?: 'PendingSubscription';
  /** Whether the pending sub is cancelable. */
  isCancelable: Scalars['Boolean'];
  /** The id of the pending subscription purchase. Used to cancel the paid upgrade. */
  originID: Scalars['ID'];
  /**
   * The formatted price of the pending subscription in USD.
   * @deprecated Transitioning to priceInfo instead
   */
  price: Scalars['String'];
  /** PriceInfo holds the pending subscription's pricing information such as currency, cost, and tax information. */
  priceInfo: PriceInfo;
  /** The date the pending subscription begins. */
  startsAt: Scalars['Time'];
  /** Tier of pending subscription. */
  tier: Scalars['String'];
  /** The type of pending subscription. Ie GIFT_TO_PAID for a gift to paid conversion. */
  type: PendingSubType;
};


/**
 * Data about a pending future subscription.
 * ie. a user turns a 1-month gift into a recurring subscription.
 */
export type PendingSubscriptionPriceInfoArgs = {
  taxCountry?: InputMaybe<Scalars['String']>;
};

/** The permanent emote modifiers available to set. */
export enum PermanentEmoteModifier {
  /** BlackWhite emote modifier. */
  BlackWhite = 'BLACK_WHITE',
  /** HorizontalFlip emote modifier. */
  HorizontalFlip = 'HORIZONTAL_FLIP',
  /** Squished emote modifier. */
  Squished = 'SQUISHED',
  /** Sunglasses emote modifier. */
  Sunglasses = 'SUNGLASSES',
  /** Thinking emote modifier. */
  Thinking = 'THINKING',
  /** Unknown emote modifier. */
  Unknown = 'UNKNOWN'
}

/** Describes the section(follows, recommendation ...) for a current user in the navigation bar. */
export type PersonalSection = {
  __typename?: 'PersonalSection';
  /** Returns the list of contents in this section, nil if there is an error. */
  items?: Maybe<Array<PersonalSectionItem>>;
  /** The localized title for the personal section. */
  title: PersonalSectionTitle;
  /** Describes the section (FOLLOWED, RECOMMENDED, POPULAR ...). */
  type: PersonalSectionType;
};

/** Describes the personal channel for the current user. */
export type PersonalSectionChannel = {
  __typename?: 'PersonalSectionChannel';
  /** Either live stream or vod depending on whether the stream in live. */
  content?: Maybe<PersonalSectionChannelContent>;
  /** Describes how to label channels, if a label is necessary. */
  label: PersonalSectionChannelLabel;
  /** Unique id per channel used in client tracking. */
  trackingID: Scalars['ID'];
  /** The channel (user object of channel). */
  user?: Maybe<User>;
};

/** Content metadata for either live stream or list of vod. */
export type PersonalSectionChannelContent = Stream | VideoConnection;

/**
 * Describes how to label channels in combined sections. This enum is closely related
 * to - but separate from - the PersonalSectionType enum. Some sections may not have labels
 * and some labels may not have sections.
 */
export enum PersonalSectionChannelLabel {
  /** Use label for followed channel. */
  Followed = 'FOLLOWED',
  /** Use no label. */
  None = 'NONE',
  /** Use label for popular channel. */
  Popular = 'POPULAR',
  /** Use label for recommended channel. */
  Recommended = 'RECOMMENDED',
  /** Use label for similar channel. */
  Similar = 'SIMILAR'
}

/** Input to personal section query. */
export type PersonalSectionInput = {
  /** Name of the channel the user is watching. Used to present similar channels. */
  contextChannelName?: InputMaybe<Scalars['String']>;
  /** Provides additional context used to influence recommendations. */
  recommendationContext?: InputMaybe<RecommendationsContext>;
  /** Requested sections eg: follows, recommendation, popular. */
  sectionInputs: Array<PersonalSectionType>;
};

/** The types of content(channel, category ...) that can be contained in a PersonalSectionItem. */
export type PersonalSectionItem = PersonalSectionChannel;

/** A personal section token type that contains text. */
export type PersonalSectionTextToken = {
  __typename?: 'PersonalSectionTextToken';
  /** The text to display for this token. */
  value: Scalars['String'];
};

/** The title for the personal section. */
export type PersonalSectionTitle = {
  __typename?: 'PersonalSectionTitle';
  /** The localizedFallback title, only to be used if localizedTokens is nil. */
  localizedFallback: Scalars['String'];
  /** The localized section title in the form of a list of tokens. [Maximum of 2 tokens]. */
  localizedTokens?: Maybe<Array<PersonalSectionTitleToken>>;
};

/** The content of a personal section title token. */
export type PersonalSectionTitleToken = PersonalSectionTextToken | User;

/** Describes the type in personal sections. */
export enum PersonalSectionType {
  /** Returns the list of followed channels if the user is authenticated. */
  FollowedSection = 'FOLLOWED_SECTION',
  /** Returns the list of popular channels. */
  PopularSection = 'POPULAR_SECTION',
  /** Returns the list of recommended channels. */
  RecommendedSection = 'RECOMMENDED_SECTION',
  /** Returns the list of similar channels. */
  SimilarSection = 'SIMILAR_SECTION'
}

/** The phase state signifies the progress of the phase in the competition. */
export enum PhaseState {
  /** All lobbies in the phase are done playing. */
  Finished = 'FINISHED',
  /** Some or all the lobbies in the phase are actively playing. */
  Playing = 'PLAYING',
  /** Lobby state is unknown. */
  Unknown = 'UNKNOWN',
  /** No lobbies are currently actively playing in the phase. */
  Unstarted = 'UNSTARTED'
}

export type PhotoOEmbed = OEmbed & {
  __typename?: 'PhotoOEmbed';
  authorName?: Maybe<Scalars['String']>;
  authorURL?: Maybe<Scalars['String']>;
  cacheAge?: Maybe<Scalars['Int']>;
  height: Scalars['Int'];
  inputURL: Scalars['String'];
  providerName?: Maybe<Scalars['String']>;
  providerURL?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<ThumbnailOEmbed>;
  title?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  url: Scalars['String'];
  version: Scalars['String'];
  width: Scalars['Int'];
};

/** Stream Platform. */
export type Platform = PlayStation;

export type PlatformEventSetting = {
  __typename?: 'PlatformEventSetting';
  /** Whether the setting is enabled for the given platform. */
  isEnabled: Scalars['Boolean'];
  /** The name of the platform. ("email", "push", etc..). */
  platformName: Scalars['String'];
  /** The exact state of the setting. ("on", "off", "friends_only", etc). */
  settingState: Scalars['String'];
};

/** Stream platform type. */
export enum PlatformType {
  All = 'all',
  Ps4 = 'ps4',
  Xbox = 'xbox'
}

/** Stream metadata for PlayStation. */
export type PlayStation = {
  __typename?: 'PlayStation';
  platform?: Maybe<Scalars['String']>;
  title?: Maybe<SceTitle>;
  updatedAt?: Maybe<Scalars['Time']>;
  user?: Maybe<SceUser>;
};

/** Access token that determines playback experience for a video. */
export type PlaybackAccessToken = {
  __typename?: 'PlaybackAccessToken';
  /** The signature of the token. */
  signature: Scalars['String'];
  /** Token that encodes information about the user's access to a video. */
  value: Scalars['String'];
};

/** Optional parameters to pass in when fetching a playback access token. */
export type PlaybackAccessTokenParams = {
  /** If the video should not be loaded over HTTPS. */
  disableHTTPS?: InputMaybe<Scalars['Boolean']>;
  /** If the user has adblock enabled. */
  hasAdblock?: InputMaybe<Scalars['Boolean']>;
  /** The platform the user is watching the video on. */
  platform: Scalars['String'];
  /** The player backend being used to serve video. */
  playerBackend?: InputMaybe<Scalars['String']>;
  /** The type of player the user is watching from. */
  playerType: Scalars['String'];
};

export type Playing = Activity & {
  __typename?: 'Playing';
  /** The game being played. */
  game?: Maybe<Game>;
  /** This activity's type, i.e. "PLAYING". */
  type?: Maybe<ActivityType>;
};

/** A poll users can vote in. */
export type Poll = {
  __typename?: 'Poll';
  /** A choice specified by a choice id. */
  choice?: Maybe<PollChoice>;
  /** A list of choices users can vote for. */
  choices: Array<PollChoice>;
  /**
   * User that created the poll.
   * Mods and editors can make polls on behalf of a broadcaster.
   */
  createdBy?: Maybe<User>;
  /**
   * Amount of seconds from when the poll starts to when it ends.
   * Since a broadcaster can end a poll early ("terminate a poll"), it may be possible for endedAt - startedAt != duration.
   */
  durationSeconds: Scalars['Int'];
  /**
   * Time when the poll ended.
   * Null if the poll is still active.
   */
  endedAt?: Maybe<Scalars['Time']>;
  /**
   * User that ended the poll. Mods and editors can end polls on behalf of a broadcaster.
   * Null if no user manually ended the poll.
   */
  endedBy?: Maybe<User>;
  /** ID of poll. */
  id: Scalars['ID'];
  /** Whether the poll is viewable by other users. */
  isViewable: Scalars['Boolean'];
  /** User who owns this poll. The poll will appear on their channel. */
  ownedBy?: Maybe<User>;
  /**
   * Amount of milliseconds before the poll ends.
   * 0 when the polls is ended.
   */
  remainingDurationMilliseconds: Scalars['Int'];
  /**
   * The authenticated user's relationship with this poll.
   * Main use case is to check if the user has voted in the poll already.
   * Null if un-authenticated user is making this query.
   */
  self?: Maybe<PollSelfEdge>;
  /** A map of poll settings. */
  settings: PollSettings;
  /** Time when poll started. */
  startedAt: Scalars['Time'];
  /** The status of the poll. */
  status: PollStatus;
  /** Title of poll. */
  title: Scalars['String'];
  /** A breakdown of the different tokens used in this poll. */
  tokens: PollTokenBreakdown;
  /** The top Bits contributor for the poll. */
  topBitsContributor?: Maybe<PollTopBitsContributor>;
  /** The top Community Points contributor for the poll. */
  topCommunityPointsContributor?: Maybe<PollTopCommunityPointsContributor>;
  /**
   * The top Bits contributor for the poll.
   * @deprecated Use topBitsContributor instead.
   */
  topContributor?: Maybe<PollTopContributor>;
  /** Total number of unique voters that have voted in this poll. */
  totalVoters: Scalars['Int'];
  /** A breakdown of the different votes cast in this poll. */
  votes: PollVoteBreakdown;
};


/** A poll users can vote in. */
export type PollChoiceArgs = {
  id: Scalars['ID'];
};

/** A choice in a poll that users can vote for. */
export type PollChoice = {
  __typename?: 'PollChoice';
  /** ID of choice. */
  id: Scalars['ID'];
  /** The authenticated user's relationship with this choice. */
  self: PollChoiceSelfEdge;
  /** The title of the choice. */
  title: Scalars['String'];
  /** A breakdown of the different tokens used for this choice. */
  tokens: PollTokenBreakdown;
  /** Total number of unique voters that have voted for this choice. */
  totalVoters: Scalars['Int'];
  /**
   * A list of voters for this choice.
   * Only the poll's ownerID and their mods/editors can search for this.
   */
  voters?: Maybe<PollChoiceVoterConnection>;
  /** A breakdown of the different votes cast for this choice. */
  votes: PollVoteBreakdown;
};


/** A choice in a poll that users can vote for. */
export type PollChoiceVotersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  direction?: InputMaybe<PollVoterConnectionSortDirection>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<PollVoterConnectionSort>;
};

/** A connection between poll choice and the authenticated user. */
export type PollChoiceSelfEdge = {
  __typename?: 'PollChoiceSelfEdge';
  /** The voter object pertaining to the authenticated user. */
  voter?: Maybe<PollVoter>;
};

/** A connection between poll and voters and metadata. */
export type PollChoiceVoterConnection = {
  __typename?: 'PollChoiceVoterConnection';
  /** The list of voters in this poll / choice. */
  nodes: Array<PollVoterConnectionEdge>;
};

/** A connection between poll and metadata. */
export type PollConnection = {
  __typename?: 'PollConnection';
  /** The list of polls for the user. */
  edges?: Maybe<Array<PollEdge>>;
  /** Information about pagination in this connection. */
  pageInfo: PageInfo;
};

/** A page entry, that contains the Poll item and a cursor to return from the query to allow pagination. */
export type PollEdge = {
  __typename?: 'PollEdge';
  /** Cursor used for next query. */
  cursor: Scalars['Cursor'];
  /** The underlying poll voter. */
  node: Poll;
};

/** A connection between a poll and the authenticated user. */
export type PollSelfEdge = {
  __typename?: 'PollSelfEdge';
  /** The voter object pertaining to the authenticated user. */
  voter?: Maybe<PollVoter>;
};

/** Poll Settings. */
export type PollSettings = {
  __typename?: 'PollSettings';
  /** Bits votes poll settings. */
  bitsVotes: PollSettingsBitsVotes;
  /** Channel Points votes poll settings. */
  communityPointsVotes: PollSettingsCommunityPointsVotes;
  /** ID of poll settings. */
  id: Scalars['ID'];
  /** Multichoice voting poll settings. */
  multichoice: PollSettingsMultichoice;
  /**
   * Subscriber multiplier poll settings.
   * @deprecated Subscriber multipliers are no longer supported.
   */
  subscriberMultiplier: PollSettingsSubscriberMultiplier;
  /**
   * Subscriber only poll settings.
   * @deprecated Subscriber-only polls are no longer supported.
   */
  subscriberOnly: PollSettingsSubscriberOnly;
};

/** Bits votes poll settings. */
export type PollSettingsBitsVotes = {
  __typename?: 'PollSettingsBitsVotes';
  /** Cost of bits for a vote. */
  cost: Scalars['Int'];
  /** Whether the poll allows for users to use bits for votes. */
  isEnabled: Scalars['Boolean'];
};

/** Channel Points votes poll settings. */
export type PollSettingsCommunityPointsVotes = {
  __typename?: 'PollSettingsCommunityPointsVotes';
  /** Cost of channel points for a vote. */
  cost: Scalars['Int'];
  /** Whether the poll allows for users to use channel points for votes. */
  isEnabled: Scalars['Boolean'];
};

/** Multichoice voting enabled poll setting. */
export type PollSettingsMultichoice = {
  __typename?: 'PollSettingsMultichoice';
  /** Whether the poll has multichoice voting enabled. */
  isEnabled: Scalars['Boolean'];
};

/**
 * Subscriber multiplier poll settings.
 * Deprecated: subscriber multipliers are no longer supported.
 */
export type PollSettingsSubscriberMultiplier = {
  __typename?: 'PollSettingsSubscriberMultiplier';
  /** Whether the poll has a subscriber multipler. */
  isEnabled: Scalars['Boolean'];
};

/**
 * Subscriber only poll settings.
 * Deprecated: subscriber-only polls are no longer supported.
 */
export type PollSettingsSubscriberOnly = {
  __typename?: 'PollSettingsSubscriberOnly';
  /** Whether the poll is subscriber only. */
  isEnabled: Scalars['Boolean'];
};

/** Possible sort orders for lists of polls. */
export enum PollSort {
  /** Sort the polls by time. */
  StartTime = 'START_TIME'
}

/** The status of the poll. */
export enum PollStatus {
  /** Poll is running. Users can vote. Results are publicly visible. */
  Active = 'ACTIVE',
  /** Poll has ended and is no longer publicly visible. Users cannot vote. Results are not publicly visible. */
  Archived = 'ARCHIVED',
  /** Poll ran its entire duration and "naturally" completed. Users cannot vote. Results are publicly visible. */
  Completed = 'COMPLETED',
  /** Poll has been moderated by Twitch and is no longer viewable, even to the poll owner. Users cannot vote. Results are not visible to any user. */
  Moderated = 'MODERATED',
  /** Poll was manually ended ("terminated") by a user. Users cannot vote. Results are publicly visible. */
  Terminated = 'TERMINATED',
  /** Encountered some poll status that we do not know how to handle BibleThump. */
  Unknown = 'UNKNOWN'
}

/** A breakdown of tokens used/by for this poll/choice/user. */
export type PollTokenBreakdown = {
  __typename?: 'PollTokenBreakdown';
  /** Total number of bits used. */
  bits: Scalars['Int'];
  /** Total number of community points used. */
  communityPoints: Scalars['Int'];
  /** ID of token breakdown. */
  id: Scalars['ID'];
};

/** Top contributor to the poll and the bits they contributed. */
export type PollTopBitsContributor = {
  __typename?: 'PollTopBitsContributor';
  /** Bits amount contributed. */
  bitsAmount: Scalars['Int'];
  /** Top contributor to the poll. */
  user?: Maybe<User>;
};

/** Top contributor to the poll and the community points they contributed. */
export type PollTopCommunityPointsContributor = {
  __typename?: 'PollTopCommunityPointsContributor';
  /** Community Points amount contributed. */
  communityPointsAmount: Scalars['Int'];
  /** Top contributor to the poll. */
  user?: Maybe<User>;
};

/**
 * Top contributor to the poll and the bits they contributed.
 * Deprecated: use PollTopBitsContributor instead.
 */
export type PollTopContributor = {
  __typename?: 'PollTopContributor';
  /** Bits amount contributed. */
  bitsAmount: Scalars['Int'];
  /** Top contributor to the poll. */
  user?: Maybe<User>;
};

/** A breakdown of votes cast for/by this poll/choice/user. */
export type PollVoteBreakdown = {
  __typename?: 'PollVoteBreakdown';
  /** Total number of base votes. */
  base: Scalars['Int'];
  /** Total number of votes due to bits contributions. */
  bits: Scalars['Int'];
  /** Total number of votes due to Community Points contributions. */
  communityPoints: Scalars['Int'];
  /** ID of vote breakdown. */
  id: Scalars['ID'];
  /** Total number of votes across all different vote types. */
  total: Scalars['Int'];
};

/** The tokens that are used on a vote. */
export type PollVoteTokensInput = {
  /** The amount of bits used for this vote. */
  bits: Scalars['Int'];
  /** The amount of channel points used for this vote. */
  channelPoints: Scalars['Int'];
};

/** A voter taking part in a poll and associated information. */
export type PollVoter = {
  __typename?: 'PollVoter';
  /** The Choices this voter voted for. */
  choices: Array<PollVoterChoice>;
  /** id of the voter in the poll. */
  id: Scalars['ID'];
  /** The Poll this voter voted in. */
  poll?: Maybe<Poll>;
  /** A breakdown of the different tokens used by the voter in the poll. */
  tokens: PollTokenBreakdown;
  /** The User object relating to this voter. */
  user?: Maybe<User>;
  /** A breakdown of the different votes this voter used in the poll. */
  votes: PollVoteBreakdown;
};

/** A choice a voter made taking part in a poll. */
export type PollVoterChoice = {
  __typename?: 'PollVoterChoice';
  /** The id of the PollVoterChoice. */
  id: Scalars['ID'];
  /** The poll choice. */
  pollChoice?: Maybe<PollChoice>;
  /** A breakdown of the different tokens used by the voter. */
  tokens: PollTokenBreakdown;
  /** A breakdown of the different votes this voter used. */
  votes: PollVoteBreakdown;
};

/** A connection between poll and voters and metadata. */
export type PollVoterConnection = {
  __typename?: 'PollVoterConnection';
  /** The list of voters in this poll / choice. */
  nodes: Array<PollVoterConnectionEdge>;
};

/** A page entry, that contains the PollVoter item and a cursor to return from the query to allow pagination. */
export type PollVoterConnectionEdge = {
  __typename?: 'PollVoterConnectionEdge';
  /** Cursor used for next query. */
  cursor: Scalars['Cursor'];
  /** The underlying poll voter. */
  node: PollVoter;
};

/** Possible sort orders for lists of voters. */
export enum PollVoterConnectionSort {
  /** Sort the voters by amount of Bits on vote. */
  Bits = 'BITS',
  /** Sort the voters by amount of channel points. */
  ChannelPoints = 'CHANNEL_POINTS',
  /** Sort the voters by time of creation. */
  CreatedDate = 'CREATED_DATE',
  /** Sort the voters by # of votes. */
  Votes = 'VOTES'
}

/** Possible sort directions for lists of voters. */
export enum PollVoterConnectionSortDirection {
  /** Sort in ascending order. */
  Asc = 'ASC',
  /** Sort in descending order. */
  Desc = 'DESC'
}

export type Post = {
  __typename?: 'Post';
  /** The user that created this post. */
  author?: Maybe<User>;
  /** The content of the post as entered by the user and annotated with links and emotes. */
  body?: Maybe<MessageBody>;
  /** Time the post was created by the user. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Collection of embedable content attached to this post. */
  embeds?: Maybe<Array<Maybe<PostEmbed>>>;
  /** This Post's unique feeds ID. */
  id: Scalars['ID'];
  /** Is this post deleted. */
  isDeleted?: Maybe<Scalars['Boolean']>;
  /** The reactions associated with this post. */
  reactions?: Maybe<Array<Maybe<Reaction>>>;
  /** Data related to the current user. */
  self?: Maybe<PostSelfConnection>;
};

/** TODO: Add events. */
export type PostEmbed = Clip | LinkOEmbed | PhotoOEmbed | RichOEmbed | Video | VideoOEmbed;

export type PostPermissionSet = {
  __typename?: 'PostPermissionSet';
  /** True if the current user is allowed to delete this post. */
  canDelete: Scalars['Boolean'];
};

export type PostSelfConnection = {
  __typename?: 'PostSelfConnection';
  /** Permissions that the current user has on this post. */
  permissions?: Maybe<PostPermissionSet>;
};

/** A single Prediction made by a user on a Prediction Event. */
export type Prediction = {
  __typename?: 'Prediction';
  /** The Event that this Prediction relates to. */
  event?: Maybe<PredictionEvent>;
  /** The unique identifier of the Prediction. */
  id: Scalars['ID'];
  /** Whether the Prediction's results have been acknowledged by the user. Null if the Prediction has not been resolved yet. */
  isResultAcknowledged?: Maybe<Scalars['Boolean']>;
  /** The Outcome that was Predicted. */
  outcome?: Maybe<PredictionOutcome>;
  /** The number of points that the user spent on this Prediction. */
  points: Scalars['Int'];
  /** The number of points won by the user for this Prediction. Null if the Prediction has not been resolved yet. */
  pointsWon?: Maybe<Scalars['Int']>;
  /** The timestamp of when the user initially made this Prediction. */
  predictedAt: Scalars['Time'];
  /** The result of this Prediction. Null if the Prediction has not been resolved or refunded yet. */
  result?: Maybe<PredictionResult>;
  /** The timestamp of when the user most recently updated this Prediction. */
  updatedAt: Scalars['Time'];
  /** The user that made this Prediction. */
  user?: Maybe<User>;
};

/** An Event that users can make Predictions on. */
export type PredictionEvent = {
  __typename?: 'PredictionEvent';
  /** The channel that the Prediction Event belongs to. Null if this is Event is not tied to a channel. */
  channel?: Maybe<Channel>;
  /** The timestamp of when the Event was created. */
  createdAt: Scalars['Time'];
  /** The creator of the Event. Null if the Event was created by an automatic process or an admin. */
  createdBy?: Maybe<PredictionEventActor>;
  /** The timestamp of when the Event was resolved or canceled. Null if the Event is not resolved or canceled yet. */
  endedAt?: Maybe<Scalars['Time']>;
  /**
   * The user or extension that resolved or canceled the Event. Null if this was triggered by an automatic process or
   * by an admin, or if the Event is not resolved or canceled yet.
   */
  endedBy?: Maybe<PredictionEventActor>;
  /** Unique identifier of the Prediction Event. */
  id: Scalars['ID'];
  /** The timestamp of when the Event was locked. Null if the Event is still active. */
  lockedAt?: Maybe<Scalars['Time']>;
  /**
   * The user or extension that locked the Event. Null if this was triggered by an automatic process or by an admin,
   * or if the Event is stillactive.
   */
  lockedBy?: Maybe<PredictionEventActor>;
  /** The Outcomes available for predicting in this Event. */
  outcomes: Array<PredictionOutcome>;
  /** The length of the prediction window (the duration that the Event accepts predictions) in seconds. */
  predictionWindowSeconds: Scalars['Int'];
  /** The relationship between this Prediction Event and the logged in user. */
  self?: Maybe<PredictionEventSelfEdge>;
  /** The current status of the Event. */
  status: PredictionEventStatus;
  /** The title of the Event. */
  title: Scalars['String'];
  /**
   * The Outcome that ended up being selected as the "correct" Outcome. Null if the Event has not been resolved yet.
   * This Outcome will also be present as one of the outcomes in the "outcomes" field.
   */
  winningOutcome?: Maybe<PredictionOutcome>;
};

/** Someone or something that is capable of performing actions on a Prediction Event. */
export type PredictionEventActor = ExtensionClient | User;

/** Paginated list of Prediction Events for a channel. */
export type PredictionEventConnection = {
  __typename?: 'PredictionEventConnection';
  /** The elements in the list. */
  edges: Array<PredictionEventEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Element in a list of Prediction Events. */
export type PredictionEventEdge = {
  __typename?: 'PredictionEventEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The Prediction Event. */
  node: PredictionEvent;
};

/** The relationship between a Prediction Event and the logged in user. */
export type PredictionEventSelfEdge = {
  __typename?: 'PredictionEventSelfEdge';
  /** The user's Prediction on the Event. Null if the user does not have a Prediction on the Event. */
  prediction?: Maybe<Prediction>;
  /** A restriction on the user participating in this Event. Null if there are no restrictions. If non-null, the user can only participate in Spectator Mode. */
  restriction?: Maybe<UserPredictionEventRestriction>;
};

/** Possible statuses for a Prediction Event. */
export enum PredictionEventStatus {
  /** Event is actively accepting new predictions. */
  Active = 'ACTIVE',
  /** Event has been canceled and all users have been refunded. */
  Canceled = 'CANCELED',
  /** Event has been canceled, and is in the process of refunding participants. */
  CancelPending = 'CANCEL_PENDING',
  /** Event is no longer accepting new predictions, and is awaiting resolution. */
  Locked = 'LOCKED',
  /** Event has been resolved, the winning Option has been determined, and winners have received their Channel Points. */
  Resolved = 'RESOLVED',
  /** Event has been resolved, and is in the process of paying out winners. */
  ResolvePending = 'RESOLVE_PENDING'
}

/** A single Outcome that users can choose in a Prediction Event. */
export type PredictionOutcome = {
  __typename?: 'PredictionOutcome';
  /** The color of this Outcome. */
  color: PredictionOutcomeColor;
  /** The unique identifier of the Prediction Outcome. */
  id: Scalars['ID'];
  /** The title of the Event. */
  title: Scalars['String'];
  /** The top predictors (sorted by most points spent) of this Outcome. Empty if no users have predicted this Outcome. */
  topPredictors: Array<Prediction>;
  /** The total number of points that have been spent predicting this Outcome. */
  totalPoints: Scalars['Int'];
  /** The total number of users that have predicted this Outcome. */
  totalUsers: Scalars['Int'];
};

/** The possible colors for a Prediction Outcome. */
export enum PredictionOutcomeColor {
  /** Blue. */
  Blue = 'BLUE',
  /** Green. */
  Green = 'GREEN',
  /** Grey. */
  Grey = 'GREY',
  /** Orange. */
  Orange = 'ORANGE',
  /** Pink. */
  Pink = 'PINK',
  /** Purple. */
  Purple = 'PURPLE'
}

/** Possible result types for a Prediction. */
export enum PredictionResult {
  /** The Prediction was incorrect. */
  Lose = 'LOSE',
  /** The Prediction was canceled and refunded. */
  Refund = 'REFUND',
  /** The Prediction was correct. */
  Win = 'WIN'
}

/** DEPRECATED. */
export type Premiere = {
  __typename?: 'Premiere';
  /**
   * The Premiere’s identifier.
   * @deprecated Premieres as a product has been deprecated
   */
  id: Scalars['ID'];
  /**
   * The paginated items in the premiere. At this time, they will all be VoDs.
   * A maximum of 100 items will be returned per request.
   * @deprecated Premieres as a product has been deprecated
   */
  items?: Maybe<PremiereConnection>;
  /**
   * The archived video. Only populated if the premiere is in state SUCCESS.
   * @deprecated Premieres as a product has been deprecated
   */
  pastPremiere?: Maybe<Video>;
  /**
   * Status of the premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  status: PremiereStatus;
  /**
   * The user who this premiere belongs to.
   * @deprecated Premieres as a product has been deprecated
   */
  user?: Maybe<User>;
};


/** DEPRECATED. */
export type PremiereItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/**
 * DEPRECATED.
 * Paginated list of videos.
 */
export type PremiereConnection = {
  __typename?: 'PremiereConnection';
  /**
   * The list of items in this page.
   * @deprecated Premieres as a product has been deprecated
   */
  edges?: Maybe<Array<Maybe<PremiereItemEdge>>>;
  /**
   * Information about this page of videos.
   * @deprecated Premieres as a product has been deprecated
   */
  pageInfo?: Maybe<PageInfo>;
  /**
   * The total number of items in the premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  totalCount?: Maybe<Scalars['Int']>;
};

/**
 * DEPRECATED.
 * The types of objects that can be contained in a premiere.
 */
export type PremiereItem = Video;

/**
 * DEPRECATED.
 * A page entry, that contains a premiere item and a cursor to return
 * from the query to allow pagination.
 * NOTE: this should have been named PremiereEdge.
 */
export type PremiereItemEdge = {
  __typename?: 'PremiereItemEdge';
  /**
   * Cursor is a cursor.
   * @deprecated Premieres as a product has been deprecated
   */
  cursor: Scalars['Cursor'];
  /**
   * Node is a node.
   * @deprecated Premieres as a product has been deprecated
   */
  node: PremiereItem;
};

/** DEPRECATED. */
export enum PremiereStatus {
  /**
   * A cancelled premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  Cancelled = 'CANCELLED',
  /**
   * A failed premiere. Examples of failed premieres are premieres that attempt to run
   * prior to the video being processed (or failed processing,) or the event failing
   * in the middle due to technical difficulties.
   * @deprecated Premieres as a product has been deprecated
   */
  Failed = 'FAILED',
  /**
   * A scheduled premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  Scheduled = 'SCHEDULED',
  /**
   * A premiere that has been started.
   * @deprecated Premieres as a product has been deprecated
   */
  Started = 'STARTED',
  /**
   * A successfully completed premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  Success = 'SUCCESS',
  /**
   * An unknown status to ensure we are able to return something.
   * @deprecated Premieres as a product has been deprecated
   */
  Unknown = 'UNKNOWN',
  /**
   * An unscheduled premiere.
   * @deprecated Premieres as a product has been deprecated
   */
  Unscheduled = 'UNSCHEDULED'
}

/** Domain of dev insights report. */
export enum PresignDevInsightsReportUrlDomain {
  /** Report for a drop. */
  Drop = 'DROP',
  /** Report for an extension. */
  Extension = 'EXTENSION',
  /** Report for a game. */
  Game = 'GAME'
}

/** Input for presignDevInsightsReportURL mutation. */
export type PresignDevInsightsReportUrlInput = {
  /** Domain of report, for a GAME or EXTENSION or DROP. */
  domain: PresignDevInsightsReportUrlDomain;
  /** Game ID or Extension ID or Drops Campaign ID/Reward ID. */
  id: Scalars['ID'];
  /** Type of report, default is OVERVIEW_V2. */
  type?: InputMaybe<PresignDevInsightsReportUrlReportType>;
};

/** URL info that can be used to upload the image. */
export type PresignDevInsightsReportUrlPayload = {
  __typename?: 'PresignDevInsightsReportURLPayload';
  /**
   * URL to be used by the client to download the CSV report.
   * Expires in 5 minutes.
   */
  url?: Maybe<Scalars['String']>;
};

/** Type of dev insights report. */
export enum PresignDevInsightsReportUrlReportType {
  /** Drops report that returns overview of drops. */
  DropsCampaignsDropsOverview = 'DROPS_CAMPAIGNS_DROPS_OVERVIEW',
  /** Drops report that returns overview of campaigns. */
  DropsCampaignsOverview = 'DROPS_CAMPAIGNS_OVERVIEW',
  /** Drops report that returns top 10 streamers for campaigns. */
  DropsCampaignsTopStreamers = 'DROPS_CAMPAIGNS_TOP_STREAMERS',
  /** Default report type, used for games and extensions. */
  OverviewV2 = 'OVERVIEW_V2'
}

/**
 * Generic Price Information that supports taxing and multi region pricing.
 * LONG-TERM NOTE: using Int (32 bit) as a price field can cause issue when we sell products locally
 * e.g. 2147483648 (2^31) Lao Att = 253132 USD cent
 * Therefor, if we sell product which price more than $2500 in Laos currency. We will need to fix this.
 */
export type PriceInfo = {
  __typename?: 'PriceInfo';
  /** The currency associated with the price of a subscription product. */
  currency: Currency;
  /** The description associated with pricing information. */
  description: Scalars['String'];
  /** The discounted total also broken down by price and tax. */
  discount?: Maybe<DiscountBreakdown>;
  /** The ISO-4217 wording of deriving price. */
  exponent: Scalars['Int'];
  /** Identifier used for caching. */
  id: Scalars['ID'];
  /** If the tax is already included in price. */
  isTaxInclusive: Scalars['Boolean'];
  /** The numerical price of a subscription product. */
  price: Scalars['Int'];
  /** The tax rate of localized product. */
  tax: Scalars['Int'];
  /** The total price given price and tax. */
  total: Scalars['Int'];
};

/** Wrapper around standard Emoticons for Prime Smilies Emoticons. */
export type PrimeEmoticons = {
  __typename?: 'PrimeEmoticons';
  /** Name for the currently enabled Emoticon set selected by the user. */
  currentSetName: PrimeEmoticonsSetName;
  /** All Prime Emoticon Sets of emote values (id, token, setId). */
  emoticonSets?: Maybe<Array<SmiliesSet>>;
};

/** The Names for the smilies Emoticon sets supported by Prime. */
export enum PrimeEmoticonsSetName {
  /** Emotes that are granted via Prime with Monkey faces. */
  Monkeys = 'MONKEYS',
  /** Emotes that are granted via Prime with Turbo faces. */
  Purple = 'PURPLE',
  /** Emotes that are granted to all users with Robot faces. Group id is #0 and emoticons start at id #1. */
  Robots = 'ROBOTS'
}

/** Prime Digital Content Offers are displayed to users on Twitch via Offers in the top nav. */
export type PrimeOffer = {
  __typename?: 'PrimeOffer';
  /** Unique Identifier for an offer used by the Catalog service. */
  catalogOfferID: Scalars['ID'];
  /** Hint describing the current availability state of the claim for the user. */
  claimHint: ClaimHint;
  /** Instructions string in Markdown displayed after offer is claimed to use or redeem. */
  claimInstructions: Scalars['String'];
  /** Content metadata for the given offer. */
  content?: Maybe<PrimeOfferContent>;
  /** The method of offer entitlement. */
  deliveryMethod: OfferDeliveryMethod;
  /** Description string in Markdown used in info block for Offer. */
  description: Scalars['String'];
  /** Unique Identifier for an offer. */
  id: Scalars['ID'];
  /** Offer image asset URL. */
  imageURL: Scalars['String'];
  /** Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority. */
  priority: Scalars['Int'];
  /** The connection for whether the user is entitled to the offer. */
  self?: Maybe<PrimeOfferSelfConnection>;
  /** Tags related to the offer such as Free Games with Prime (FGWP). */
  tags: Array<Scalars['String']>;
  /** Primary Title for Offer. */
  title: Scalars['String'];
};

/** An Object containing metadata for Digital Content. */
export type PrimeOfferContent = {
  __typename?: 'PrimeOfferContent';
  /** Content Categories for the game, displayed in info. */
  categories: Array<Scalars['String']>;
  /** If the content has an external marketing page (Blizzard, Retail, etc), some offers will have no external URL. */
  externalURL?: Maybe<Scalars['String']>;
  /** The Game metadata. */
  game?: Maybe<Game>;
  /** The publisher of the content. */
  publisher: Scalars['String'];
  /** Content SKU list for the offer. */
  skus: Array<Scalars['String']>;
};

/**
 * The requesting user's eligibility for a given Prime Gaming content offer.
 * These fields map directly to eligibility rules used by SCES to calculate eligibility.
 * They are true if the user is eligible under the specified rule.
 */
export type PrimeOfferEligibility = {
  __typename?: 'PrimeOfferEligibility';
  /** Boolean indicating if the user can claim the offer, determined by the included eligibility rules. */
  canClaim: Scalars['Boolean'];
  /**
   * LinkedAccountRule
   * True if the user has the required account link, if applicable.
   */
  hasRequiredAccount: Scalars['Boolean'];
  /** Boolean indicating if the user has already claimed the offer. */
  isClaimed: Scalars['Boolean'];
  /**
   * MarketplaceRule
   * True if the user is in one of the offer's eligible marketplaces.
   */
  isInEligibleMarketplace: Scalars['Boolean'];
  /**
   * PrimeGamingRule
   * True if the user is Prime Gaming enabled.
   */
  isPrimeGaming: Scalars['Boolean'];
  /**
   * ClaimLimitRule
   * True if the user has not exceeded the claim limit for the offer.
   */
  isUnderClaimLimit: Scalars['Boolean'];
  /**
   * OfferWindowRule
   * True if the time is within the offer's available window.
   */
  isWithinOfferWindow: Scalars['Boolean'];
  /** State of the offer: EXPIRED, LIVE, FUTURE. */
  offerState: OfferState;
  /** The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN, ERROR. */
  status: OfferStatus;
};

/** The connection between the user and their offer entitlement state. */
export type PrimeOfferSelfConnection = {
  __typename?: 'PrimeOfferSelfConnection';
  /** The data (link, text, or claim code) for the entitlement that was created. */
  claimData: Scalars['String'];
  /** Indicates whether the user has the entitlement to the offer. */
  hasEntitlement: Scalars['Boolean'];
  /** The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN. */
  status: Scalars['String'];
};

/**
 * Represents a Prime Gaming content offer with the requesting user's eligibility information.
 * These offers are displayed on the Crown menu on Twitch.tv.
 */
export type PrimeOfferWithEligibility = {
  __typename?: 'PrimeOfferWithEligibility';
  /** Unique Identifier for an offer used by the Catalog service. */
  catalogOfferID: Scalars['ID'];
  /** Instructions string in Markdown displayed after offer is claimed to use or redeem. */
  claimInstructions: Scalars['String'];
  /** Content metadata for the given offer. */
  content?: Maybe<PrimeOfferContent>;
  /** The method of offer entitlement. */
  deliveryMethod: OfferDeliveryMethod;
  /** Description string in Markdown used in info block for Offer. */
  description: Scalars['String'];
  /** Unique Identifier for an offer. */
  id: Scalars['ID'];
  /** Offer image asset URL. */
  imageURL: Scalars['String'];
  /** Describes the user's eligibility for the requested offer. */
  offerEligibility?: Maybe<PrimeOfferEligibility>;
  /** Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority. */
  priority: Scalars['Int'];
  /** Tags related to the offer such as Free Games with Prime (FGWP). */
  tags: Array<Scalars['String']>;
  /** Primary Title for Offer. */
  title: Scalars['String'];
};

/** PrimePayoutDetail shows the detailed breakdown of the prime payouts for a given user. */
export type PrimePayoutDetail = {
  __typename?: 'PrimePayoutDetail';
  /** currency for the payout number above. */
  currency: Currency;
  /** currentPrimePayout is the payout that will be made in this specific payout cycle. */
  currentPrimePayout: CurrentPrimePayout;
  /** deferredPrimePayout is part of the earning that was earned this month but will not be paid out this month. */
  deferredPrimePayout: DeferredPrimePayout;
  /** month when this payout will be made. */
  month: Scalars['Int'];
  /** year when this payout will be made. */
  year: Scalars['Int'];
};

/** PrimePayoutDetails shows the history of prime payout detail. */
export type PrimePayoutDetails = {
  __typename?: 'PrimePayoutDetails';
  /** primePayoutHistory is the history of prime payout details for a user. */
  primePayoutHistory: Array<PrimePayoutDetail>;
};

/** Metadata relevant to Prime copy or marketing that needs to be scheduled. */
export type PrimePromotion = {
  __typename?: 'PrimePromotion';
  /** externalURL is a string with the destination URL. */
  externalURL?: Maybe<Scalars['String']>;
  /** id is the unique identifier for the PrimePromotion. */
  id: Scalars['ID'];
  /** isExternalLink is boolean that indicates whether the text should be a link. */
  isExternalLink: Scalars['Boolean'];
  /** text is a string field containing the user visible text for a dynamic/changing string. */
  text: Scalars['String'];
};

/** Prime Settings related data for a given user. */
export type PrimeSettings = {
  __typename?: 'PrimeSettings';
  /** This type's unique identifier. */
  id: Scalars['ID'];
  /** If true, chat notifications will be sent on Prime Credit Token Channel Subscriptions. */
  isSubCreditChatNotificationEnabled: Scalars['Boolean'];
  /** The currently chosen Emoticon Set for the Prime User that are Smilies. */
  primeEmoticons?: Maybe<PrimeEmoticons>;
};

/** Information about the authenticated user's Prime subscription credit benefit. */
export type PrimeSubCreditBenefit = {
  __typename?: 'PrimeSubCreditBenefit';
  /** Checks when the authenticated user's Prime subscription credit will renew. */
  renewalDate?: Maybe<Scalars['Time']>;
  /** Checks if the authenticated user has the Prime benefit for 30-day subscription credit renewals. */
  willRenew?: Maybe<Scalars['Boolean']>;
};

/** Information about the Amazon user's Prime Video benefit. */
export type PrimeVideoBenefit = {
  __typename?: 'PrimeVideoBenefit';
  /** Error when the authentication token is expired. */
  error?: Maybe<WatchPartyError>;
  /** True if the user has valid access. */
  isValid?: Maybe<Scalars['Boolean']>;
};

/** Contains rating information for Prime Video content. */
export type PrimeVideoRating = {
  __typename?: 'PrimeVideoRating';
  /** Number of votes. */
  count: Scalars['Int'];
  /** Fractional number of stars. */
  stars: Scalars['Float'];
};

/** PrivacyLawName is the privacy law. */
export enum PrivacyLawName {
  /** Privacy law CCPA. */
  Ccpa = 'CCPA',
  /** Privacy GDPR. */
  Gdpr = 'GDPR',
  /** Rest of World. */
  Row = 'ROW'
}

/** The enumerated error reasons when processing payment made for the purchase of an offer. */
export enum ProcessAndroidPaymentErrorCode {
  /** Transaction had already been processed. */
  AlreadyHandled = 'ALREADY_HANDLED',
  /** User is ineligible to purchase. */
  Ineligible = 'INELIGIBLE',
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** Unable to process payment due to an invalid argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Must have auth credentials to purchase an offer. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** ProcessAndroidPaymentInput contains the necessary fields to process an Android payment. */
export type ProcessAndroidPaymentInput = {
  /** User IDs of the gift purchase recipients (if the Offer is a gift). */
  giftRecipientUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the Offer. */
  offerID: Scalars['ID'];
  /** The ID of the user making the purchase. */
  purchasingUserID: Scalars['ID'];
  /** The number of units purchased. */
  quantity: Scalars['Int'];
  /** The receipt data required to process Android purchases. */
  receiptData: AndroidReceiptDataInput;
  /** The static and dynamic bindings of the attributes on an Offer. */
  tagBindings: Array<OfferTagBindingInput>;
  /** The purchase tracking data. */
  trackingData?: InputMaybe<AndroidPaymentTrackingDataInput>;
};

/** ProcessAndroidPaymentPayload returns the order created for the purchase. */
export type ProcessAndroidPaymentPayload = {
  __typename?: 'ProcessAndroidPaymentPayload';
  /** Reason why a Purchase Order failed to be created if an error occurred. */
  error?: Maybe<ProcessAndroidPaymentErrorCode>;
  /** The Purchase Order created for this txn process attempt. */
  purchaseOrder?: Maybe<PurchaseOrder>;
};

/** The enumerated error reasons when processing payment made for the purchase of an offer. */
export enum ProcessIosPaymentErrorCode {
  /** Transaction had already been processed. */
  AlreadyHandled = 'ALREADY_HANDLED',
  /** User is ineligible to purchase. */
  Ineligible = 'INELIGIBLE',
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** Unable to process payment due to an invalid argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Must have auth credentials to purchase an offer. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** ProcessIOSPaymentInput contains the necessary fields to process a payment from the iOS platform. */
export type ProcessIosPaymentInput = {
  /** User IDs of the gift purchase recipients (if the Offer is a gift). */
  giftRecipientUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the Offer that was used for the purchase. */
  offerID: Scalars['ID'];
  /** The ID of the user making the purchase. */
  purchasingUserID: Scalars['ID'];
  /** The number of units purchased. */
  quantity: Scalars['Int'];
  /** The receipt data required to process iOS purchases. */
  receiptData: IosReceiptDataInput;
  /** The static and dynamic bindings of the attributes on an Offer. */
  tagBindings: Array<OfferTagBindingInput>;
  /** The purchase tracking data. */
  trackingData?: InputMaybe<IosPaymentTrackingDataInput>;
};

/** ProcessIOSPaymentPayload returns the order created for the purchase. */
export type ProcessIosPaymentPayload = {
  __typename?: 'ProcessIOSPaymentPayload';
  /** The error code representing the reason why the requested Purchase Order failed to be created. Populated only if an error occurred, nil otherwise. */
  error?: Maybe<ProcessIosPaymentErrorCode>;
  /** The Purchase Order record created for this transaction attempt. */
  purchaseOrder?: Maybe<PurchaseOrder>;
};

/** A benefit the user receives when purchasing a product from the product catalog. */
export type ProductCatalogBenefit = {
  /** The identifier of the benefit. */
  id: Scalars['ID'];
};

/** A product appearing in the product catalog. */
export type ProductCatalogItem = {
  /** A list of benefits the user will receive when purchasing the product. */
  benefits?: Maybe<Array<ProductCatalogBenefit>>;
  /** A description of the product. */
  description?: Maybe<Scalars['String']>;
  /** The identifier of the product. */
  id: Scalars['ID'];
  /** A list of offers available for purchasing the product. */
  offers?: Maybe<Array<Offer>>;
  /** The owner (ex: channel) of the product. */
  owner: Scalars['ID'];
  /** The title of the product. */
  title: Scalars['String'];
};

/** Contains the product's checkout price and tax info for a purchase and error if a final price cannot be determined. */
export type ProductPurchase = {
  __typename?: 'ProductPurchase';
  /** The price and tax breakdown for the purchase. */
  checkoutPriceSummary?: Maybe<CheckoutPriceSummary>;
  /** Error when the final price could not be retrieved for a product. */
  errorCode?: Maybe<ProductPurchaseErrorCode>;
  /** The region from which the tax was calculated. */
  taxRegion?: Maybe<TaxRegion>;
};

/** Possible errors when retrieving product purchase info. */
export enum ProductPurchaseErrorCode {
  /** Billing info not found for the user. */
  BillingInfoNotFound = 'BILLING_INFO_NOT_FOUND',
  /** PricingID not found. */
  PricingIdNotFound = 'PRICING_ID_NOT_FOUND',
  /** User ineligible to make corresponding purchase. */
  PurchaseIneligible = 'PURCHASE_INELIGIBLE',
  /** Unexpected error occurred. */
  Unknown = 'UNKNOWN',
  /** Cannot determine the user residence. */
  UnknownUserResidence = 'UNKNOWN_USER_RESIDENCE',
  /** The user is unauthorized to retrieve the purchase info. */
  UserUnauthorized = 'USER_UNAUTHORIZED'
}

/** ProgramAgreement describes the End User License Agreement associated with a user's current payout plan. */
export type ProgramAgreement = {
  __typename?: 'ProgramAgreement';
  /** Agreement body in HTML. */
  body: Scalars['String'];
  /** Agreement type accepted by the user. */
  type: PayoutOnboardingCategory;
  /** Agreement version (e.g. "v1"). */
  version: Scalars['String'];
};

/** Types that can only be displayed for an Offer Promotion. */
export enum PromoDiscountType {
  /** No Discount type to be shown. */
  DiscountTypeNone = 'DISCOUNT_TYPE_NONE',
  /** Percent Discount type to be shown. */
  DiscountTypePercent = 'DISCOUNT_TYPE_PERCENT'
}

/** Data used to display promotional discounts to the client. */
export type PromotionDisplay = {
  __typename?: 'PromotionDisplay';
  /** Describes the discount percent to display to the client. */
  discountPercent?: Maybe<Scalars['Float']>;
  /** Describes the type of discount that will be applied to the client. */
  discountType: PromoDiscountType;
};

/** PublishClipError is an error associated with the publishClip mutation. */
export type PublishClipError = {
  __typename?: 'PublishClipError';
  message?: Maybe<Scalars['String']>;
};

/** PublishClipInput edits the clip with the provided slug via segments. */
export type PublishClipInput = {
  /** The number of seconds into the clip's raw media the preview image is set to. */
  previewOffsetSeconds?: InputMaybe<Scalars['Float']>;
  /** The segments describing the desired changes to apply to the newly edited clip. */
  segments: Array<ClipSegmentInput>;
  /** The slug uniquely identifying the clip to edit. */
  slug: Scalars['ID'];
  /** The new title this clip will be updated to. */
  title?: InputMaybe<Scalars['String']>;
};

/** PublishClipPayload returns the edited clip or an error. */
export type PublishClipPayload = {
  __typename?: 'PublishClipPayload';
  /** The clip with its updated properties. */
  clip?: Maybe<Clip>;
  /** The error when the clip fails to publish. */
  error?: Maybe<PublishClipError>;
};

/** Publish a Competition. */
export type PublishCompetitionInput = {
  /** ID of the Competition we want to update. */
  id: Scalars['ID'];
};

/** Data that was mutated after the competition was updated. */
export type PublishCompetitionPayload = {
  __typename?: 'PublishCompetitionPayload';
  /** The competition which was updated. */
  competition?: Maybe<Competition>;
};

/** Errors for publishing subscription emotes. */
export type PublishSubscriptionEmoteError = {
  __typename?: 'PublishSubscriptionEmoteError';
  /** The associated error code. */
  code: PublishSubscriptionEmoteErrorCode;
};

/** Possible error codes returned for publishing subscription emotes. */
export enum PublishSubscriptionEmoteErrorCode {
  /** The emote code submitted collides with an existing emote code. */
  EmoteCodeAlreadyExists = 'EMOTE_CODE_ALREADY_EXISTS',
  /** The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines). */
  EmoteCodeUnacceptable = 'EMOTE_CODE_UNACCEPTABLE',
  /** The uploaded emote image could not be found. */
  EmoteImageNotFound = 'EMOTE_IMAGE_NOT_FOUND',
  /** The product has no available empty emote slots. */
  EmoteLimitReached = 'EMOTE_LIMIT_REACHED',
  /** An animated image asset was not supplied, but is required for the selected asset type. */
  EmoteMissingAnimatedAsset = 'EMOTE_MISSING_ANIMATED_ASSET',
  /** A static image asset was not supplied, but is required for the selected asset type. */
  EmoteMissingStaticAsset = 'EMOTE_MISSING_STATIC_ASSET',
  /** Data for least one of the image sizes is not provided or invalid. */
  IncompleteEmoteImageData = 'INCOMPLETE_EMOTE_IMAGE_DATA',
  /** The emote code suffix submitted contains invalid characters. */
  InvalidCodeSuffix = 'INVALID_CODE_SUFFIX',
  /** The selected emote asset type was invalid. */
  InvalidEmoteAssetType = 'INVALID_EMOTE_ASSET_TYPE',
  /** The upload emote image could not be parsed. */
  InvalidImageUpload = 'INVALID_IMAGE_UPLOAD',
  /** Only the product owner is allowed to upload emotes. */
  InvalidOwner = 'INVALID_OWNER',
  /** There were not enough image assets supplied for the selected asset type. */
  NotEnoughEmoteImageAssets = 'NOT_ENOUGH_EMOTE_IMAGE_ASSETS',
  /** There were more image assets supplied than required for the selected asset type. */
  TooManyEmoteImageAssets = 'TOO_MANY_EMOTE_IMAGE_ASSETS',
  /** Other errors returned from the service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The data needed to finalize the creation of a Subscription Emote. */
export type PublishSubscriptionEmoteInput = {
  /** The type of image asset for the emote. */
  assetType?: InputMaybe<EmoteAssetType>;
  /** The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code. */
  codeSuffix: Scalars['String'];
  /** A list containing the image IDs for all assets needed for the emote. */
  imageAssets?: InputMaybe<Array<EmoteImageAssetInput>>;
  /** DEPRECATED: Use imageAssets instead. The ID of the 28x28px emote ("1x") image file previously uploaded to upload service. */
  imageID1x?: InputMaybe<Scalars['ID']>;
  /** DEPRECATED: Use imageAssets instead. The ID of the 56x56px emote ("2x") image file previously uploaded to upload service. */
  imageID2x?: InputMaybe<Scalars['ID']>;
  /** DEPRECATED: Use imageAssets instead. The ID of the 112x112px emote ("4x") image file previously uploaded to upload service. */
  imageID4x?: InputMaybe<Scalars['ID']>;
  /** The ProductID of the subscription product which this emote will be associated with. */
  productID: Scalars['ID'];
};

/** Results of the subscription emote publish. */
export type PublishSubscriptionEmotePayload = {
  __typename?: 'PublishSubscriptionEmotePayload';
  /** The newly created emote if successful. */
  emote?: Maybe<Emote>;
  /** Service error, if any. */
  error?: Maybe<PublishSubscriptionEmoteError>;
};

/** Parameters to get details about a purchasable offer for the current logged in user. */
export type PurchasableOfferParams = {
  /** List of gift recipient IDs if the offer is giftable. */
  giftRecipientIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the Offer. */
  offerID: Scalars['ID'];
  /** The ID of the Promotion attached to a Purchasable Offer (optional). */
  promotionID?: InputMaybe<Scalars['ID']>;
  /** The static and dynamic bindings of the attributes on an Offer. */
  tagBindings?: InputMaybe<Array<OfferTagBindingInput>>;
};

/** Set of purchase Ineligibility reasons. */
export enum PurchaseIneligibilityReason {
  /** User already has an active subscription to this product. */
  HasActiveSubscription = 'HAS_ACTIVE_SUBSCRIPTION',
  /** Not applicable as user is eligible to make a purchase. */
  NotApplicable = 'NOT_APPLICABLE'
}

/** The enumerated error reasons when purchasing an offer. */
export enum PurchaseOfferErrorCode {
  /** User is ineligible to purchase. */
  Ineligible = 'INELIGIBLE',
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** User's payment method is invalid. */
  InvalidPaymentMethod = 'INVALID_PAYMENT_METHOD',
  /** Must have auth credentials to purchase an offer. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** PurchaseOfferInput contains the necessary fields to purchase an offer. */
export type PurchaseOfferInput = {
  /** Data to facilitate the Fraud analysis. */
  billingAuthInfo?: InputMaybe<BillingAuthInfo>;
  /** User IDs of the gift purchase recipients (if the Offer is a gift). */
  giftRecipientUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the Offer. */
  offerID: Scalars['ID'];
  /** Payments' session tracking. */
  paymentSession: PaymentSession;
  /** The ID of the user making the purchase. */
  purchasingUserID: Scalars['ID'];
  /** The number of units purchased. */
  quantity: Scalars['Int'];
  /** The static and dynamic bindings of the attributes on an Offer. */
  tagBindings: Array<OfferTagBindingInput>;
  /** Tenant-specific tracking params. */
  tenantTracking?: InputMaybe<Scalars['String']>;
};

/** PurchaseOfferPayload returns the order created for the purchase. */
export type PurchaseOfferPayload = {
  __typename?: 'PurchaseOfferPayload';
  /** Reason why a Purchase Order failed to be created if an error occurred. */
  error?: Maybe<PurchaseOfferErrorCode>;
  /** The Purchase Order created for this purchase attempt. */
  purchaseOrder?: Maybe<PurchaseOrder>;
};

/** PurchaseOrder is the record of a purchase made by a user. */
export type PurchaseOrder = {
  __typename?: 'PurchaseOrder';
  /** The action token ID used to facilitate the 3D Secure flow. */
  actionTokenID?: Maybe<Scalars['ID']>;
  /** The reason for a purchase order failure, if it failed. */
  failureReason?: Maybe<PurchaseOrderFailureReason>;
  /** The ID of the Purchase Order. */
  id: Scalars['ID'];
  /** The state of the Purchase Order. */
  state: PurchaseOrderState;
};

/** The enumerated failure reasons for a purchase order failure. */
export enum PurchaseOrderFailureReason {
  /** Bank declined the charge. */
  BankDeclined = 'BANK_DECLINED',
  /** Failed to entitle the benefit. User was refunded if a charge occurred. */
  EntitlementFailed = 'ENTITLEMENT_FAILED',
  /** User is ineligible to purchase. */
  Ineligible = 'INELIGIBLE',
  /** User's payment method is invalid. */
  InvalidPaymentMethod = 'INVALID_PAYMENT_METHOD',
  /** System error. */
  SystemError = 'SYSTEM_ERROR',
  /** Unknown failure reason. */
  Unknown = 'UNKNOWN'
}

/** PurchaseOrderState is the current state of the Purchase Order. */
export enum PurchaseOrderState {
  /** The Purchase Order's benefits have been fully cancelled. */
  BenefitsCancelled = 'BENEFITS_CANCELLED',
  /** The Purchase Order's benefit cancellation has been kicked off. */
  CancelBenefitsInitiated = 'CANCEL_BENEFITS_INITIATED',
  /** The Purchase Order failed. */
  Failed = 'FAILED',
  /** The Purchase Order has been paid and fulfillment has been kicked off. */
  FulfillmentInitiated = 'FULFILLMENT_INITIATED',
  /** The Purchase Order flow has been initiated and is at its starting state. */
  Initiated = 'INITIATED',
  /** The Purchase Order has a scheduled future-dated payment to complete the purchase. */
  PaymentPending = 'PAYMENT_PENDING',
  /** A refund has been successfully applied to the Purchase Order. */
  RefundApplied = 'REFUND_APPLIED',
  /** A refund has failed to the Purchase Order. */
  RefundFailed = 'REFUND_FAILED',
  /** A refund has been kicked off for the Purchase Order. */
  RefundInitiated = 'REFUND_INITIATED',
  /** The Purchase Order has been successfully fulfilled. */
  Success = 'SUCCESS',
  /** The Purchase Order failed and requires 3DS2 verification. */
  ThreeDSecureChallengeRequired = 'THREE_D_SECURE_CHALLENGE_REQUIRED',
  /** The Purchase Order is in an unknown state. */
  Unknown = 'UNKNOWN'
}

/** Purchase profile of a recurring or non-recurring subscription that a user bought. */
export type PurchaseProfile = {
  __typename?: 'PurchaseProfile';
  /** Cancels the entitled benefit and refunds if isRefundable is true. */
  cancelledAt?: Maybe<Scalars['Time']>;
  /** Date this purchase profile was created. */
  createdAt: Scalars['Time'];
  expiresAt?: Maybe<Scalars['Time']>;
  /** Usually the Twitch user's ID, but recorded by the payment provider. */
  extPurchaserID?: Maybe<Scalars['ID']>;
  /** The external subscription ID recorded by the payment provider. */
  extSubscriptionID?: Maybe<Scalars['ID']>;
  /** ID of the Purchase Profile in Payments team database. */
  id: Scalars['ID'];
  isExpired?: Maybe<Scalars['Boolean']>;
  /** Whether this purchase profile was gifted. */
  isGift?: Maybe<Scalars['Boolean']>;
  /** Whether this purchase profile is being paid for. */
  isPaying: Scalars['Boolean'];
  isRecurring: Scalars['Boolean'];
  isRefundable?: Maybe<Scalars['Boolean']>;
  paidAt?: Maybe<Scalars['Time']>;
  /** Product type of the purchase. */
  productType: SubscriptionProductType;
  purchasedAt?: Maybe<Scalars['Time']>;
  /** Twitch purchaser's email. */
  purchaserEmail: Scalars['String'];
  /** Twitch purchaser's user ID. */
  purchaserID: Scalars['ID'];
  /** Twitch purchaser's real name. */
  purchaserName?: Maybe<Scalars['String']>;
  /** Currency for the renewalPrice, e.g. "USD". */
  renewalCurrency?: Maybe<Scalars['String']>;
  /** Expected renewal price of the product in the smallest subunit of the currency, e.g. "499". */
  renewalPrice?: Maybe<Scalars['Int']>;
  /** Different from cancellation in that it stops renewal but let's user keep the benefit until it expires. */
  renewalStoppedAt?: Maybe<Scalars['Time']>;
  /** State of the purchase profile. i.e. cancelling the purchase profile can set state to 'cancelled'. */
  state: PurchaseProfileState;
  /** Subscription benefit associated with this purchase profile, if still active. */
  subscriptionBenefit?: Maybe<SubscriptionBenefit>;
  /** Date this purchase profile was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Whether this purchase profile will renew in the future and charge the user's payment method. */
  willRenew: Scalars['Boolean'];
};

export enum PurchaseProfileState {
  Active = 'ACTIVE',
  Cancelled = 'CANCELLED',
  Inactive = 'INACTIVE',
  Migrated = 'MIGRATED'
}

/** Category of product that can be purchased. */
export enum PurchaseableProductType {
  /** Bits product. */
  Bits = 'BITS',
  /** Subscription product. */
  Subscription = 'SUBSCRIPTION'
}

/** Root fields to access the Twitch API. */
export type Query = {
  __typename?: 'Query';
  /** Get the context that corresponds to an upcoming ad request made client side. */
  adContext?: Maybe<AdContext>;
  /** Get a single AdCreative. */
  adCreative?: Maybe<AdCreative>;
  /** Get all tags. */
  allTags?: Maybe<TagConnection>;
  /** Get AutoMod evaluation of text using AutoMod rule. */
  automodContent?: Maybe<AutoModContent>;
  /** A list of global chat badges. */
  badges?: Maybe<Array<Maybe<Badge>>>;
  /** Gets a list of Bits offers for a logged out user, for use on the Bits landing page. */
  bitsOffers?: Maybe<Array<BitsOffer>>;
  /** Returns a challenge by its ID. */
  challenge?: Maybe<ChannelChallenge>;
  /** Get a list of the most recent changelog items. */
  changelogEntries?: Maybe<Array<ChangelogEntry>>;
  /** Get a channel by ID or name. */
  channel?: Maybe<Channel>;
  /** Get a channel/viewer pair by login. */
  channelViewer?: Maybe<ChannelViewer>;
  /** Get a list of channels, either by IDs or by their names. */
  channels?: Maybe<Array<Maybe<Channel>>>;
  /** Get the ban status of a usser with respect to a channel's chat room. */
  chatRoomBanStatus?: Maybe<ChatRoomBanStatus>;
  /** GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available. */
  cheerConfig: GlobalCheerConfig;
  /** Get the logged-in user's authorizations for a client ID. */
  clientAuthorization?: Maybe<ClientAuthorization>;
  /** Get a clip by slug. */
  clip?: Maybe<Clip>;
  /** Get the state of a cloud broadcast for the given broadcastID. */
  cloudBroadcast?: Maybe<CloudBroadcast>;
  /** Get the capabilities of a single cloud broadcast provider. */
  cloudBroadcastProvider?: Maybe<CloudBroadcastProvider>;
  /** Get a single collection (playlist) item by its ID. */
  collection?: Maybe<Collection>;
  /** Gets competition by ID. */
  competition?: Maybe<Competition>;
  /** The features the user has access to when organizing competitions with the Versus product. */
  competitionOrganizerCapabilities?: Maybe<CompetitionOrganizerCapability>;
  /** Gets a paginated list of competitions, commonly by its state. If state is UNKNOWN, the query will default to LIVE competitions. */
  competitions?: Maybe<CompetitionConnection>;
  /** Get a privacy consent status from a user, e.g. GDPR or CCPA. */
  consent?: Maybe<Consent>;
  /** Get a content tag by tag ID. */
  contentTag?: Maybe<Tag>;
  /** Get content tags by tag IDs. */
  contentTags?: Maybe<Array<Tag>>;
  /** Get a Creator Camp article. */
  creatorCampArticle?: Maybe<CreatorCampArticle>;
  /** Get a Creator Camp category. */
  creatorCampCategory?: Maybe<CreatorCampCategory>;
  /** Get information populated in the Creator Dashboard. */
  creatorDashboard?: Maybe<CreatorDashboard>;
  /** Get information for the Creator Home page. */
  creatorHome?: Maybe<CreatorHome>;
  /** Get the chanel/viewer pair with the current user and the channelID. */
  currentChannelViewer?: Maybe<ChannelViewer>;
  /**
   * The currently authenticated user.
   * Returns null if the user is not authenticated.
   */
  currentUser?: Maybe<User>;
  /** Fetch a single directory by name and type. */
  directory?: Maybe<Directory>;
  /** Fetch a single drop by ID. This could be either an event or time based drop. */
  drop?: Maybe<DropType>;
  /** Fetch a single drop benefit by ID. */
  dropBenefit?: Maybe<DropBenefit>;
  /** Fetch a single drop campaign by ID. */
  dropCampaign?: Maybe<DropCampaign>;
  /** Determine the currently logged in users eligibility for the specified drop. */
  dropEligibility?: Maybe<DropEligibility>;
  /** Get an emote by ID. */
  emote?: Maybe<Emote>;
  /** Get the current set of emote modifiers. */
  emoteModifiers?: Maybe<Array<CommunityPointsEmoteModifier>>;
  /** Get an emote set by ID. */
  emoteSet?: Maybe<EmoteSet>;
  /** Experiment properties for temporary use. */
  experiment?: Maybe<Experiment>;
  /**
   * Get an Extension by ID. Optionally, provide a specific version. If no version is provided,
   * the released version of that extension is returned.
   */
  extension?: Maybe<Extension>;
  /** Get an ExtensionCarousel by ID. The default carousel can be loaded by providing the ID: "default". */
  extensionCarousel?: Maybe<ExtensionCarousel>;
  /**
   * Fetch a paginated list of Extension Categories. Each Category will provide the first ten
   * extensions sorted by popularity in that category.
   */
  extensionCategories?: Maybe<ExtensionCategoryConnection>;
  /** Fetch a single category. Both slugs and ids are valid inputs for getting a category. */
  extensionCategory?: Maybe<ExtensionCategory>;
  /**
   * Fetch a single Extension Client by ID.
   * An ExtensionClient is the authorization component of an extension.
   * Returns Null if the current user doesn't have access to the extension.
   */
  extensionClient?: Maybe<ExtensionClient>;
  /** Fetch a paginated list of Extension Clients. */
  extensionClients?: Maybe<ExtensionClientConnection>;
  /** Fetch an ExtensionManifest by ID and version. */
  extensionManifest?: Maybe<ExtensionManifest>;
  /** Fetch a paginated list of ExtensionManifests. */
  extensionManifests?: Maybe<ExtensionManifestConnection>;
  /** Fetch a Summary of the state of an extension. The Cursor is used to page extension manifests. */
  extensionManifestsSummary?: Maybe<ExtensionManifestsSummary>;
  /**
   * extensionRatingsCSVReportPresignedURL asks the ExtensionRatings backend if the given report is completed, and if
   * so, to generate and return a presigned S3 URL that the devsite can use to allow the user to download it.
   * If the URL is not ready yet, the response will be an empty string.
   */
  extensionRatingsCSVReportPresignedURL?: Maybe<ExtensionRatingsCsvReportPresignedUrl>;
  /** Fetch the authentication settings for a particular extension. */
  extensionSecrets?: Maybe<ExtensionSecretsInfo>;
  /** Fetch an ExtensionVersionDiscoveryManifest by ID and version. */
  extensionVersionDiscoveryManifest?: Maybe<ExtensionVersionDiscoveryManifest>;
  /**
   * Search extensions by text found in the Extension name, description or summary. The results are
   * always returned in order of popularity. By default, all RELEASED and IN_TEST extensions are returned.
   * Pass RELEASED as the value of 'state' to only return extensions in the RELEASED state.
   */
  extensions?: Maybe<ExtensionConnection>;
  /**
   * Fetch the sections & content that should be featured on mobile
   * `language` is a letter code for the language the requesting user speaks (e.g. "en").
   */
  featuredContentSections?: Maybe<Array<FeaturedContentSection>>;
  /**
   * Fetch streams that are featured on the front page, ordered by featurePriority ascending.
   * DEPRECATED: `geolocation` is computed based on GeoIP with a fallback value of "US" and should be omitted
   * `language` is a letter code for the language the requesting user speaks (ex. "en")
   * By default returns 6 streams.
   */
  featuredStreams?: Maybe<Array<Maybe<FeaturedStream>>>;
  /**
   * Fetch VODs that should be featured on the homepage
   * `language` is a letter code for the language the requesting user speaks (e.g. "en").
   * @deprecated Subject to change
   */
  featuredVideos?: Maybe<Array<Maybe<FeaturedVideo>>>;
  /**
   * Get a Feed by ID.
   * @deprecated No longer supported
   */
  feed?: Maybe<Feed>;
  /**
   * Convert a URL to an object that can be embedded into Twitch feeds.
   * @deprecated No longer supported
   */
  feedEmbed?: Maybe<FeedEmbed>;
  /**
   * Get a feed item by ID.
   * @deprecated No longer supported
   */
  feedItemContent?: Maybe<FeedItemContent>;
  /** Get a single game as identified by its name or ID. At least one parameter must be provided. */
  game?: Maybe<Game>;
  /**
   * Fetch games based on a variety of sorting options.
   * By default returns 10 games, sorted by highest ccu.
   * DEPRECATED field arguments: locale, tags
   * Use GameOptions instead.
   */
  games?: Maybe<GameConnection>;
  /** Get whether a username is available for registration. */
  isUsernameAvailable?: Maybe<Scalars['Boolean']>;
  /** Get key code information given a key code. */
  key?: Maybe<Claimable>;
  /** Get a chat message by its id. */
  message?: Maybe<Message>;
  /** Get a list of the most recent Mod View Newsfeed items. */
  modViewNewsfeedEntries?: Maybe<Array<ModViewNewsfeedEntry>>;
  /**
   * Returns a developer organization by ID.
   * User must be apart of the organization.
   */
  organization?: Maybe<Organization>;
  /**
   * Gets a pending Twitch Developer Organization application of the currently authenticated user.
   * This is deprecated due to multi-org and ability to have multiple applications.
   * @deprecated Use pendingOrganizationApplications instead.
   */
  pendingOrganizationApplication?: Maybe<OrganizationApplication>;
  /** Gets a pending Twitch Developer Organization applications of the currently authenticated user. */
  pendingOrganizationApplications?: Maybe<Array<OrganizationApplication>>;
  /**
   * Get a list of sections(follows, recommendation) for the current user
   * may not return all the requested section e.g requesting following section for logged out user.
   */
  personalSections?: Maybe<Array<PersonalSection>>;
  /** Returns a poll by its ID. */
  poll?: Maybe<Poll>;
  /** Returns a Prediction Event by its ID. */
  predictionEvent?: Maybe<PredictionEvent>;
  /**
   * Get Current PrimeOffers for a given region based on country code (request info or query param)
   * optional dateOverride to provide offers that would be displayed on that date
   * optional countryCode to provide offers that are displayed for that country
   * optional locale to provide offers displayed for the supplied locale.
   */
  primeOffers: Array<PrimeOffer>;
  /**
   * Retrieve currently live Prime Gaming offers for a given region using the new eligibility architecture.
   * If provided, dateOverride is used to specify offers that would be live on the given date.
   * If provided, countryCode is used to specify offers that would be live in the given region.
   * If provided, locale is used to specify the offer content language for the given locale.
   */
  primeOffersWithEligibility: Array<PrimeOfferWithEligibility>;
  /**
   * Retrieve currently live Prime Gaming offers for a given region.
   * This query retrieves offer data without eligibility or entitlement information.
   * If provided, dateOverride is used to specify offers that would be live on the given date.
   * If provided, countryCode is used to specify offers that would be live in the given region.
   * If provided, locale is used to specify the offer content language for the given locale.
   */
  primeOffersWithoutEligibility: Array<PrimeOffer>;
  /**
   * PrimePromotions data - query supports optional identifiers for promotion strings but default behavior will use
   * countryCode and userID to find available marketing promotions. For whitelisted QA users dateOverride can be provided.
   */
  primePromotions: Array<Maybe<PrimePromotion>>;
  /** PrimeVideoBenefit returns a user's prime video benefits from Amazon. Requires an LWA token. */
  primeVideoBenefit?: Maybe<PrimeVideoBenefit>;
  /**
   * Get details about a purchasable offer for the current logged in user.
   * This field can only be requested if an OAuth token is supplied with the request.
   * If the OAuth token is not supplied or if the offer does not exist, this will return null.
   */
  purchasableOffer?: Maybe<Offer>;
  /**
   * Fetch radio content based on the content type, optionally filtered by an Amazon Standard Identification Number.
   * @deprecated Use specific user.radio queries instead.
   */
  radioContent?: Maybe<RadioContent>;
  /**
   * Fetch a group of recommended games.
   * `recRequestID` is a tracking id created by the caller. This should be unique per request.
   * `location` defines the source location of the recommended streams request (e.g. "TV_APPS").
   * `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
   */
  recommendedGames?: Maybe<RecommendedGamesConnection>;
  /**
   * Fetch a group of recommended streams.
   * `recRequestID` is a tracking id created by the caller. This should be unique per request.
   * `location` defines the source location of the recommended streams request (e.g. "LEFT_NAV").
   * `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
   * `filters` is an optional parameter that can be used to filter recommendation results.
   */
  recommendedStreams?: Maybe<RecommendedStreamsConnection>;
  /** Holds configuration necessary for calling Recurly. */
  recurlyConfigs?: Maybe<RecurlyConfigs>;
  /** Get a message rejected by chat. */
  rejectedChatMessage?: Maybe<RejectedChatMessage>;
  /** Get a list of valid reasons for a content type. */
  reportReasons?: Maybe<Array<ReportReason>>;
  /** Get a list of valid country and ToS reasons for a content types. */
  reportToSAndCountryReasons?: Maybe<ReportToSAndCountryReasons>;
  /** Metadata about the request to the API. */
  requestInfo: RequestInfo;
  /** Get a room by its ID. */
  room?: Maybe<Room>;
  /**
   * Get a schedule segment by ID. Additional options can be provided to get the segment relative to a
   * different time or timezone.
   */
  scheduleSegment?: Maybe<ScheduleSegment>;
  /**
   * Get search results for a user's query.
   * @deprecated Use the 'searchFor' query instead.
   */
  search?: Maybe<SearchResult>;
  /** Search for tags to apply to a channel. */
  searchApplicableTags?: Maybe<Array<Tag>>;
  /** Get search results for categories/games. */
  searchCategories?: Maybe<SearchCategoriesConnection>;
  /** Search for category tags to filter categories in Browse. */
  searchCategoryTags?: Maybe<Array<Tag>>;
  /** Get gql search results for a user's query. */
  searchFor?: Maybe<SearchFor>;
  /** Search for tags to filter live channels in Browse. */
  searchLiveTags?: Maybe<Array<Tag>>;
  /** Get Live Streams in search by user query. */
  searchStreams?: Maybe<SearchStreamConnection>;
  /** Get search suggestions for a user's query. */
  searchSuggestions?: Maybe<SearchSuggestionConnection>;
  /** Get users by query in search. for search page product use searchFor instead. */
  searchUsers?: Maybe<SearchUserConnection>;
  /**
   * Fetch shelves to display on the homepage.
   * DEPRECATED field arguments: platform (use context.platform), langWeightedCCU.
   */
  shelves?: Maybe<ShelfConnection>;
  /**
   * Get paginated short video feed.
   * @deprecated No longer supported
   */
  shortVideoFeed?: Maybe<ShortVideoFeedConnection>;
  /** Whether or not the Twitch Developers CSAT callout should appear for the currently authenticated user. */
  shouldShowDevsiteCSAT?: Maybe<Scalars['Boolean']>;
  /** Get a squad stream by ID. */
  squadStream?: Maybe<SquadStream>;
  /**
   * The playback access token that determines whether the user can watch the live stream
   * Fetched for both authed and unauthed users.
   */
  streamPlaybackAccessToken?: Maybe<PlaybackAccessToken>;
  /**
   * Fetch live streams, ordered by the number of viewers descending.
   * languages can be empty or null, which will imply all the languages are included on the results.
   * tags are an array of tag ID as optional filters for streams.
   * DEPRECATED field arguments: platformType, languageTags, tags
   * Use StreamOptions instead.
   */
  streams?: Maybe<StreamConnection>;
  /**
   * Get a subscription product by its name. See product name examples below. The productName uniquely identifies a product.
   *
   * e.g. "meclipse", "meclipse_2000", "meclipse_3000", these are respectively, the tier 1, 2, and 3 subscription product
   * names for the user with login "shroud".
   */
  subscriptionProduct?: Maybe<SubscriptionProduct>;
  /**
   * Get all avaialble token bundle products available for the user.
   * CountryCode will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
   */
  subscriptionTokenBundleProducts?: Maybe<Array<SubscriptionTokenBundleProduct>>;
  /** Gets the Token Product Config. */
  subscriptionTokenProductConfig?: Maybe<SubscriptionTokenProductConfig>;
  /** Gets a list of cloud broadcast providers that can be used by clients to start a broadcast via the provider. */
  supportedCloudBroadcastProviders?: Maybe<Array<CloudBroadcastProviderKey>>;
  /** Get the logged in user's available hero assets. */
  supportedHeroAssets: Array<HeroAsset>;
  /** Get the verticals available for a particular user. */
  supportedVerticals?: Maybe<Array<VerticalDirectory>>;
  /** Gets a team by its Twitch name. */
  team?: Maybe<Team>;
  /** Gets a list of sorted top tags aggregated from all tags applied to current live channels. */
  topTags?: Maybe<Array<Tag>>;
  /** Get localized metadata for any twitch's website url. */
  urlMetadata?: Maybe<UrlMetadata>;
  /**
   * Get a user by their ID or login.
   * If no ID or login is provided, null is returned.
   * Lookup type can tell the resolver to include all users (inclusing deleted and
   * suspended accounts) on the lookup, defaults to only retrieve active users.
   */
  user?: Maybe<User>;
  /** Fetch the user by a specific attribute. */
  userByAttribute?: Maybe<User>;
  /**
   * Fetch a user by their ID, or receive a reason indicating
   * why the user could not be retrieved.
   */
  userResultByID?: Maybe<UserResult>;
  /**
   * Fetch a user by their login, or receive a reason indicating
   * why the user could not be retrieved.
   */
  userResultByLogin?: Maybe<UserResult>;
  /** Get a list of users, either by their logins or by their IDs. */
  users?: Maybe<Array<Maybe<User>>>;
  /**
   * Get a verification request given an opaqueID.
   * These are generally email verification requests, but could be phone-numbers in the future.
   */
  verificationRequest?: Maybe<VerificationRequest>;
  /** Get content for a vertical directory by its ID. */
  verticalDirectory?: Maybe<VerticalDirectory>;
  /** Get content for a vertical subdirectory filtered by one or more context IDs (ex: category ID, tag ID). */
  verticalSubDirectory?: Maybe<VerticalSubDirectory>;
  /**
   * Get a video by its ID.
   * By default, Video queries only return public videos.
   * If the owner should also see their own private videos, set includePrivate flag in the `options` input.
   * This flag does not include other people's private videos.
   */
  video?: Maybe<Video>;
  /** A paginated list of comments against id, videoID, or channelID. */
  videoComments?: Maybe<VideoCommentConnection>;
  /**
   * Get the current or past video ingest metadata such as bitrates and codecs by its ID and channelID.
   * Optional customerID for staffs.
   */
  videoIngestSession?: Maybe<VideoIngestSession>;
  /** Get the current video ingest metadata such as bitrates and codecs starting a specified number of seconds ago by channelID. Optional customerID for staffs. */
  videoIngestSessionLatest?: Maybe<VideoIngestSession>;
  /** Get the current or past video ingest metadata such as bitrates and codecs by time range and channelID. Optional customerID for staffs. */
  videoIngestSessions?: Maybe<Array<VideoIngestSession>>;
  /**
   * The playback access token that determines whether the user can watch the video.
   * Fetched for both authed and unauthed users.
   */
  videoPlaybackAccessToken?: Maybe<PlaybackAccessToken>;
  /** Get a list of videos in order of descending popularity. */
  videos?: Maybe<VideoConnection>;
  /** Get a list of Prime Video items for Watch Parties. */
  watchPartyItems?: Maybe<WatchPartyItemConnection>;
  /** Get a whisper thread by ID. */
  whisperThread?: Maybe<WhisperThread>;
};


/** Root fields to access the Twitch API. */
export type QueryAdContextArgs = {
  context: AdRequestContext;
};


/** Root fields to access the Twitch API. */
export type QueryAdCreativeArgs = {
  adSystem: Scalars['String'];
  creativeID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryAllTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  tagScope?: InputMaybe<TagScope>;
};


/** Root fields to access the Twitch API. */
export type QueryAutomodContentArgs = {
  input: AutoModContentInput;
};


/** Root fields to access the Twitch API. */
export type QueryChallengeArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryChangelogEntriesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};


/** Root fields to access the Twitch API. */
export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryChannelViewerArgs = {
  channelLogin: Scalars['String'];
  userLogin: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryChannelsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  names?: InputMaybe<Array<Scalars['String']>>;
};


/** Root fields to access the Twitch API. */
export type QueryChatRoomBanStatusArgs = {
  channelID: Scalars['ID'];
  userID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryClientAuthorizationArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryClipArgs = {
  slug: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCloudBroadcastArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCloudBroadcastProviderArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCollectionArgs = {
  id: Scalars['ID'];
  options?: InputMaybe<CollectionOptions>;
};


/** Root fields to access the Twitch API. */
export type QueryCompetitionArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCompetitionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<CompetitionState>;
};


/** Root fields to access the Twitch API. */
export type QueryConsentArgs = {
  consentSessionID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryContentTagArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryContentTagsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** Root fields to access the Twitch API. */
export type QueryCreatorCampArticleArgs = {
  category: Scalars['String'];
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCreatorCampCategoryArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryCreatorDashboardArgs = {
  endAt: Scalars['Time'];
  period: TimeSeriesPeriod;
  startAt: Scalars['Time'];
};


/** Root fields to access the Twitch API. */
export type QueryCurrentChannelViewerArgs = {
  channelID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryDirectoryArgs = {
  name: Scalars['String'];
  type: DirectoryType;
};


/** Root fields to access the Twitch API. */
export type QueryDropArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryDropBenefitArgs = {
  id: Scalars['ID'];
  ownerID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryDropCampaignArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryDropEligibilityArgs = {
  dropInstanceID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryEmoteArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryEmoteSetArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionArgs = {
  id: Scalars['ID'];
  version?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryExtensionCarouselArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Root fields to access the Twitch API. */
export type QueryExtensionCategoryArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionClientArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionClientsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  organizationID?: InputMaybe<Scalars['ID']>;
};


/** Root fields to access the Twitch API. */
export type QueryExtensionManifestArgs = {
  id: Scalars['ID'];
  version: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionManifestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionManifestsSummaryArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionRatingsCsvReportPresignedUrlArgs = {
  reportFilename: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionSecretsArgs = {
  extensionID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionVersionDiscoveryManifestArgs = {
  id: Scalars['ID'];
  version: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryExtensionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<ExtensionStateFilter>;
};


/** Root fields to access the Twitch API. */
export type QueryFeaturedContentSectionsArgs = {
  language: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryFeaturedStreamsArgs = {
  acceptedMature?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  geolocation?: InputMaybe<Scalars['String']>;
  language?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryFeaturedVideosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  language: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryFeedArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryFeedEmbedArgs = {
  url: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryFeedItemContentArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryGameArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryGamesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<Scalars['String']>;
  options?: InputMaybe<GameOptions>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};


/** Root fields to access the Twitch API. */
export type QueryIsUsernameAvailableArgs = {
  username: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryKeyArgs = {
  code: Scalars['String'];
  countryOfResidence?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryMessageArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryModViewNewsfeedEntriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** Root fields to access the Twitch API. */
export type QueryOrganizationArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryPersonalSectionsArgs = {
  input: PersonalSectionInput;
};


/** Root fields to access the Twitch API. */
export type QueryPollArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryPredictionEventArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryPrimeOffersArgs = {
  countryCode?: InputMaybe<Scalars['String']>;
  dateOverride?: InputMaybe<Scalars['Time']>;
  locale?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryPrimeOffersWithEligibilityArgs = {
  countryCode?: InputMaybe<Scalars['String']>;
  dateOverride?: InputMaybe<Scalars['Time']>;
  locale?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryPrimeOffersWithoutEligibilityArgs = {
  countryCode?: InputMaybe<Scalars['String']>;
  dateOverride?: InputMaybe<Scalars['Time']>;
  locale?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryPrimePromotionsArgs = {
  dateOverride?: InputMaybe<Scalars['Time']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** Root fields to access the Twitch API. */
export type QueryPrimeVideoBenefitArgs = {
  accessToken: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryPurchasableOfferArgs = {
  params: PurchasableOfferParams;
};


/** Root fields to access the Twitch API. */
export type QueryRadioContentArgs = {
  contentType: RadioContentType;
  id?: InputMaybe<Scalars['ID']>;
};


/** Root fields to access the Twitch API. */
export type QueryRecommendedGamesArgs = {
  context: RecommendationsContext;
  first?: InputMaybe<Scalars['Int']>;
  location: Scalars['String'];
  recRequestID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryRecommendedStreamsArgs = {
  context: RecommendationsContext;
  filters?: InputMaybe<StreamRecommendationsFilters>;
  first?: InputMaybe<Scalars['Int']>;
  location: Scalars['String'];
  recRequestID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryRecurlyConfigsArgs = {
  paymentSession?: InputMaybe<PaymentSession>;
};


/** Root fields to access the Twitch API. */
export type QueryRejectedChatMessageArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryReportReasonsArgs = {
  content: ReportContentType;
};


/** Root fields to access the Twitch API. */
export type QueryReportToSAndCountryReasonsArgs = {
  content: ReportContentType;
};


/** Root fields to access the Twitch API. */
export type QueryRoomArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryScheduleSegmentArgs = {
  id: Scalars['ID'];
  options?: InputMaybe<ScheduleSegmentOptions>;
};


/** Root fields to access the Twitch API. */
export type QuerySearchArgs = {
  options?: InputMaybe<SearchOptions>;
  platform: Scalars['String'];
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchApplicableTagsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  query: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchCategoryTagsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchForArgs = {
  options?: InputMaybe<SearchForOptions>;
  platform: Scalars['String'];
  requestID?: InputMaybe<Scalars['ID']>;
  target?: InputMaybe<SearchForTarget>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchLiveTagsArgs = {
  categoryID?: InputMaybe<Scalars['ID']>;
  limit?: InputMaybe<Scalars['Int']>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchStreamsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySearchSuggestionsArgs = {
  queryFragment: Scalars['String'];
  requestID?: InputMaybe<Scalars['ID']>;
};


/** Root fields to access the Twitch API. */
export type QuerySearchUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  userQuery: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryShelvesArgs = {
  context?: InputMaybe<RecommendationsContext>;
  first?: InputMaybe<Scalars['Int']>;
  itemsPerRow?: InputMaybe<Scalars['Int']>;
  langWeightedCCU?: InputMaybe<Scalars['Boolean']>;
  platform: Scalars['String'];
  requestID: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryShortVideoFeedArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<ShortVideoFeedOptions>;
};


/** Root fields to access the Twitch API. */
export type QuerySquadStreamArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryStreamPlaybackAccessTokenArgs = {
  channelName: Scalars['String'];
  params: PlaybackAccessTokenParams;
};


/** Root fields to access the Twitch API. */
export type QueryStreamsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  input?: InputMaybe<StreamMetadataFilterInput>;
  languages?: InputMaybe<Array<Language>>;
  options?: InputMaybe<StreamOptions>;
  platformType?: InputMaybe<PlatformType>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};


/** Root fields to access the Twitch API. */
export type QuerySubscriptionProductArgs = {
  productName: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QuerySubscriptionTokenBundleProductsArgs = {
  channelID?: InputMaybe<Scalars['ID']>;
  countryCode?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QuerySupportedVerticalsArgs = {
  recommendationsContext: RecommendationsContext;
};


/** Root fields to access the Twitch API. */
export type QueryTeamArgs = {
  name: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryTopTagsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};


/** Root fields to access the Twitch API. */
export type QueryUrlMetadataArgs = {
  url: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryUserArgs = {
  id?: InputMaybe<Scalars['ID']>;
  login?: InputMaybe<Scalars['String']>;
  lookupType?: InputMaybe<UserLookupType>;
};


/** Root fields to access the Twitch API. */
export type QueryUserByAttributeArgs = {
  input: UserByAttribute;
};


/** Root fields to access the Twitch API. */
export type QueryUserResultByIdArgs = {
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryUserResultByLoginArgs = {
  login: Scalars['String'];
};


/** Root fields to access the Twitch API. */
export type QueryUsersArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  logins?: InputMaybe<Array<Scalars['String']>>;
};


/** Root fields to access the Twitch API. */
export type QueryVerificationRequestArgs = {
  opaqueID: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryVerticalDirectoryArgs = {
  contentMax: Scalars['Int'];
  contentMin: Scalars['Int'];
  id: Scalars['ID'];
  recommendationsContext: RecommendationsContext;
};


/** Root fields to access the Twitch API. */
export type QueryVerticalSubDirectoryArgs = {
  contentContext?: InputMaybe<VerticalSubDirectoryContentContext>;
  contentMax: Scalars['Int'];
  contentMin: Scalars['Int'];
  id: Scalars['ID'];
  recommendationsContext: RecommendationsContext;
};


/** Root fields to access the Twitch API. */
export type QueryVideoArgs = {
  id?: InputMaybe<Scalars['ID']>;
  options?: InputMaybe<VideoOptions>;
};


/** Root fields to access the Twitch API. */
export type QueryVideoCommentsArgs = {
  Before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  channelID?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  videoID?: InputMaybe<Scalars['String']>;
};


/** Root fields to access the Twitch API. */
export type QueryVideoIngestSessionArgs = {
  channelID: Scalars['ID'];
  customerID?: InputMaybe<Scalars['ID']>;
  id: Scalars['ID'];
};


/** Root fields to access the Twitch API. */
export type QueryVideoIngestSessionLatestArgs = {
  channelID: Scalars['ID'];
  customerID?: InputMaybe<Scalars['ID']>;
  secondsAgo: Scalars['Int'];
};


/** Root fields to access the Twitch API. */
export type QueryVideoIngestSessionsArgs = {
  channelID: Scalars['ID'];
  customerID?: InputMaybe<Scalars['ID']>;
  endedAt: Scalars['Time'];
  startedAt: Scalars['Time'];
};


/** Root fields to access the Twitch API. */
export type QueryVideoPlaybackAccessTokenArgs = {
  id: Scalars['ID'];
  params: PlaybackAccessTokenParams;
};


/** Root fields to access the Twitch API. */
export type QueryVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  broadcastType?: InputMaybe<BroadcastType>;
  first?: InputMaybe<Scalars['Int']>;
  language?: InputMaybe<Language>;
};


/** Root fields to access the Twitch API. */
export type QueryWatchPartyItemsArgs = {
  accessToken?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<WatchPartyItemSearchOptions>;
};


/** Root fields to access the Twitch API. */
export type QueryWhisperThreadArgs = {
  id?: InputMaybe<Scalars['ID']>;
};

/** Interval that a quest is being evaluated for. */
export type QuestEvaluationInterval = {
  __typename?: 'QuestEvaluationInterval';
  /** Duration of the interval (in days). */
  durationInDays: Scalars['Int'];
  /** End time of the interval. */
  endTime: Scalars['Time'];
  /** Start time of the interval. */
  startTime: Scalars['Time'];
};

/** Progress towards a particular quest goal. */
export type QuestGoalFloat = {
  __typename?: 'QuestGoalFloat';
  /** Current progress towards quest goal. */
  current: Scalars['Float'];
  /** Number needed to complete the quest goal. */
  goal: Scalars['Float'];
};

/** Progress towards a particular quest goal. */
export type QuestGoalInt = {
  __typename?: 'QuestGoalInt';
  /** Current progress towards quest goal. */
  current: Scalars['Int'];
  /** Number needed to complete the quest goal. */
  goal: Scalars['Int'];
};

/** The quests associated with a user. */
export type Quests = {
  __typename?: 'Quests';
  /** "Build a Community" quest. */
  buildACommunity?: Maybe<BuildACommunity>;
  /** "It Begins" quest. */
  itBegins?: Maybe<ItBegins>;
  /** "Path to Affiliate" quest. */
  pathToAffiliate?: Maybe<PathToAffiliate>;
  /** "Path to Partner" quest. */
  pathToPartner?: Maybe<PathToPartner>;
};

/** ROW cookie vendor for a user. */
export type RowCookieVendor = {
  __typename?: 'ROWCookieVendor';
  /** User content status for each vendor. */
  consentStatus: ConsentStatus;
  /** A flag that shows if the consent is given by the user or by consent service as default value. */
  hasUserSetConsent: Scalars['Boolean'];
  /** A flag that shows if the vendor should be visible to management page. */
  isVisible: Scalars['Boolean'];
  /** Vendor name. */
  name: VendorName;
};

/** List of ROW cookie vendor. */
export type RowVendorConsent = {
  __typename?: 'ROWVendorConsent';
  /** status for vendors. */
  status: Array<RowCookieVendor>;
};

/** RTMPSession is metadata related to the RTMP data sent by the broadcaster. */
export type RtmpSession = {
  __typename?: 'RTMPSession';
  /** Audio codecs of RTMP session. */
  audioCodecs: Scalars['String'];
  /** H.264 advanced video codec. */
  avcLevel?: Maybe<Scalars['Int']>;
  /** Staff-only field. The IP address of the broadcaster of the RTMP session. */
  clientIP?: Maybe<Scalars['String']>;
  /** Name of the broadcaster's encoder. */
  encoder: Scalars['String'];
  /** H.264 encoder Instantaneous Decoder Refresh interval. */
  idrInterval?: Maybe<Scalars['Int']>;
  /** rtmpExitReason tells how the stream session was terminated. */
  rtmpExitReason?: Maybe<Scalars['String']>;
  /** RTMP request parameters sent by the broadcaster. */
  rtmpFlags: Scalars['String'];
  /** A full list of RTMP header sent by the broadcaster. */
  rtmpMetadata: Scalars['String'];
  /** Duration of each video frame segment in seconds. */
  segmentDurationSeconds: Scalars['Int'];
  /** Video codecs of RTMP session. */
  videoCodecs: Scalars['String'];
  /** Video resolution height in pixel. */
  videoResolutionHeight: Scalars['Int'];
  /** Video resolution width in pixel. */
  videoResolutionWidth: Scalars['Int'];
};

/** Twitch Radio access. */
export type Radio = {
  __typename?: 'Radio';
  /** Twitch Radio account information for the user. */
  account: RadioAccount;
  /**
   * Fetch the requesting user's currently playing radio content.
   * @deprecated Use 'currentRadioTrack' in 'channel' instead.
   */
  currentlyPlaying: RadioCurrentlyPlaying;
  /** Fetch a radio playlist by ID. Tracks can be requested here, but can be slow to respond. */
  playlist?: Maybe<RadioPlaylist>;
  /** Fetch all, or filtered subset of, radio playlists. Cannot request track data from this query. */
  playlists: Array<RadioPlaylist>;
  /** Fetch the requesting user's recently played radio content ids. Optionally filtered by type. */
  recentlyPlayed: Array<RadioRecentlyPlayed>;
  /** Fetch a radio station by ID. Returns the initial queue with a token to get the next tracks if no pageToken is passed. */
  station?: Maybe<RadioStation>;
  /** Fetch all radio stations. */
  stations: Array<RadioStation>;
};


/** Twitch Radio access. */
export type RadioPlaylistArgs = {
  id: Scalars['ID'];
};


/** Twitch Radio access. */
export type RadioPlaylistsArgs = {
  filter?: InputMaybe<RadioPlaylistFilter>;
};


/** Twitch Radio access. */
export type RadioRecentlyPlayedArgs = {
  filter?: InputMaybe<RadioRecentlyPlayedFilter>;
};


/** Twitch Radio access. */
export type RadioStationArgs = {
  id: Scalars['ID'];
  numberOfTracks?: InputMaybe<Scalars['Int']>;
  pageToken?: InputMaybe<Scalars['String']>;
};

/** Amazon Music user information for a Twitch user using Twitch Radio. */
export type RadioAccount = {
  __typename?: 'RadioAccount';
  /** User token to authenticate with Amazon services */
  amazonAccessToken: Scalars['String'];
  /** The Twitch user's ID as known in Amazon Music. */
  customerID: Scalars['ID'];
  /** The unique Amazon client device identifier for this user and service. */
  deviceID: Scalars['ID'];
  /** ISO 3166-1 alpha-2 country code territory of the user in Amazon Music. */
  musicTerritory: Scalars['String'];
  tokenExpiresAt: Scalars['Time'];
};

/** A Twitch Radio Album. */
export type RadioAlbum = {
  __typename?: 'RadioAlbum';
  /** The album's unique id (an Amazon Standard Identification Number). */
  id: Scalars['ID'];
  /** URL to the album's main image. */
  imageURL: Scalars['String'];
  /** The album name. */
  name: Scalars['String'];
};

/** A Twitch Radio artist. */
export type RadioArtist = {
  __typename?: 'RadioArtist';
  /** The creator channel. */
  channel?: Maybe<Channel>;
  /** The creator channel id. */
  creatorChannelID?: Maybe<Scalars['ID']>;
  /** The artist's unique id (an Amazon Standard Identification Number). */
  id: Scalars['ID'];
  /** The artist name. */
  name: Scalars['String'];
};

/** A container for Twitch Radio content request results. */
export type RadioContent = {
  __typename?: 'RadioContent';
  /** The requested playlists. */
  items?: Maybe<Array<RadioContentItem>>;
};

/** The types of radio content that can be requested (e.g., playlists, stations, tracks, etc). */
export type RadioContentItem = RadioPlaylist | RadioRecentlyPlayed;

/** A Twitch Radio LinkFire Input Response for Content Promotion. */
export type RadioContentPromotion = {
  __typename?: 'RadioContentPromotion';
  /** Text on the redirect button. */
  buttonText: Scalars['String'];
  /** Icon for the media service having dark/light theme assets. Formats supported: PNG, SVG. Default value is SVG. */
  icon: RadioIconThemeAssets;
  /**
   * IconURL for the media service. Formats supported: PNG, SVG. Default value is SVG.
   * @deprecated Use 'icon' instead.
   */
  iconURL: Scalars['String'];
  /** Rank to order the icons. */
  rank: Scalars['Int'];
  /** Title of the service. */
  title: Scalars['String'];
  /** URL to redirect to the service. */
  url: Scalars['String'];
};


/** A Twitch Radio LinkFire Input Response for Content Promotion. */
export type RadioContentPromotionIconArgs = {
  format?: InputMaybe<RadioIconFormat>;
};


/** A Twitch Radio LinkFire Input Response for Content Promotion. */
export type RadioContentPromotionIconUrlArgs = {
  format?: InputMaybe<RadioIconFormat>;
};

/** The different Twitch Radio collection types that can be requested. */
export enum RadioContentType {
  /** Retrieve playlists, can be filtered by ASIN. */
  Playlist = 'PLAYLIST',
  /** Retrieve the user's recently played playlists. */
  RecentlyPlayed = 'RECENTLY_PLAYED'
}

/** The currently playing radio track addition result. */
export type RadioCurrentTrackResponse = {
  __typename?: 'RadioCurrentTrackResponse';
  /** Radio currently Playing Track is added Successfully or not. */
  isSuccess: Scalars['Boolean'];
};

/** Content currently playing in the client for a user. */
export type RadioCurrentlyPlaying = {
  __typename?: 'RadioCurrentlyPlaying';
  /** The radio content promotion json data. */
  contentPromotions?: Maybe<Array<RadioContentPromotion>>;
  /** Whether the track is currently playing or not. */
  isCurrentlyPlaying: Scalars['Boolean'];
  /** The Track Details of the currently playing track. */
  track?: Maybe<RadioTrack>;
};

/** The types of content we can register current plays for. */
export enum RadioCurrentlyPlayingType {
  /** A radio playlist. */
  Playlist = 'PLAYLIST',
  /** A radio station. */
  Station = 'STATION'
}

/** Icon Formats for the media service. */
export enum RadioIconFormat {
  /** PNG Icon for the media service. */
  Png = 'PNG',
  /** SVG Icon for the media service. */
  Svg = 'SVG'
}

/** Theme for the media service assets. */
export type RadioIconThemeAssets = {
  __typename?: 'RadioIconThemeAssets';
  /** Dark theme Asset URL. */
  darkURL: Scalars['String'];
  /** Light theme Asset URL. */
  lightURL: Scalars['String'];
};

/** A Twitch Radio playlist. */
export type RadioPlaylist = {
  __typename?: 'RadioPlaylist';
  /** Curator of the playlist. */
  curator: Scalars['String'];
  /** Playlist's Description. */
  description: Scalars['String'];
  /** The playlist's unique id (an Amazon Standard Identification Number). */
  id: Scalars['ID'];
  /** URL to the playlist's main image. */
  imageURL: Scalars['String'];
  /** Is the playlist featured. */
  isFeatured: Scalars['Boolean'];
  /** The playlist's title. */
  title: Scalars['String'];
  /** List of tracks in the playlist. */
  tracks?: Maybe<Array<RadioTrack>>;
};

/** Filters for querying the playlists. */
export enum RadioPlaylistFilter {
  /** Get all playlists. */
  All = 'ALL',
  /** Get only featured playlists. */
  Featured = 'FEATURED'
}

/** Content recently played in the client. */
export type RadioRecentlyPlayed = {
  __typename?: 'RadioRecentlyPlayed';
  /** The type of content the ID maps to. */
  contentType: RadioRecentlyPlayedType;
  /** The id of the recently played item. */
  id: Scalars['ID'];
  /** Recently played playlist metadata. */
  playlist?: Maybe<RadioPlaylist>;
  /** Recently played station metadata. */
  station?: Maybe<RadioStation>;
  /** The time this ID was last recently played by the current user. */
  updatedAt: Scalars['Time'];
};

/** Filter for recentlyPlayed. */
export enum RadioRecentlyPlayedFilter {
  /** Get all recently played items. */
  All = 'ALL',
  /** Retrieve only playlists. */
  Playlists = 'PLAYLISTS'
}

/** The types of content we can register recent plays for. */
export enum RadioRecentlyPlayedType {
  /** A radio playlist. */
  Playlist = 'PLAYLIST',
  /** A radio station. */
  Station = 'STATION'
}

/** A Twitch Radio station. */
export type RadioStation = {
  __typename?: 'RadioStation';
  /** The station's unique id (an Amazon Standard Identification Number). */
  id: Scalars['ID'];
  /** URL to the station's main image. */
  imageURL: Scalars['String'];
  /** Is the station featured. */
  isFeatured: Scalars['Boolean'];
  /** Page token to be passed back to the Client Gateway when requesting additional tracks. */
  pageToken?: Maybe<Scalars['String']>;
  /** The station's title. */
  title: Scalars['String'];
  /** List of tracks in the station. */
  tracks?: Maybe<Array<RadioTrack>>;
};

/** A Twitch Radio track. */
export type RadioTrack = {
  __typename?: 'RadioTrack';
  /** The track album. */
  album: RadioAlbum;
  /** The track artists. */
  artists: Array<RadioArtist>;
  /** The duration of the track in seconds. */
  duration: Scalars['Int'];
  /** Track's Genre. */
  genre: Scalars['String'];
  /** The track's unique id (an Amazon Standard Identification Number). */
  id: Scalars['ID'];
  /** Industry standard track's unique id. */
  isrc: Scalars['String'];
  /** The title of the track. */
  title: Scalars['String'];
};

/**
 * A raid represents a broadcaster directing their viewers to another channel
 * in a synchronized "raid" on the channel after a countdown during which
 * each viewer has a chance to opt out of the raid.
 *
 * Raids are created by a broadcaster from their dashbboard where they can search
 * and select the channel they wish to target. Once selected the raid takes counts
 * down to prepare after which the broadcaster can tell the raid to "Go", redirecting
 * all joined raiders to the target channel.
 */
export type Raid = {
  __typename?: 'Raid';
  /** Timestamp of raid announcement. */
  announceAt?: Maybe<Scalars['Time']>;
  /** Timestamp of raid go time. */
  goAt?: Maybe<Scalars['Time']>;
  /** The ID of the raid. */
  id: Scalars['ID'];
  /** Channel hosting the raid. */
  sourceChannel?: Maybe<User>;
  /** Target of the raid. */
  targetChannel?: Maybe<User>;
  /** Number of viewers in raid. */
  viewerCount?: Maybe<Scalars['Int']>;
};

/** A user's raid settings. */
export type RaidSettings = {
  __typename?: 'RaidSettings';
  /** Determines what other channels can raid this channel. */
  incomingRaidsPolicy: IncomingRaidsPolicy;
};

/** An integer range with a minimum and a maximum. */
export type Range = {
  __typename?: 'Range';
  /** The maximum value of the Range. */
  max: Scalars['Int'];
  /** The minimum value of the Range. */
  min: Scalars['Int'];
};

/** Possible errors returned by the RateExtension mutation. */
export enum RateExtensionError {
  /** Internal service error eg. database timeout. */
  InternalError = 'INTERNAL_ERROR'
}

/** RateExtensionInput submits a user's rating and feedback on a Twitch extension. */
export type RateExtensionInput = {
  /** The ID of the extension being rated. */
  extensionClientID: Scalars['ID'];
  /** The version of the extension being rated. */
  extensionVersion: Scalars['String'];
  /** Whether the user recommends the extension or not. */
  isRecommended: Scalars['Boolean'];
  /** Indicates from where the user submitted the rating. */
  location: ExtensionRatingLocation;
  /** The ID of the user performing the rating. */
  userID: Scalars['ID'];
};

/** The result of a rateExtension mutation. */
export type RateExtensionPayload = {
  __typename?: 'RateExtensionPayload';
  /** The error if the mutation fails to submit the extension rating. */
  error?: Maybe<RateExtensionError>;
  /** The resulting ExtensionRating record. */
  rating?: Maybe<ExtensionRating>;
};

export type ReactableContent = Clip | Post | Stream | Video;

export type Reaction = {
  __typename?: 'Reaction';
  /** count of users that reacted with a particular Emote. */
  count: Scalars['Int'];
  /** The Emote associated with the Reaction. */
  emote: Emote;
  /** The authenticated user's relationship with this reaction. */
  self: ReactionSelfConnection;
};

export type ReactionSelfConnection = {
  __typename?: 'ReactionSelfConnection';
  /** Did the authenticated user react. */
  hasReacted: Scalars['Boolean'];
};

export type ReadNotificationsInput = {
  /** IDs of the notifications to set as read. The minimum number is 1 and the maximum is 100. */
  ids: Array<Scalars['ID']>;
};

export type ReadNotificationsPayload = {
  __typename?: 'ReadNotificationsPayload';
  /** The amount of notifications that were set to read. */
  count: Scalars['Int'];
  /** The notifications that were set to read. Only ID and isRead are accessible. */
  notifications: Array<Maybe<OnsiteNotification>>;
};

/** Feedback from a user about a piece of content. */
export type RecommendationFeedback = {
  __typename?: 'RecommendationFeedback';
  /** Reason for feedback. */
  category: RecommendationFeedbackCategory;
  /** Feedback target. */
  content?: Maybe<RecommendationFeedbackContent>;
  /** Recommendation Feedback ID. Generated from the type, category, content id, and user id. */
  id: Scalars['ID'];
  /** Last time this feedback was given. */
  lastUpdated: Scalars['Time'];
  /** Feedback target type. */
  type: RecommendationFeedbackType;
  /** Feedback giver. */
  user?: Maybe<User>;
};

/** Reason for feedback. */
export enum RecommendationFeedbackCategory {
  /** The user has already seen this content. */
  AlreadyWatched = 'ALREADY_WATCHED',
  /** The user is not interested in this type of content. */
  NotInterested = 'NOT_INTERESTED',
  /** The user finds this type of content to be offensive. */
  Offensive = 'OFFENSIVE',
  /** Used when the other reasons do not capture the reason a user is giving feedback. */
  Other = 'OTHER',
  /** Only returned when there is an issue. Shouldn't be returned, should not be used for fetching. */
  Unspecified = 'UNSPECIFIED'
}

/** Connection between a user and recommendation feedback. */
export type RecommendationFeedbackConnection = {
  __typename?: 'RecommendationFeedbackConnection';
  /** Contains the edges for the recommendation feedback. */
  edges?: Maybe<Array<RecommendationFeedbackEdge>>;
  /** Contains pagination metadata. */
  pageInfo: PageInfo;
};

/** Feedback target. */
export type RecommendationFeedbackContent = Channel | Game | Video;

/** Edge containing the node and cursor for recommendation feedback items. */
export type RecommendationFeedbackEdge = {
  __typename?: 'RecommendationFeedbackEdge';
  /** Cursor for the feedback edge. */
  cursor: Scalars['Cursor'];
  /** Node for the feedback edge. */
  node?: Maybe<RecommendationFeedback>;
};

/** Feedback target type. */
export enum RecommendationFeedbackType {
  /** Feedback given about a game / category. */
  Category = 'CATEGORY',
  /** Feedback given about channels. */
  Channel = 'CHANNEL',
  /** Feedback given about a shelf. */
  Shelf = 'SHELF',
  /** Only returned when there is an issue. Shouldn't be returned, should not be used for fetching. */
  Unspecified = 'UNSPECIFIED',
  /** Feedback given about a video. */
  Vod = 'VOD'
}

export type Recommendations = {
  __typename?: 'Recommendations';
  /**
   * The recommended community gifting quantities to display to the user when they intend to gift subscriptions.
   * The trackingID is not a unique ID for the recommendations, but a passthrough value for backend logging to link to purchases made by the user after being shown these recommendations.
   */
  communityGiftQuantities?: Maybe<Array<Scalars['Int']>>;
  /** A list of recommended friends. */
  friends?: Maybe<Array<Maybe<RecommendedFriend>>>;
  /**
   * Live recommendations.
   * recRequestID is a tracking id created by the caller. Should be unique per request.
   */
  liveRecommendations?: Maybe<LiveRecommendationConnection>;
  /**
   * Stream recommendations.
   * @deprecated use a specific recommendation instead
   */
  streams?: Maybe<RecommendedStreamConnection>;
  /**
   * A list of recommended VODs.
   * @deprecated this feature has been sunset
   */
  videos?: Maybe<RecommendedVideoConnection>;
};


export type RecommendationsCommunityGiftQuantitiesArgs = {
  trackingID: Scalars['ID'];
};


export type RecommendationsLiveRecommendationsArgs = {
  context?: InputMaybe<RecommendationsContext>;
  first?: InputMaybe<Scalars['Int']>;
  language: Scalars['String'];
  location?: InputMaybe<Scalars['String']>;
  recRequestID: Scalars['String'];
};


export type RecommendationsStreamsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


export type RecommendationsVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/**
 * RecommendationsContext define parameters which can control recommendations logic.
 * Clients should strive to fill in as many fields as possible for the highest quality recommendaitons.
 * Many of these fields should be identical to what is sent in pageview events: https://blueprint.di.xarth.tv/#/schema/pageview.
 */
export type RecommendationsContext = {
  /** The 'app_window_height' field sent in pageview events. */
  appWindowHeight?: InputMaybe<Scalars['Int']>;
  /** The 'app_window_width' field sent in pageview events. */
  appWindowWidth?: InputMaybe<Scalars['Int']>;
  /** The 'client_app' field sent in pageview events. */
  clientApp?: InputMaybe<Scalars['String']>;
  /** Optional ISO country code, defaults to use the country code from the geoip of the request. */
  country?: InputMaybe<Scalars['String']>;
  /** The 'location' field sent in pageview events (signifying the location on the site or app). */
  location?: InputMaybe<Scalars['String']>;
  /** Web, ios, android, etc. */
  platform?: InputMaybe<Scalars['String']>;
  /** The 'referrer_domain' field sent in pageview events. */
  referrerDomain?: InputMaybe<Scalars['String']>;
  /** The 'viewport_height' field sent in pageview events. */
  viewportHeight?: InputMaybe<Scalars['Int']>;
  /** The 'viewport_width' field sent in pageview events. */
  viewportWidth?: InputMaybe<Scalars['Int']>;
};

export type RecommendedFriend = {
  __typename?: 'RecommendedFriend';
  /** Reason why this recommendation was made. */
  reason?: Maybe<Scalars['String']>;
  /** The user recommended to be a friend of the source user. */
  user?: Maybe<User>;
};

/** The response of a recommended games request which contains a list of recommended games. */
export type RecommendedGamesConnection = {
  __typename?: 'RecommendedGamesConnection';
  /** A list of recommended games. */
  edges?: Maybe<Array<RecommendedGamesEdge>>;
  /** Per-generation tracking id for identifying a recommendation model. */
  generationID: Scalars['ID'];
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  pageInfo: PageInfo;
  /** Unique tracking id per response. */
  responseID: Scalars['ID'];
};

/** The content to render from a recommended game. */
export type RecommendedGamesEdge = {
  __typename?: 'RecommendedGamesEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The underlying game content to render. */
  node?: Maybe<Game>;
  /** Globally unique id per category used in client tracking. */
  trackingID: Scalars['ID'];
};

export type RecommendedStream = {
  /** The recommended stream. */
  stream?: Maybe<Stream>;
  /** The type of recommendation. Different types contain different metadata about why the recommendation was made. */
  type?: Maybe<StreamRecommendationType>;
};

/** NOTE: this type will soon be removed. */
export type RecommendedStreamConnection = {
  __typename?: 'RecommendedStreamConnection';
  /**
   * This field is deprecated.
   * @deprecated This field has been sunset
   */
  nodes?: Maybe<Array<Maybe<RecommendedStream>>>;
};

/** The response of a recommended streams request which contains a list of recommended streams. */
export type RecommendedStreamsConnection = {
  __typename?: 'RecommendedStreamsConnection';
  /** A list of recommended streams. */
  edges?: Maybe<Array<RecommendedStreamsEdge>>;
  /** Per-generation tracking id for identifying a recommendation model. */
  generationID: Scalars['ID'];
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  pageInfo: PageInfo;
  /** Unique tracking id per response. */
  responseID: Scalars['ID'];
};

/** The content to render from a recommended stream. */
export type RecommendedStreamsEdge = {
  __typename?: 'RecommendedStreamsEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The underlying stream content to render. */
  node?: Maybe<Stream>;
  /** Globally unique id per stream used in client tracking. */
  trackingID: Scalars['ID'];
};

export type RecommendedVideoConnection = {
  __typename?: 'RecommendedVideoConnection';
  edges?: Maybe<Array<Maybe<RecommendedVideoEdge>>>;
  pageInfo?: Maybe<PageInfo>;
  /** A unique ID for this generated list of recommendations. */
  setID?: Maybe<Scalars['String']>;
};

export type RecommendedVideoEdge = {
  __typename?: 'RecommendedVideoEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<Video>;
};

/** Record ad event error. */
export type RecordAdEventError = {
  __typename?: 'RecordAdEventError';
  /** Error from recording ad event. */
  code: RecordAdEventErrorCode;
};

/** Enumeration of RecordAdEvent error status codes. */
export enum RecordAdEventErrorCode {
  /** The event payload was invalid. */
  InvalidJson = 'INVALID_JSON',
  /** The RAd token in the request was not valid. */
  InvalidToken = 'INVALID_TOKEN',
  /** An internal error has occurred, other than a 500. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The input for recording an ad event. */
export type RecordAdEventInput = {
  /** The ad event name. */
  eventName: Scalars['String'];
  /** Ad details JSON encoded as a string. */
  eventPayload: Scalars['String'];
  /** The RAd service token used for validation. */
  radToken: Scalars['String'];
};

/** The payload returned after recording an ad event. */
export type RecordAdEventPayload = {
  __typename?: 'RecordAdEventPayload';
  /** Error from mutation, if one exists. */
  error?: Maybe<RecordAdEventError>;
};

export type RecurlyConfigs = {
  __typename?: 'RecurlyConfigs';
  /** For interacting with the Braintree gateway and Paypal (supported by Recurly). */
  braintreeClientAuthorization: Scalars['String'];
  /** For interacting with Pay With Amazon gateway (supported by Recurly). */
  payWithAmazonConfigs: PayWithAmazonConfigs;
  /** Sent to Recurly to identify requests. */
  publicKey: Scalars['String'];
};

/**
 * Payment Method information for a recurring payment.
 * An abstraction for a set of Payments models, existing here to surface to the Payments Management Page.
 */
export type RecurringPaymentDetail = {
  __typename?: 'RecurringPaymentDetail';
  /** Time that the payment will attempt to renew. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Product type of the purchase. */
  productType: SubscriptionProductType;
  /** Currency for the renewalPrice, e.g. "USD". */
  renewalCurrency?: Maybe<Scalars['String']>;
  /** Expected renewal price of the product in the smallest subunit of the currency, e.g. "499". */
  renewalPrice?: Maybe<Scalars['Int']>;
  /** Divisor for renewalPrice for display: e.g. "100" for USD. */
  renewalPriceDivisor?: Maybe<Scalars['Int']>;
  /** Subscription benefit, if still active. */
  subscriptionBenefit?: Maybe<SubscriptionBenefit>;
  /** Twitch user ID, owner of the entitlement benefit. */
  ticketOwnerID?: Maybe<Scalars['ID']>;
  /**
   * Twitch user ID, owner of the channel that was subscribed to.
   * Can be null if product type is Turbo.
   */
  ticketProductOwnerID?: Maybe<Scalars['ID']>;
  /** Whether this subscription will renew in the future and charge the user's payment method. */
  willRenew: Scalars['Boolean'];
};

/** Redeem claimable error. */
export type RedeemClaimableError = {
  __typename?: 'RedeemClaimableError';
  /** Error code while redeeming. */
  code: RedeemClaimableErrorCode;
};

/** Redeem claimable error status codes. */
export enum RedeemClaimableErrorCode {
  /** The key has already been claimed. */
  AlreadyClaimed = 'ALREADY_CLAIMED',
  /**
   * PIN already redeemed.
   * Currently only used for Gift Card PINs.
   */
  AlreadyRedeemed = 'ALREADY_REDEEMED',
  /**
   * User excedded redemption velocity limit.
   * Currently only used for Gift Card PINs.
   */
  ExceededVelocityLimit = 'EXCEEDED_VELOCITY_LIMIT',
  /**
   * User can't redeem due to wallet balance limit
   * Currently only used for Gift Card PINs.
   */
  ExceededWalletBalance = 'EXCEEDED_WALLET_BALANCE',
  /**
   * Unsupported Country of Residence
   * Currently only used for Gift Card PINs.
   */
  InvalidCountryOfResidence = 'INVALID_COUNTRY_OF_RESIDENCE',
  /**
   * Invalid PIN/Claimable.
   * Currently only used for Gift Card PINs.
   */
  InvalidPin = 'INVALID_PIN',
  /** The request has been throttled. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /**
   * Two Factor Auth is required past a certain balance
   * for fraud mitigation. Currently only used for Gift Card PINs.
   */
  TwoFactorRequired = 'TWO_FACTOR_REQUIRED',
  /** The user is not allowed to redeem this key. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error being returned from service. */
  Unknown = 'UNKNOWN'
}

/** The input for claiming a key code. */
export type RedeemClaimableInput = {
  /**
   * Optional param for user's self-declared country of residence.
   * Currently only used for Gift Card Redemptions.
   */
  countryOfResidence?: InputMaybe<Scalars['String']>;
  /** The key code that needs to be claimed. */
  keyCode: Scalars['String'];
};

/** The payload returned after claiming a key code. */
export type RedeemClaimablePayload = {
  __typename?: 'RedeemClaimablePayload';
  /** Possible errors returned from the service for this mutation. */
  error?: Maybe<RedeemClaimableError>;
  /** The updated key information. */
  key?: Maybe<Claimable>;
};

/** An error from redeeming a custom Community Points reward in a channel. */
export type RedeemCommunityPointsCustomRewardError = {
  __typename?: 'RedeemCommunityPointsCustomRewardError';
  /** An identifier for the error that occurred. */
  code?: Maybe<RedeemCommunityPointsCustomRewardErrorCode>;
};

/** The possible reasons redeeming a custom Community Points reward in a channel could fail. */
export enum RedeemCommunityPointsCustomRewardErrorCode {
  /** The redemption message contained a blocked phrase. */
  ChannelSettings = 'CHANNEL_SETTINGS',
  /** The reward is disabled. */
  Disabled = 'DISABLED',
  /** The client is retrying a redemption with a transaction id that has already been redeemed. */
  DuplicateTransaction = 'DUPLICATE_TRANSACTION',
  /** The current user is not allowed to redeem this reward in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The reward is currently under a cooldown. */
  GlobalCooldown = 'GLOBAL_COOLDOWN',
  /** The reward has hit its maximum number of redemptions per stream. */
  MaxPerStream = 'MAX_PER_STREAM',
  /** The reward has hit its maximum number of redempetions per user per stream. */
  MaxPerUserPerStream = 'MAX_PER_USER_PER_STREAM',
  /** The redemption message starts with a '/' like a chat command. */
  MessageIsCommand = 'MESSAGE_IS_COMMAND',
  /** The user does not have sufficient points to redeem the reward. */
  NotEnoughPoints = 'NOT_ENOUGH_POINTS',
  /** The reward was not found. */
  NotFound = 'NOT_FOUND',
  /** The client-provided properties (title, cost, or prompt) did not match the reward's true properties. */
  PropertiesMismatch = 'PROPERTIES_MISMATCH',
  /** The stream is not live. */
  StreamNotLive = 'STREAM_NOT_LIVE',
  /** The client is retrying a redemption with a transaction id that is currently being redeemed in another request. */
  TransactionInProgress = 'TRANSACTION_IN_PROGRESS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** The user is banned and cannot redeem rewards. */
  UserBanned = 'USER_BANNED'
}

/** Input for redeeming a custom Community Points reward in a channel. */
export type RedeemCommunityPointsCustomRewardInput = {
  /** The channel ID that the reward is being redeemed in. */
  channelID: Scalars['ID'];
  /**
   * The cost that the client expects this reward to cost.
   * If this cost is different from the reward's true cost, the request will fail.
   */
  cost: Scalars['Int'];
  /**
   * The prompt that the client expects this reward to have.
   * If this prompt is different from the reward's true prompt, the request will fail.
   * Should be null if the reward does not have a prompt.
   */
  prompt?: InputMaybe<Scalars['String']>;
  /** The unique reward ID. */
  rewardID: Scalars['ID'];
  /**
   * For rewards that require text input, this is the user-supplied text.
   * Discarded if the reward does not require text input.
   */
  textInput?: InputMaybe<Scalars['String']>;
  /**
   * The title that the client expects this reward to have.
   * If this title is different from the reward's true title, the request will fail.
   */
  title: Scalars['String'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming a custom Community Points reward in a channel. */
export type RedeemCommunityPointsCustomRewardPayload = {
  __typename?: 'RedeemCommunityPointsCustomRewardPayload';
  /** An error that occurred while redeeming a custom Community Points reward in a channel. */
  error?: Maybe<RedeemCommunityPointsCustomRewardError>;
  /** The newly created redemption. */
  redemption?: Maybe<CommunityPointsCustomRewardRedemption>;
};

/** RedeeemCreatorGiftsInput the input for redeeming subscriptions from a creator's balance. */
export type RedeemCreatorGiftsInput = {
  /**
   * The amount of balance to redeem. This value must be greater than 0 and less than the creator's
   * standing balance.
   */
  amount: Scalars['Int'];
};

/** RedeemCreatorGiftsPayload the output of redeeming subscriptions from a creator's balance. */
export type RedeemCreatorGiftsPayload = {
  __typename?: 'RedeemCreatorGiftsPayload';
  /** The container for creator gifts the creator has. */
  creatorGifting?: Maybe<CreatorGifting>;
};

export type RedeemRitualTokenError = {
  __typename?: 'RedeemRitualTokenError';
  code: RedeemRitualTokenErrorCode;
};

export enum RedeemRitualTokenErrorCode {
  /** User is not a follower and tried redeeming the token in a follower-only chat. */
  FollowerOnlyModeEnforcementFailed = 'FOLLOWER_ONLY_MODE_ENFORCEMENT_FAILED',
  /** User is not a subscriber and tried redeeming the token in a subs-only chat. */
  SubOnlyModeEnforcementFailed = 'SUB_ONLY_MODE_ENFORCEMENT_FAILED',
  /** Token is not in a status that can be redeemed. */
  TokenNotAvailable = 'TOKEN_NOT_AVAILABLE',
  /** Token does not exist. */
  TokenNotFound = 'TOKEN_NOT_FOUND',
  /** User is banned in the channel. */
  UserChatBanned = 'USER_CHAT_BANNED',
  /** User is timed out in the channel. */
  UserChatTimedOut = 'USER_CHAT_TIMED_OUT'
}

/** RedeemRitualTokenInput is the input when redeeming a ritual token. */
export type RedeemRitualTokenInput = {
  /** The channel to redeem the token in. */
  channelID: Scalars['ID'];
  /** User-specified text to send with the token redemption. */
  messageText?: InputMaybe<Scalars['String']>;
  /** The type of ritual to be redeemed. */
  type: RitualTokenType;
};

/** RedeemRitualTokenPayload is the response when redeeming a ritual token. */
export type RedeemRitualTokenPayload = {
  __typename?: 'RedeemRitualTokenPayload';
  error?: Maybe<RedeemRitualTokenError>;
  token?: Maybe<RitualToken>;
};

/** RedeemSubscriptionInput creates a new subscription redemption input. */
export type RedeemSubscriptionInput = {
  /** The channelID to which the user is currently subscribed to and is allowing to redeem a subscription. */
  fromChannelID: Scalars['ID'];
  /** The channelID to which the user wants to redeem their subscription to. */
  targetChannelID: Scalars['ID'];
  /** The User who is trying to redeem the subscription. */
  userID: Scalars['ID'];
};

/** RedeemSubscriptionPayload returns a status code indicating whether the update was successful or not. */
export type RedeemSubscriptionPayload = {
  __typename?: 'RedeemSubscriptionPayload';
  /** A code indicating why the redemption of subscription failed, if it did. */
  errorCode?: Maybe<RedeemSubscriptionResponseErrorCode>;
  /** The Subscription Product that the user has been entitled to. */
  product?: Maybe<SubscriptionProduct>;
};

/** An Error indicating why the submit failed, if it did. */
export enum RedeemSubscriptionResponseErrorCode {
  /** The channel the user is trying to redeem from has not been off-boarded. */
  ChannelNotOffBoarded = 'CHANNEL_NOT_OFF_BOARDED',
  /** The Channel ID is invalid. */
  InvalidChannel = 'INVALID_CHANNEL',
  /** The User is not Eligible to Redeem Subscription to this Channel. */
  NotEligible = 'NOT_ELIGIBLE',
  /** The target Channel the user is trying to redeem to is Invalid. */
  RedeemChannelInvalid = 'REDEEM_CHANNEL_INVALID',
  /** Something unexpected occured when Redeeming the Subscription. */
  Unknown = 'UNKNOWN',
  /** The user already has an existing subscription to the target channel they are trying to redeem to. */
  UserHasExistingSubscription = 'USER_HAS_EXISTING_SUBSCRIPTION',
  /** The User has already redeemed the subscription offerd by the channel. */
  UserHasRedeemedSubscription = 'USER_HAS_REDEEMED_SUBSCRIPTION',
  /** The user is not subscribed to the channel that is being off-boarded. */
  UserNotSubscribedToOffBoardedChannel = 'USER_NOT_SUBSCRIBED_TO_OFF_BOARDED_CHANNEL'
}

export type RedeemTrueXAdInput = {
  /** args are parameters describing the engagement the user just completed for bits. */
  args: Scalars['String'];
  /** signature is a digital signature protecting the integrity of `args`. */
  signature: Scalars['String'];
  /** targetID is the `User.id` of the channel where the user is watching the ad. */
  targetID?: InputMaybe<Scalars['ID']>;
  /**
   * trueXAd is descriptive information about the engagement that was just shown.
   * This information is useful for logging errors on the server-side.
   */
  trueXAd?: InputMaybe<TrueXAd>;
};

export type RedeemTrueXAdPayload = {
  __typename?: 'RedeemTrueXAdPayload';
  /** currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent. */
  currentUser?: Maybe<User>;
  /** grantedBits is the number of bits the user earned from this engagement. */
  grantedBits: Scalars['Int'];
};

/** How to group the referral sources. */
export enum ReferralsDimension {
  /** Return referrals grouped by channel. */
  Channel = 'CHANNEL',
  /** Return referrals grouped by country. */
  Country = 'COUNTRY',
  /** Return referrals grouped by external source. */
  External = 'EXTERNAL',
  /** Return referrals grouped by internal source. */
  Internal = 'INTERNAL',
  /** Return referrals grouped by platforms. */
  Platform = 'PLATFORM'
}

/** Which subset of referrals to return. */
export enum ReferralsFilter {
  /** Return all referral sources. */
  All = 'ALL',
  /** Return live video play referrals from external sources, filtered by the web platform. */
  ExternalLiveWeb = 'EXTERNAL_LIVE_WEB',
  /** Return live video play referrals from internal channels, filtered by the web platform. */
  InternalChannelLiveWeb = 'INTERNAL_CHANNEL_LIVE_WEB',
  /** Return live video play referrals from internal sources, filtered by the web platform. */
  InternalLiveWeb = 'INTERNAL_LIVE_WEB'
}

/** The required input for an RefreshExtensionToken mutation. */
export type RefreshExtensionTokenInput = {
  /** The id of the channel the extension is currently installed on. */
  channelID: Scalars['ID'];
  /** The ID of the extension that the user is refreshing their token for. */
  extensionID: Scalars['ID'];
  /** The current extension jwt being refreshed. */
  jwt?: InputMaybe<Scalars['String']>;
};

/** The result of a RefreshExtensionToken mutation. */
export type RefreshExtensionTokenPayload = {
  __typename?: 'RefreshExtensionTokenPayload';
  /** Error from an RefreshExtensionToken Call. */
  error?: Maybe<Scalars['String']>;
  /** The user's new token. */
  token?: Maybe<ExtensionToken>;
};

/** RegenerateStreamKeyInput is input required to regenerate a broadcaster's stream key. */
export type RegenerateStreamKeyInput = {
  /** channelID of the broadcaster. */
  channelID: Scalars['ID'];
};

/** RegenerateStreamKeyPayload contains the VideoStreamSettings with updated stream key. */
export type RegenerateStreamKeyPayload = {
  __typename?: 'RegenerateStreamKeyPayload';
  /** The updated video stream for channel. */
  channel?: Maybe<Channel>;
};

/** RegenerateVerificationCodeInput is input required to regenerate a user's verification code in EVS. */
export type RegenerateVerificationCodeInput = {
  /** Address that the user is verifying. This will most likely be an email address or phone number. */
  address: Scalars['String'];
  /** Key for the entity associated with the address. This is generally the Twitch ID of the user. */
  key: Scalars['String'];
};

/** RegenerateVerificationCodePayload is the VerificationRequest document returned from EVS on success. */
export type RegenerateVerificationCodePayload = {
  __typename?: 'RegenerateVerificationCodePayload';
  /** The updated verification request. */
  request?: Maybe<VerificationRequest>;
};

/** RegisterPayoutInformationError describes the error that occured when registering a user's payout information during payout onboarding. */
export type RegisterPayoutInformationError = {
  __typename?: 'RegisterPayoutInformationError';
  /** Code to describe error that occurred while registering payout information. */
  code: RegisterPayoutInformationErrorCode;
  /** Lists any field names that have an invalid format. */
  invalidFields?: Maybe<Array<RegisterPayoutInformationFieldName>>;
};

/** Enumerates possible errors when registering payout information. */
export enum RegisterPayoutInformationErrorCode {
  /** User does not have permission to register payout information for the targeted user. */
  Forbidden = 'FORBIDDEN',
  /** An internal error has occurred. */
  InternalError = 'INTERNAL_ERROR',
  /** One or more fields have an invalid format. */
  InvalidFormat = 'INVALID_FORMAT',
  /** Must have auth credentials to register payout information. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** Enumerates vaid field names when registering payout information. */
export enum RegisterPayoutInformationFieldName {
  /** Assigned if Birthdate is given in invalid format. */
  Birthdate = 'BIRTHDATE',
  /** Assigned if City is given in invalid format. */
  City = 'CITY',
  /** Assigned if Company Name is given in invalid format. */
  CompanyName = 'COMPANY_NAME',
  /** Assigned if Country Code is given in invalid format. */
  CountryCode = 'COUNTRY_CODE',
  /** Assigned if Email is given in invalid format. */
  Email = 'EMAIL',
  /** Assigned if First Name is given in invalid format. */
  FirstName = 'FIRST_NAME',
  /** Assigned if Last Name is given in invalid format. */
  LastName = 'LAST_NAME',
  /** Assigned if Middle Name is given in invalid format. */
  MiddleName = 'MIDDLE_NAME',
  /** Assigned if Parent Email is given in invalid format. */
  ParentEmail = 'PARENT_EMAIL',
  /** Assigned if Parent Name is given in invalid format. */
  ParentName = 'PARENT_NAME',
  /** Assigned if Postal is given in invalid format. */
  Postal = 'POSTAL',
  /** Assigned if State Code is given in invalid format. */
  StateCode = 'STATE_CODE',
  /** Assigned if Primary Address is given in invalid format. */
  StreetAddress = 'STREET_ADDRESS',
  /** Assigned if Secondary Address is given in invalid format. */
  StreetAddress_2 = 'STREET_ADDRESS_2'
}

/** RegisterPayoutInformationInput is the input required to register a user's payout information during payout onboarding. */
export type RegisterPayoutInformationInput = {
  /** Birthdate submitted by the user while registering into a payout program. */
  birthdate: Scalars['Time'];
  /** City submitted by the user while registering into a payout program. */
  city: Scalars['String'];
  /** Company Name submitted by the user while registering into a payout program. */
  companyName?: InputMaybe<Scalars['String']>;
  /** Country Code (ISO-3166) submitted by the user while registering into a payout program. */
  countryCode: Scalars['String'];
  /** Email submitted by the user while registering into a payout program. */
  email: Scalars['String'];
  /** First Name submitted by the user while registering into a payout program. */
  firstName: Scalars['String'];
  /** Last Name submitted by the user while registering into a payout program. */
  lastName: Scalars['String'];
  /** Middle Name submitted by the user while registering into a payout program. */
  middleName?: InputMaybe<Scalars['String']>;
  /** Parent Email submitted by the under age user while registering into a payout program. */
  parentEmail?: InputMaybe<Scalars['String']>;
  /** Parent Name submitted by the under age user while registering into a payout program. */
  parentName?: InputMaybe<Scalars['String']>;
  /** Postal submitted by the user while registering into a payout program. */
  postal?: InputMaybe<Scalars['String']>;
  /** State Code submitted by the user while registering into a payout program. */
  stateCode?: InputMaybe<Scalars['String']>;
  /** Primary Address submitted by the user while registering into a payout program. */
  streetAddress: Scalars['String'];
  /** Secondary Address submitted by the user while registering into a payout program. */
  streetAddress2?: InputMaybe<Scalars['String']>;
  /** TargetUserID is the ID of the user whose payout information will be registered. */
  targetUserID: Scalars['ID'];
};

/** RegisterPayoutInformationPayload is the updated workflow after registration is accepted. */
export type RegisterPayoutInformationPayload = {
  __typename?: 'RegisterPayoutInformationPayload';
  /** Describes error that occured when registering payout information. */
  error?: Maybe<RegisterPayoutInformationError>;
  /** New workflow state. */
  workflow?: Maybe<PayoutOnboardingWorkflow>;
};

/** Error returned during a invalid user request. */
export type RegisterTwoFactorConfirmationError = {
  __typename?: 'RegisterTwoFactorConfirmationError';
  /** Error code returned by the backend. */
  code: RegisterTwoFactorConfirmationErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to confirm registeration for two factor authentication. */
export enum RegisterTwoFactorConfirmationErrorCode {
  /** The user does not have a verified email. */
  EmailNotVerified = 'EMAIL_NOT_VERIFIED',
  /** The one time password provided is invalid. */
  InvalidOtp = 'INVALID_OTP',
  /** The phone number provided is used for too many Twitch accounts. */
  LimitReached = 'LIMIT_REACHED',
  /** The one time password provided is missing. */
  MissingOtp = 'MISSING_OTP',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** The user cannot confirm two factor registration since the initial registration was never started or has expired. */
  RegistrationNotStarted = 'REGISTRATION_NOT_STARTED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a registerTwoFactorConfirmation mutation. */
export type RegisterTwoFactorConfirmationInput = {
  /** The one time password required to complete two factor registration. */
  oneTimePassword: Scalars['String'];
  /** The ID of the user that is requesting to complete registration of two factor authentication. */
  userID: Scalars['ID'];
};

/** The result of a registerTwoFactorConfirmationPayload mutation. */
export type RegisterTwoFactorConfirmationPayload = {
  __typename?: 'RegisterTwoFactorConfirmationPayload';
  /** New access token returned for clients to use after turning on 2FA. */
  accessToken?: Maybe<Scalars['String']>;
  /** error code and localized error. */
  error?: Maybe<RegisterTwoFactorConfirmationError>;
};

/** Error returned during a invalid user request. */
export type RegisterTwoFactorError = {
  __typename?: 'RegisterTwoFactorError';
  /** Error code returned by the backend. */
  code: RegisterTwoFactorErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to register for two factor authentication. */
export enum RegisterTwoFactorErrorCode {
  /** The user does not have a verified email. */
  EmailNotVerified = 'EMAIL_NOT_VERIFIED',
  /** Phone number was not valid. */
  InvalidPhoneNumber = 'INVALID_PHONE_NUMBER',
  /** Phone number was not provided. */
  MissingPhoneNumber = 'MISSING_PHONE_NUMBER',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** The user has requested to register for two factor authentication too many times. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a registerTwoFactor mutation. */
export type RegisterTwoFactorInput = {
  /** The phone number used for two factor registration. */
  phoneNumber: Scalars['String'];
  /** The ID of the user that is requesting to register for two factor authentication. */
  userID: Scalars['ID'];
};

/** The result of a registerTwoFactorPayload mutation. */
export type RegisterTwoFactorPayload = {
  __typename?: 'RegisterTwoFactorPayload';
  /** error code and localized error. */
  error?: Maybe<RegisterTwoFactorError>;
};

/** The registration type signifies the policy for participants to join the competition. */
export enum RegistrationType {
  /** Open competition where only followers of the channel can join. */
  Followers = 'FOLLOWERS',
  /** Open competition where only followers and subscribers of the channel can join. */
  FollowerAndSubscribers = 'FOLLOWER_AND_SUBSCRIBERS',
  /** Competition that only invited participants can join. */
  Invitational = 'INVITATIONAL',
  /** Competition that any Twitch user can join. */
  Open = 'OPEN',
  /** Open competition where only subscribers of the channel can join. */
  Subscribers = 'SUBSCRIBERS',
  /** Unknown type. */
  Unknown = 'UNKNOWN'
}

export type RejectFriendRequestInput = {
  /** The authenticated user will reject the friend request sent by the user with an ID equal to targetID. */
  targetID: Scalars['ID'];
};

export type RejectFriendRequestPayload = {
  __typename?: 'RejectFriendRequestPayload';
  /** The user whose friend request was just rejected. */
  user?: Maybe<User>;
};

/** Errors from rejectSquadStreamInvitation mutation. */
export type RejectSquadStreamInvitationError = {
  __typename?: 'RejectSquadStreamInvitationError';
  /** Error from request to reject invitation. */
  code: RejectSquadStreamInvitationErrorCode;
};

/** Possible errors from this mutation. */
export enum RejectSquadStreamInvitationErrorCode {
  /** Invitation not in pending state cannot be rejected. */
  InvitationCannotBeRejected = 'INVITATION_CANNOT_BE_REJECTED',
  /** Invitation to be rejected does not exist. */
  InvitationNotFound = 'INVITATION_NOT_FOUND',
  /** Squad associated with the invitation does not exist. */
  SquadNotFound = 'SQUAD_NOT_FOUND',
  /** User does not have permissions to reject invitation. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Inputs to the rejectSquadStreamInvitation mutation. */
export type RejectSquadStreamInvitationInput = {
  /** ID of the invitation to be rejected. */
  invitationID: Scalars['ID'];
};

/** Outputs from the rejectSquadStreamInvitation mutation. */
export type RejectSquadStreamInvitationPayload = {
  __typename?: 'RejectSquadStreamInvitationPayload';
  /** Error from mutation if exists. */
  error?: Maybe<RejectSquadStreamInvitationError>;
  /** The rejected invitation. */
  invitation?: Maybe<SquadStreamInvitation>;
};

/** RejectSquadStreamOutOfNetworkInvitationsError is the error associated with a rejectSquadStreamOutOfNetworkInvitations. */
export type RejectSquadStreamOutOfNetworkInvitationsError = {
  __typename?: 'RejectSquadStreamOutOfNetworkInvitationsError';
  /** The associated error code. */
  code: RejectSquadStreamOutOfNetworkInvitationsErrorCode;
};

/** RejectSquadStreamOutOfNetworkInvitationsErrorCode are the possible errors that this mutation returns. */
export enum RejectSquadStreamOutOfNetworkInvitationsErrorCode {
  /** The user is not authorized to reject invitations on behalf of the recipient. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Inputs to the rejectSquadStreamOutOfNetworkInvitations mutation. */
export type RejectSquadStreamOutOfNetworkInvitationsInput = {
  /** ID of the user whose out of network invitations will be rejected. */
  recipientID: Scalars['ID'];
};

/** Outputs from the rejectSquadStreamOutOfNetworkInvitations mutation. */
export type RejectSquadStreamOutOfNetworkInvitationsPayload = {
  __typename?: 'RejectSquadStreamOutOfNetworkInvitationsPayload';
  /** The possible error returned from the service. */
  error?: Maybe<RejectSquadStreamOutOfNetworkInvitationsError>;
};

export type RejectedChatMessage = {
  __typename?: 'RejectedChatMessage';
  /** Original message's raw body. */
  body?: Maybe<Scalars['String']>;
  /** Optional list of fragments from the messages's body that lead to the message rejection. */
  failedFragments?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The ID of the message. */
  id?: Maybe<Scalars['ID']>;
  /**
   * Specifies if a action by a moderator has been taken on the message.
   * @deprecated Use status field instead
   */
  isResolved?: Maybe<Scalars['Boolean']>;
  /** The extracted caught message. */
  message?: Maybe<Message>;
  /** The user that created the message. */
  sender?: Maybe<User>;
  /** Status of the message. */
  status: CaughtMessageStatus;
  /** The channel where the message was originally sent. */
  target?: Maybe<User>;
};

/** RemoveAutohostChannelsInput remove channelIDs from a user's list to autohost. */
export type RemoveAutohostChannelsInput = {
  /** ChannelIDs that will be removed from the list to autohost. */
  channelIDs: Array<Scalars['ID']>;
  /** UserID to update autohost list for. */
  userID: Scalars['ID'];
};

/** RemoveAutohostChannelsPayload returns the user whose autohostChannels field had been updated. */
export type RemoveAutohostChannelsPayload = {
  __typename?: 'RemoveAutohostChannelsPayload';
  /** User whose autohostChannels field had been updated. */
  user?: Maybe<User>;
};

/** RemoveCollectionItemInput accepts a collectionID and item ID and parameters to remove the item from a collection. */
export type RemoveCollectionItemInput = {
  /** The id of the collection. */
  collectionID: Scalars['ID'];
  /** The id of the item of which will be added to the collection. */
  itemID: Scalars['ID'];
  /** The type of item ie. video. */
  itemType: Scalars['String'];
};

/** The response from removing an item from a collection. */
export type RemoveCollectionItemPayload = {
  __typename?: 'RemoveCollectionItemPayload';
  /** The newly updated collection. */
  collection?: Maybe<Collection>;
};

/** RemoveCompetitionPhaseInput contains the inputs required to remove a phase. */
export type RemoveCompetitionPhaseInput = {
  /** The competition id of the competition. */
  competitionID: Scalars['ID'];
  /** The id of the competition phase. */
  phaseID: Scalars['ID'];
};

/** RemoveCompetitionPhasePayload is the success response for removing a phase. */
export type RemoveCompetitionPhasePayload = {
  __typename?: 'RemoveCompetitionPhasePayload';
  /** The new state of competition after removing a phase. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Remove a player from a Competition. If you remove a player that is part of a team, the player will removed from the team as well. If that player is a captain of the team, the team will no longer have a captain. */
export type RemoveCompetitionPlayerInput = {
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
  /** Twitch user id of the player. */
  userID: Scalars['ID'];
};

/** Indication that the player was removed. */
export type RemoveCompetitionPlayerPayload = {
  __typename?: 'RemoveCompetitionPlayerPayload';
  /** The new state of competition after removing a competition player from the competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Inputs for removing a competition team from a competition. */
export type RemoveCompetitionTeamInput = {
  /** ID of the competition. */
  competitionID: Scalars['ID'];
  /** ID of the team. */
  teamID: Scalars['ID'];
};

/** RemoveCompetitionTeamPayload is the success response removing a competition team from the competition. */
export type RemoveCompetitionTeamPayload = {
  __typename?: 'RemoveCompetitionTeamPayload';
  /** The new state of competition after removing a competition team from the competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** RemoveEditorError contains details about a client error that occurred. */
export type RemoveEditorError = {
  __typename?: 'RemoveEditorError';
  /** The type of error that occurred when revoking a user's editor status. */
  code: RemoveEditorErrorCode;
};

/** RemoveEditorErrorCode defines a client error that occurred while removing an editor. */
export enum RemoveEditorErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The target user does not exist. */
  TargetUserNotFound = 'TARGET_USER_NOT_FOUND'
}

/** RemoveEditorInput contains the parameters to revoke the editor status from a user for a channel. */
export type RemoveEditorInput = {
  /** The channel from which the editor status of the user will be revoked. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user whose editor status will be revoked.
   * Either targetUserID or targetUserLogin must be provided.
   */
  targetUserID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user whose editor status will be revoked.
   * Either targetUserID or targetUserLogin must be provided.
   */
  targetUserLogin?: InputMaybe<Scalars['String']>;
};

/** RemoveEditorPayload is the response after attempting to revoke the editor status of a user. */
export type RemoveEditorPayload = {
  __typename?: 'RemoveEditorPayload';
  /** The channel for which the editor status of the target user is removed. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<RemoveEditorError>;
  /** The user whose editor status was revoked. */
  targetUser?: Maybe<User>;
};

/** Error returned after attempting to remove an emote from its group. */
export type RemoveEmoteFromGroupError = {
  __typename?: 'RemoveEmoteFromGroupError';
  /** The error code associated with this error. */
  code: RemoveEmoteFromGroupErrorCode;
};

/** Possible error codes for RemoveEmoteFromGroupError. */
export enum RemoveEmoteFromGroupErrorCode {
  /** The specified emote does not exist. */
  EmoteNotFound = 'EMOTE_NOT_FOUND',
  /** The user is not allowed to remove this emote from its group. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** The input for remove emote from group. */
export type RemoveEmoteFromGroupInput = {
  /** ID of the emote to be removed from its group. */
  emoteID: Scalars['ID'];
};

/** Result of remove emote from group. */
export type RemoveEmoteFromGroupPayload = {
  __typename?: 'RemoveEmoteFromGroupPayload';
  /** The updated emote if successful. */
  emote?: Maybe<Emote>;
  /** Error returned after attempting to remove an emote from its group. */
  error?: Maybe<RemoveEmoteFromGroupError>;
};

/** RemoveOrganizationMemberError is the error associated with a RemoveOrganizationMember. */
export type RemoveOrganizationMemberError = {
  __typename?: 'RemoveOrganizationMemberError';
  /** The associated error code. */
  code: RemoveOrganizationMemberErrorCode;
};

/** RemoveOrganizationMemberErrorCode defines a client error that occurred while removing an organization member. */
export enum RemoveOrganizationMemberErrorCode {
  /** Can not remove this user because it is assigned as an extension billing manager. Need to unassign first. */
  AssignedBillingManager = 'ASSIGNED_BILLING_MANAGER',
  /** Deprecated: code not used, a resolver error is returned instead. */
  InternalError = 'INTERNAL_ERROR',
  /** User does not have permission to remove another member. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** The user to be removed does not exist. */
  UserNotFound = 'USER_NOT_FOUND'
}

/** Inputs to the removeOrganizationMember mutation. */
export type RemoveOrganizationMemberInput = {
  /** The ID of the organization. */
  organizationID: Scalars['ID'];
  /** The twitch ID of the organization member. */
  userID: Scalars['ID'];
};

/** Outputs from the removeOrganizationMember mutation. */
export type RemoveOrganizationMemberPayload = {
  __typename?: 'RemoveOrganizationMemberPayload';
  /** The possible error returned from the service. */
  error?: Maybe<RemoveOrganizationMemberError>;
  /** The user who is removed from organization. */
  targetUser?: Maybe<User>;
};

export type RemoveReactionInput = {
  emoteID: Scalars['ID'];
  entityID: Scalars['ID'];
};

export type RemoveReactionPayload = {
  __typename?: 'RemoveReactionPayload';
  content: ReactableContent;
};

/** RemoveSquadStreamMemberError is the error associated with a removeSquadStreamMember. */
export type RemoveSquadStreamMemberError = {
  __typename?: 'RemoveSquadStreamMemberError';
  /** The associated error code. */
  code: RemoveSquadStreamMemberErrorCode;
};

/** RemoveSquadStreamMemberErrorCode are the possible errors that this mutation returns. */
export enum RemoveSquadStreamMemberErrorCode {
  /** The user is not authorized to remove members from the squad. */
  Unauthorized = 'UNAUTHORIZED',
  /** The user to be removed is not in the squad specified. */
  UserNotInSquad = 'USER_NOT_IN_SQUAD'
}

/** Inputs to the removeSquadStreamMember mutation. */
export type RemoveSquadStreamMemberInput = {
  /** The user ID of the member that should be removed from the squad stream. */
  memberUserID: Scalars['ID'];
  /** The ID of the squad stream. */
  squadStreamID: Scalars['ID'];
};

/** Outputs from the removeSquadStreamMember mutation. */
export type RemoveSquadStreamMemberPayload = {
  __typename?: 'RemoveSquadStreamMemberPayload';
  /** The possible error returned from the service. */
  error?: Maybe<RemoveSquadStreamMemberError>;
  /** The updated squad stream. */
  squadStream?: Maybe<SquadStream>;
};

/**
 * Inputs for removing a stucco (from the library).
 * - Active stuccos cannot be removed, they have to be inactive first (not part of a stucco pack).
 */
export type RemoveStuccoInput = {
  /** ID of the channel the stucco is removed from. */
  channelID: Scalars['ID'];
  /** Unique ID of the stucco to be removed. */
  stuccoID: Scalars['ID'];
};

/** The output payload for removing a stucco, returns the library of stuccos after removal. */
export type RemoveStuccoPayload = {
  __typename?: 'RemoveStuccoPayload';
  /** The list of stuccos available in the channel's library after removal. */
  stuccos?: Maybe<Array<Stucco>>;
};

/** RenewalPolicy defines whether the charge model will renew or not. */
export enum RenewalPolicy {
  /** Will renew automatically. */
  AutoRenew = 'AUTO_RENEW',
  /** Will not renew automatically. */
  NoRenew = 'NO_RENEW',
  /** Unknown renewal policy. */
  Unknown = 'UNKNOWN'
}

/** ReorderCollectionItemInput accepts a collectionID and item ID and parameters to update the item order of a collection. */
export type ReorderCollectionItemInput = {
  /** The id of the collection. */
  collectionID: Scalars['ID'];
  /** The id of the item of which will be moved in the collection. */
  itemID: Scalars['ID'];
  /** The type of item ie. video. */
  itemType: Scalars['String'];
  /** The new position of the item. */
  position: Scalars['Int'];
};

/** The response from reordering an item in a collection. */
export type ReorderCollectionItemPayload = {
  __typename?: 'ReorderCollectionItemPayload';
  /** The newly updated collection. */
  collection?: Maybe<Collection>;
};

export type ReportContentInput = {
  /** Content type being reported. */
  content: ReportContentType;
  /** ID of the content being reported. */
  contentID: Scalars['ID'];
  /** The description of the report. */
  description: Scalars['String'];
  /** Extra (content specific) data for the report. */
  extra: Scalars['String'];
  /** Extra arguments required for NetzDG reporting. */
  netzDGArgs?: InputMaybe<ReportContentNetzDgInput>;
  /** The reason ID for the report. */
  reason: Scalars['ID'];
  /** ID of the user being reported. */
  targetID: Scalars['ID'];
  /** The path taken through the report wizard. */
  wizardPath?: InputMaybe<Array<Scalars['String']>>;
};

/** Valid values for ReportContentNetzDGInput.contentDirectedTo. */
export enum ReportContentNetzDgContentDirectedTo {
  /** The reported content is directed at the reporter. */
  Me = 'ME',
  /** The reported content is directed at someone else. */
  SomeoneElse = 'SOMEONE_ELSE',
  /** The reported content is directed at someone the reporter represents. */
  SomeoneIRepresent = 'SOMEONE_I_REPRESENT'
}

/** Extra fields that are required for NetzDG reporting. */
export type ReportContentNetzDgInput = {
  /** Who the reporter thinks the offending content is directed to. */
  contentDirectedTo: ReportContentNetzDgContentDirectedTo;
  /** The email address of the reporter. */
  reporterEmail: Scalars['String'];
  /** Who the reporter is reporting on behalf of. */
  reportingFor: ReportContentNetzDgReportingFor;
};

/** Valid values for ReportContentNetzDGInput.ReportingFor. */
export enum ReportContentNetzDgReportingFor {
  /** The reporter is reporting on behalf of a complaints office. */
  ComplaintsOffice = 'COMPLAINTS_OFFICE',
  /** The report is reporting on behalf of an agency of the german government. */
  GovernmentAgency = 'GOVERNMENT_AGENCY',
  /** The reporter is reporting for themselves. */
  Myself = 'MYSELF'
}

export type ReportContentPayload = {
  __typename?: 'ReportContentPayload';
  /** Content type that was reported. */
  content: ReportContentType;
  /** ID of the content that was reported. */
  contentID: Scalars['ID'];
};

/** Types of content that can be reported. */
export enum ReportContentType {
  /** Report against a channel feed comment. */
  ChannelFeedCommentReport = 'CHANNEL_FEED_COMMENT_REPORT',
  /** Report against a channel feed post. */
  ChannelFeedPostReport = 'CHANNEL_FEED_POST_REPORT',
  /** Report against a channel's channel points. */
  ChannelPointsReport = 'CHANNEL_POINTS_REPORT',
  /** Report against a chat message. */
  ChatReport = 'CHAT_REPORT',
  /** Report against a clip. */
  ClipReport = 'CLIP_REPORT',
  /** (Deprecated) Report against a vod collection. */
  CollectionReport = 'COLLECTION_REPORT',
  /** (Deprecated) Report against a curse private group. */
  CursePrivateGroup = 'CURSE_PRIVATE_GROUP',
  /** (Deprecated) Report against a curse public group. */
  CursePublicGroup = 'CURSE_PUBLIC_GROUP',
  /** (Deprecated) Report against a curse whisper. */
  CurseWhisper = 'CURSE_WHISPER',
  /** Report against an emote. */
  EmoteReport = 'EMOTE_REPORT',
  /** Report against an oracle event. */
  EventReport = 'EVENT_REPORT',
  /** Report against an extension. */
  ExtensionReport = 'EXTENSION_REPORT',
  /** Report against a livestream. */
  LivestreamReport = 'LIVESTREAM_REPORT',
  /** Report against a live up notification. */
  LiveUpReport = 'LIVE_UP_REPORT',
  /** Report against a poll. */
  PollReport = 'POLL_REPORT',
  /** Report against a raid. */
  RaidReport = 'RAID_REPORT',
  /** Report against a reward redemption. */
  RewardRedemptionReport = 'REWARD_REDEMPTION_REPORT',
  /** Report against a chatroom. */
  RoomReport = 'ROOM_REPORT',
  /** Report against sings duet seed. */
  SingsDuetSeedReport = 'SINGS_DUET_SEED_REPORT',
  /** Report against sings group biography. */
  SingsGroupBioReport = 'SINGS_GROUP_BIO_REPORT',
  /** Report against sings group chat. */
  SingsGroupChatReport = 'SINGS_GROUP_CHAT_REPORT',
  /** Report against sings group name. */
  SingsGroupNameReport = 'SINGS_GROUP_NAME_REPORT',
  /** Report against a sings group vod comment. */
  SingsVodCommentReport = 'SINGS_VOD_COMMENT_REPORT',
  /** Report against an unban request. */
  UnbanRequestReport = 'UNBAN_REQUEST_REPORT',
  /** Report against a live user. */
  UserReport = 'USER_REPORT',
  /** Report against a twitch vod comment. */
  VodCommentReport = 'VOD_COMMENT_REPORT',
  /** Report against a twitch vod. */
  VodReport = 'VOD_REPORT',
  /**
   * Report against a whisper. Deprecated in favor of the whisperReport mutation.
   * @deprecated use whisperReport mutation instead.
   */
  WhisperReport = 'WHISPER_REPORT'
}

/** A valid reason for a report. */
export type ReportReason = {
  __typename?: 'ReportReason';
  /** The unique ID of the reason. */
  id: Scalars['ID'];
  /** Whether or not this report reason is in-scope for a country-specific law. */
  isApplicableToCountryRegulations: Scalars['Boolean'];
  /** The displayed text for this reason localized based on Accept-Language. */
  text: Scalars['String'];
};

/** A valid country and ToS reasons for a report. */
export type ReportToSAndCountryReasons = {
  __typename?: 'ReportToSAndCountryReasons';
  /**
   * The countryCode of the country-specific reporting flow that applies to the user.
   * If null then there is no relevant country-specific reporting flow for the user.
   */
  countryCode?: Maybe<Scalars['String']>;
  /**
   * Localized string that should be displayed to the user as a disclosure that their report.
   * Falls under given legislation, and may be viewed by legal authorities.
   */
  disclosureText?: Maybe<Scalars['String']>;
  /** The list of report reasons that apply for the content type. */
  toSAndCountryReasons: Array<ReportReason>;
};

/** Possible error reasons returned by reportWhisper mutation. */
export enum ReportWhisperErrorReason {
  /** Invalid user ID. */
  InvalidUserId = 'INVALID_USER_ID',
  /** There are no whispers from the target user to the reporter. */
  NoWhispersFromTargetUser = 'NO_WHISPERS_FROM_TARGET_USER',
  /** The reporter is currently rate limited. */
  RateLimited = 'RATE_LIMITED',
  /** Unauthorized. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Input to the reportWhisper mutation. */
export type ReportWhisperInput = {
  /** The description of the report. */
  description: Scalars['String'];
  /** The reason option for the report. */
  reason: Scalars['String'];
  /** ID of the user being reported. */
  targetID: Scalars['ID'];
  /** The path taken through the report wizard. */
  wizardPath?: InputMaybe<Array<Scalars['String']>>;
};

/** Payload returned from the reportWhisper mutation. */
export type ReportWhisperPayload = {
  __typename?: 'ReportWhisperPayload';
  /** Reports aren't queryable in GQL, so only an error is returned. */
  error?: Maybe<ReportWhisperPayloadError>;
};

/** Error type that may be returned returned from the reportWhisper mutation. */
export type ReportWhisperPayloadError = {
  __typename?: 'ReportWhisperPayloadError';
  /** Reason that the report wasn't created. */
  reason: ReportWhisperErrorReason;
};

export type ReportWhisperThreadInput = {
  /** Reason why the user is reporting the thread. */
  reason?: InputMaybe<Scalars['String']>;
  /** ID of user being reported. */
  targetUserID: Scalars['ID'];
  /** ID of thread to report. */
  threadID: Scalars['ID'];
};

export type ReportWhisperThreadPayload = {
  __typename?: 'ReportWhisperThreadPayload';
  thread: WhisperThread;
};

/** Metadata about a GraphQL request. */
export type RequestInfo = {
  __typename?: 'RequestInfo';
  /** The country code where the request originated. Defaults to "US" if geoip lookup fails. */
  countryCode: Scalars['String'];
  /** Whether the request came from a country belonging to the European Union. */
  fromEU: Scalars['Boolean'];
  /** The IP address where the request originated. */
  ipAddress?: Maybe<Scalars['String']>;
  /** Whether the request came from a country belonging to the European Economic Area. */
  isFromEEA: Scalars['Boolean'];
};

export type RequestRitualTokenError = {
  __typename?: 'RequestRitualTokenError';
  code: RequestRitualTokenErrorCode;
};

export enum RequestRitualTokenErrorCode {
  /** Token is not in a status that can be requested. */
  TokenNotAvailable = 'TOKEN_NOT_AVAILABLE',
  /** Token does not exist. */
  TokenNotFound = 'TOKEN_NOT_FOUND'
}

/** RequestRitualTokenInput is the input when requesting a ritual token. */
export type RequestRitualTokenInput = {
  /** The channel to request a ritual token in. */
  channelID: Scalars['ID'];
  /** The type of ritual token to request. */
  type: RitualTokenType;
};

/** RequestRitualTokenPayload is the response when requesting a ritual token. */
export type RequestRitualTokenPayload = {
  __typename?: 'RequestRitualTokenPayload';
  error?: Maybe<RequestRitualTokenError>;
  token?: Maybe<RitualToken>;
};

/** ResendVerificationEmailInput is input required to resend the verification email. */
export type ResendVerificationEmailInput = {
  /** ID of the user to resend a verification email to. */
  userID: Scalars['ID'];
};

/** ResendVerificationEmailPayload is the output after resending a verification email. */
export type ResendVerificationEmailPayload = {
  __typename?: 'ResendVerificationEmailPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** Error returned during an invalid username reset request. */
export type ResetUsernameCodeError = {
  __typename?: 'ResetUsernameCodeError';
  /** Error code returned by the backend. */
  code: ResetUsernameErrorCode;
};

/** Possible error codes returned from a username reset. */
export enum ResetUsernameErrorCode {
  /** Login contains characters that are not allowed. */
  LoginContainsInvalidCharacters = 'LOGIN_CONTAINS_INVALID_CHARACTERS',
  /** Login is too long. */
  LoginTooLong = 'LOGIN_TOO_LONG',
  /** Login is too short. */
  LoginTooShort = 'LOGIN_TOO_SHORT',
  /** Login is not available. */
  LoginUnavailable = 'LOGIN_UNAVAILABLE',
  /** Too many attempts to update login. */
  RequestsThrottled = 'REQUESTS_THROTTLED',
  /** Authorization token is not valid. */
  TokenInvalid = 'TOKEN_INVALID',
  /** Unrecognized error returned from the backend service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Input for a username reset. */
export type ResetUsernameInput = {
  /** The new login for the user. */
  login: Scalars['String'];
  /** The authorization token for the username reset. */
  resetUsernameToken: Scalars['String'];
};

/** The result of a username reset. */
export type ResetUsernamePayload = {
  __typename?: 'ResetUsernamePayload';
  /** Error code for error from returned the username reset. */
  error?: Maybe<ResetUsernameCodeError>;
  /** The modified username for the user. */
  login?: Maybe<Scalars['String']>;
};

/** An error returned from the resolvePredictionEvent mutation. */
export type ResolvePredictionEventError = {
  __typename?: 'ResolvePredictionEventError';
  /** Code describing the error. */
  code: ResolvePredictionEventErrorCode;
};

/** Possible error codes from the resolvePredictionEvent mutation. */
export enum ResolvePredictionEventErrorCode {
  /** This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken. */
  EventEnded = 'EVENT_ENDED',
  /** The current user is forbidden from resolving this Prediction Event. */
  Forbidden = 'FORBIDDEN',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input for resolving a Prediction Event (and paying out all of the users who predicted correctly). */
export type ResolvePredictionEventInput = {
  /** The unique identifier of the Prediction Event to resolve. */
  eventID: Scalars['ID'];
  /** The unique identifier of the Prediction Outcome to select as the winner. */
  outcomeID: Scalars['ID'];
};

/** Payload for resolving a prediciton event. */
export type ResolvePredictionEventPayload = {
  __typename?: 'ResolvePredictionEventPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<ResolvePredictionEventError>;
  /** The resolved Prediction Event. */
  predictionEvent?: Maybe<PredictionEvent>;
};

/** A restriction for a specific resource. */
export type ResourceRestriction = {
  __typename?: 'ResourceRestriction';
  /** The list of exemptions for a given resource restriction. */
  exemptions?: Maybe<Array<ResourceRestrictionExemption>>;
  /** The restriction's unique identifier. */
  id: Scalars['ID'];
  /** The list of options that were applied at time of creation for a given resource restriction. */
  options: Array<ResourceRestrictionOption>;
  /** The type of restriction on this resource. */
  type: ResourceRestrictionType;
};

/** Exemption information for a specific resource restriction. */
export type ResourceRestrictionExemption = {
  __typename?: 'ResourceRestrictionExemption';
  /** The list of description data a user make take to become exempt for the given restriction. */
  actions?: Maybe<Array<ResourceRestrictionExemptionAction>>;
  /** The time that the restriction is no longer active. */
  endsAt?: Maybe<Scalars['Time']>;
  /** The keys needed for a given restriction. */
  keys?: Maybe<Array<Scalars['String']>>;
  /** The time that the restriction becomes active. */
  startsAt?: Maybe<Scalars['Time']>;
  /** The type of exemption. */
  type: ResourceRestrictionExemptionType;
};

/** Description data for clients to get for user actions to get exempt. */
export type ResourceRestrictionExemptionAction = {
  __typename?: 'ResourceRestrictionExemptionAction';
  /** Name of the action need. e.g. Ticket Product short name. */
  name: Scalars['String'];
  /** The human readable title of the restriction. */
  title: Scalars['String'];
};

/** An enumeration of the different exemption types. */
export enum ResourceRestrictionExemptionType {
  /** The restriction is exempt for all users. */
  All = 'ALL',
  /** The restriction is exempt for channel moderators. */
  ChannelModerator = 'CHANNEL_MODERATOR',
  /** The restriction is exempt for channel VIPs. */
  ChannelVip = 'CHANNEL_VIP',
  /** The restriction is exempt for viewers that are in the same org as the channel owner. */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** The restriction is exempt for the preview duration. */
  Preview = 'PREVIEW',
  /** The restriction is exempt for owning a product. */
  Product = 'PRODUCT',
  /** The restriction is exempt for site admins. */
  SiteAdmin = 'SITE_ADMIN',
  /** The restriction is exempt for staff accounts. */
  Staff = 'STAFF',
  /** The restriction is exempt for an unknown reason. */
  Unknown = 'UNKNOWN'
}

/** An enumeration of the different restriction options. */
export enum ResourceRestrictionOption {
  /** Allows users with any tier subscriptions to access the resource. */
  AllowAllTiers = 'ALLOW_ALL_TIERS',
  /** Allows users holding the channel moderator role to access the resource. */
  AllowChannelModerator = 'ALLOW_CHANNEL_MODERATOR',
  /** Allows users holding the channel VIP role to access the resource. */
  AllowChannelVip = 'ALLOW_CHANNEL_VIP',
  /** Allows only users with tier 2 and 3 subscriptions to access the resource. */
  AllowTier_2And_3Only = 'ALLOW_TIER_2_AND_3_ONLY',
  /** Allows only users with tier 3 subscriptions to access the resource. */
  AllowTier_3Only = 'ALLOW_TIER_3_ONLY'
}

/** An enumeration of the different restriction types. */
export enum ResourceRestrictionType {
  /** The resource is restricted by the All-Access Pass. */
  AllAccessPass = 'ALL_ACCESS_PASS',
  /** The resource is restricted by the organization membership logic in RBAC. */
  OrganizationAccessOnly = 'ORGANIZATION_ACCESS_ONLY',
  /** The resource is restricted by a subscription. */
  SubOnlyLive = 'SUB_ONLY_LIVE',
  /** The resource is restricted for an unknown reason. */
  Unknown = 'UNKNOWN'
}

/** Inputs to the respondToTeamInvitation mutation. */
export type RespondToTeamInvitationInput = {
  /** Whether the user accepts or declines the team invite. */
  accepted: Scalars['Boolean'];
  /** The team whose invite the user will be responding to. */
  teamID: Scalars['ID'];
  /** The authenticated user who will respond to the team invitation with an ID equal to userID. */
  userID: Scalars['ID'];
};

/** Outputs from the respondToTeamInvitation mutation. */
export type RespondToTeamInvitationPayload = {
  __typename?: 'RespondToTeamInvitationPayload';
  /** The user who just accepted a team invitation. */
  user?: Maybe<User>;
};

/** An enumeration of the different restriction types. */
export enum RestrictionResource {
  /** For live video content. */
  Live = 'LIVE',
  /** For non-live video content, e.g. VODs. */
  Video = 'VIDEO'
}

/** A recent resub token to use for sending a special message. */
export type ResubNotification = {
  __typename?: 'ResubNotification';
  /** The number of months of total subbing. */
  cumulativeTenureMonths: Scalars['Int'];
  /** Gifter who gave the gift, null if no gifter or anon */
  gifter?: Maybe<User>;
  /** A unique ID for the resub notification. */
  id: Scalars['ID'];
  /** If the resub notification is caused by a gift or not */
  isGiftSubscription: Scalars['Boolean'];
  /** The number of months of consecutive subbing. */
  months: Scalars['Int'];
  /** The number of months of consecutive subbing. */
  streakTenureMonths: Scalars['Int'];
  /** The token to use when submitting a sub/resub message. */
  token: Scalars['String'];
};

/** The possible erors when resuming a schedule. */
export enum ResumeScheduleError {
  /** The schedule was not found. */
  NotFound = 'NOT_FOUND',
  /** Not authorized to resume this schedule. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** The input to resume a schedule. */
export type ResumeScheduleInput = {
  /** The id of the schedule. */
  scheduleID: Scalars['ID'];
};

/** The returned payload when resuming a schedule. */
export type ResumeSchedulePayload = {
  __typename?: 'ResumeSchedulePayload';
  /** The possible error. */
  error?: Maybe<ResumeScheduleError>;
  /** The updated schedule input. */
  schedule?: Maybe<Schedule>;
};

/** Revenue configuration data related to a subscription product. */
export type RevenueConfig = {
  __typename?: 'RevenueConfig';
  /** Unique identifier for the revenue configuration. */
  id: Scalars['ID'];
  /** 0-100 percent value of revenue the broadcaster will earn. */
  splitPercent: Scalars['Int'];
  /** Start time of when the revenue split configuration takes effect. */
  startAt?: Maybe<Scalars['Time']>;
};

/** RevokeVIPError contains details about a client error that occurred. */
export type RevokeVipError = {
  __typename?: 'RevokeVIPError';
  /** The type of error that occurred when revoking a user's VIP status. */
  code: RevokeVipErrorCode;
};

/** RevokeVIPErrorCode defines a client error that occurred while revoking a VIP status. */
export enum RevokeVipErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The revoker does not have permission to revoke the VIP status in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The user whose VIP status is to be revoked does not exist. */
  RevokeeNotFound = 'REVOKEE_NOT_FOUND',
  /** The user whose VIP statu is to be revoked does not actually have the VIP status to be revoked. */
  RevokeeNotVip = 'REVOKEE_NOT_VIP'
}

/** RevokeVIPInput contains the parameters to revoke the VIP status of a user from a channel. */
export type RevokeVipInput = {
  /** The channel from which the VIP status of the user will be revoked. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user whose VIP status will be revoked.
   * Either revokeeID or revokeeLogin must be provided.
   */
  revokeeID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user whose VIP status will be revoked.
   * Either revokeeID or revokeeLogin must be provided.
   */
  revokeeLogin?: InputMaybe<Scalars['String']>;
};

/** RevokeVIPPayload is the response after attempting to revoke the VIP status of a user. */
export type RevokeVipPayload = {
  __typename?: 'RevokeVIPPayload';
  /** The channel that the user is revoked as a VIP to. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<RevokeVipError>;
  /** The user whose VIP status is revoked. */
  revokee?: Maybe<User>;
};

/** Rewarded Video information. */
export type RewardedVideo = {
  __typename?: 'RewardedVideo';
  /** A flag indicating if the user is eligible for rewarded videos. */
  isEligible: Scalars['Boolean'];
  /** A flag indicating if the user needs to do a captcha in order to use rewarded videos. */
  shouldCaptcha: Scalars['Boolean'];
};

export type RichOEmbed = OEmbed & {
  __typename?: 'RichOEmbed';
  authorName?: Maybe<Scalars['String']>;
  authorURL?: Maybe<Scalars['String']>;
  cacheAge?: Maybe<Scalars['Int']>;
  height: Scalars['Int'];
  html: Scalars['String'];
  inputURL: Scalars['String'];
  providerName?: Maybe<Scalars['String']>;
  providerURL?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<ThumbnailOEmbed>;
  title?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  version: Scalars['String'];
  width: Scalars['Int'];
};

/**
 * A ritual is an opportunity for a viewer to better connect with a streamer's
 * community by announcing when they reach milestones in the channel.
 * A ritual token is issued when a user is eligible for the ritual, and can be
 * redeemed to send the announcement in a channel.
 */
export type RitualToken = {
  __typename?: 'RitualToken';
  /** The channel that the user can redeem the ritual token in. */
  channel?: Maybe<User>;
  /**
   * The time after which the ritual is considered expired and can no longer be
   * redeemed. Clients should dismiss the ritual UI if it's still shown after
   * this time. Null if the ritual never expires.
   */
  expiresAt?: Maybe<Scalars['Time']>;
  /** A unique ID for the ritual token. */
  id: Scalars['ID'];
  /** The status of the ritual token. */
  status?: Maybe<RitualTokenStatus>;
  /** The type of the ritual to be redeemed. */
  type?: Maybe<RitualTokenType>;
  /** The user that owns the ritual token. */
  user?: Maybe<User>;
};

export enum RitualTokenStatus {
  /** AVAILABLE means a user has been granted this token and it can be redeemed. */
  Available = 'AVAILABLE',
  /** DISMISSED means a user has opted out of redeeming this token. */
  Dismissed = 'DISMISSED',
  /** ELIGIBLE means a user does not have this token, but can request one. */
  Eligible = 'ELIGIBLE',
  /** REDEEMED means a user has successfully consumed this token. */
  Redeemed = 'REDEEMED'
}

export enum RitualTokenType {
  /** NEW_CHATTER is granted 5 minutes after a user joins a channel for the first time. */
  NewChatter = 'NEW_CHATTER'
}

/**
 * DEPRECATED.
 * A chatroom associated with a channel where members of the room can exchange messages.
 */
export type Room = {
  __typename?: 'Room';
  /**
   * UUID of the room.
   * @deprecated The Rooms product has been sunset
   */
  id: Scalars['ID'];
  /**
   * Whether the room can be read by non-members and logged out users.
   * @deprecated The Rooms product has been sunset
   */
  isPreviewable: Scalars['Boolean'];
  /**
   * Paginated list of members of the chatroom.
   * @deprecated The Rooms product has been sunset
   */
  members?: Maybe<RoomMemberConnection>;
  /**
   * List of messages to the room, in reverse chronological order. If fromTime is used, that time is used
   * as the cursor instead of after/before.
   * @deprecated The Rooms product has been sunset
   */
  messages?: Maybe<RoomMessageConnection>;
  /**
   * Minimum role required to join the room. For example, in a sub room, subs can join,
   * but also the broadcaster, mods, and staff.
   * @deprecated The Rooms product has been sunset
   */
  minimumAllowedRole: RoomRole;
  /**
   * Room modes (e.g. slow mode).
   * @deprecated The Rooms product has been sunset
   */
  modes?: Maybe<RoomModes>;
  /**
   * The name of the room (e.g. subs-only).
   * @deprecated The Rooms product has been sunset
   */
  name: Scalars['String'];
  /**
   * The user the room belongs to.
   * @deprecated The Rooms product has been sunset
   */
  owner: User;
  /**
   * rolePermissions describes the role necessary to perform actions in the room.
   * @deprecated The Rooms product has been sunset
   */
  rolePermissions?: Maybe<RoomRolePermissions>;
  /**
   * Returns the current user's settings for the room.
   * @deprecated The Rooms product has been sunset
   */
  self?: Maybe<RoomView>;
  /**
   * The room topic (e.g. "serious discussion only").
   * @deprecated The Rooms product has been sunset
   */
  topic?: Maybe<Scalars['String']>;
};


/**
 * DEPRECATED.
 * A chatroom associated with a channel where members of the room can exchange messages.
 */
export type RoomMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/**
 * DEPRECATED.
 * A chatroom associated with a channel where members of the room can exchange messages.
 */
export type RoomMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  fromTime?: InputMaybe<Scalars['Time']>;
  last?: InputMaybe<Scalars['Int']>;
};

/**
 * DEPRECATED
 * Paginated list of room members (users).
 */
export type RoomMemberConnection = {
  __typename?: 'RoomMemberConnection';
  /**
   * The elements of the list.
   * @deprecated The Rooms product has been sunset
   */
  edges: Array<Maybe<RoomMemberEdge>>;
  /**
   * Information about this page.
   * @deprecated The Rooms product has been sunset
   */
  pageInfo: PageInfo;
};

/** Element in a list of room members. */
export type RoomMemberEdge = {
  __typename?: 'RoomMemberEdge';
  /**
   * Opaque cursor describing this edge's position in the paginated list.
   * @deprecated The Rooms product has been sunset
   */
  cursor: Scalars['Cursor'];
  /**
   * The user who is a member of the room.
   * @deprecated The Rooms product has been sunset
   */
  node?: Maybe<User>;
  /**
   * Type of user for grouping users in the rooms member list.
   * @deprecated The Rooms product has been sunset
   */
  type: RoomMemberType;
};

/**
 * DEPRECATED
 * Type of user for grouping users in the rooms member list.
 */
export enum RoomMemberType {
  /**
   * User that is admin.
   * @deprecated The Rooms product has been sunset
   */
  Admin = 'ADMIN',
  /**
   * User that is the broadcaster.
   * @deprecated The Rooms product has been sunset
   */
  Broadcaster = 'BROADCASTER',
  /**
   * User that is global moderator.
   * @deprecated The Rooms product has been sunset
   */
  Globalmod = 'GLOBALMOD',
  /**
   * User that is a channel moderator.
   * @deprecated The Rooms product has been sunset
   */
  Mod = 'MOD',
  /**
   * User that has no special role.
   * @deprecated The Rooms product has been sunset
   */
  Regular = 'REGULAR',
  /**
   * User that is staff.
   * @deprecated The Rooms product has been sunset
   */
  Staff = 'STAFF'
}

/**
 * DEPRECATED
 * A message sent from a user to a room.
 */
export type RoomMessage = {
  __typename?: 'RoomMessage';
  /**
   * The text and emoticon content of a message.
   * @deprecated The Rooms product has been sunset
   */
  content: RoomMessageContent;
  /**
   * Time the message was deleted or purged. Null if the message is not deleted.
   * @deprecated The Rooms product has been sunset
   */
  deletedAt?: Maybe<Scalars['Time']>;
  /**
   * UUID of the message.
   * @deprecated The Rooms product has been sunset
   */
  id: Scalars['ID'];
  /**
   * The room the message was sent in.
   * @deprecated The Rooms product has been sunset
   */
  room: Room;
  /**
   * The user that sent the message.
   * @deprecated The Rooms product has been sunset
   */
  sender: User;
  /**
   * Time the message was sent.
   * @deprecated The Rooms product has been sunset
   */
  sentAt: Scalars['Time'];
};

/**
 * DEPRECATED
 * Paginated list of messages in a room.
 */
export type RoomMessageConnection = {
  __typename?: 'RoomMessageConnection';
  /**
   * The elements of the list.
   * @deprecated The Rooms product has been sunset
   */
  edges: Array<Maybe<RoomMessageEdge>>;
  /**
   * Information about this page.
   * @deprecated The Rooms product has been sunset
   */
  pageInfo: PageInfo;
};

/**
 * DEPRECATED
 * The content of a user's message to a room.
 */
export type RoomMessageContent = {
  __typename?: 'RoomMessageContent';
  /**
   * Parsed list of fragments in the message, include emotes, mentions, and plaintext.
   * @deprecated The Rooms product has been sunset
   */
  fragments: Array<Maybe<RoomMessageFragment>>;
  /**
   * String representation of the user message.
   * @deprecated The Rooms product has been sunset
   */
  text: Scalars['String'];
};

/** Element in a list of messages. */
export type RoomMessageEdge = {
  __typename?: 'RoomMessageEdge';
  /**
   * Opaque cursor describing this edge's position in the paginated list.
   * @deprecated The Rooms product has been sunset
   */
  cursor: Scalars['Cursor'];
  /**
   * The message.
   * @deprecated The Rooms product has been sunset
   */
  node?: Maybe<RoomMessageItem>;
};

/**
 * DEPRECATED
 * One parsed part of a message, which may be an emote, mention, or plaintext.
 */
export type RoomMessageFragment = {
  __typename?: 'RoomMessageFragment';
  /**
   * Contains an emote or a mentioned user depending on the text of the fragment.
   * @deprecated The Rooms product has been sunset
   */
  content?: Maybe<FragmentContent>;
  /**
   * Plaintext representation of the fragment.
   * @deprecated The Rooms product has been sunset
   */
  text: Scalars['String'];
};

/**
 * DEPRECATED
 * RoomMessageGroupMention represents a group mention, such as @here.
 */
export type RoomMessageGroupMention = {
  __typename?: 'RoomMessageGroupMention';
  /**
   * The type of mention.
   * @deprecated The Rooms product has been sunset
   */
  type: RoomMessageMentionType;
};

export type RoomMessageItem = RoomMessage;

/** Represents a group mention, such as @here. */
export enum RoomMessageMentionType {
  /**
   * An @here mention.
   * @deprecated The Rooms product has been sunset
   */
  Here = 'HERE'
}

/** Modes that have been enabled for the room. */
export type RoomModes = {
  __typename?: 'RoomModes';
  /**
   * If enabled, messages to the room must contain only emotes.
   * @deprecated The Rooms product has been sunset
   */
  emotesOnlyModeEnabled: Scalars['Boolean'];
  /**
   * If enabled, messages to the room must be unique.
   * @deprecated The Rooms product has been sunset
   */
  r9kModeEnabled: Scalars['Boolean'];
  /**
   * The number of seconds users must wait between messages. If 0, slow mode is disabled.
   * @deprecated The Rooms product has been sunset
   */
  slowModeDurationSeconds: Scalars['Int'];
};

/**
 * DEPRECATED
 * Represents the permissions a user has in a room.
 */
export type RoomPermissions = {
  __typename?: 'RoomPermissions';
  /**
   * Whether the user can moderate the room.
   * @deprecated The Rooms product has been sunset
   */
  moderate: Scalars['Boolean'];
  /**
   * Whether the user can read messages in the room.
   * @deprecated The Rooms product has been sunset
   */
  readMessages: Scalars['Boolean'];
  /**
   * Whether the user can send messages in the room.
   * @deprecated The Rooms product has been sunset
   */
  sendMessages: Scalars['Boolean'];
};

/**
 * DEPRECATED
 * Describes the role a user must be in order to perform an action, such as sending messages. Roles are
 * hierarchical, so users that meet a role also meet all lower roles as well. For example, a moderator
 * meets the subscriber role, even if they are not subscribed to the channel. Roles are defined in order
 * from highest to lowest in the enum.
 */
export enum RoomRole {
  /**
   * The channel owner.
   * @deprecated The Rooms product has been sunset
   */
  Broadcaster = 'BROADCASTER',
  /**
   * All users.
   * @deprecated The Rooms product has been sunset
   */
  Everyone = 'EVERYONE',
  /**
   * A moderator for the channel.
   * @deprecated The Rooms product has been sunset
   */
  Moderator = 'MODERATOR',
  /**
   * A subscriber of the channel.
   * @deprecated The Rooms product has been sunset
   */
  Subscriber = 'SUBSCRIBER'
}

/**
 * DEPRECATED
 * RoomRolePermissions describes the role necessary to perform actions in a room.
 */
export type RoomRolePermissions = {
  __typename?: 'RoomRolePermissions';
  /**
   * Read describes the role necessary to read messages in the room.
   * @deprecated The Rooms product has been sunset
   */
  read: RoomRole;
  /**
   * Send describes the role necessary to send messages in the room.
   * @deprecated The Rooms product has been sunset
   */
  send: RoomRole;
};

/**
 * DEPRECATED
 * A RoomView represents the authenticated user's self connection to a room, and includes the user's
 * settings and permissions.
 */
export type RoomView = {
  __typename?: 'RoomView';
  /**
   * Whether the user has archived the room.
   * @deprecated The Rooms product has been sunset
   */
  isArchived: Scalars['Boolean'];
  /**
   * Whether the user has muted the room.
   * @deprecated The Rooms product has been sunset
   */
  isMuted: Scalars['Boolean'];
  /**
   * Whether the user has unread messages in the room.
   * @deprecated The Rooms product has been sunset
   */
  isUnread: Scalars['Boolean'];
  /**
   * Last time the user read a message in the room.
   * @deprecated The Rooms product has been sunset
   */
  lastReadAt?: Maybe<Scalars['Time']>;
  /**
   * The permissions the authenticated user has in the room.
   * @deprecated The Rooms product has been sunset
   */
  permissions?: Maybe<RoomPermissions>;
  /**
   * The room the room view belongs to.
   * @deprecated The Rooms product has been sunset
   */
  room: Room;
  /**
   * The number of mentions for the user in the room that the user has not read.
   * @deprecated The Rooms product has been sunset
   */
  unreadMentionCount: Scalars['Int'];
};

/** An error describing why the issue happened, when relevant. */
export enum RotateExtensionSecretsError {
  /** User has indicated an invalid extension id. */
  InvalidClient = 'INVALID_CLIENT',
  /** User indicated an Invalid delay; must be greater than zero. */
  InvalidDelay = 'INVALID_DELAY',
  /** User is unable to delete the extension secrets. */
  Unauthorized = 'UNAUTHORIZED'
}

/** RotateExtensionSecretsInput includes the necessary parameters for creating a new extension secrets. */
export type RotateExtensionSecretsInput = {
  /** Delay is the time delay in seconds between creation & activation of the secret. */
  delaySeconds: Scalars['Int'];
  /** extensionID to generate a the secret for. */
  extensionID: Scalars['ID'];
};

/** RotateExtensionSecretsPayload returns the new extension secrets information. */
export type RotateExtensionSecretsPayload = {
  __typename?: 'RotateExtensionSecretsPayload';
  /** A user-friendly error, should one occur. */
  error?: Maybe<RotateExtensionSecretsError>;
  /** All the existing secrets for the extension. */
  secrets?: Maybe<Array<ExtensionSecret>>;
};

/** Errors that can result from running multiplayer ads. */
export enum RunMultiplayerAdErrorCode {
  /** The channel is not live, so ads cannot be run on it. */
  ChannelNotLive = 'CHANNEL_NOT_LIVE',
  /** At least one of the multiplayer ad offers has expired. */
  OfferExpired = 'OFFER_EXPIRED',
  /** At least one of the multiplayer ad offers was not found. */
  OfferNotFound = 'OFFER_NOT_FOUND',
  /** An unknown error has occurred. */
  Unknown = 'UNKNOWN'
}

/** Inputs for running multiplayer ads. */
export type RunMultiplayerAdsInput = {
  /** ID of the channel the ads will run on. */
  channelID: Scalars['ID'];
  /** How long the multiplayer ad should run for. */
  desiredAdDurationSeconds?: InputMaybe<Scalars['Int']>;
  /** The ID of the ad offers to run. */
  offerIDs: Array<Scalars['ID']>;
};

/** The response after running multiplayer ads. */
export type RunMultiplayerAdsPayload = {
  __typename?: 'RunMultiplayerAdsPayload';
  /**
   * The error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<RunMultiplayerAdErrorCode>;
};

/**
 * Sony Computer Entertainment (SCE) title properties.
 * Used as part of stream metadata for PlayStation.
 */
export type SceTitle = {
  __typename?: 'SCETitle';
  ageRating?: Maybe<Scalars['Int']>;
  attribute?: Maybe<Scalars['String']>;
  genre?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  isPreset?: Maybe<Scalars['Boolean']>;
  language?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  presetText?: Maybe<Array<Maybe<Scalars['String']>>>;
  presetTextDescription?: Maybe<Scalars['String']>;
  productID?: Maybe<Scalars['String']>;
  sessionID?: Maybe<Scalars['String']>;
  shortName?: Maybe<Scalars['String']>;
  storeURL?: Maybe<Scalars['String']>;
};

/**
 * Sony Computer Entertainment (SCE) user properties.
 * Used as part of stream metadata for PlayStation.
 */
export type SceUser = {
  __typename?: 'SCEUser';
  country?: Maybe<Scalars['String']>;
  npID?: Maybe<Scalars['ID']>;
  onlineID?: Maybe<Scalars['ID']>;
};

/** The SEO metatag of a twitch webpage. */
export type SeoMetatag = {
  __typename?: 'SEOMetatag';
  /** The attributes of the tag. */
  attributes: Array<SeoMetatagAttribute>;
  /** The name of the tag. */
  name: Scalars['String'];
};

/** An attribute of a metatag. */
export type SeoMetatagAttribute = {
  __typename?: 'SEOMetatagAttribute';
  /** The key of the attribute. */
  key: Scalars['String'];
  /** The value of the attribute. */
  value: Scalars['String'];
};

/**
 * A link between a single sign-on (SSO) app and a Twitch account.
 * SSO apps are the Twitch apps on console and smart TV.
 */
export type SsoLink = {
  __typename?: 'SSOLink';
  /** The name of the SSO app that is linked to the authenticated user's Twitch account. */
  app?: Maybe<Scalars['String']>;
  /**
   * The identifier of the device or user account on XboxLive, PSN, etc.
   * that is linked to the authenticated user's Twitch account.
   */
  ssoID?: Maybe<Scalars['String']>;
};

/** The view configuration of an extension if the component anchor is supported. */
export type SaveComponentViewInput = {
  /** The developer configured height of the extension as a ratio relative to it's width. */
  aspectHeight?: InputMaybe<Scalars['Int']>;
  /**
   * Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  aspectRatioX: Scalars['Int'];
  /**
   * Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  aspectRatioY: Scalars['Int'];
  /** The developer configured width of the extension as a ratio relative to it's height. */
  aspectWidth?: InputMaybe<Scalars['Int']>;
  /**
   * Specifies whether to automatically scale the extension iframe using css zoom as the video
   * player dimensions change.
   */
  hasAutoscale?: InputMaybe<Scalars['Boolean']>;
  /**
   * Specifies whether CSS zooming should be applied to the CE container, creating a consistent
   * size of 1024 pixels along the long edge of the component. Default: true.
   */
  hasZoom?: InputMaybe<Scalars['Boolean']>;
  /**
   * If Autoscale is true, this indicates the baseline width of the extension.
   * This fields is optional, but is required if hasAutoscale is true.
   */
  scalePixels?: InputMaybe<Scalars['Int']>;
  /**
   * Size of the long edge of the Component Extension, relative to the length of the corresponding
   * interactable dimension of the video.
   */
  size?: InputMaybe<Scalars['Float']>;
  /**
   * The percentage of the available space (0-100) (between the top and bottom player controls)
   * that the extension aims to consume.
   *
   * NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
   *        however, since both will be used for a short time during the rollout of the new UI,
   *        aspectWidth and aspectHeight will not be deprecated until later.
   */
  targetHeight: Scalars['Int'];
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
  /**
   * If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
   * Default: 1024.
   */
  zoomPixels?: InputMaybe<Scalars['Int']>;
};

/** ConfigViewInput holds the view configuration of an extension if the config page is supported. */
export type SaveConfigViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** ExtensionAssetManifestInput is data related to the assets of an extension. */
export type SaveExtensionAssetManifestInput = {
  /** Hash of the asset zip file. */
  assetHash: Scalars['String'];
};

/** ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction. */
export type SaveExtensionCapabilitiesInput = {
  /** The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  bitsSupportLevel?: InputMaybe<ExtensionBitsSupportLevel>;
  /** Location of configuration. */
  configurationLocation: ExtensionConfigurationLocation;
  /** Does this extension use bits. */
  hasBitsSupport: Scalars['Boolean'];
  /** Does this extension support chat. */
  hasChatSupport: Scalars['Boolean'];
  /** Required configuration string. */
  requiredConfiguration: Scalars['String'];
  /** The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE". */
  subscriptionsSupportLevel?: InputMaybe<ExtensionSubscriptionsSupportLevel>;
  /** Whitelists for restricting extension access and behavior. */
  whitelists: ExtensionWhitelistsInput;
  /** Will this extension request an identity link. */
  willRequestIdentityLink: Scalars['Boolean'];
};

/** ExtensionDeveloperManifestInput is the developer specific extension data. */
export type SaveExtensionDeveloperManifestInput = {
  /** Author email. */
  authorEmail: Scalars['String'];
  /** Testing uri for extension development. */
  testingBaseURI: Scalars['String'];
};

/** Extension metadata used for discovery. */
export type SaveExtensionDiscoveryManifestInput = {
  /** Name of the extension author. */
  authorName: Scalars['String'];
  /** Extension categories. */
  categories: Array<Scalars['ID']>;
  /** Extension descriprion. 1024 character limit. */
  description: Scalars['String'];
  /** games an extension is associated with. */
  games: Array<Scalars['ID']>;
  /** name of the extension. */
  name: Scalars['String'];
  /** Url to an extensions privacy policy. */
  privacyPolicyURL: Scalars['String'];
  /** Extension summary. 140 character limit. */
  summary: Scalars['String'];
  /** Extension developers support email. */
  supportEmail: Scalars['String'];
  /** Extension eula/tos url. */
  termsURL: Scalars['String'];
  /** A summary of the extension's functionality from a viewer's perspective. */
  viewerSummary: Scalars['String'];
};

/** SaveExtensionManifestError is an error associated with the saveExtensionManifest mutation. */
export enum SaveExtensionManifestError {
  /** At least one anchor must be specified. */
  AnchorRequired = 'ANCHOR_REQUIRED',
  /** Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidAuthorEmail = 'INVALID_AUTHOR_EMAIL',
  /** Extension author name length must be > 40. */
  InvalidAuthorNameLength = 'INVALID_AUTHOR_NAME_LENGTH',
  /** Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum. */
  InvalidBitsSupportLevel = 'INVALID_BITS_SUPPORT_LEVEL',
  /** Extension component aspect height must be < 50 or > 1. */
  InvalidComponentAspectHeight = 'INVALID_COMPONENT_ASPECT_HEIGHT',
  /** Aspect Ratio X must be set to a positive integer. */
  InvalidComponentAspectRatioX = 'INVALID_COMPONENT_ASPECT_RATIO_X',
  /** Aspect Ratio Y must be set to a positive integer. */
  InvalidComponentAspectRatioY = 'INVALID_COMPONENT_ASPECT_RATIO_Y',
  /** Extension component aspect width must be < 50 or > 1. */
  InvalidComponentAspectWidth = 'INVALID_COMPONENT_ASPECT_WIDTH',
  /** Target Height must be set to a positve integer. */
  InvalidComponentTargetHeight = 'INVALID_COMPONENT_TARGET_HEIGHT',
  /** Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidComponentViewerPath = 'INVALID_COMPONENT_VIEWER_PATH',
  /** Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidConfigViewerPath = 'INVALID_CONFIG_VIEWER_PATH',
  /** Extension description must be shorter than 1024 characters. */
  InvalidDescriptionLength = 'INVALID_DESCRIPTION_LENGTH',
  /** Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidLiveConfigViewerPath = 'INVALID_LIVE_CONFIG_VIEWER_PATH',
  /** Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidMobileViewerPath = 'INVALID_MOBILE_VIEWER_PATH',
  /** Extension names must be shorter than 40 characters. */
  InvalidNameLength = 'INVALID_NAME_LENGTH',
  /** Extension panel hiehgt must be < 500 or > 100. */
  InvalidPanelHeight = 'INVALID_PANEL_HEIGHT',
  /** Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidPanelViewerPath = 'INVALID_PANEL_VIEWER_PATH',
  /** Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidPrivacyUri = 'INVALID_PRIVACY_URI',
  /** Scale pixels must be set to a positive integer when autoscale is true. */
  InvalidScalingPixels = 'INVALID_SCALING_PIXELS',
  /** Extension summary must be shorter than 140 characters. */
  InvalidSummaryLength = 'INVALID_SUMMARY_LENGTH',
  /** Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidSupportEmail = 'INVALID_SUPPORT_EMAIL',
  /** Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTermsUri = 'INVALID_TERMS_URI',
  /** Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTestingBaseUri = 'INVALID_TESTING_BASE_URI',
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidVideoOverlayViewerPath = 'INVALID_VIDEO_OVERLAY_VIEWER_PATH',
  /** Extension viewer summary must be shorter than 140 characters. */
  InvalidViewerSummaryLength = 'INVALID_VIEWER_SUMMARY_LENGTH',
  /** HasZoom was specified but ZoomPixels is missing. */
  InvalidZoom = 'INVALID_ZOOM',
  /** The number of whitelisted broadcasters exceeds the limit. */
  MaxBroadcasters = 'MAX_BROADCASTERS',
  /** The number of whitelisted testing users exceeds the limit. */
  MaxTesters = 'MAX_TESTERS',
  /** The number of whitelisted config URLs exceeds the limit. */
  MaxWhitelistedConfigUrls = 'MAX_WHITELISTED_CONFIG_URLS',
  /** The number of whitelisted panel URLs exceeds the limit. */
  MaxWhitelistedPanelUrls = 'MAX_WHITELISTED_PANEL_URLS',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** SaveExtensionManifestInput updates the manifest. */
export type SaveExtensionManifestInput = {
  /** ExtensionAssetManifest is data related to the assets of an extension. */
  assetManifest: SaveExtensionAssetManifestInput;
  /** Data about what an Extension can do, in general, and at the time of interaction. */
  capabilities: SaveExtensionCapabilitiesInput;
  /** ExtensionDeveloperManifest is the developer specific extension data. */
  developerManifest: SaveExtensionDeveloperManifestInput;
  /** Extension metadata used for discovery. */
  discoveryManifest: SaveExtensionDiscoveryManifestInput;
  /** The extension ID of the manifest to update. */
  id: Scalars['ID'];
  /** The extension version to update. */
  version: Scalars['String'];
  /** Extension views. */
  views: SaveExtensionViewsInput;
};

/** SaveExtensionManifestPayload returns the update Extension manifest. */
export type SaveExtensionManifestPayload = {
  __typename?: 'SaveExtensionManifestPayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<SaveExtensionManifestError>;
  /** The updated extension manifest. */
  manifest?: Maybe<ExtensionManifest>;
};

/** The potential anchor-specific configurations and extension can have. */
export type SaveExtensionViewsInput = {
  /** The developer configuration of the extension as a component extension, if supported. */
  component?: InputMaybe<SaveComponentViewInput>;
  /** The developer configuration of the extension's configuration view, if supported. */
  config?: InputMaybe<SaveConfigViewInput>;
  /** The developer configuration of the extension's live configuration dashboard view, if supported. */
  liveConfig?: InputMaybe<SaveLiveConfigViewInput>;
  /** The developer configuration of the extension as a mobile extension, if supported. */
  mobile?: InputMaybe<SaveMobileViewInput>;
  /** The developer configuration of the extension as a panel extension, if supported. */
  panel?: InputMaybe<SavePanelViewInput>;
  /** The developer configuration of the extension as a video overlay extension, if supported. */
  videoOverlay?: InputMaybe<SaveVideoOverlayViewInput>;
};

/** ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior. */
export type SaveExtensionWhitelistsInput = {
  /**
   * List of broadcaster account IDs allowed to install an extension after release.
   * If this is empty or missing, all broadcasters can use this extension.
   */
  broadcasters: Array<Scalars['ID']>;
  /** URLs which are permitted to be opened from the configuration dialog. */
  configURLs: Array<Scalars['String']>;
  /** URLs which are permitted to be opened from an extension set as a panel. */
  panelURLs: Array<Scalars['String']>;
  /**
   * List of account IDs which should have access to a version of an extension.
   * Users in this list are ignored by the broadcaster whitelist check.
   */
  testers: Array<Scalars['ID']>;
};

/** HiddenView holds the view configuration of an extension if it is a hidden load test extension. */
export type SaveHiddenViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported. */
export type SaveLiveConfigViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** MobileViewInput holds the view configuration of an extension if mobile is supported. */
export type SaveMobileViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** PanelViewInput holds the view configuration of an extension if the panel anchor is supported. */
export type SavePanelViewInput = {
  /** The extension developer configured height of the panel extension. */
  height: Scalars['Int'];
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported. */
export type SaveVideoOverlayViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** The channel schedule. */
export type Schedule = {
  __typename?: 'Schedule';
  /** The ID of the schedule. */
  id: Scalars['ID'];
  /** A period during which scheduled events temporarily cease. */
  interruption?: Maybe<ScheduleInterruption>;
  /** The next uncancelled segment of the schedule. */
  nextSegment?: Maybe<ScheduleSegment>;
  /** The segments after a specific date ordered by start time. This field can be paginated and return segments across week boundaries. */
  segmentList?: Maybe<ScheduleSegmentListConnection>;
  /** All segments for the specified week. If relativeDate isn't provided, the current week is used. */
  segments?: Maybe<Array<ScheduleSegment>>;
};


/** The channel schedule. */
export type ScheduleSegmentListArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<ScheduleSegmentListInput>;
};


/** The channel schedule. */
export type ScheduleSegmentsArgs = {
  includeFutureSegments?: InputMaybe<Scalars['Boolean']>;
  relativeDate?: InputMaybe<Scalars['Time']>;
  startingWeekday?: InputMaybe<Scalars['String']>;
  utcOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** The interruption of a schedule. */
export type ScheduleInterruption = {
  __typename?: 'ScheduleInterruption';
  /** The end time when the schedule will no longer be disabled. */
  endAt: Scalars['Time'];
  /** The reason the schedule is disabled. */
  reason: ScheduleInterruptionReason;
  /** The start time when the schedule will be disabled. */
  startAt: Scalars['Time'];
};

/** The reason of an interruption of a schedule. */
export enum ScheduleInterruptionReason {
  /** Fallback value for reason unknown to the GQL schema. */
  Other = 'OTHER',
  /** The user is on vacation. */
  Vacation = 'VACATION'
}

/** The segment of a schedule. */
export type ScheduleSegment = {
  __typename?: 'ScheduleSegment';
  /** The UTC date when the segment is no longer cancelled. */
  cancelledUntil?: Maybe<Scalars['Time']>;
  /** The game categories tied to this segment. */
  categories?: Maybe<Array<Game>>;
  /** The end time of the segment. */
  endAt?: Maybe<Scalars['Time']>;
  /** The start date and time of the first occurrence of the segment. */
  firstOccurrenceDate?: Maybe<Scalars['Time']>;
  /** Whether or not the current user has a reminder set for the segment. */
  hasReminder: Scalars['Boolean'];
  /** The ID of the segment. */
  id: Scalars['ID'];
  /** If this segment is cancelled or not. */
  isCancelled: Scalars['Boolean'];
  /** A count of users who have a reminder set, available only to the schedule owner. */
  reminderCount?: Maybe<Scalars['Int']>;
  /** The number of times the segment should repeat. If 1, this is a single segment. */
  repeatEndsAfterCount?: Maybe<Scalars['Int']>;
  /** The start time of the segment. */
  startAt: Scalars['Time'];
  /** The title of the segment. */
  title: Scalars['String'];
};

/** The days. */
export enum ScheduleSegmentDay {
  /** FRIDAY. */
  Friday = 'FRIDAY',
  /** MONDAY. */
  Monday = 'MONDAY',
  /** SATURDAY. */
  Saturday = 'SATURDAY',
  /** SUNDAY. */
  Sunday = 'SUNDAY',
  /** THURSDAY. */
  Thursday = 'THURSDAY',
  /** TUESDAY. */
  Tuesday = 'TUESDAY',
  /** WEDNESDAY. */
  Wednesday = 'WEDNESDAY'
}

/** Paginated list of segments using the Relay cursor specification. */
export type ScheduleSegmentListConnection = {
  __typename?: 'ScheduleSegmentListConnection';
  /** The list of schedule segments. */
  edges?: Maybe<Array<ScheduleSegmentListEdge>>;
  /** Pagination information for this connection. */
  pageInfo: PageInfo;
};

/** Element in a list of endorsed channels. */
export type ScheduleSegmentListEdge = {
  __typename?: 'ScheduleSegmentListEdge';
  /** Cursor identifying the position of this edge for future queries. */
  cursor: Scalars['Cursor'];
  /** The information about the endorsed channel. */
  node: ScheduleSegment;
};

/** The inputs for the segmentList query. */
export type ScheduleSegmentListInput = {
  /** Flag to indicate whether in progress segments should be returned. */
  ignoreInProgress?: InputMaybe<Scalars['Boolean']>;
  /** The reference time to request segments after. If not provided, the current time will be used. */
  startTime?: InputMaybe<Scalars['Time']>;
  /** The desired timezone for the times sent with the returned segments. If not set, UTC is used. */
  utcOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** The optional parameters for scheduleSegment. */
export type ScheduleSegmentOptions = {
  /** The reference time to request segments after. If not provided, the current time will be used. */
  relativeDate?: InputMaybe<Scalars['Time']>;
  /** The weekday that is used to mark the beginning of the week. If not supplied, this will default to "MONDAY". */
  startingWeekday?: InputMaybe<ScheduleSegmentDay>;
  /** The desired timezone for the times sent with the returned segments. If not set, UTC is used. */
  utcOffsetMinutes?: InputMaybe<Scalars['Int']>;
};

/** Whether the image should be set on a benefit or campaign. */
export enum Scope {
  /** Image is for a benefit. */
  Benefit = 'BENEFIT',
  /** Image is for a campaign. */
  Campaign = 'CAMPAIGN'
}

/** Contains categories search results. */
export type SearchCategoriesConnection = {
  __typename?: 'SearchCategoriesConnection';
  /** List of matching game results. */
  edges?: Maybe<Array<SearchCategoriesEdge>>;
  /** Information about this page of categories. */
  pageInfo: PageInfo;
  /** Total number of results. */
  totalCount: Scalars['Int'];
};

/** An element in the categories result, and its metadata. */
export type SearchCategoriesEdge = {
  __typename?: 'SearchCategoriesEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension for the current edge. */
  node: Game;
};

/** Contains results for a searchFor query. */
export type SearchFor = {
  __typename?: 'SearchFor';
  /** Contains results for channels. */
  channels?: Maybe<SearchForResultUsers>;
  /** Contains results for games. */
  games?: Maybe<SearchForResultGames>;
  /** Contains results for live channels. */
  liveChannels?: Maybe<SearchForResultUsers>;
  /** Contains results for related live channels. */
  relatedLiveChannels?: Maybe<SearchForResultRelatedLiveChannels>;
  /** Contains results for users. */
  users?: Maybe<SearchForResultUsers>;
  /** Contains results for videos. */
  videos?: Maybe<SearchForResultVideos>;
};

/** Contains a single result item and a tracking ID. */
export type SearchForEdge = {
  __typename?: 'SearchForEdge';
  /** List of matching items. */
  item: SearchForItem;
  /** An id used for search metrics. */
  trackingID: Scalars['ID'];
};

/** Contains a single result item and a tracking ID. */
export type SearchForEdgeRelatedLiveChannels = {
  __typename?: 'SearchForEdgeRelatedLiveChannels';
  /** List of matching items. */
  item: User;
  /** An id used for search metrics. */
  trackingID: Scalars['ID'];
};

/** A result item may be a User, Game, or Video. */
export type SearchForItem = Game | User | Video;

/** SearchForOptions allows the user to target specific result types. */
export type SearchForOptions = {
  /** List of indices to run a user's query against. */
  targets?: InputMaybe<Array<SearchForTarget>>;
};

/** Contains game search results. */
export type SearchForResultGames = {
  __typename?: 'SearchForResultGames';
  /** Cursor for fetching the next page of results. */
  cursor?: Maybe<Scalars['String']>;
  /** List of edges containing game results and trackingIDs. */
  edges: Array<SearchForEdge>;
  /** List of matching game results. */
  items?: Maybe<Array<Game>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Order in which the result should be displayed. */
  score: Scalars['Int'];
  /** Total number of results. */
  totalMatches: Scalars['Int'];
};

/** Contains results for related live channels. */
export type SearchForResultRelatedLiveChannels = {
  __typename?: 'SearchForResultRelatedLiveChannels';
  /** List of edges containing user results and trackingIDs. */
  edges: Array<SearchForEdgeRelatedLiveChannels>;
  /** List of matching user results. */
  items?: Maybe<Array<User>>;
  /** Optional score associated with the related live section. */
  score?: Maybe<Scalars['Int']>;
};

/** Contains user search results. */
export type SearchForResultUsers = {
  __typename?: 'SearchForResultUsers';
  /** Cursor for fetching the next page of results. */
  cursor?: Maybe<Scalars['String']>;
  /** List of edges containing user results and trackingIDs. */
  edges: Array<SearchForEdge>;
  /** List of matching user results. */
  items?: Maybe<Array<User>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Order in which the result should be displayed. */
  score: Scalars['Int'];
  /** Total number of results. */
  totalMatches: Scalars['Int'];
};

/** Contains video search results. */
export type SearchForResultVideos = {
  __typename?: 'SearchForResultVideos';
  /** Cursor for fetching the next page of results. */
  cursor?: Maybe<Scalars['String']>;
  /** List of edges containing video results and trackingIDs. */
  edges: Array<SearchForEdge>;
  /** List of matching video results. */
  items?: Maybe<Array<Video>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Order in which the result should be displayed. */
  score: Scalars['Int'];
  /** Total number of results. */
  totalMatches: Scalars['Int'];
};

/** Specify which index to run a user's search. */
export type SearchForTarget = {
  /** Pagination cursor for user to optionally provide to request a specific page of results. */
  cursor?: InputMaybe<Scalars['String']>;
  /** Search index to run a user's query against. */
  index: SearchIndex;
  /** Limit the number of results returned. */
  limit?: InputMaybe<Scalars['Int']>;
};

/** Enumeration of indexes a search query can target. */
export enum SearchIndex {
  /** Channel index. */
  Channel = 'CHANNEL',
  /** Game index. */
  Game = 'GAME',
  /** Live channel index. */
  Live = 'LIVE',
  /** User index. */
  User = 'USER',
  /** Video on demand index. */
  Vod = 'VOD'
}

/** SearchOptions to customize results returned by the search query. */
export type SearchOptions = {
  /** List of indices to run a user's query against. If no targets are specified, the query is run against all the indices listed in SearchIndex. */
  targets?: InputMaybe<Array<SearchTarget>>;
};

/** Contains the result returned by the search engine for a particular query. */
export type SearchResult = {
  __typename?: 'SearchResult';
  /** JSON encoded as a string. */
  result: Scalars['String'];
};

/** List of users. */
export type SearchStreamConnection = {
  __typename?: 'SearchStreamConnection';
  /** List of matching channels results. */
  edges?: Maybe<Array<SearchStreamEdge>>;
  /** Information about this page of videos. */
  pageInfo: PageInfo;
  /** The total number of items in the collection. */
  totalCount: Scalars['Int'];
};

/** An element in a paginated list of videos, and its metadata. */
export type SearchStreamEdge = {
  __typename?: 'SearchStreamEdge';
  /** The cursor of the channel record list. This is same for one page. */
  cursor: Scalars['Cursor'];
  /** The channel result returned. */
  node: Stream;
};

/** A search suggestion. */
export type SearchSuggestion = {
  __typename?: 'SearchSuggestion';
  /** Extra data for category or channel type of search suggestion. */
  content?: Maybe<SearchSuggestionContent>;
  /**
   * The part of the suggestion that matches the search query.
   * @deprecated Use 'matchingCharacters' instead.
   */
  highlight: SearchSuggestionHighlight;
  /** The search suggestion's unique identifier. */
  id: Scalars['ID'];
  /** The part of the suggestion that matches the search query. */
  matchingCharacters?: Maybe<SearchSuggestionHighlight>;
  /** The search suggestion string. */
  text: Scalars['String'];
};

/** A category search suggestion. */
export type SearchSuggestionCategory = {
  __typename?: 'SearchSuggestionCategory';
  /**
   * The boxart URL for the category, provided by the endpoint.
   * Use this field for lower latency.
   *
   * The image dimensions are specifiable via the `height` and `width` parameters.
   * If `height` or `width` are not specified, the URL will contain
   * the template strings `{height}` and/or `{width}` in their respective places.
   */
  boxArtURL: Scalars['String'];
  /** The category. */
  game?: Maybe<Game>;
  /** The category's unique identifier. */
  id: Scalars['ID'];
};


/** A category search suggestion. */
export type SearchSuggestionCategoryBoxArtUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

/** A channel search suggestion. */
export type SearchSuggestionChannel = {
  __typename?: 'SearchSuggestionChannel';
  /** The channel's unique identifier. */
  id: Scalars['ID'];
  /**
   * Whether or not the channel is verified, provided by the endpoint.
   * Use this field for lower latency.
   */
  isVerified: Scalars['Boolean'];
  /**
   * The login of the channel, provided by the endpoint.
   * Use this field for lower latency.
   */
  login: Scalars['String'];
  /**
   * The profile image URL for the channel, provided by the endpoint.
   * Use this field for lower latency.
   *
   * Valid widths are 28, 50, 70, 150, 300, and 600.
   * The image height will be the same as the given width.
   */
  profileImageURL?: Maybe<Scalars['String']>;
  /** The user of the channel. */
  user?: Maybe<User>;
};


/** A channel search suggestion. */
export type SearchSuggestionChannelProfileImageUrlArgs = {
  width: Scalars['Int'];
};

/** A list of search suggestions and related tracking data. */
export type SearchSuggestionConnection = {
  __typename?: 'SearchSuggestionConnection';
  /** The list of search suggestions. */
  edges?: Maybe<Array<SearchSuggestionEdge>>;
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  pageInfo: PageInfo;
  /** Tracking data for the search suggestions. */
  tracking?: Maybe<SearchSuggestionTracking>;
};

/** The types with additional content in a search suggestion. */
export type SearchSuggestionContent = SearchSuggestionCategory | SearchSuggestionChannel;

/** Edge containing the search suggestion. */
export type SearchSuggestionEdge = {
  __typename?: 'SearchSuggestionEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The search suggestion. */
  node: SearchSuggestion;
};

/** A range that matches the search query. */
export type SearchSuggestionHighlight = {
  __typename?: 'SearchSuggestionHighlight';
  /** The end of the match. */
  end: Scalars['Int'];
  /** The start of the match. */
  start: Scalars['Int'];
};

/** An object containing tracking data for a search suggestion. */
export type SearchSuggestionTracking = {
  __typename?: 'SearchSuggestionTracking';
  /** The unique identifier of the model instance. */
  modelTrackingID: Scalars['ID'];
  /** The unique identifier generated for every response. */
  responseID: Scalars['ID'];
};

/** Specify which index to run a user's search. */
export type SearchTarget = {
  /** When true, response will return  the total number of matching documents in index for a given query. The value for limit is ignored and assumed to be zero. */
  countTotalMatches?: InputMaybe<Scalars['Boolean']>;
  /** Search index to run a user's query against. */
  index: SearchIndex;
  /** Max number of matching documents that will be returned. */
  limit: Scalars['Int'];
};

/** A list of user returned from forage by user query. */
export type SearchUserConnection = {
  __typename?: 'SearchUserConnection';
  /** List of matching user results. */
  edges?: Maybe<Array<SearchUserEdge>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Total number of results. */
  totalCount: Scalars['Int'];
};

/** Element in a list of users returned from forage. */
export type SearchUserEdge = {
  __typename?: 'SearchUserEdge';
  /** Cursor for fetching the next page of results(only on last edge of current connection). */
  cursor: Scalars['Cursor'];
  /** The information about user. */
  node: User;
};

/** Season metadata. */
export type SeasonDetails = {
  __typename?: 'SeasonDetails';
  /** Number of episodes. */
  episodeCount?: Maybe<Scalars['Int']>;
  /** The season number. */
  season?: Maybe<Scalars['Int']>;
};

/** Inputs for seeding a competition participant. */
export type SeedCompetitionParticipantInput = {
  /** ID of the competition. */
  competitionID: Scalars['ID'];
  /** ID of the competition player or competition team. */
  participantID: Scalars['ID'];
  /** The assigned seed value. */
  seedValue: Scalars['Int'];
};

/** SeedCompetitionParticipantPayload is the success response for seeding a competition player or competition team. */
export type SeedCompetitionParticipantPayload = {
  __typename?: 'SeedCompetitionParticipantPayload';
  /** The new state of competition after seeding a competition player or competition team. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** The segment start time input. */
export type SegmentStartTimeInput = {
  /** The day of the segment. */
  day: ScheduleSegmentDay;
  /** The hour of the segment 0-23. */
  hour: Scalars['Int'];
  /** The minute of the segment 0-59. */
  minute: Scalars['Int'];
};

/** An enumeration of the statuses of suggested segments. */
export enum SegmentsStatusType {
  /** The suggested segments have successfully been created. */
  Completed = 'COMPLETED',
  /** The backend failed to generate suggested segments. */
  Failed = 'FAILED',
  /** The vod is currently being processed for suggested segments. */
  InProgress = 'IN_PROGRESS',
  /** There wasn't enough data to generate suggested segments. */
  NotEnoughData = 'NOT_ENOUGH_DATA'
}

/** Inputs for selecting a channel badge. */
export type SelectChannelBadgeInput = {
  /** Set ID of the badge to select. */
  badgeSetID: Scalars['ID'];
  /** Optional Version of the Badge to select. */
  badgeSetVersion?: InputMaybe<Scalars['String']>;
  /** ID of the channel this badge is selected on. */
  channelID: Scalars['ID'];
};

/** The output for the select channel badge mutation. */
export type SelectChannelBadgePayload = {
  __typename?: 'SelectChannelBadgePayload';
  /** Indicates if selecting the badge was successful. */
  isSuccessful?: Maybe<Scalars['Boolean']>;
  /** The channel (user object of channel) this badge is selected on. */
  user?: Maybe<User>;
};

/** Inputs for selecting a global badge. */
export type SelectGlobalBadgeInput = {
  /** Set ID of the badge to select. */
  badgeSetID: Scalars['ID'];
  /** Optional Version of the Badge to select. */
  badgeSetVersion?: InputMaybe<Scalars['String']>;
};

/** The output for the select global badge mutation. */
export type SelectGlobalBadgePayload = {
  __typename?: 'SelectGlobalBadgePayload';
  /** Indicates if selecting the badge was successful. */
  isSuccessful?: Maybe<Scalars['Boolean']>;
  /** The user of the selected badge. */
  user?: Maybe<User>;
};

/** An interface to represent the logged in user's relationship to the claimable. */
export type SelfClaimEdge = {
  /** If the user is eligible to claim the object. */
  canClaim: Scalars['Boolean'];
  /** Nullable field for the country where the user redeemed the claimable. */
  countryOfResidence?: Maybe<Scalars['String']>;
  /** The user ID that is claiming. */
  id: Scalars['ID'];
  /** Nullable status code for if the user cannot claim the object. */
  statusCode?: Maybe<Scalars['String']>;
};

/** Input for sending a chat message through subscriber-only mode with Channel Points. */
export type SendChatMessageThroughSubscriberModeInput = {
  /** The channel the message is being sent to. */
  channelID: Scalars['ID'];
  /** The client's perception of the reward's cost. */
  cost: Scalars['Int'];
  /** The user's message. */
  message: Scalars['String'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming the skip subs only chat message reward. */
export type SendChatMessageThroughSubscriberModePayload = {
  __typename?: 'SendChatMessageThroughSubscriberModePayload';
  /** The user's new Channel Points balance. */
  balance?: Maybe<Scalars['Int']>;
  /** The error that occurred during redemption, if any. */
  error?: Maybe<SendCopoMessageError>;
  /** Whether the message was flagged by Automod and held for review. */
  isHeldByAutomod?: Maybe<Scalars['Boolean']>;
};

export type SendCheerInput = {
  /** bits is the number of bits the message will spend (as parsed by the client). */
  bits: Scalars['Int'];
  /** content is the text to process and forward to the chat system. */
  content: Scalars['String'];
  /**
   * Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
   * The server will reject any request with an ID that has already been used.
   */
  id: Scalars['ID'];
  /** Optional field that dictates the user wants their cheer to appear anonymously (i.e. unassociated with their username). */
  isAnonymous?: InputMaybe<Scalars['Boolean']>;
  /** Optional field that dictates whether automod should be enabled for the cheer or not. */
  isAutoModEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Optional field that dictates the cheer message was sent from a room, as this provides the context for what room
   * it was sent from.
   */
  roomID?: InputMaybe<Scalars['ID']>;
  /** Optional field that dictates that the user want to cheer anyways, even though they know it will be automodded. */
  shouldCheerAnyway?: InputMaybe<Scalars['Boolean']>;
  /** targetID is the `User.id` of the channel to send the cheer to. */
  targetID: Scalars['ID'];
};

export type SendCheerPayload = {
  __typename?: 'SendCheerPayload';
  /** currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent. */
  currentUser?: Maybe<User>;
  /** id is the client-generated value passed in as part of the request. */
  id: Scalars['ID'];
  /** If any validation errors occur, this will not be nil. */
  validationError?: Maybe<SendCheerValidationError>;
};

/** Resolver for validation errors that occur on send cheer. */
export type SendCheerValidationError = {
  __typename?: 'SendCheerValidationError';
  /** Error code that describes the validation error. */
  code: SendCheerValidationErrorCode;
  /** Error message that is returned from the backend service. */
  message: Scalars['String'];
  /** Optional rejected message for when the error requires frontend message changes, like AutoMod'd messages. */
  messageContent?: Maybe<RoomMessageContent>;
};

/** Validation error status codes. */
export enum SendCheerValidationErrorCode {
  /** Bits amount is below the minimum. */
  AmountBelowMinBits = 'AMOUNT_BELOW_MIN_BITS',
  /** The bits message contained an anonymous cheermote when it's not allowed (ex: in public cheers). */
  AnonymousCheermoteNotAllowed = 'ANONYMOUS_CHEERMOTE_NOT_ALLOWED',
  /** The message was auto modded. */
  AutoModMessage = 'AUTO_MOD_MESSAGE',
  /** The message was not processed due to an automodded pending cheer. */
  AutoModPending = 'AUTO_MOD_PENDING',
  /** The message contained term(s) blocked by the channel. */
  ChannelBlockedTerms = 'CHANNEL_BLOCKED_TERMS',
  /** The channel was ineligible for receiving bits. */
  ChannelIneligible = 'CHANNEL_INELIGIBLE',
  /** The emote amount was below the minimum bits emote amount. */
  EmoteAmountBelowMinBits = 'EMOTE_AMOUNT_BELOW_MIN_BITS',
  /** The user has insufficient balance. */
  InsufficientBalance = 'INSUFFICIENT_BALANCE',
  /** The anonymous message contained text that is invalid. */
  InvalidAnonymousMessage = 'INVALID_ANONYMOUS_MESSAGE',
  /** The bits amount is invalid. */
  InvalidBitsAmount = 'INVALID_BITS_AMOUNT',
  /** The bits message is invalid. */
  InvalidBitsMessage = 'INVALID_BITS_MESSAGE',
  /** The event ID is invalid, probably because it's been used. */
  InvalidEventId = 'INVALID_EVENT_ID',
  /** The message length is greater than the max message length. */
  MessageLengthExceeded = 'MESSAGE_LENGTH_EXCEEDED',
  /** The request has been throttled. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** The bits emotes that were sent were greater than the max allowed. */
  TooLargeBitsEmote = 'TOO_LARGE_BITS_EMOTE',
  /** The cheer was over the maximum cheer limit. */
  TooLargeCheer = 'TOO_LARGE_CHEER',
  /** An unknown error has occurred, but it was a validation error. */
  Unknown = 'UNKNOWN',
  /** The user is banned from bits. */
  UserBanned = 'USER_BANNED',
  /** The user is ineligible to send bits. */
  UserIneligible = 'USER_INELIGIBLE',
  /** The use is suspended from sending bits. */
  UserSuspended = 'USER_SUSPENDED',
  /** The message contained Zalgo text. */
  ZalgoMessage = 'ZALGO_MESSAGE'
}

/** An error from redeeming a chat message Channel Points reward. */
export type SendCopoMessageError = {
  __typename?: 'SendCopoMessageError';
  /** The error code. */
  code?: Maybe<SendCopoMessageErrorCode>;
};

/** Possible errors from redeeming a chat message Channel Points reward. */
export enum SendCopoMessageErrorCode {
  /**
   * The user's message was flagged by Automod and is being reviewed.
   * @deprecated use isHeldByAutomod on the payload instead
   */
  AutomodHeld = 'AUTOMOD_HELD',
  /** The chat is in Blizzard connect mode and the user does not have their Blizzard account connected. */
  BlizzardConnectMode = 'BLIZZARD_CONNECT_MODE',
  /** The user's message contained a blocked phrase. */
  ChannelSettings = 'CHANNEL_SETTINGS',
  /** The chat is emote-only mode and the message contained text. */
  EmoteOnly = 'EMOTE_ONLY',
  /** The chat is in followers-only mode and the user has not been following long enough. */
  FollowersOnly = 'FOLLOWERS_ONLY',
  /** The chat is in followers-only mode and the user is not following. */
  FollowersOnlyZero = 'FOLLOWERS_ONLY_ZERO',
  /** The user does not have sufficient points to redeem the reward. */
  InsufficientPoints = 'INSUFFICIENT_POINTS',
  /** The user's message starts with a '/' like a chat command. */
  MessageIsCommand = 'MESSAGE_IS_COMMAND',
  /** The user's message was rejected for another reason- possibly intentionally hidden, such as IP block. */
  MessageRejected = 'MESSAGE_REJECTED',
  /** User has previously sent an identical message. */
  MsgDuplicate = 'MSG_DUPLICATE',
  /** The chat is in r9k-only mode (relatively unique messages) and the message was not unique. */
  R9KMode = 'R9K_MODE',
  /** The reward cost has changed since the user has tried to redeem it. */
  RewardCostMismatch = 'REWARD_COST_MISMATCH',
  /** The reward is currently disabled. */
  RewardDisabled = 'REWARD_DISABLED',
  /** The user is not allowed to redeem this reward on this channel. */
  RewardForbidden = 'REWARD_FORBIDDEN',
  /** The request failed due to an underlying server error. */
  ServerError = 'SERVER_ERROR',
  /** The chat is in slow mode and the user has recently sent a message. */
  SlowMode = 'SLOW_MODE',
  /** The chat is in subs-only mode and the user is not subbed. */
  SubsOnly = 'SUBS_ONLY',
  /** The client is retrying a redemption with a transaction id that has already been redeemed. */
  TransactionAlreadyCommitted = 'TRANSACTION_ALREADY_COMMITTED',
  /** The client is retrying a redemption with a transaction id that is currently being redeemed in another request. */
  TransactionInProgress = 'TRANSACTION_IN_PROGRESS',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** The user is banned in the channel. */
  UserBanned = 'USER_BANNED',
  /** The user is suspended from Twitch. */
  UserSuspended = 'USER_SUSPENDED',
  /** The user is timed out in the channel. */
  UserTimedOut = 'USER_TIMED_OUT',
  /** The chat is in verified account mode and the user's account is not verified. */
  VerifiedAccount = 'VERIFIED_ACCOUNT'
}

/** Error type. */
export type SendExtensionMessageError = {
  __typename?: 'SendExtensionMessageError';
  /** Error code. */
  code: SendExtensionMessageErrorCode;
};

/** Possible error reasons returned by sendExtensionMessage mutation. */
export enum SendExtensionMessageErrorCode {
  /** Unauthorized. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Input to the sendExtensionMessage mutation. */
export type SendExtensionMessageInput = {
  /** The channelID the extension is active on. */
  channelID: Scalars['ID'];
  /** The type of the content. */
  contentType: Scalars['String'];
  /** A JWT token signed with the shared secret for this extension. */
  extAuthToken: Scalars['String'];
  /** The ID of the extension which is sending the message. */
  extensionID: Scalars['ID'];
  /** The content of the message to be sent. */
  message: Scalars['String'];
  /** The set of target message receievers to send to, e.g. "broadcast". */
  targets: Array<Scalars['String']>;
};

/** Payload returned from the sendExtensionMessage mutation. */
export type SendExtensionMessagePayload = {
  __typename?: 'SendExtensionMessagePayload';
  /** error, if any. */
  error?: Maybe<SendExtensionMessageError>;
  /** Information about what rate limits, if any, were applied to this send. */
  rateLimitsApplied?: Maybe<Array<SendExtensionMessageThrottleData>>;
};

/** Information about a rate limit throttle. */
export type SendExtensionMessageThrottleData = {
  __typename?: 'SendExtensionMessageThrottleData';
  /** Was the rate limit exceeded. */
  isLimitExceeded: Scalars['Boolean'];
  /** The limit itself. */
  limit: Scalars['String'];
  /** Name of the rate limiter applied. */
  rateLimiterName: Scalars['String'];
  /** How much quota remains. */
  remainingQuota: Scalars['Int'];
  /** Time when this rate limit will reset. */
  resetsAt?: Maybe<Scalars['Time']>;
};

/** Input for sending a highlighted chat message with Channel Points. */
export type SendHighlightedChatMessageInput = {
  /** The channel the message is being sent to. */
  channelID: Scalars['ID'];
  /** The client's perception of the reward's cost. */
  cost: Scalars['Int'];
  /** The user's message. */
  message: Scalars['String'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming the highlighted chat message reward. */
export type SendHighlightedChatMessagePayload = {
  __typename?: 'SendHighlightedChatMessagePayload';
  /** The user's new Channel Points balance. */
  balance?: Maybe<Scalars['Int']>;
  /** The error that occurred during redemption, if any. */
  error?: Maybe<SendCopoMessageError>;
  /** Whether the message was flagged by Automod and held for review. */
  isHeldByAutomod?: Maybe<Scalars['Boolean']>;
};

export type SendRoomMessageError = {
  __typename?: 'SendRoomMessageError';
  code: SendRoomMessageErrorCode;
  /** On SLOW_MODE_ENFORCEMENT_FAILED, USER_CHAT_TIMED_OUT: the number of remaining seconds user must wait before sending another message. */
  remainingDurationSeconds?: Maybe<Scalars['Int']>;
  /** On SLOW_MODE_ENFORCEMENT_FAILED: the number of seconds users must wait in between sending messages. */
  slowModeDurationSeconds?: Maybe<Scalars['Int']>;
};

export enum SendRoomMessageErrorCode {
  /** Message failed automod check. */
  AutoModEnforcementFailed = 'AUTO_MOD_ENFORCEMENT_FAILED',
  /** Room is in emotes only mode and message contained non-emote text. */
  EmoteOnlyModeEnforcementFailed = 'EMOTE_ONLY_MODE_ENFORCEMENT_FAILED',
  /** User not allowed to chat in room. */
  Forbidden = 'FORBIDDEN',
  /** Room is in R9K mode and message was not unique. */
  R9KModeEnforcementFailed = 'R9K_MODE_ENFORCEMENT_FAILED',
  /** User is rate limited. */
  RateLimitFailed = 'RATE_LIMIT_FAILED',
  /** Room is in slow mode and user tried to send a message to quickly. */
  SlowModeEnforcementFailed = 'SLOW_MODE_ENFORCEMENT_FAILED',
  /** Message failed spam check. */
  SpamEnforcementFailed = 'SPAM_ENFORCEMENT_FAILED',
  /** User is banned in the channel. */
  UserChatBanned = 'USER_CHAT_BANNED',
  /** User is timed out in the channel. */
  UserChatTimedOut = 'USER_CHAT_TIMED_OUT',
  /** User is suspended from Twitch. */
  UserSuspended = 'USER_SUSPENDED',
  /** Message contained zalgo characters. */
  ZalgoEnforcementFailed = 'ZALGO_ENFORCEMENT_FAILED'
}

export type SendRoomMessageInput = {
  message: Scalars['String'];
  /** Optional nonce which will be included in the pubsub event for this message. */
  nonce?: InputMaybe<Scalars['String']>;
  roomID: Scalars['ID'];
};

export type SendRoomMessagePayload = {
  __typename?: 'SendRoomMessagePayload';
  error?: Maybe<SendRoomMessageError>;
  message?: Maybe<RoomMessage>;
};

/** Error code for when a mutation fails. */
export type SendWhisperError = {
  __typename?: 'SendWhisperError';
  /** Error code for the failed whisper send. */
  code: SendWhisperErrorCode;
};

/** Possible errors returned by the sendWhisper mutation. */
export enum SendWhisperErrorCode {
  /** Message body is empty. */
  BodyEmpty = 'BODY_EMPTY',
  /** Whisper was not delivered for an unspecified reason. */
  NotDelivered = 'NOT_DELIVERED',
  /** Sender does not have a verified account. */
  SenderNotVerified = 'SENDER_NOT_VERIFIED',
  /** Target is banned. */
  TargetBanned = 'TARGET_BANNED',
  /** Target's settings prevent them from receiving message. */
  TargetRestricted = 'TARGET_RESTRICTED'
}

export type SendWhisperInput = {
  /** Message to send to user. */
  message: Scalars['String'];
  /** Random string generated by the client and should be unique across messages. */
  nonce: Scalars['String'];
  /** User to send a whisper to. */
  recipientUserID: Scalars['ID'];
};

export type SendWhisperPayload = {
  __typename?: 'SendWhisperPayload';
  /** If an error occurred, the error code. Otherwise null. */
  error?: Maybe<SendWhisperError>;
  /** The message that was sent, or null if there was an error. */
  message?: Maybe<WhisperMessage>;
};

/** Series metadata. */
export type SeriesDetails = {
  __typename?: 'SeriesDetails';
  /** Number of seasons. */
  seasonCount?: Maybe<Scalars['Int']>;
};

/** Sets the auto ad density for the channel. */
export type SetAutoAdDensityInput = {
  /** Input for auto ad length seconds. */
  autoAdLengthSeconds: Scalars['Int'];
  /** Input for auto ad period minutes. */
  autoAdPeriodMinutes: Scalars['Int'];
  /** Input for target ID of channel. */
  targetChannelID: Scalars['ID'];
};

/** Shows the newly updated values for autoad settings. */
export type SetAutoAdDensityPayload = {
  __typename?: 'SetAutoAdDensityPayload';
  /** The user whose channels ad density was set. */
  autoAdLengthSeconds?: Maybe<Scalars['Int']>;
  /** Auto ad period minutes. */
  autoAdPeriodMinutes?: Maybe<Scalars['Int']>;
  /** Input for target ID of channel. */
  targetChannelID?: Maybe<Scalars['ID']>;
};

/** Input for setting auto refill settings. */
export type SetAutoRefillSettingsInput = {
  /** The charge instrument information for starting a purchase. */
  chargeInstrument: ChargeInstrumentInput;
  /** The currency this should be charged in. */
  currency: Currency;
  /** The gross amount (of currency) that can be charged on the charge instrument. */
  grossAmount: Scalars['Int'];
  /** Optional id of the auto refill settings that are being modified. */
  id?: InputMaybe<Scalars['ID']>;
  /** Indicates if the profile is active. */
  isEnabled: Scalars['Boolean'];
  /** Id of the refill offer used on auto refill. */
  offerID: Scalars['ID'];
  /** The threshold amount a balance must go below to trigger a reload. */
  threshold: Scalars['Int'];
};

/** The payload for the set auto refill settings mutation. */
export type SetAutoRefillSettingsPayload = {
  __typename?: 'SetAutoRefillSettingsPayload';
  /** The changed auto refill profile. */
  autoRefillProfile?: Maybe<AutoRefillProfile>;
};

/** SetAutohostChannelsInput sets the user's list to autohost. */
export type SetAutohostChannelsInput = {
  /** ChannelIDs that will be on the list to autohost. */
  channelIDs: Array<Scalars['ID']>;
  /** UserID to update autohost list for. */
  userID: Scalars['ID'];
};

/** SetAutohostChannelsPayload returns the user whose autohostChannels field had been updated. */
export type SetAutohostChannelsPayload = {
  __typename?: 'SetAutohostChannelsPayload';
  /** User whose autohostChannels field had been updated. */
  user?: Maybe<User>;
};

/** Input for the set bits user settings mutation. */
export type SetBitsUserSettingsInput = {
  /** Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience. */
  abandonedFirstCheerTutorial?: InputMaybe<Scalars['Boolean']>;
  /** Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button. */
  skippedFirstCheerTutorial?: InputMaybe<Scalars['Boolean']>;
};

/** Payload for set bits user settings mutation. */
export type SetBitsUserSettingsPayload = {
  __typename?: 'SetBitsUserSettingsPayload';
  /** currentUser is the authenticated user object which includes the updated `Wallet` info after the message bits have been spent. */
  currentUser?: Maybe<User>;
};

export type SetChannelFeedEnabledInput = {
  /** The new desired value for channel_feed_enabled. */
  enabled: Scalars['Boolean'];
};

export type SetChannelFeedEnabledPayload = {
  __typename?: 'SetChannelFeedEnabledPayload';
  /** The user whose channel feed setting was toggled. */
  user: User;
};

export type SetChannelNotificationSettingInput = {
  category: Scalars['String'];
  channelID: Scalars['ID'];
  platform: Scalars['String'];
  settingState: Scalars['String'];
};

export type SetChannelNotificationSettingPayload = {
  __typename?: 'SetChannelNotificationSettingPayload';
  settingState: Scalars['String'];
};

/** SetChannelTrailerErrorCode are the types of errors that the setChannelTrailer mutation may return. */
export enum SetChannelTrailerErrorCode {
  /** The caller is not authorized to update the user's trailer settings. */
  Unauthorized = 'UNAUTHORIZED',
  /** The vod is longer than 60 seconds (max time for channel trailers). */
  VodTooLong = 'VOD_TOO_LONG'
}

/** Inputs to the setChannelTrailer mutation. */
export type SetChannelTrailerInput = {
  /** The channel whose trailer should be updated. */
  channelID: Scalars['ID'];
  /**
   * The ID of the video that should be used as the channel's trailer,
   * or null if the trailer should be cleared.
   */
  trailerVideoID?: InputMaybe<Scalars['ID']>;
};

/** Output of the setChannelTrailer mutation. */
export type SetChannelTrailerPayload = {
  __typename?: 'SetChannelTrailerPayload';
  /** The channel whose trailer vod was modified. */
  channel?: Maybe<Channel>;
  /** The error if the mutation failed in an expected way, or null if the mutation was successful. */
  error?: Maybe<SetChannelTrailerErrorCode>;
};

/** The required input to set a user's chat pause setting. */
export type SetChatPauseSettingInput = {
  /** The desired method for a user to pause chat. */
  chatPauseSetting: ChatPauseSetting;
};

/** Result of a setChatPauseSetting mutation. */
export type SetChatPauseSettingPayload = {
  __typename?: 'SetChatPauseSettingPayload';
  /** The newly saved chat pause setting. */
  chatPauseSetting?: Maybe<ChatPauseSetting>;
};

/** Update tags associated with CLIP, STREAM, or VOD with contentID. */
export type SetContentTagsInput = {
  /** ID of the channel owning the content. */
  authorID: Scalars['ID'];
  /** ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs. */
  contentID: Scalars['ID'];
  /** Type of content being returned. Can only be of values CLIP, STREAM, or VOD. */
  contentType: ContentType;
  /** List of tag IDs to be replaced from the content. */
  tagIDs: Array<Scalars['ID']>;
};

/** Result of mutation is the contentID. */
export type SetContentTagsPayload = {
  __typename?: 'SetContentTagsPayload';
  /** Content which tags have been updated. */
  content?: Maybe<TaggedContent>;
};

/** The input to be provided to the SetCreatorBadgeFlair mutation. */
export type SetCreatorBadgeFlairInput = {
  /** ID for channel to apply setting for. */
  channelID: Scalars['ID'];
  /** Setting to apply to channel setting for badge flair. */
  creatorBadgeFlair: CreatorBadgeFlairSetting;
};

export type SetCreatorBadgeFlairPayload = {
  __typename?: 'SetCreatorBadgeFlairPayload';
  /** Channel whose badge flair setting was updated. */
  channel?: Maybe<Channel>;
};

/** SetDashboardAlertQueueActivityStatusError is the error associated with SetDashboardAlertQueueActivityStatus. */
export type SetDashboardAlertQueueActivityStatusError = {
  __typename?: 'SetDashboardAlertQueueActivityStatusError';
  /** The associated error code. */
  code: SetDashboardAlertQueueActivityStatusErrorCode;
};

/** SetDashboardAlertQueueActivityStatusErrorCode are the possible errors that this mutation returns. */
export enum SetDashboardAlertQueueActivityStatusErrorCode {
  /** The input activity ID is invalid. */
  InvalidActivityId = 'INVALID_ACTIVITY_ID',
  /** The input alert status is invalid. */
  InvalidAlertStatus = 'INVALID_ALERT_STATUS',
  /** The input channel ID is invalid. */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** The alert is not found. */
  NotFound = 'NOT_FOUND'
}

/** Inputs to the SetDashboardAlertQueueActivityStatus mutation. */
export type SetDashboardAlertQueueActivityStatusInput = {
  /** The ID corresponding to the activity whose alert queue activity status should be updated. */
  activityID: Scalars['ID'];
  /** The value to set the status to. */
  alertStatus: DashboardActivityFeedActivityAlertStatus;
  /** The ID corresponding to the user whose alert queue activity status should be updated. */
  userID: Scalars['ID'];
};

/** Outputs from the SetDashboardAlertQueueActivityStatus mutation. */
export type SetDashboardAlertQueueActivityStatusPayload = {
  __typename?: 'SetDashboardAlertQueueActivityStatusPayload';
  /** The updated activity. */
  activity?: Maybe<DashboardActivityFeedActivity>;
  /** The possible error returned from the service. */
  error?: Maybe<SetDashboardAlertQueueActivityStatusError>;
};

/** SetDashboardAlertQueuePreferenceError is the error associated with SetDashboardAlertQueuePreference. */
export type SetDashboardAlertQueuePreferenceError = {
  __typename?: 'SetDashboardAlertQueuePreferenceError';
  /** The associated error code. */
  code: SetDashboardAlertQueuePreferenceErrorCode;
};

/** SetDashboardAlertQueuePreferenceErrorCode are the possible errors that this mutation returns. */
export enum SetDashboardAlertQueuePreferenceErrorCode {
  /** The input channel ID is invalid. */
  InvalidChannelId = 'INVALID_CHANNEL_ID'
}

/** Inputs to the SetDashboardAlertQueuePreference mutation. Only one of the boolean settings should be set at once. */
export type SetDashboardAlertQueuePreferenceInput = {
  /** If true, cannot publish alerts to the user. */
  shouldEnableDNDMode?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish bits alerts to the user. */
  shouldHideBits?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish follows alerts to the user. */
  shouldHideFollows?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish subscription gift alerts to the user. */
  shouldHideGiftSubscriptions?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish hosts alerts to the user. */
  shouldHideHosts?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish raids alerts to the user. */
  shouldHideRaids?: InputMaybe<Scalars['Boolean']>;
  /** If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown). */
  shouldHideSubscriptions?: InputMaybe<Scalars['Boolean']>;
  /** The ID corresponding to the user whose alert queue preference should be updated. */
  userID: Scalars['ID'];
};

/** Outputs from the SetDashboardAlertQueuePreference mutation. */
export type SetDashboardAlertQueuePreferencePayload = {
  __typename?: 'SetDashboardAlertQueuePreferencePayload';
  /** The possible error returned from the service. */
  error?: Maybe<SetDashboardAlertQueuePreferenceError>;
  /** The updated preferences for dashboard alert queue. */
  preferences?: Maybe<DashboardAlertQueuePreferences>;
};

/** Enumerates possible errors when setting a default payment method. */
export enum SetDefaultPaymentMethodErrorCode {
  /** User does not have permission to set default payment method for the targeted user. */
  Forbidden = 'FORBIDDEN',
  /** An internal error has occurred. */
  InternalError = 'INTERNAL_ERROR',
  /** One or more fields are invalid or missing. */
  InvalidRequest = 'INVALID_REQUEST',
  /** Must have auth credentials to set default payment method. */
  Unauthenticated = 'UNAUTHENTICATED'
}

/** The input to be provided to the setDefaultPaymentMethod mutation. */
export type SetDefaultPaymentMethodInput = {
  /** Country (ISO-3166) associated to the billing info for the customer's payment method. */
  billingCountry?: InputMaybe<Scalars['String']>;
  /** The last four digits of the user provided account number. */
  lastFour?: InputMaybe<Scalars['String']>;
  /** Payment type used via the payment provider. */
  paymentType: PaymentInstrumentType;
  /** The payment provider we're updating the payment method on. */
  provider: PaymentProvider;
  /** The token used to verify the selected payment method. */
  token: Scalars['String'];
  /** The user to set default payment method for. */
  userID: Scalars['ID'];
};

/** The result of the setDefaultPaymentMethod mutation. */
export type SetDefaultPaymentMethodPayload = {
  __typename?: 'SetDefaultPaymentMethodPayload';
  /** Code to describe error that occurred while setting the default payment method. */
  errorCode?: Maybe<SetDefaultPaymentMethodErrorCode>;
  /** User who had their payment method updated. */
  user?: Maybe<User>;
};

/** The required input to set a user's deleted message display setting. */
export type SetDeletedMessageDisplaySettingInput = {
  /** The desired deleted message display setting to be saved. */
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting;
};

/** Result of a setDeletedMessageDisplaySetting mutation. */
export type SetDeletedMessageDisplaySettingPayload = {
  __typename?: 'SetDeletedMessageDisplaySettingPayload';
  /** The newly saved deleted message display setting. */
  deletedMessageDisplaySetting?: Maybe<DeletedMessageDisplaySetting>;
};

/** SetDropBenefitsOnDropInput has fields required to update a drop's list of benefits. */
export type SetDropBenefitsOnDropInput = {
  /** The benefits that should be awarded when this drop is claimed. */
  benefitIDs: Array<Scalars['ID']>;
  /** The drop to update. */
  dropID: Scalars['ID'];
};

/** SetDropBenefitsOnDropPayload returns the result of the creation/update. */
export type SetDropBenefitsOnDropPayload = {
  __typename?: 'SetDropBenefitsOnDropPayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropCampaignAccessInput has fields required to update a campaign's access. */
export type SetDropCampaignAccessInput = {
  /** A list of channels that are allowed for this campaign. */
  allowedChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of channels that are blocked from this campaign. */
  blockedChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** The campaign ID. */
  campaignID: Scalars['ID'];
  /** Is the allowedChannels list in effect. Just having allowedChannels present does not mean the access list should be enabled. */
  isAllowedChannelsEnabled: Scalars['Boolean'];
  /** Is the blockedChannels list in effect. Just having blockedChannels present does not mean the block list should be enabled. */
  isBlockedChannelsEnabled: Scalars['Boolean'];
  /** A list of users that are able to view this campaign and functionalities while the campaign is in the testing state. */
  testViewers?: InputMaybe<Array<Scalars['ID']>>;
};

/** SetDropCampaignAccessPayload returns the result of the update. */
export type SetDropCampaignAccessPayload = {
  __typename?: 'SetDropCampaignAccessPayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropCampaignStatusInput has fields required to update a campaign's status. */
export type SetDropCampaignStatusInput = {
  /** The campaign ID. */
  campaignID: Scalars['ID'];
  /** The status the campaign should receive. */
  status: DropCampaignStatus;
};

/** SetDropCampaignStatusPayload returns the result of the creation/update. */
export type SetDropCampaignStatusPayload = {
  __typename?: 'SetDropCampaignStatusPayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropCampaignSummaryInput has fields required to update a campaign summary. */
export type SetDropCampaignSummaryInput = {
  /** The redirect URL where a user can link their account. */
  accountLinkURL: Scalars['String'];
  /** The campaign ID. */
  campaignID: Scalars['ID'];
  /** The type of a campaign defines what type of drops are allowed to be added to the campaign. */
  campaignType?: InputMaybe<CampaignType>;
  /** The description of this campaign. */
  description: Scalars['String'];
  /** The URL that links to the details / marketing page for this drop. */
  detailsURL: Scalars['String'];
  /** The date at which this campaign ends and all contained drops end at the latest. */
  endAt: Scalars['Time'];
  /** The game associated with this campaign. */
  gameID: Scalars['ID'];
  /** The name of the campaign. */
  name: Scalars['String'];
  /** This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops. */
  ownerID: Scalars['ID'];
  /** The date at which this campaign starts and all contained drops start the earliest. */
  startAt: Scalars['Time'];
};

/** SetDropCampaignSummaryPayload returns the result of the creation/update. */
export type SetDropCampaignSummaryPayload = {
  __typename?: 'SetDropCampaignSummaryPayload';
  /** Returns the created/updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropEventRuleInput has the fields required to set an event based rule on a drop. */
export type SetDropEventRuleInput = {
  /** How long the viewer has to claim their reward. */
  claimDurationSeconds: Scalars['Int'];
  /** The associated drop for the rule to update. */
  dropID: Scalars['ID'];
  /** The in-game conditions that must be met for the drop to trigger. */
  eventRules: Array<DropEventConditionInput>;
  /** A textual description of what has to occur for the drop to trigger. */
  questDescription: Scalars['String'];
  /** Name of the drop. */
  questName: Scalars['String'];
};

/** SetDropRulePayload returns the result of the rule creation. */
export type SetDropEventRulePayload = {
  __typename?: 'SetDropEventRulePayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropManualTriggerRuleInput has the fields required to set a manual trigger based rule on a drop. */
export type SetDropManualTriggerRuleInput = {
  /** How long the viewer has to claim their reward. */
  claimDurationSeconds: Scalars['Int'];
  /** The associated drop for the rule to update. */
  dropID: Scalars['ID'];
};

/** SetDropManualTriggerRulePayload returns the result of the rule creation. */
export type SetDropManualTriggerRulePayload = {
  __typename?: 'SetDropManualTriggerRulePayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropSummaryInput has fields required to update a drop's summary. */
export type SetDropSummaryInput = {
  /** The associated drop for the summary to update. */
  dropID: Scalars['ID'];
  /** The date at which this drop can no longer occur. */
  endAt?: InputMaybe<Scalars['Time']>;
  /** The friendly name of this drop. */
  name: Scalars['String'];
  /** The date at which this drop can start to occur. */
  startAt?: InputMaybe<Scalars['Time']>;
};

/** SetDrop2BenefitPayload returns the result of the creation/update. */
export type SetDropSummaryPayload = {
  __typename?: 'SetDropSummaryPayload';
  /** Returns the created/updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** SetDropTimeBasedRuleInput has fields required to update a drop's rule to a minutes watched based rule. */
export type SetDropTimeBasedRuleInput = {
  /** The associated drop for the rule to update. */
  dropID: Scalars['ID'];
  /** The ID of the drop that must be claimed before you can make progress on this drop. */
  preconditionDropID: Scalars['ID'];
  /** The amount of minutes a viewer must have watched before they can claim this drop. */
  requiredMinutesWatched: Scalars['Int'];
};

/** SetDropTimeBasedRulePayload returns the result of the rule update. */
export type SetDropTimeBasedRulePayload = {
  __typename?: 'SetDropTimeBasedRulePayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** The required input to set a user's emote animations setting. */
export type SetEmoteAnimationsEnabledInput = {
  /** Whether emote animations should be enabled for the current user. */
  isEmoteAnimationsEnabled: Scalars['Boolean'];
};

/** Result of a setEmoteAnimationsEnabled mutation. */
export type SetEmoteAnimationsEnabledPayload = {
  __typename?: 'SetEmoteAnimationsEnabledPayload';
  /** Whether emote animations are enabled for the current user. */
  isEmoteAnimationsEnabled?: Maybe<Scalars['Boolean']>;
};

/** The required input to set a user's emote animations setting callout dismissed. */
export type SetEmoteAnimationsSettingCalloutDismissedInput = {
  /** Whether the emote animations setting callout is dismissed by the user. */
  isEmoteAnimationsSettingCalloutDismissed: Scalars['Boolean'];
};

/** Result of a setEmoteAnimationsSettingCalloutDismissed mutation. */
export type SetEmoteAnimationsSettingCalloutDismissedPayload = {
  __typename?: 'SetEmoteAnimationsSettingCalloutDismissedPayload';
  /** Whether the emote animations setting callout is dismissed by the user. */
  isEmoteAnimationsSettingCalloutDismissed?: Maybe<Scalars['Boolean']>;
};

/** Possible errors from this mutation. */
export type SetEmoteModifierGroupsError = {
  __typename?: 'SetEmoteModifierGroupsError';
  /** Error code from the mutation. */
  code: SetEmoteModifierGroupsErrorCode;
};

/** Possible error codes from this mutation. */
export enum SetEmoteModifierGroupsErrorCode {
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** The provided input is invalid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Unknown error returned from service. */
  Unknown = 'UNKNOWN',
  /** The user is not authorized to set emote modifiers. */
  UserUnauthorized = 'USER_UNAUTHORIZED'
}

/** SetEmoteModifierGroupsInput is the input required when a creator sets their emote modifiers. */
export type SetEmoteModifierGroupsInput = {
  /** Emote modifier groups to set. */
  groups: Array<EmoteModifierGroupInput>;
};

/** The result of setting emote modifier groups for a user. */
export type SetEmoteModifierGroupsPayload = {
  __typename?: 'SetEmoteModifierGroupsPayload';
  /** Error from the mutation if it exists. */
  error?: Maybe<SetEmoteModifierGroupsError>;
  /** The modified emote groups that were set. */
  groups?: Maybe<Array<EmoteModifierGroupPayload>>;
};

/** SetExtensionConfigurationError returns an error code for the frontend to handle. */
export type SetExtensionConfigurationError = {
  __typename?: 'SetExtensionConfigurationError';
  /** The standardized code used by the frontend. */
  code: SetExtensionConfigurationErrorCode;
};

/** The standardized codes used by the frontend. */
export enum SetExtensionConfigurationErrorCode {
  /** User is unable to set the configuration. */
  Unauthorized = 'UNAUTHORIZED',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** The required input for a setExtensionConfiguration mutation. */
export type SetExtensionConfigurationInput = {
  /** The channel to which this configuration applies to. */
  channelID: Scalars['ID'];
  /** The version of the configuration. */
  configVersion: Scalars['String'];
  /** The configuration string to post. */
  content: Scalars['String'];
  /** The extension ID. */
  extensionID: Scalars['ID'];
};

/** SetExtensionConfiguration returns the Input as the extensions configuration endpoint returns a 204. */
export type SetExtensionConfigurationPayload = {
  __typename?: 'SetExtensionConfigurationPayload';
  /** The channel to which this configuration applies to. */
  channelID?: Maybe<Scalars['ID']>;
  /** The version of the configuration. */
  configVersion?: Maybe<Scalars['String']>;
  /** The configuration string to post. */
  content?: Maybe<Scalars['String']>;
  /** Error code for the frontend to handle. */
  error?: Maybe<SetExtensionConfigurationError>;
  /** The extension ID. */
  extensionID?: Maybe<Scalars['ID']>;
};

/** SetExtensionFeatureFlagsError is wrapper for error associated with the setExtensionFeatureFlags mutation. */
export type SetExtensionFeatureFlagsError = {
  __typename?: 'SetExtensionFeatureFlagsError';
  /** Error code. */
  code: SetExtensionFeatureFlagsErrorCode;
  /** The missing installation id if got EXTENSION_NOT_INSTALLED error. */
  missingInstallationID?: Maybe<Scalars['ID']>;
};

/** SetExtensionFeatureFlagsErrorCode is an error code associated with SetExtensionFeatureFlagsError. */
export enum SetExtensionFeatureFlagsErrorCode {
  /** The extension is not installed on the channel. */
  ExtensionNotInstalled = 'EXTENSION_NOT_INSTALLED',
  /** Channel id is invalid, for example, is empty. */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** The required input to set feature flags for an installation. */
export type SetExtensionFeatureFlagsInput = {
  /** Optional value to enable/disable chat for the specified installation. */
  canSendChat?: InputMaybe<Scalars['Boolean']>;
  /** Optional value to enable/disable bits for the specified installation. */
  canUseBits?: InputMaybe<Scalars['Boolean']>;
  /** Optional value for dynamicManagement flag on games. */
  dynamicManagement?: InputMaybe<Array<InputMaybe<ExtensionDynamicManagementInput>>>;
  /** The ID of the extension installation to set feature flags for. */
  id: Scalars['ID'];
};

/** The result of setting feature flags on an installation. */
export type SetExtensionFeatureFlagsPayload = {
  __typename?: 'SetExtensionFeatureFlagsPayload';
  /** The error when the mutation fails to set feature flags. */
  error?: Maybe<SetExtensionFeatureFlagsError>;
  /** The new state of the installation after the setExtensionFeatureFlags mutation. */
  installedExtension?: Maybe<ExtensionInstallation>;
};

/** The required input to set oauth on an installation. */
export type SetExtensionInstallationOAuthInput = {
  /** The installation ID we're setting the oauth token for. */
  id: Scalars['ID'];
  /** The OAuth token created for the extension. */
  oauthToken: Scalars['String'];
};

/** The resulting installedExtension state after setting OAuth. */
export type SetExtensionInstallationOAuthPayload = {
  __typename?: 'SetExtensionInstallationOAuthPayload';
  /** The new state of the installation after the setExtensionInstallationOAuth mutation. */
  installedExtension?: Maybe<ExtensionInstallation>;
};

/**
 * SetGameDropAccountLinkClientInput has fields necessary to update a game's account link
 * client ID used to verify a user has connected their in-game account.
 */
export type SetGameDropAccountLinkClientInput = {
  /** The client ID used to verify that users have linked their accounts properly. */
  clientID: Scalars['ID'];
  /** The ID of the game to link the client ID to. */
  gameID: Scalars['ID'];
};

/** SetGameDropAccountLinkClientPayload returns the result of the update. */
export type SetGameDropAccountLinkClientPayload = {
  __typename?: 'SetGameDropAccountLinkClientPayload';
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
  /** The updated game record. */
  game?: Maybe<Game>;
};

/** SetHeroAsAvatarError contains details about an error that occured when copying the hero to an avatar. */
export type SetHeroAsAvatarError = {
  __typename?: 'SetHeroAsAvatarError';
  /** The type of error that occured when copying the hero to the avatar. */
  code: SetHeroAsAvatarErrorCode;
};

/** SetHeroAsAvatarErrorCode defines a client error that occured while copying the hero to an avatar. */
export enum SetHeroAsAvatarErrorCode {
  /** The requesting user did not have permission to update the avatar. */
  Forbidden = 'FORBIDDEN',
  /** Some other unexpected error occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/**
 * SetHeroAsAvatarInput contains the parameters to copy the user's hero to their avatar.
 * no parameters are required, because this mutation copies the requesting user's hero to
 * the requesting user's avatar, but we're passing the heroID here
 * because of a bug in the way `make check` works.
 */
export type SetHeroAsAvatarInput = {
  /** The ID of the hero to copy to its owning user's profile picture. */
  heroID: Scalars['ID'];
};

/** SetHeroAsAvatarPayload is the response after setting the avatar. */
export type SetHeroAsAvatarPayload = {
  __typename?: 'SetHeroAsAvatarPayload';
  /**
   * The error that occured.
   * Null if the operation was successful.
   */
  error?: Maybe<SetHeroAsAvatarError>;
  /** The user object post mutation - null if error. */
  user?: Maybe<User>;
};

/** The required input to set a role's moderator logs' access. */
export type SetModLogsAccessInput = {
  /** The access level to moderator logs to be given to the role. */
  accessLevel: ModLogsAccessLevel;
  /** The Channel for which to set moderator log access. */
  channelID: Scalars['ID'];
  /** The user role for which to set the moderator log access permission. */
  channelRole: ChannelUserRole;
};

/** Result of a setModLogsAccess mutation. */
export type SetModLogsAccessPayload = {
  __typename?: 'SetModLogsAccessPayload';
  /** The access level of the role set. */
  modLogsAccess?: Maybe<ModLogsAccess>;
};

/** The required input to set a user's mod view settings relating to turorial. */
export type SetModViewSettingsInput = {
  /** The time the tutorial on the mod view page was seen. */
  tutorialSeenAt: Scalars['Time'];
  /** The viewed state of the tutorial on the mod view page. */
  tutorialState: TutorialState;
};

/** Result of a setModViewSettings mutation. */
export type SetModViewSettingsPayload = {
  __typename?: 'SetModViewSettingsPayload';
  /** The newly resolved modviewsettings resolver. */
  modViewSettings?: Maybe<ModViewSettings>;
};

export type SetNotificationSettingInput = {
  category: Scalars['String'];
  platform: Scalars['String'];
  settingState: Scalars['String'];
};

export type SetNotificationSettingPayload = {
  __typename?: 'SetNotificationSettingPayload';
  settingState: Scalars['String'];
};

/** SetOverwatchLeagueTeamPreferenceInput contains the OverwatchLeagueTeamPreference ID to set. */
export type SetOverwatchLeagueTeamPreferenceInput = {
  /** The channelID from the channel this event is taking place on. */
  OverwatchTeamPreferenceOptionID: Scalars['ID'];
};

/**
 * SetOverwatchLeagueTeamPreferencePayload is the success response for setting an Overwatch League Team preference, and
 * the corresponding updated OverwatchLeagueTeamPreference struct.
 */
export type SetOverwatchLeagueTeamPreferencePayload = {
  __typename?: 'SetOverwatchLeagueTeamPreferencePayload';
  /** A possible error returned from the service. */
  error?: Maybe<SetOverwatchTeamPreferenceError>;
  /** The updated OverwatchLeagueTeamPreference struct. */
  overwatchLeagueTeamPreference?: Maybe<OverwatchLeagueTeamPreference>;
};

/** Error code for an error that occurs while claiming the bounty. */
export type SetOverwatchTeamPreferenceError = {
  __typename?: 'SetOverwatchTeamPreferenceError';
  /** Error code for error that occurred while claiming the bounty. */
  code: SetOverwatchTeamPreferenceErrorCode;
};

/** Error types recognized by the SetOverwatchLeagueTeamPreference mutation. */
export enum SetOverwatchTeamPreferenceErrorCode {
  /** Unknown error being returned from service. */
  Unknown = 'UNKNOWN'
}

/** The required input for a setPreferredLanguageTag mutation. */
export type SetPreferredLanguageTagInput = {
  /** The preferred language tag to set onto the user. */
  preferredLanguageTag: LanguageTag;
  /** The user to modify. */
  userID: Scalars['ID'];
};

/** The result of a setPreferredLanguageTag mutation. */
export type SetPreferredLanguageTagPayload = {
  __typename?: 'SetPreferredLanguageTagPayload';
  /** The user whose preferred language tag was changed. */
  user?: Maybe<User>;
};

/** Error from a failed currently playing track mutation. */
export type SetRadioCurrentlyPlayingError = {
  __typename?: 'SetRadioCurrentlyPlayingError';
  /** Mutation error code. */
  code?: Maybe<SetRadioCurrentlyPlayingErrorCode>;
};

/** Currently playing error codes. */
export enum SetRadioCurrentlyPlayingErrorCode {
  /** The ID provided was malformed. */
  InvalidId = 'INVALID_ID',
  /** No record found for the request params. */
  NoRecord = 'NO_RECORD',
  /** Permission denied to add/update a currently playing item. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** The required input to set radio track information currently being played. */
export type SetRadioCurrentlyPlayingInput = {
  /** The type of content the ID maps to. */
  contentType?: InputMaybe<RadioCurrentlyPlayingType>;
  /** Whether the track is currently playing or not. */
  isCurrentlyPlaying: Scalars['Boolean'];
  /** The ID of the source. */
  sourceID?: InputMaybe<Scalars['ID']>;
  /** The ID of the currently playing track. */
  trackID?: InputMaybe<Scalars['ID']>;
};

/** Result of a setRadioCurrentlyPlaying mutation. */
export type SetRadioCurrentlyPlayingPayload = {
  __typename?: 'SetRadioCurrentlyPlayingPayload';
  /** The currently playing radio track addition result. */
  currentTrack?: Maybe<RadioCurrentTrackResponse>;
  /** Error code. */
  error?: Maybe<SetRadioCurrentlyPlayingError>;
};

/** The required input to set a user's readable chat colors setting. */
export type SetReadableChatColorsEnabledInput = {
  /** Whether readable chat colors should be enabled for the current user. */
  isReadableChatColorsEnabled: Scalars['Boolean'];
};

/** Result of a setReadableChatColorsEnabled mutation. */
export type SetReadableChatColorsEnabledPayload = {
  __typename?: 'SetReadableChatColorsEnabledPayload';
  /** Whether readable chat colors are enabled for the current user. */
  isReadableChatColorsEnabled: Scalars['Boolean'];
};

/** SetResourceRestrictionInput sets a restriction for the given resourceID. */
export type SetResourceRestrictionInput = {
  /** The ID of the resource to set the restriction on. */
  resourceID: Scalars['ID'];
  /** The type of resource that will be restricted. */
  resourceType: RestrictionResource;
  /** The restriction options, if any, to apply to the restriction being created. */
  restrictionOptions?: InputMaybe<Array<ResourceRestrictionOption>>;
  /** The type of restriction that should be placed onto the channel. If empty, the restriction will be deleted. */
  restrictionType?: InputMaybe<ResourceRestrictionType>;
};

/** SetResourceRestrictionPayload returns the updated restriction for a channel. */
export type SetResourceRestrictionPayload = {
  __typename?: 'SetResourceRestrictionPayload';
  /** The channel if a live resource restriction was updated. */
  channel?: Maybe<Channel>;
  /** The stream if a live resource restriction was updated. */
  stream?: Maybe<Stream>;
  /** The video if a video resource restriction was updated. */
  video?: Maybe<Video>;
};

/** An error that has been mapped from a Reminder service twirp error. Can sometimes include messages. */
export type SetScheduleReminderError = {
  __typename?: 'SetScheduleReminderError';
  /** The error code. */
  code: SetScheduleReminderErrorCode;
  /** The error message string. */
  message?: Maybe<Scalars['String']>;
};

/** Enum for set schedule reminders errors. */
export enum SetScheduleReminderErrorCode {
  /** The schedule segment you're attempting to set a reminder for was cancelled. */
  FailedPrecondition = 'FAILED_PRECONDITION',
  /** The request for setting a reminder was invalid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The schedule segment you're attempting to set a reminder for was not found. */
  NotFound = 'NOT_FOUND',
  /** The error code is unknown. */
  Unknown = 'UNKNOWN'
}

/** SetScheduleReminderInput has fields required to set a schedule event reminder. */
export type SetScheduleReminderInput = {
  /** The ID of the segment to set a reminder for. */
  segmentID: Scalars['ID'];
  /** Whether the reminder should be enabled or disabled. */
  shouldEnable: Scalars['Boolean'];
};

/** SetScheduleReminderPayload returns the result of the creation/update. */
export type SetScheduleReminderPayload = {
  __typename?: 'SetScheduleReminderPayload';
  /** A mapped error returned by the Reminder service. */
  error?: Maybe<SetScheduleReminderError>;
  /** The new reminder state, if operation completed with no error. */
  isEnabled?: Maybe<Scalars['Boolean']>;
};

/**
 * SetSessionStatusInput represents a user's status within a single session (browser tab, game, desktop application,
 * mobile application, etc.).
 */
export type SetSessionStatusInput = {
  /**
   * activity is the action the user is performing in your application. The purpose of an activity is to allow the user's
   * friends and related users to join in on whatever the user is doing. If the user is not performing any action that
   * other users can join in on (e.g. watching a VOD, browsing their settings page) or is not performing any action at
   * all, this should be set to null.
   */
  activity?: InputMaybe<ActivityInput>;
  /**
   * availability is the state of the user's session in your application. You should set it to ONLINE if the user is
   * known to be at their device, IDLE if they are not, and OFFLINE if your application is currently terminating.
   *
   * Note that if your application fails to send an OFFLINE heartbeat before terminating, the session will automatically
   * expire after some time without a heartbeat.
   */
  availability: AvailabilityInput;
  /**
   * sessionID must be supplied and can be any string unique to this session. Generating a random UUID when your
   * application starts and sending it for each setSessionStatus is a good idea.
   *
   * Each instance of your application should send the same ID for each of its setSessionStatus calls, but two instances
   * of your application running at the same time should never have the same session ID.
   */
  sessionID: Scalars['String'];
};

export type SetSessionStatusPayload = {
  __typename?: 'SetSessionStatusPayload';
  /**
   * The number of seconds your application should wait before sending another setSessionStatus. If your application does
   * not call setSessionStatus again within roughly this duration, it will be assumed to have terminated unexpectedly and
   * its session status for this user will expire.
   */
  setAgainInSeconds: Scalars['Int'];
  /** The modified user. */
  user?: Maybe<User>;
};

/** Inputs to the setSquadStreamPrimaryPlayer mutation. */
export type SetSquadStreamPrimaryPlayerInput = {
  /** ID of the device viewing squad stream. */
  deviceID: Scalars['ID'];
  /** ID of the channel as the current primary player. */
  primaryPlayerID: Scalars['ID'];
  /** ID of the squad stream. */
  squadID: Scalars['ID'];
};

/** Outputs to the setSquadStreamPrimaryPlayer mutation. */
export type SetSquadStreamPrimaryPlayerPayload = {
  __typename?: 'SetSquadStreamPrimaryPlayerPayload';
  /** The current primary player of the squad stream. */
  primaryPlayer?: Maybe<User>;
};

/** Error from set unban requests settings mutation. */
export type SetUnbanRequestsSettingsError = {
  __typename?: 'SetUnbanRequestsSettingsError';
  /** Error code from the set unban requests settings mutation. */
  code: SetUnbanRequestsSettingsErrorCode;
};

/** Error codes for from set unban requests settings mutation. */
export enum SetUnbanRequestsSettingsErrorCode {
  /** User attempted to set with an invalid value. */
  InvalidValue = 'INVALID_VALUE',
  /** User is not authorized to set unban request settings on the channel. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Required input to set unban requests settings on a channel. */
export type SetUnbanRequestsSettingsInput = {
  /** The channel on which to update settings for. */
  channelID: Scalars['ID'];
  /** The amount of time after a ban before an unban request can be made. */
  cooldownMinutes: Scalars['Int'];
  /** Whether unban requests are allowed to be created on the channel. */
  isEnabled: Scalars['Boolean'];
};

/** Result of setting a channel's unban requests settings. */
export type SetUnbanRequestsSettingsPayload = {
  __typename?: 'SetUnbanRequestsSettingsPayload';
  /** Error from attempting to set unban requests settings. */
  error?: Maybe<SetUnbanRequestsSettingsError>;
  /** The updated settings on the channel. */
  settings?: Maybe<UnbanRequestsSettings>;
};

/** SetUserResidenceInput is input required to set a user's residence. */
export type SetUserResidenceInput = {
  /** User's country in ISO alpha-2. */
  countryCode: Scalars['String'];
  /** Target user for setting residence. */
  userID: Scalars['ID'];
  /** User's zip code. */
  zipCode?: InputMaybe<Scalars['String']>;
};

/** SetUserResidencePayload is the response from the SetUserResidence mutation. */
export type SetUserResidencePayload = {
  __typename?: 'SetUserResidencePayload';
  /** User whose residence was set for. */
  user?: Maybe<User>;
};

export type Share = {
  __typename?: 'Share';
  /** The user that created this share. */
  author?: Maybe<User>;
  /** Time the share was created by the user. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Share ID. */
  id: Scalars['ID'];
  /** The item that was shared. */
  target?: Maybe<ShareTarget>;
};

export type ShareTarget = Clip | Post | Stream | Video;

/** An ordered list of content to render with metadata on the content. */
export type Shelf = {
  __typename?: 'Shelf';
  /** The ordered content for the shelf. */
  content: ShelfContentConnection;
  /** How to present the content in the shelf. */
  displayType: Scalars['String'];
  /** A unique identifier for the shelf for use in tracking and pagination. */
  id: Scalars['ID'];
  /** The title for the shelf. */
  title: ShelfTitle;
  /** Information used for recommendation tracking. */
  trackingInfo: TrackingInfo;
};

/**
 * Paginated list of Shelves. (pagination not yet implemented)
 * Implements the Relay cursor connections specification.
 * See: https://facebook.github.io/relay/graphql/connections.htm.
 */
export type ShelfConnection = {
  __typename?: 'ShelfConnection';
  /** The list of shelves to display. */
  edges?: Maybe<Array<ShelfEdge>>;
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  pageInfo: PageInfo;
};

/** The content to render in a shelf. */
export type ShelfContent = Clip | Game | Stream | Tag | Video;

/** The list of content to render in a shelf. */
export type ShelfContentConnection = {
  __typename?: 'ShelfContentConnection';
  /** The list of content to display. */
  edges?: Maybe<Array<ShelfContentEdge>>;
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  pageInfo: PageInfo;
};

/** The content to render in a shelf. */
export type ShelfContentEdge = {
  __typename?: 'ShelfContentEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The metadata to show for each content edge. */
  metadata?: Maybe<ShelfContentMetadata>;
  /** The underlying content to render. */
  node?: Maybe<ShelfContent>;
  /** Used to associate promotions for tracking. */
  promotionsCampaignID: Scalars['ID'];
  /** Used to determine what the source of the shelf content is from. */
  sourceType: SourceType;
  /** Used in client tracking. */
  trackingID: Scalars['ID'];
};

/** The metadata for content to render in a shelf. */
export type ShelfContentMetadata = {
  __typename?: 'ShelfContentMetadata';
  /** Whether the content has a live event. */
  hasLive: Scalars['Boolean'];
  /** The localized subtitle for a content item in a shelf. */
  subtitle?: Maybe<ShelfTitle>;
  /** The localized title for a content item in a shelf. */
  title: ShelfTitle;
};

/**
 * Contains information about a Shelf's relationship to a given page (connection),
 * and the Shelf itself.
 */
export type ShelfEdge = {
  __typename?: 'ShelfEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The shelf. */
  node: Shelf;
};

/** The title for the shelf. */
export type ShelfTitle = {
  __typename?: 'ShelfTitle';
  /** A resource to interpolate into the title string. */
  context?: Maybe<ShelfTitleContext>;
  /** The fallback localized title, only to be used if client fails to parse the localizedTitleTokens. */
  fallbackLocalizedTitle: Scalars['String'];
  /** The name of the shelf being presented, used for backwards compatibility. Allows for localization and interpolation. */
  key: Scalars['String'];
  /** The localized shelf title in the form of a list of tokens. */
  localizedTitleTokens: Array<Maybe<TitleTokenEdge>>;
};

/** Metadata used to render the shelf title. */
export type ShelfTitleContext = Game;

/** A set of options for configuring which shelf data to return to the user. */
export type ShelvesAvailableOptions = {
  /**
   * The ID of the collection. Only valid when shelfType is set to
   * VideoShelfType.COLLECTION.
   */
  collectionID?: InputMaybe<Scalars['ID']>;
  /**
   * The ID of the game shelf to query. Only valid when shelfType is set to
   * VideoShelfType.GAME_VIDEOS.
   */
  gameID?: InputMaybe<Scalars['ID']>;
  /**
   * Which shelf type to query. Currently required.
   * In future, omitting this option returns all valid shelves.
   */
  shelfType?: InputMaybe<VideoShelfType>;
};

/** A set of options to configuring how the shelves data is returned to the consumer. */
export type ShelvesOptions = {
  /** Should indicate whether the response includes empty shelves. */
  includeEmpty?: InputMaybe<Scalars['Boolean']>;
};

/** A short video from a ShortVideoFeed and its relevant metadata. */
export type ShortVideo = {
  __typename?: 'ShortVideo';
  /** The actual short form video content to display. */
  content?: Maybe<ShortVideoContent>;
  /** The ID of the short form video. */
  id: Scalars['ID'];
  /** All of the reactions on this short form video. */
  reactions: Array<ShortVideoReaction>;
};

/** All of the different content types that make up "short form video". */
export type ShortVideoContent = Clip;

/** A paginated list of short videos. */
export type ShortVideoFeedConnection = {
  __typename?: 'ShortVideoFeedConnection';
  /** The list edges contain ShortVideoFeedEdges with pagination information. */
  edges: Array<ShortVideoFeedEdge>;
  /** Information about pagination in this connection. */
  pageInfo: PageInfo;
};

/** An element in a paginated list of short videos. */
export type ShortVideoFeedEdge = {
  __typename?: 'ShortVideoFeedEdge';
  /** Uniquely identifies this item's position in a connection. */
  cursor: Scalars['Cursor'];
  /** The short video. */
  node?: Maybe<ShortVideo>;
};

/** Options used to determine the content returned in the short video feed. */
export type ShortVideoFeedOptions = {
  /** The platform of the viewer -- used to curate content in the feed. */
  platform?: InputMaybe<ShortVideoFeedPlatform>;
  /** The type of short video feed to return. */
  type?: InputMaybe<ShortVideoFeedType>;
};

/** The platform from which the short video feed is requested. */
export enum ShortVideoFeedPlatform {
  /** The Android app. */
  Android = 'ANDROID',
  /** The iOS app. */
  Ios = 'IOS',
  /** The mobile web site. */
  MobileWeb = 'MOBILE_WEB'
}

/** The type of short form video feed. */
export enum ShortVideoFeedType {
  /** Return a video feed based off the channels the user is following. */
  Following = 'FOLLOWING',
  /** Return a video feed based off an recommendations model. */
  Recommended = 'RECOMMENDED'
}

/** An aggregated counter for the contained emote to display how many reactions to a ShortVideo there have been. */
export type ShortVideoReaction = {
  __typename?: 'ShortVideoReaction';
  /** The number of times this emote has been used to react to this video. */
  count: Scalars['Int'];
  /** The emote that was used to react. */
  emote?: Maybe<Emote>;
  /** The ID is the same as emote.ID. */
  id: Scalars['ID'];
};

/** The type representing Community Points Smart Costs Acknowledgements. */
export type SmartCostsAcknowledgement = {
  __typename?: 'SmartCostsAcknowledgement';
  /** The last acknowledged cost. */
  lastAcknowledgedCost: Scalars['Int'];
  /** The type of automatic reward the smart costs acknowledgement is for. */
  rewardType: CommunityPointsAutomaticRewardType;
};

/** The input representing Community Points Smart Costs Acknowledgements. */
export type SmartCostsAcknowledgementInput = {
  /** The last acknowledged cost. */
  lastAcknowledgedCost: Scalars['Int'];
  /** The type of automatic reward the smart costs acknowledgement is for. */
  rewardType: CommunityPointsAutomaticRewardType;
};

/** Wrapper around the standard emoticon groups for Prime Emoticons. */
export type SmiliesSet = {
  __typename?: 'SmiliesSet';
  /** The list of emotes which belong to this set. */
  emotes?: Maybe<Array<Emote>>;
  /** ID for the current smilies set. */
  id?: Maybe<Scalars['ID']>;
};

/** A social media item that is an attribute of Channel. */
export type SocialMedia = {
  __typename?: 'SocialMedia';
  /** The social media's unique identifier. */
  id: Scalars['ID'];
  /** The name of the domain which will be used to determine which favicon to render. */
  name?: Maybe<Scalars['String']>;
  /** The label displayed to the client. */
  title: Scalars['String'];
  /** The web address to a social media website. */
  url: Scalars['String'];
};

export type SocialStream = RecommendedStream & {
  __typename?: 'SocialStream';
  /** The friend who generated the recommendation. */
  friend?: Maybe<User>;
  /** The recommended stream. */
  stream?: Maybe<Stream>;
  /** The type of recommendation. Different types contain different metadata about why the recommendation was made. */
  type?: Maybe<StreamRecommendationType>;
};

/** Sort direction. */
export enum SortOrder {
  /** Ascending (A-Z, 1-9). */
  Asc = 'ASC',
  /** Descending (Z-A, 9-1). */
  Desc = 'DESC'
}

/** The type of source the shelf content is coming from. */
export enum SourceType {
  /** The target source is from a boost promotional campaign. */
  CommunityBoost = 'COMMUNITY_BOOST',
  /** The target source is from a fallback candidate. */
  Popular = 'POPULAR',
  /** The target source is from promotional campaign that is free. */
  Promotion = 'PROMOTION',
  /** The target source is from recommendations. */
  Recommended = 'RECOMMENDED',
  /** The target source is from a promotional campaign that is paid. */
  Sponsored = 'SPONSORED',
  /** The target source is unknown so we default to UNKNOWN. */
  UnknownSourceType = 'UNKNOWN_SOURCE_TYPE'
}

/** Error returned when attempting to spend subscription credit. */
export type SpendSubscriptionCreditError = {
  __typename?: 'SpendSubscriptionCreditError';
  /** Error code for error that occured while attempting to spend subscription credit. */
  code: SpendSubscriptionCreditErrorCode;
};

/** Possible error codes returned when attempting to spend subscription credit. */
export enum SpendSubscriptionCreditErrorCode {
  /** Occurs if a Twitch Prime user attempts to spend multiple times, acting as a flag for fraud. */
  TooManyRecentSpends = 'TOO_MANY_RECENT_SPENDS',
  /** Occurs if a Twitch Prime user attempts to spend subscription credit that is (still) unavailable. */
  UnableToSpend = 'UNABLE_TO_SPEND'
}

/** Input requires the broadcaster to be payed and user to deduct credit. */
export type SpendSubscriptionCreditInput = {
  /** The user id of streamer being subscribed to. */
  broadcasterID: Scalars['String'];
  /** Twitch user ID. */
  userID: Scalars['ID'];
};

/** Mutated data after spending the subscription credit. */
export type SpendSubscriptionCreditPayload = {
  __typename?: 'SpendSubscriptionCreditPayload';
  /** Possible error returned from the service. */
  error?: Maybe<SpendSubscriptionCreditError>;
  /** The modified subscription benefit data. */
  subscriptionBenefit?: Maybe<SubscriptionBenefit>;
  /** Twitch user ID. */
  userID: Scalars['ID'];
};

/** The connection of sponsored cheermote channel settings to user. */
export type SponsoredCheermoteChannelSettingsConnection = {
  __typename?: 'SponsoredCheermoteChannelSettingsConnection';
  /** The list of key pool edges associated with the user. */
  edges: Array<SponsoredCheermoteChannelSettingsEdge>;
  /** The metadata about having more key pools to fetch, or if there is a previous page of key pools. */
  pageInfo: PageInfo;
  /** The total number of key pools for the given user. */
  totalCount: Scalars['Int'];
};

/** The sponsored cheermote channel settings edge which contains our cursor and node. */
export type SponsoredCheermoteChannelSettingsEdge = {
  __typename?: 'SponsoredCheermoteChannelSettingsEdge';
  /** The cursor of the edge, which is also the key pool ID. */
  cursor: Scalars['Cursor'];
  /** The node of the edge, which contains all information about the key pool. */
  node?: Maybe<SponsoredCheermoteChannelSettingsNode>;
};

/** The information associated with a given sponsored cheermote channel setting. */
export type SponsoredCheermoteChannelSettingsNode = {
  __typename?: 'SponsoredCheermoteChannelSettingsNode';
  /** Brand's image to display, in the form of a URL. */
  brandImageURL: Scalars['String'];
  /** Brand name to display. */
  brandName: Scalars['String'];
  /** Time the campaign ends. */
  endTime: Scalars['Time'];
  /** The campaign ID, which is unique. */
  id: Scalars['ID'];
  /** The opt in status of the campaign. */
  isOptedIn: Scalars['Boolean'];
  /** Time the campaign starts. */
  startTime: Scalars['Time'];
  /** Thresholds for matching on sponsored cheering. */
  thresholds: Array<CheermoteCampaignThreshold>;
};

/**
 * A squad stream represents a group of broadcasters that are streaming together.  When a squad
 * stream is live, viewers can opt to watch the streams of all its members together from a
 * single view.
 *
 * Squad streams are created by a broadcaster who invites other broadcasters to participate.
 * Each broadcaster who accepts an invitation becomes a member of the squad stream and can also
 * invite other broadcasters to participate.  At the moment, a squad stream can have up to
 * four members and a broadcaster can only belong to a single squad stream.
 *
 * A squad stream ends when all its members leave or stop streaming.
 */
export type SquadStream = {
  __typename?: 'SquadStream';
  /** The ID of the squad stream. */
  id: Scalars['ID'];
  /** The invitations with the given status that have been sent by members to other users to join to squad stream. */
  invitations?: Maybe<Array<SquadStreamInvitation>>;
  /** Broadcasters who are currently participating in the squad stream. */
  members?: Maybe<Array<User>>;
  /** The owner can remove members from the squad stream. */
  owner?: Maybe<User>;
  /** The current status of the squad stream. */
  status: SquadStreamStatus;
};


/**
 * A squad stream represents a group of broadcasters that are streaming together.  When a squad
 * stream is live, viewers can opt to watch the streams of all its members together from a
 * single view.
 *
 * Squad streams are created by a broadcaster who invites other broadcasters to participate.
 * Each broadcaster who accepts an invitation becomes a member of the squad stream and can also
 * invite other broadcasters to participate.  At the moment, a squad stream can have up to
 * four members and a broadcaster can only belong to a single squad stream.
 *
 * A squad stream ends when all its members leave or stop streaming.
 */
export type SquadStreamInvitationsArgs = {
  status: SquadStreamInvitationStatus;
};

/** Determines who can send the user invitations to join a squad stream. */
export enum SquadStreamIncomingInvitePolicy {
  /** This user can receive invitations from anyone. */
  All = 'ALL',
  /** This user can receive invitations from friends, teammates and followed channels. */
  Network = 'NETWORK',
  /** This user should never receive invitations. */
  None = 'NONE'
}

/**
 * SquadStreamInvitation represents an invitation sent by a member of a squad stream to another user to
 * join the squad stream.
 */
export type SquadStreamInvitation = {
  __typename?: 'SquadStreamInvitation';
  /** When the invitation was created. */
  createdAt: Scalars['Time'];
  /** ID of the invitation. */
  id: Scalars['ID'];
  /** Network type of the invitation. This field is only non nil when the invitation is fetched for User.IncomingSquadStreamInvitations. */
  networkType?: Maybe<SquadStreamInvitationNetworkType>;
  /** If the invitation's status is rejected, the reason for the rejection. */
  reasonRejected?: Maybe<SquadStreamInvitationRejectedReason>;
  /** The user that the invitation is sent to. */
  recipient?: Maybe<User>;
  /** The user that sent the invitation. */
  sender?: Maybe<User>;
  /** The squad stream that the recipient is invited to join. */
  squadStream?: Maybe<SquadStream>;
  /** The status of the invitation. */
  status: SquadStreamInvitationStatus;
};

/** List of Squad Stream invitations. */
export type SquadStreamInvitationConnection = {
  __typename?: 'SquadStreamInvitationConnection';
  /** The elements of the list. */
  nodes?: Maybe<Array<SquadStreamInvitation>>;
  /** The total count of invitations. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Describes the network type of a squad stream invitation. */
export enum SquadStreamInvitationNetworkType {
  /** The invitation is from within the recipient's network (friends, teammates and followed channels). */
  InNetwork = 'IN_NETWORK',
  /** The invitation is from outside of the recipient's network. */
  OutOfNetwork = 'OUT_OF_NETWORK'
}

/** Describes the reason a squad stream invitation was rejected. */
export enum SquadStreamInvitationRejectedReason {
  /** The recipient cannot access the squad stream product (e.g. due to missing transcode, partner-only launch). */
  RecipientCannotAccessSquadStream = 'RECIPIENT_CANNOT_ACCESS_SQUAD_STREAM',
  /** The recipient does not allow the sender of the invitation to invite them (e.g. due to their squad stream settings). */
  RecipientCannotBeInvited = 'RECIPIENT_CANNOT_BE_INVITED',
  /** The recipient rejected the invitation. */
  RecipientRejected = 'RECIPIENT_REJECTED'
}

/** Describes the current state of a squad stream invitation. */
export enum SquadStreamInvitationStatus {
  /** The recipient has accepted the invitation. */
  Accepted = 'ACCEPTED',
  /** A squad stream owner has deleted the invitation. */
  Deleted = 'DELETED',
  /** The invitation has been sent to the recipient and the sender is waiting for a response. */
  Pending = 'PENDING',
  /** The recipient has rejected the invitation. */
  Rejected = 'REJECTED',
  /** The invitation has an unknown status. */
  Unknown = 'UNKNOWN'
}

/** A user's squad stream settings. */
export type SquadStreamSettings = {
  __typename?: 'SquadStreamSettings';
  /**
   * Denotes whether or not a user can access squad management features like
   * accepting/receiving invites and viewing the Squad Stream dashboard widget.
   */
  canAccessSquads: Scalars['Boolean'];
  /**
   * Determines who can send the user invitations to join a squad stream.
   * Resolves for anyone who can access the user's dashboard (editors, staff, etc.).
   */
  incomingInvitePolicy?: Maybe<SquadStreamIncomingInvitePolicy>;
};

/** Describes the status of a squad stream. */
export enum SquadStreamStatus {
  /** The squad stream has ended. */
  Ended = 'ENDED',
  /** The squad stream is live and is being broadcast to viewers. */
  Live = 'LIVE',
  /** The squad stream is being set up, and should not be shown to viewers. */
  Pending = 'PENDING',
  /** The squad stream has an unknown status. */
  Unknown = 'UNKNOWN'
}

/** StartAdError ... */
export type StartAdError = {
  __typename?: 'StartAdError';
  /** code is the code for the error that occurs while trying to run an ad break. */
  code: StartAdErrorCode;
  /** retryAfterSeconds is the amount of time in seconds remaining before user can run another ad. */
  retryAfterSeconds?: Maybe<Scalars['Int']>;
};

/** StartAdErrorCode ... */
export enum StartAdErrorCode {
  /** The user has requested an ad break before the rate limit timer has expired. */
  RateLimited = 'RATE_LIMITED',
  /** An unknown error occured while trying to run an ad break. */
  UnknownError = 'UNKNOWN_ERROR',
  /** The user is not authorized to run an ad break on the requested channel. */
  UserNotAuthorized = 'USER_NOT_AUTHORIZED'
}

/** StartAdInput ... */
export type StartAdInput = {
  /** channelID is the ID of the channel the ad will run on. */
  channelID: Scalars['ID'];
  /** lengthSeconds is the requested ad break length in seconds (30s ad, 60s ad, etc). */
  lengthSeconds?: InputMaybe<Scalars['Int']>;
};

/** StartAdPayload ... */
export type StartAdPayload = {
  __typename?: 'StartAdPayload';
  /** adSession is the response object from an ad request. */
  adSession?: Maybe<AdSession>;
  /** error is the StartAdError object from a failed request. */
  error?: Maybe<StartAdError>;
};

/** Error code for an error that occurs while starting the bounty. */
export type StartBountyError = {
  __typename?: 'StartBountyError';
  /** Error code for error that occurred while starting the bounty. */
  code: StartBountyErrorCode;
};

/** Error types recognized. */
export enum StartBountyErrorCode {
  /** The bounty cannot be started because it is not live. */
  BountyNotLive = 'BOUNTY_NOT_LIVE',
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER',
  /** The stream title contains banned words. */
  StreamTitleBannedWords = 'STREAM_TITLE_BANNED_WORDS',
  /** The stream title is too long. */
  StreamTitleTooLong = 'STREAM_TITLE_TOO_LONG',
  /** The user is not authorized to start the bounty. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error being returned from service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** StartBountyInput includes the bounty a user is trying to start. */
export type StartBountyInput = {
  /** Unique Identifier for the bounty. */
  bountyID: Scalars['ID'];
  /** Title of the stream for the bounty. Must start with #sponsored. */
  title: Scalars['String'];
  /** UserID of the user that will start the bounty. */
  userID: Scalars['ID'];
};

/** Data that was mutated after starting the bounty. */
export type StartBountyPayload = {
  __typename?: 'StartBountyPayload';
  /** The possible error returned from the service. */
  error?: Maybe<StartBountyError>;
  /** The started bounty with the updated status. */
  startedBounty?: Maybe<Bounty>;
  /** The user that now has the started bounty. */
  user?: Maybe<User>;
};

/** Error associated with a failed attempt to start a cloud broadcast. */
export type StartCloudBroadcastError = {
  __typename?: 'StartCloudBroadcastError';
  /** The cause of the error. */
  cause: StartCloudBroadcastErrorCause;
  /** An optional error message associated with the error. */
  message?: Maybe<Scalars['String']>;
};

/** Errors returned by attempting to start a cloud broadcast. */
export enum StartCloudBroadcastErrorCause {
  /** No subscription was found for the given channel and provider. */
  NoSubscription = 'NO_SUBSCRIPTION',
  /** An unknown error occurred, use message for more information. */
  Unknown = 'UNKNOWN'
}

/** Input for remotely and asynchronously starting a cloud broadcast for the given channelID. */
export type StartCloudBroadcastInput = {
  /** The desired framerate of the broadcast. */
  framerate?: InputMaybe<Scalars['Int']>;
  /** The desired height of the broadcast. */
  height?: InputMaybe<Scalars['Int']>;
  /** The cloud provider to send a start cloud broadcast request to.. */
  providerID: Scalars['ID'];
  /** The desired width of the broadcast. */
  width?: InputMaybe<Scalars['Int']>;
};

/** Response to start a cloud broadcast. */
export type StartCloudBroadcastPayload = {
  __typename?: 'StartCloudBroadcastPayload';
  /** If the broadcast was successfully started, properties of that broadcast. */
  broadcast?: Maybe<CloudBroadcast>;
  /** An optional error if the mutation failed, contaning actionable errors. */
  error?: Maybe<StartCloudBroadcastError>;
};

/** StartPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding. */
export type StartPayoutOnboardingWorkflowInput = {
  /** TargetUserID is the ID of the user whose workflow will be started. */
  targetUserID: Scalars['ID'];
};

/** StartPayoutOnboardingWorkflowPayload returns a new workflow when starting payout onboarding. */
export type StartPayoutOnboardingWorkflowPayload = {
  __typename?: 'StartPayoutOnboardingWorkflowPayload';
  /** A new workflow status. */
  workflow?: Maybe<PayoutOnboardingWorkflow>;
};

/** Input for starting a PV Watch Party. */
export type StartWatchPartyInput = {
  /** Amazon LWA access token. */
  accessToken: Scalars['String'];
  /** Channel ID of the creator. */
  channelID: Scalars['ID'];
  /** Catalog GTI to use. */
  watchPartyItemID: Scalars['ID'];
};

/** Returns the new Watch Party and all decoration/details. */
export type StartWatchPartyPayload = {
  __typename?: 'StartWatchPartyPayload';
  /** Error if the user's token expired. */
  error?: Maybe<WatchPartyError>;
  /** The watch party that was started. */
  watchParty?: Maybe<WatchParty>;
};

/** Error code for an error that occurs while stopping the bounty. */
export type StopBountyError = {
  __typename?: 'StopBountyError';
  /** Error code for error that occurred while stopping the bounty. */
  code: StopBountyErrorCode;
};

/** Error types recognized. */
export enum StopBountyErrorCode {
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER',
  /** The user is not authorized to stop the bounty. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error being returned from service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** StopBountyInput includes the bounty a user is trying to stop. */
export type StopBountyInput = {
  /** Unique Identifier for the bounty. */
  bountyID: Scalars['ID'];
  /** UserID of the user that will stop the bounty. */
  userID: Scalars['ID'];
};

/** Data that was mutated after stopping the bounty. */
export type StopBountyPayload = {
  __typename?: 'StopBountyPayload';
  /** The possible error returned from the service. */
  error?: Maybe<StopBountyError>;
  /** The stopped bounty with the updated status. */
  stoppedBounty?: Maybe<Bounty>;
  /** The user that now has the stopped bounty. */
  user?: Maybe<User>;
};

/** An error associated with a failed call to stopCloudBroadcast. */
export type StopCloudBroadcastError = {
  __typename?: 'StopCloudBroadcastError';
  /** The cause of the error. */
  cause: StopCloudBroadcastErrorCause;
  /** Optional message associated with an error. */
  message?: Maybe<Scalars['String']>;
};

/** Errors returned by attempting to stop a cloud broadcast. */
export enum StopCloudBroadcastErrorCause {
  /**
   * No broadcast was found for the given channel and provider.
   * Either because the broadcast is stopped or because the provider did not know about the user.
   */
  BroadcastNotFound = 'BROADCAST_NOT_FOUND',
  /** An unknown error message occurred, see message for more information. */
  Unknown = 'UNKNOWN'
}

/** Input for remotely stoping a Cloud broadcast for the given channelID. */
export type StopCloudBroadcastInput = {
  /** The the broadcast id to use when stopping a broadcast. */
  id: Scalars['ID'];
};

/** Response to stop a Cloud broadcast. */
export type StopCloudBroadcastPayload = {
  __typename?: 'StopCloudBroadcastPayload';
  /** If the broadcast was successfully stopped, properties of that broadcast. */
  broadcast?: Maybe<CloudBroadcast>;
  /** Optional error associated with a failed attempt to stop a cloud broadcast. */
  error?: Maybe<StopCloudBroadcastError>;
};

/** Input for stopping a PV Watch Party. */
export type StopWatchPartyInput = {
  /** Amazon LWA access token. */
  accessToken: Scalars['String'];
  /** Channel ID of the creator. */
  channelID: Scalars['ID'];
};

/** Returns LWA authentication errors. */
export type StopWatchPartyPayload = {
  __typename?: 'StopWatchPartyPayload';
  /** Error if the user's token expired. */
  error?: Maybe<WatchPartyError>;
  /** The watch party that was stopped. */
  watchParty?: Maybe<WatchParty>;
};

/** A live stream. */
export type Stream = {
  __typename?: 'Stream';
  /** The associated archive of the stream. */
  archiveVideo?: Maybe<Video>;
  averageFPS?: Maybe<Scalars['Float']>;
  bitrate?: Maybe<Scalars['Float']>;
  /** The language the stream is being broadcasted in. */
  broadcastLanguage?: Maybe<Language>;
  /** The user who is broadcasting the live stream. */
  broadcaster?: Maybe<User>;
  /** Software being used for the broadcast. */
  broadcasterSoftware?: Maybe<Scalars['String']>;
  /**
   * channel is deprecated.
   * @deprecated Channel fields have been merged into User. Use stream.broadcaster instead.
   */
  channel?: Maybe<Channel>;
  /** Number of clips created since stream start. */
  clipCount?: Maybe<Scalars['Int']>;
  codec?: Maybe<Scalars['String']>;
  /** The time streaming started. */
  createdAt?: Maybe<Scalars['Time']>;
  /**
   * The stream delay in seconds.
   * @deprecated Not a supported feature anymore.
   */
  delayLengthSeconds?: Maybe<Scalars['Int']>;
  /**
   * Information about what directories the stream is categorized in.
   * @deprecated This was made for Communities, but the feature is officially dead. Use 'game' instead
   */
  directories: Array<Maybe<Directory>>;
  /** Information about the game being streamed. */
  game?: Maybe<Game>;
  /** The height of the stream's video, in pixels. */
  height?: Maybe<Scalars['Int']>;
  /** The stream's unique identifier. */
  id: Scalars['ID'];
  /** Whether the stream is hidden from its directory. */
  isDirectoryHidden?: Maybe<Scalars['Boolean']>;
  /** Information about whether the channel is encrypted. */
  isEncrypted?: Maybe<Scalars['Boolean']>;
  /**
   * Whether the broadcaster has indicated the stream is intended for mature audiences only.
   * @deprecated Use broadcaster.broadcastSettings.isMature instead
   */
  isMature?: Maybe<Scalars['Boolean']>;
  /** Whether the broadcaster is partnered with Twitch. */
  isPartner?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not viewers of this stream can receive drops.
   * Note: Actually earning drops additionally requires that the game have an
   * active drops campaign and is done at the discretion of the developer.
   */
  isStreamDropsEnabled?: Maybe<Scalars['Boolean']>;
  /** The lanugage setting of the streaming user. */
  language?: Maybe<Language>;
  /** When the stream was last updated. */
  lastUpdatedAt?: Maybe<Scalars['Time']>;
  /**
   * The maximum height of the stream's video, in pixels.
   * @deprecated Not a supported feature anymore
   */
  maxHeight?: Maybe<Scalars['Int']>;
  /** Platform-specific (e.g. Xbox, PlayStation) metadata. */
  platform?: Maybe<Platform>;
  /**
   * The playback access token that determines whether the user can watch the stream.
   * Fetched for both authed and unauthed users.
   */
  playbackAccessToken?: Maybe<PlaybackAccessToken>;
  /**
   * A URL to a dynamically sized image.
   * If either `height` or `width` are not given, a templated value will be present instead.
   */
  previewImageURL?: Maybe<Scalars['String']>;
  /**
   * The restriction that is currently active on the channel for restricting a user's access to it.
   * @deprecated Use Channel.restriction for full restriction data or Stream.restrictionType for stream's restriction type
   */
  restriction?: Maybe<ResourceRestriction>;
  /** The list of restriction options that were applied in addition to the restriction type for this stream. */
  restrictionOptions: Array<ResourceRestrictionOption>;
  /** The type of restriction this stream currently has. */
  restrictionType?: Maybe<Scalars['String']>;
  /** self contains information on the relationship between the current user (anonymous or authenticated) and this stream. */
  self?: Maybe<StreamSelfConnection>;
  /**
   * Tags are used as a discovery and search mechanism for tags and tagged content.
   * The tag data may not be updated immediately after streamers update their tags.
   * Please use User.tags instead if you want real time data from Graffiti.
   * For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
   */
  tags?: Maybe<Array<Tag>>;
  /**
   * A user-defined title describing the stream.
   * @deprecated Title field in Users has been deprecated. Use broadcaster.broadcastSettings.title instead
   */
  title?: Maybe<Scalars['String']>;
  /** What type of stream this is (e.g. live, playlist, watch_party). */
  type?: Maybe<Scalars['String']>;
  /** The number of viewers currently watching the stream. */
  viewersCount?: Maybe<Scalars['Int']>;
  /** The width of the stream's video, in pixels. */
  width?: Maybe<Scalars['Int']>;
};


/** A live stream. */
export type StreamPlaybackAccessTokenArgs = {
  params: PlaybackAccessTokenParams;
};


/** A live stream. */
export type StreamPreviewImageUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};

/** StreamBitrate represents the bitrate of stream session by time. */
export type StreamBitrate = {
  __typename?: 'StreamBitrate';
  /** Time of recorded bitrate. */
  recordedAt: Scalars['Time'];
  /** Bitrate of video stream in Kbps. */
  valueKbps: Scalars['Float'];
};

/** Paginated list of Streams. */
export type StreamConnection = {
  __typename?: 'StreamConnection';
  edges?: Maybe<Array<Maybe<StreamEdge>>>;
  /** Used for tracking. */
  generationID?: Maybe<Scalars['ID']>;
  pageInfo?: Maybe<PageInfo>;
  /** Used for tracking. */
  responseID?: Maybe<Scalars['ID']>;
};

/**
 * Contains information about a Streams's relationship to a given page (connection),
 * and the Stream itself.
 */
export type StreamEdge = {
  __typename?: 'StreamEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<Stream>;
  /** Unique id per stream response item, used by clients to attribute displays/clicks to items. */
  trackingID?: Maybe<Scalars['ID']>;
};

/** StreamFramerate represents the framerate of strem session by time. */
export type StreamFramerate = {
  __typename?: 'StreamFramerate';
  /** Time of recorded bitrate. */
  recordedAt: Scalars['Time'];
  /** Framerate of video stream in Frame Per Second. */
  valueFPS: Scalars['Float'];
};

/** StreamKey represents a RTMP stream key with its expiration date. */
export type StreamKey = {
  __typename?: 'StreamKey';
  /** Stream key expiration date. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** RTMP stream key value. */
  value: Scalars['String'];
};

/** StreamKeyError represents the error code and its translated error message response that explains why the broadcaster can't start a stream. */
export type StreamKeyError = {
  __typename?: 'StreamKeyError';
  /** code is the error code for why the broadcaster is not allow to broadcast. */
  code: Scalars['String'];
  /** Link is the url link that is associated from the translated message. */
  links: Array<Scalars['String']>;
  /** message is the translated message for why the broadcaster is not allow to broadcast. */
  message: Scalars['String'];
};

/** StreamKeyResult represents StreamKey or StreamKeyError. */
export type StreamKeyResult = StreamKey | StreamKeyError;

/** Mosaic layouts for Dashboard Stream Manager. */
export type StreamManagerMosaicLayout = ChannelDashboardLayout & {
  __typename?: 'StreamManagerMosaicLayout';
  /** The actual Mosaic layout data to be stored or fetched. */
  data: Scalars['MosaicData'];
  /** A unique identifier to uniquely reference this layout. */
  id: Scalars['ID'];
  /** When the layout was last updated */
  lastUpdated?: Maybe<Scalars['Time']>;
  /** The display name for the layout shown to the user. */
  name: Scalars['String'];
  /**
   * A version to identify how the MosaicData was generated,
   * such as for deprecation purposes.
   */
  version: Scalars['String'];
};

/**
 * Query to let consumers filter streams that have specific metadata.
 * e.g. return only those hearthstone streams that have broadcasterheroclass as mage.
 * FE uses these parameters to implemtent filters.
 */
export type StreamMetadataFilterInput = {
  /** Filter streams by CSGO Map. */
  counterStrikeMap?: InputMaybe<Scalars['String']>;
  /** Filter streams by CSGO skill. */
  counterStrikeSkill?: InputMaybe<Scalars['String']>;
  /** Filter streams by Hearthstone hero class e.g "Mage". */
  hearthstoneBroadcasterHeroClass?: InputMaybe<Scalars['String']>;
  /** Filter streams by Hearthstone hero name e.g "Jaina". */
  hearthstoneBroadcasterHeroName?: InputMaybe<Scalars['String']>;
  /** Filter streams by Hearthstone game mode e.g "arena" or "rank" etc. */
  hearthstoneGameMode?: InputMaybe<Scalars['String']>;
  /** Filter streams by League Of Legends champion id. */
  leagueOfLegendsChampionID?: InputMaybe<Scalars['String']>;
  /** The maximum AVC level of the stream. e.g "4.1". */
  maxAVCLevel?: InputMaybe<Scalars['String']>;
  /** The maximum AVC profile of the stream. */
  maxAVCProfile?: InputMaybe<AvcProfile>;
  /** The maximum height of the stream. */
  maxHeight?: InputMaybe<Scalars['Int']>;
  /** Filter streams by Overwatch broadcaster's character e.g "Widowmaker". */
  overwatchBroadcasterCharacter?: InputMaybe<Scalars['String']>;
  /** Filter streams by PUBG game mode. */
  pubgGameMode?: InputMaybe<Scalars['String']>;
  /** Filter streams by PUBG max number of players alive in game. */
  pubgPlayerAliveMax?: InputMaybe<Scalars['String']>;
  /** Filter streams by PUBG min number of players alive in game. */
  pubgPlayerAliveMin?: InputMaybe<Scalars['String']>;
};

/**
 * Optional inputs to filter streams
 * add additional optional fields for filtering streams to the StreamOptions input type.
 */
export type StreamOptions = {
  /** Filter streams based on restriction types. */
  includeRestricted?: InputMaybe<Array<StreamRestrictionType>>;
  /**
   * Broadcaster languages to filter the streams by.
   * Deprecated: use language tags instead.
   */
  languages?: InputMaybe<Array<Language>>;
  /** The locale of the user. */
  locale?: InputMaybe<Scalars['String']>;
  /** The platform to filter streams by. */
  platformType?: InputMaybe<PlatformType>;
  /** If sorted by relevance, this provides additional context used to influence recommendations. */
  recommendationsContext?: InputMaybe<RecommendationsContext>;
  /** A GUID that is created by the caller for tracking. This should be globally unique per request and is required if sort=RELEVANCE. */
  requestID?: InputMaybe<Scalars['ID']>;
  /** The sort param can be used to change the default sorting. */
  sort?: InputMaybe<StreamSort>;
  /** List of tags to filter by. */
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** The content to render in a live recommendation item. */
export type StreamRecommendationEdge = {
  __typename?: 'StreamRecommendationEdge';
  /** As pagination is currently not supported by the backend, this will always be the zero value. */
  cursor: Scalars['Cursor'];
  /** The underlying stream content to render. */
  node?: Maybe<Stream>;
  /** Unique id per stream used in client tracking. */
  trackingID: Scalars['ID'];
};

export enum StreamRecommendationType {
  /** A SocialStream. */
  Social = 'SOCIAL'
}

/** StreamRecommendationsFilters defines parameters which filter down stream recommendation results. */
export type StreamRecommendationsFilters = {
  /**
   * Stream recommendation results will only include streams with these category ids.
   * Clients can use this filtering option for flows where a user can select categories to filter on.
   * The category IDs should be available from queries in the previous step of the user flow.
   * Example: categoryIDs: ["513143", "33214"] where "513143" and "33214" are coming from categories selected by the user in the previous page.
   */
  categoryIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/** Type of restricted stream. Currently used as inputs for user.followedLiveUsers, StreamOptions, and GameStreamOptions. */
export enum StreamRestrictionType {
  /** Represents streams that are restricted by OWL all-access pass. */
  OwlAllAccessPass = 'OWL_ALL_ACCESS_PASS',
  /** Represents streams that are restricted to sub-only. */
  SubOnlyLive = 'SUB_ONLY_LIVE'
}

/** The relationship between the authenticated user and a stream. */
export type StreamSelfConnection = {
  __typename?: 'StreamSelfConnection';
  /** Whether or not the requesting user is authorized to view the channel's stream. */
  canWatch: Scalars['Boolean'];
  /** Whether the stream is restricted. */
  isRestricted: Scalars['Boolean'];
  /** If the stream is restricted, the type indicates how the stream is restricted. */
  restrictionType?: Maybe<Scalars['String']>;
};

/** The start and end time of a stream session for a user. */
export type StreamSession = {
  __typename?: 'StreamSession';
  /** The associated archive of the stream. */
  archiveVideo?: Maybe<Video>;
  /** The end time for the stream session. */
  endedAt: Scalars['Time'];
  /** The start time for the stream session. */
  startedAt: Scalars['Time'];
};

/** Possible ways of sorting collections of live streams. */
export enum StreamSort {
  /**
   * Sort streams for the game "Counter-Strike: Global Offensive" by skill, descending (highest skill first).
   * Other streams are included last, sorted at random.
   * Deprecated: this sort option no longer exists.
   */
  CsgoSkill = 'CSGO_SKILL',
  /**
   * Sort streams for the game "League of Legends" by summoner rank, descending (highest rank first).
   * Other streams are included last, sorted at random.
   * Deprecated: this sort option no longer exists.
   */
  LolSummonerRank = 'LOL_SUMMONER_RANK',
  /** Sort by stream creation time, most recently started streams first. */
  Recent = 'RECENT',
  /** Sort by relevance to the current user. */
  Relevance = 'RELEVANCE',
  /**
   * Sort streams by number of concurrent viewers, descending (most viewers first).
   * This is the default if StreamSort is not set or is a deprecated field.
   */
  ViewerCount = 'VIEWER_COUNT',
  /** Sort streams by number of concurrent viewers, ascending (least viewers first). */
  ViewerCountAsc = 'VIEWER_COUNT_ASC'
}

/** Analytics information for a streaming session. */
export type StreamSummary = {
  __typename?: 'StreamSummary';
  /** The associated archives of the stream. */
  archiveVideos?: Maybe<Array<Video>>;
  /** Average viewers for the time period. */
  averageViewers: Scalars['Float'];
  /** The ID for the streaming channel. */
  channelID: Scalars['ID'];
  /** Unique chatters for the time period. */
  chatters: Scalars['Int'];
  /** The number of clips created during the stream summary. */
  clipsCreated: Scalars['Int'];
  /** The time that the stream session ended. */
  endedAt: Scalars['Time'];
  /** Number of follows for the time period. */
  follows: Scalars['Int'];
  /** Notification information for a given stream session. */
  goLiveNotification?: Maybe<GoLiveNotification>;
  /** Live views for the time period. */
  liveViews: Scalars['Int'];
  /** Max viewers for the time period. */
  maxViewers: Scalars['Int'];
  /** New subscriptions for the time period. */
  newSubscriptions: Scalars['Int'];
  /** The time that the stream session started. */
  startedAt: Scalars['Time'];
  /**
   * Unique chatters for the time period.
   * @deprecated Use chatters instead
   */
  uniqueChatters: Scalars['Int'];
  /** Unique viewers for the time period. */
  uniqueViewers: Scalars['Int'];
};

/** The type of streamer shelf to display. */
export enum StreamerShelfType {
  /** Shows the streamer's autohost list. */
  Autohost = 'AUTOHOST',
  /** Disables the shelf. */
  Disabled = 'DISABLED',
  /** Shows the streamer's team members. */
  Team = 'TEAM'
}

export type Streaming = Activity & {
  __typename?: 'Streaming';
  /** The stream being broadcasted. */
  stream?: Maybe<Stream>;
  /** This activity's type, i.e. "STREAMING". */
  type?: Maybe<ActivityType>;
};

/** A stucco (wide emote) represents an image that can be used for user interaction in specific cases. */
export type Stucco = {
  __typename?: 'Stucco';
  /** The description is used to describe the stucco (e.g. for screenreaders). */
  description: Scalars['String'];
  /** The unique ID of this stucco. */
  id: Scalars['ID'];
  /** The set of URLS to images related to this stucco, contains URLS for 1x, 2x and 4x images. */
  imageSet: StuccoImageSet;
  /** Indicates if this stucco does not belong to a single channel (available to all channels). */
  isGlobal: Scalars['Boolean'];
  /** The owner of this stucco, usually the channel this has been uploaded to. */
  ownerID: Scalars['ID'];
  /** The state of the stucco. */
  state: StuccoState;
  /** The textCode used to represent and identify this stucco, consists of channel prefix + stucco prefix + code. */
  textCode: Scalars['String'];
};

/** Image set of different sizes of the stucco. */
export type StuccoImageSet = {
  __typename?: 'StuccoImageSet';
  /** Image url of the 92x28px stucco ("1x") image asset. */
  image1xURL: Scalars['String'];
  /** Image url of the 182x56px stucco ("2x") image asset. */
  image2xURL: Scalars['String'];
  /** Image url of the 368x112px stucco ("4x") image asset. */
  image4xURL: Scalars['String'];
};

/** A Stucco pack is a collection of stuccos, the pack can be activated to be used by viewers of that channel. */
export type StuccoPack = {
  __typename?: 'StuccoPack';
  /** The ID of the stucco pack. */
  id: Scalars['ID'];
  /** User id of the owner of this pack (usually a channel). */
  ownerID: Scalars['ID'];
  /** The stuccos contained in this pack, represented as slots, containing the slot index and the stucco. */
  slots?: Maybe<Array<StuccoPackSlot>>;
};

/** A stucco pack slot represents a single ordered slot in a pack of stuccos. */
export type StuccoPackSlot = {
  __typename?: 'StuccoPackSlot';
  /** The index of this slot (used for ordering). */
  index: Scalars['Int'];
  /** The stucco in this slot. */
  stucco: Stucco;
};

/** The state a stucco can be in. */
export enum StuccoState {
  /** - Active: part of a stucco pack. */
  Active = 'ACTIVE',
  /** - Archived: Archived stucco, no longer visible. */
  Archived = 'ARCHIVED',
  /** - Inactive: available in the library. */
  Inactive = 'INACTIVE',
  /** - Moderated: stucco was moderated and is no longer available to the broadcaster or viewers. */
  Moderated = 'MODERATED',
  /** - Pending: stucco is currently going through moderation. */
  Pending = 'PENDING'
}

/** Sub Count Series shows a user's sub counts broken down by type, tier, and date. */
export type SubCountSeries = {
  __typename?: 'SubCountSeries';
  /** The duration each datapoint spans (ex: Day). */
  period: TimeSeriesPeriod;
  /** The datapoints in the timeseries, ordered ascending order by timestamp. */
  subCountSeriesDataPoints: Array<SubCountSeriesDataPoint>;
  /** The total number of subscriptions for the given time period (ex: 957). */
  totalCount: Scalars['Int'];
};

/** A single data point in the time series. */
export type SubCountSeriesDataPoint = {
  __typename?: 'SubCountSeriesDataPoint';
  /** The breakdown of which tiers contributed how much to the total gift sub count. */
  giftSubTierBreakdown: Array<SubCountTierDataPoint>;
  /** The breakdown of which tiers contributed how much to the total multi month sub count. */
  multiMonthSubTierBreakdown: Array<SubCountTierDataPoint>;
  /** The breakdown of which tiers contributed how much to the total paid sub count. */
  paidSubTierBreakdown: Array<SubCountTierDataPoint>;
  /** The timestamp associated with this data point. */
  timeStamp: Scalars['Time'];
  /** The total number of gifted subscriptions captured during this period. */
  totalGiftSubCount: Scalars['Int'];
  /** The total number of multi month subscriptions captured during this period. */
  totalMultiMonthSubCount: Scalars['Int'];
  /** The number of paid subscriptions captured during this period. */
  totalPaidSubCount: Scalars['Int'];
  /** The number of Prime subscriptions captured during this period. */
  totalPrimeSubCount: Scalars['Int'];
};

/** SubCountTierDataPoint shows the breakdown of subcount by tier. */
export type SubCountTierDataPoint = {
  __typename?: 'SubCountTierDataPoint';
  /** How many of this type of subscription were captured in this time period. */
  count: Scalars['Int'];
  /** The type of subscription, i.e. Tier 1, Tier 2, Tier 3. */
  tier: Scalars['String'];
};

/** Wrapper for errors associated with submitCSATFeedback mutation. */
export type SubmitCsatFeedbackError = {
  __typename?: 'SubmitCSATFeedbackError';
  /** The code associated with the error from submitCSATFeedback mutation. */
  code: SubmitCsatFeedbackErrorCode;
};

/** Possible error codes returned by the submitCSATFeedback mutation. */
export enum SubmitCsatFeedbackErrorCode {
  /** Invalid argument error, such as exceeding max characters in feedback or providing an invalid GUID. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Unkown backend error. */
  Unknown = 'UNKNOWN'
}

/** SubmitCSATFeedbackInput creates or updates a currently authenticated user's rating/feedback of Twitch Developer Products. */
export type SubmitCsatFeedbackInput = {
  /** The action that prompted the CSAT callout to appear. */
  actionPrompted?: InputMaybe<CsatActionPrompted>;
  /** The company ID, if the user is submitting the feedback through an organization's console. */
  companyID?: InputMaybe<Scalars['ID']>;
  /** The additional feedback that the user submits after the rating. */
  feedback?: InputMaybe<Scalars['String']>;
  /** The GUID used when updating a CSAT Feedback entry with additional feedback or changes. */
  guid?: InputMaybe<Scalars['ID']>;
  /** The rating that the user submits. */
  rating?: InputMaybe<CsatRating>;
  /** The page in Twilight that the user responds to the CSAT callout from. */
  source: Scalars['String'];
};

/** The result of a submitCSATFeedback mutation. */
export type SubmitCsatFeedbackPayload = {
  __typename?: 'SubmitCSATFeedbackPayload';
  /** The error from a failed submitCSATFeedback mutation. */
  error?: Maybe<SubmitCsatFeedbackError>;
  /** The response of the mutation. */
  response?: Maybe<SubmitCsatFeedbackResponse>;
};

/** The response of a successful submitCSATFeedback mutation. */
export type SubmitCsatFeedbackResponse = {
  __typename?: 'SubmitCSATFeedbackResponse';
  /** Unique identifier returned in the response. */
  guid: Scalars['ID'];
};

/** SubmitEmotePrefix creates a new emoticon prefix for a channel. */
export type SubmitEmotePrefixInput = {
  /** The channel ID whose emote prefix will be updated. */
  channelID: Scalars['ID'];
  /** The new emote prefix. */
  name: Scalars['String'];
};

/** SubmitEmotePrefixPayload returns a status code indicating whether the update was successful or not. */
export type SubmitEmotePrefixPayload = {
  __typename?: 'SubmitEmotePrefixPayload';
  /** A code indicating why the prefix submit failed, if it did. */
  errorCode?: Maybe<SubmitEmotePrefixResponseCode>;
  /** The newly submitted prefix. */
  prefix?: Maybe<EmoticonPrefix>;
};

/** A code indicating why the prefix submit failed, if it did. */
export enum SubmitEmotePrefixResponseCode {
  /** The prefix for the affiliate can not be updated. Affiliates can update prefix once every name change. */
  ErrAffiliatePrefixUpdateTooSoon = 'ERR_AFFILIATE_PREFIX_UPDATE_TOO_SOON',
  /** The prefix submitted was not the correct length. */
  ErrInvalidPrefixLength = 'ERR_INVALID_PREFIX_LENGTH',
  /** The prefix submitted does not meet the regular expression requirements. */
  ErrInvalidPrefixRegex = 'ERR_INVALID_PREFIX_REGEX',
  /** The prefix is not in a state that it can be updated. */
  ErrInvalidPrefixState = 'ERR_INVALID_PREFIX_STATE',
  /** Only eligible users can update their emoticon prefix. */
  ErrInvalidUser = 'ERR_INVALID_USER',
  /** The user is not in good standing and therefore cannot update their emoticon prefix. */
  ErrNotInGoodStanding = 'ERR_NOT_IN_GOOD_STANDING',
  /** Emote prefixes must be unique across the website. */
  ErrPrefixNotUnique = 'ERR_PREFIX_NOT_UNIQUE',
  /** The prefix was updated recently and can't be updated again for a while. */
  ErrPrefixUpdateTooSoon = 'ERR_PREFIX_UPDATE_TOO_SOON',
  /** The prefix submitted for the affiliate does not match the auto generated prefix. */
  ErrSubmittedPrefixDoesNotMatchAutoGeneratedPrefix = 'ERR_SUBMITTED_PREFIX_DOES_NOT_MATCH_AUTO_GENERATED_PREFIX',
  /** Something unexpected happened when submitting the emote prefix. */
  ErrUnknown = 'ERR_UNKNOWN'
}

/** SubmitEmoticonPrefix creates a new emoticon prefix for a channel. */
export type SubmitEmoticonPrefixInput = {
  /** The channel ID. */
  channelID: Scalars['ID'];
  /** Emoticon prefix. */
  name: Scalars['String'];
};

/** SubmitEmoticonPrefixPayload returns the updated emoticon prefix. */
export type SubmitEmoticonPrefixPayload = {
  __typename?: 'SubmitEmoticonPrefixPayload';
  /**
   * The response doesn't return the real state of the prefix. Querying the emoticon
   * prefix is required to get the most accurate state.
   */
  response: EmoticonPrefix;
};

/** Possible errors returned by the SubmitExtensionFeedback mutation. */
export enum SubmitExtensionFeedbackError {
  /** Internal service error eg. database timeout. */
  InternalError = 'INTERNAL_ERROR'
}

/** SubmitExtensionFeedbackInput submits a user's feedback for a related rating on a Twitch extension. */
export type SubmitExtensionFeedbackInput = {
  /** Feedback that the broadcaster can write. */
  comment: Scalars['String'];
  /** The ID of the extension the feedback applies to. */
  extensionClientID: Scalars['ID'];
  /** The version of the extension the feedback applies to. */
  extensionVersion: Scalars['String'];
  /** ID of the user submitting the feedback for the extension. */
  userID: Scalars['ID'];
};

/** The result of a submitExtensionFeedback mutation. */
export type SubmitExtensionFeedbackPayload = {
  __typename?: 'SubmitExtensionFeedbackPayload';
  /** The ExtensionRating record that the feedback was attached to. */
  comment?: Maybe<ExtensionComment>;
  /** The error when the mutation fails to submit the extension feedback. */
  error?: Maybe<SubmitExtensionFeedbackError>;
};

/** A list of channels subscribed to by a user. */
export type SubscribedChannelConnection = {
  __typename?: 'SubscribedChannelConnection';
  /** The subscribed channels. */
  edges?: Maybe<Array<SubscribedChannelEdge>>;
  /** Pagination. */
  pageInfo: PageInfo;
  /** The total number of subscribed channels. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** A broadcaster user with cursor. */
export type SubscribedChannelEdge = {
  __typename?: 'SubscribedChannelEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the user for the current edge. */
  node?: Maybe<User>;
};

/** SubscriberBadgeProgress contains progress information for subscription badges based on a user's tenure. */
export type SubscriberBadgeProgress = {
  __typename?: 'SubscriberBadgeProgress';
  /** The ID is a composite of channel_id (owner of badge) / user_id (viewer requesting badge) / version */
  id: Scalars['ID'];
  /** URL of 18x18 asset. */
  image1xURL: Scalars['String'];
  /** URL of 36x36 asset. */
  image2xURL: Scalars['String'];
  /** URL of 72x72 asset. */
  image4xURL: Scalars['String'];
  /** The percentage of tenure already earned towards this badge. */
  percentCompleted: Scalars['Float'];
  /** The total tenure in months required to earn this badge. */
  requiredTenureMonths: Scalars['Int'];
  /** Metadata about how a subscriber badge is stored & fetched. */
  version: Scalars['String'];
};

/** Breakdown of number of subscriptions by tier. */
export type SubscriberCountBreakdown = {
  __typename?: 'SubscriberCountBreakdown';
  /** The number of subscriptions to the product. */
  count: Scalars['Int'];
  /** The tier of the product. */
  tier: Scalars['String'];
};

/**
 * Information pertaining to user's subscriber score.
 * Contains subscription count, sub points, emote limits, and information about the next subscriber level.
 */
export type SubscriberScore = {
  __typename?: 'SubscriberScore';
  /** Breakdown of subscriber score by product tier. */
  breakdown?: Maybe<Array<SubscriberScoreBreakdown>>;
  /** Current subscriber count. */
  count: Scalars['Int'];
  /** Breakdown of total subs by product tier. */
  countBreakdown?: Maybe<Array<SubscriberCountBreakdown>>;
  /** Current subscriber score. */
  current: Scalars['Int'];
  /** Current number of emotes unlocked. */
  currentEmoteLimit: Scalars['Int'];
  /**
   * Next goal to unlock more emotes.
   * Will be null if max score already reached.
   */
  next?: Maybe<Scalars['Int']>;
  /**
   * Emote limit after reaching nextScoreGoal.
   * Will be null if max emote limit reached.
   */
  nextEmoteLimit?: Maybe<Scalars['Int']>;
};

/** Breakdown of score by tier. */
export type SubscriberScoreBreakdown = {
  __typename?: 'SubscriberScoreBreakdown';
  /** The score of the product. */
  score: Scalars['Int'];
  /** The tier of the product. */
  tier: Scalars['String'];
};

/** Data about a user's subscription to a broadcaster. */
export type SubscriptionBenefit = {
  __typename?: 'SubscriptionBenefit';
  /** The date that the subscription benefit ends. */
  endsAt?: Maybe<Scalars['Time']>;
  /** gift resolves gift info about a SubscriptionBenefit. */
  gift?: Maybe<SubscriptionGift>;
  /** The unique identifier. */
  id: Scalars['ID'];
  /** For a recurring subscription, the price is charged at every interval i months. */
  intervalNumber: Scalars['Int'];
  /** Whether the sub is set to "do not renew". */
  isDNRd: Scalars['Boolean'];
  /** Whether this subscription has been extended. This means that a non-recurring subscription has been extended with additional months. */
  isExtended: Scalars['Boolean'];
  /** Whether the subscription is in the grace period to be cancelled and refunded. */
  isRefundable: Scalars['Boolean'];
  /** The id of where the subscription originated from. Used when DNRing a recurring subscription. */
  originID?: Maybe<Scalars['String']>;
  /**
   * If the subscriptionBenefit has a future dated paid upgrade. (ie. a user has upgraded a 1-month gift to a recurring subscription).
   * @deprecated gift to paid upgrades will now be in the pendingSubscription schema
   */
  paidUpgrade?: Maybe<PaidUpgrade>;
  /** If the subscriptionBenefit has a pending future dated paid subscription. */
  pendingSubscription?: Maybe<PendingSubscription>;
  /** The platform the subscription was purchased on. */
  platform: SubscriptionPlatform;
  /** Resolves the product that the subscription benefit is to. */
  product?: Maybe<SubscriptionProduct>;
  /** Whether this benefit was achieved using a Twitch Prime subscription. */
  purchasedWithPrime: Scalars['Boolean'];
  /**
   * The date that the subscription benefit will renew. Will be nil if the subscription benefit
   * is not going to renew.
   */
  renewsAt?: Maybe<Scalars['Time']>;
  /**
   * The states this benefit has transitioned through. Captures both user-initiated states
   * such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
   */
  states?: Maybe<Array<SubscriptionBenefitStateHistory>>;
  /**
   * Exposes the third party SKU for managing third party subscriptions from the client.
   * Will be nil if there is not a thirdPartySKU associated with this subscription benefit.
   */
  thirdPartySKU?: Maybe<Scalars['String']>;
  /** The subscription tier. */
  tier: Scalars['String'];
  /** The user who is subscribed to. */
  user?: Maybe<User>;
};

/** A paginated list of subscription benefits. */
export type SubscriptionBenefitConnection = {
  __typename?: 'SubscriptionBenefitConnection';
  /** The list of subscription benefits on this page. */
  edges?: Maybe<Array<SubscriptionBenefitEdge>>;
  /** Information about this page of payment transactions. */
  pageInfo: PageInfo;
};

/** Criteria for building paginated list of user's all active subscriptions. */
export type SubscriptionBenefitCriteriaInput = {
  /** Only return subscription benefits for a given filter value. */
  filter?: InputMaybe<SubscriptionBenefitFilter>;
  /** Platform where subscriptions were purchased. */
  platform?: InputMaybe<SubscriptionPlatform>;
};

/** An element in a paginated list of subscription benefits. */
export type SubscriptionBenefitEdge = {
  __typename?: 'SubscriptionBenefitEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The element node. */
  node?: Maybe<SubscriptionBenefit>;
};

/** Set of ways to filter subscription benefit paginated results. */
export enum SubscriptionBenefitFilter {
  /** All active subscriptions. */
  All = 'ALL',
  /** Only Subscriptions received through gifts from another Twitch user. */
  Gift = 'GIFT',
  /** Only subscriptions purchased on a platform, specified in the input as platform. */
  Platform = 'PLATFORM'
}

/** The logic state of the Subscription Benefit. */
export enum SubscriptionBenefitState {
  /** Active (recurring) state. */
  Active = 'ACTIVE',
  /** State for when Twitch has completed a refund request. */
  Cancelled = 'CANCELLED',
  /** State for when Twitch has initiated a refund request. */
  CancelInitiated = 'CANCEL_INITIATED',
  /** State when a user has initiated a DNR request. */
  DnrInitiated = 'DNR_INITIATED',
  /** State for when a Subscription has been paused (used to support Android account hold feature). */
  OnHold = 'ON_HOLD',
  /** Unknown (0-value) state. */
  Unknown = 'UNKNOWN',
  /** State for when Twitch has completed a DNR request. */
  WillNotRenew = 'WILL_NOT_RENEW'
}

/**
 * Data about the states a Subscription Benefit has transitioned through. Captures both user-initiated states
 * such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
 */
export type SubscriptionBenefitStateHistory = {
  __typename?: 'SubscriptionBenefitStateHistory';
  /** When the benefit transitioned to this state. */
  createdAt?: Maybe<Scalars['Time']>;
  /** The logical state the benefit occupied. */
  state: SubscriptionBenefitState;
};

/** Configs that help initiate the subscription checkout flow. */
export type SubscriptionCheckoutConfigs = {
  __typename?: 'SubscriptionCheckoutConfigs';
  /** Lists any additional actions for a subscription checkout session. */
  actions: Array<CheckoutAction>;
  /** Whether the initiated checkout flow can complete/succeed and gift the recipient the product. */
  canGift: Scalars['Boolean'];
  /** Whether the initiated checkout flow can proceed with a purchase. */
  canPurchase: Scalars['Boolean'];
  /** Whether the purchaser is eligible for a one-time promotion in the subscription purchase checkout flow. */
  isOneMonthFreeEligible: Scalars['Boolean'];
  /** Holds configuration necessary for initializing payment provider client libraries and facilitate checkout flow. */
  paymentProviderConfigs: PaymentProviderConfigs;
  /** Purchase Ineligibility reason details. */
  purchaseIneligibilityReason: PurchaseIneligibilityReason;
};

/**
 * An Offer for purchasing community gift subscriptions with associated metadata about the Offer.
 * Composes the "model" (Offer) with the "view" metadata about the offer.
 */
export type SubscriptionCommunityGifting = {
  __typename?: 'SubscriptionCommunityGifting';
  /** The image assets for this offer. */
  assets: SubscriptionCommunityGiftingAssets;
  /** The Offer document for this Community Gift offer. */
  offer?: Maybe<Offer>;
  /** The default number of subscriptions that this offer is offering. */
  quantity: Scalars['Int'];
  /** The type of this community gifting offer. */
  type: SubscriptionCommunityGiftingType;
};

/** Groups image assets related to the community gifting Offer. */
export type SubscriptionCommunityGiftingAssets = {
  __typename?: 'SubscriptionCommunityGiftingAssets';
  /** The link to the 1x pixel density image asset for this community gifting offer. */
  imageURL1x: Scalars['String'];
  /** The link to the 2x pixel density image asset for this community gifting offer. */
  imageURL2x: Scalars['String'];
  /** The link to the 3x pixel density image asset for this community gifting offer. */
  imageURL3x: Scalars['String'];
  /** The link to the 4x pixel density image asset for this community gifting offer. */
  imageURL4x: Scalars['String'];
};

/** Describes the type of community gifting Offer that is being resolved. */
export enum SubscriptionCommunityGiftingType {
  /** A preset bundle of fixed-quantity community gift subscriptions. */
  Bundle = 'BUNDLE',
  /** An offer that allows the user to choose how many gift subscriptions they would like to purchase. */
  Custom = 'CUSTOM',
  /** An unknown gifting type. */
  Unknown = 'UNKNOWN'
}

/** Gift information for a subscription benefit. */
export type SubscriptionGift = {
  __typename?: 'SubscriptionGift';
  /** giftDate is the date that the gift was given. */
  giftDate?: Maybe<Scalars['Time']>;
  /** Gifter is the user who sent the gift. Will be nil if isGift is false or is the gift is anonymous. */
  gifter?: Maybe<User>;
  /** isGift says whether the subscription benefit is a gift or not. */
  isGift: Scalars['Boolean'];
};

/**
 * A gift offer that is available on a particular subscription based
 * on gift type and platform.
 */
export type SubscriptionGiftOffer = {
  __typename?: 'SubscriptionGiftOffer';
  /** Unique identifier of a subscription gift offer. */
  id: Scalars['ID'];
  /** The subscription gift offer price info which contains information about currency, cost and tax information. */
  priceInfo: PriceInfo;
  /** The available promotions on this gift offer. */
  promotion?: Maybe<SubscriptionGiftPromotion>;
  /** The amount of gifts in this offer. */
  quantity: Scalars['Int'];
  /**
   * thirdPartySKU represents the purchasable third party SKU of the gift the user will purchase.
   * Will return an nil if the user has no purchasable skus.
   * Will return nil if not on a platform with an external subscription gift offer or if the country is not supported.
   */
  thirdPartySKU?: Maybe<Scalars['String']>;
  /** The type of gift this offer is for. */
  type: SubscriptionGiftType;
};


/**
 * A gift offer that is available on a particular subscription based
 * on gift type and platform.
 */
export type SubscriptionGiftOfferPriceInfoArgs = {
  taxCountry?: InputMaybe<Scalars['String']>;
};

/** The different types of platforms available for gift offers. */
export enum SubscriptionGiftOfferPlatform {
  /** Gift offers available for the Android clients. */
  Android = 'ANDROID',
  /** Gift offers available for the web clients. */
  Web = 'WEB'
}

/** The promotion offer on a subscription gift offer. */
export type SubscriptionGiftPromotion = {
  __typename?: 'SubscriptionGiftPromotion';
  /** The subscription gift's discount type for this promotion(e.g. "PERCENT_OFF"). */
  discountType: SubscriptionPromotionDiscountType;
  /** The discount value of the subscription gift product (e.g. "50"). */
  discountValue: Scalars['String'];
  /** Unique identifier of a subscription gift promotion. */
  id: Scalars['ID'];
  /** The subscription gift offer price info which contains information about currency, cost and tax information. */
  priceInfo: PriceInfo;
  /** The quantity of gifts this promotion is for(ex: 11 gifts for a promotion on 10 gifts). */
  quantity: Scalars['Int'];
  /** Promotion consumable SKU used by third party that the user will purchase. */
  thirdPartySKU?: Maybe<Scalars['String']>;
};


/** The promotion offer on a subscription gift offer. */
export type SubscriptionGiftPromotionPriceInfoArgs = {
  taxCountry?: InputMaybe<Scalars['String']>;
};

/** The different types of subscription gifting. */
export enum SubscriptionGiftType {
  /** Community gifts are one or more gifts given to one or more users by a user. */
  Community = 'COMMUNITY',
  /** Unknown or no gift type. */
  None = 'NONE',
  /** Standard gifts are gifts to a specific user given by a user. */
  Standard = 'STANDARD'
}

/** A parent field for grouping the different types of gift subscriptions. */
export type SubscriptionGifting = {
  __typename?: 'SubscriptionGifting';
  /** Offers and associated metadata for purchasing community gift subscriptions. */
  community?: Maybe<Array<SubscriptionCommunityGifting>>;
  /**
   * Offers for purchasing a gift subscription to the given user.
   * This will prefer the ID if both login and ID are provided.
   * If neither are provided, this will return null.
   */
  standard?: Maybe<Array<SubscriptionStandardGifting>>;
};


/** A parent field for grouping the different types of gift subscriptions. */
export type SubscriptionGiftingStandardArgs = {
  recipientID?: InputMaybe<Scalars['ID']>;
  recipientLogin?: InputMaybe<Scalars['String']>;
};

/** Represents the interval of a subscription product. */
export type SubscriptionInterval = {
  __typename?: 'SubscriptionInterval';
  /** The unit-less amount of time a subscription lasts for. */
  duration: Scalars['Int'];
  /** Denotes the unit of the interval. */
  unit: SubscriptionIntervalUnit;
};

/** Denotes the unit of the period of a subscription product. */
export enum SubscriptionIntervalUnit {
  /** This subscription product lasts X months. */
  Month = 'MONTH',
  /** This subscription product lasts forever. */
  OneTime = 'ONE_TIME',
  /** This subscription product length is unknown. */
  Unknown = 'UNKNOWN',
  /** This subscription product lasts X weeks. */
  Week = 'WEEK',
  /** This subscription product lasts X years. */
  Year = 'YEAR'
}

/** Subscription pricing information. */
export type SubscriptionOffer = {
  __typename?: 'SubscriptionOffer';
  /** Currency the offer is for. */
  currency: Scalars['String'];
  /** Exponent to use when shifting the currency. */
  exponent: Scalars['Int'];
  /** Id for offer on subscription product. */
  id: Scalars['ID'];
  /** Price for the offer. */
  price: Scalars['Int'];
  /** Promotion description. */
  promoDescription?: Maybe<Scalars['String']>;
};

/** SubscriptionPlatform enumerates platform options such as WEB, IOS, ANDROID. */
export enum SubscriptionPlatform {
  /** Access from the Twitch Android application. */
  Android = 'ANDROID',
  /** Access from the Twitch iOS application. */
  Ios = 'IOS',
  /** Access from all Twitch Mobile applications (ANDROID + IOS). */
  MobileAll = 'MOBILE_ALL',
  /** Unknown or no platform. */
  None = 'NONE',
  /** Access from the browser.                                           ). */
  Web = 'WEB'
}

/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProduct = {
  __typename?: 'SubscriptionProduct';
  /** The maximum number of animated Emotes that can be associated with this product. */
  animatedEmoteLimit?: Maybe<Scalars['Int']>;
  /** The subscription product's display name. */
  displayName?: Maybe<Scalars['String']>;
  /**
   * The emote groups that the user gains access to use on Twitch when they purchase this product.
   * When using the ALL filter the data is uncached and should only be used on the creator dashboard.
   */
  emoteGroups?: Maybe<Array<EmoteSet>>;
  /** The maximum number of Emotes that can be associated with this product. */
  emoteLimit?: Maybe<Scalars['Int']>;
  /** The emote modifiers associated with the product. */
  emoteModifiers?: Maybe<Array<EmoteModifier>>;
  /**
   * The identifier of the static EmoteSet that a user gains access to use on Twitch,
   * when they purchase this product.
   * @deprecated Products can have more than one emote set now so use emoteGroups instead.
   */
  emoteSetID?: Maybe<Scalars['ID']>;
  /**
   * A list of Emotes the user gains access to use on Twitch when they purchase
   * this product.
   */
  emotes?: Maybe<Array<Maybe<Emote>>>;
  /**
   * A list of GiftOffers that are available on this subscription product
   * depending on which platform and gift type is given
   * Used by clients to display different gift prices, quantities and gift promotion information.
   */
  giftOffers?: Maybe<Array<SubscriptionGiftOffer>>;
  /** The subscription product's promotion if it is active. */
  giftPromotion?: Maybe<SubscriptionPromotion>;
  /** The different types of gift subscriptions ("Community" vs "Standard"). */
  gifting: SubscriptionGifting;
  /** Whether the subscription hides ads for the channel. */
  hasAdFree: Scalars['Boolean'];
  /** Whether the subscribers of this product are affected by slow chat mode. */
  hasFastChat?: Maybe<Scalars['Boolean']>;
  /** Whether the channel has sub only chatroom restriction. */
  hasSubOnlyChat?: Maybe<Scalars['Boolean']>;
  /** Whether the subscribers of this product are able to see the subs-only video archive. */
  hasSubonlyVideoArchive?: Maybe<Scalars['Boolean']>;
  /** The subscription product's identifier. */
  id: Scalars['ID'];
  /** The interval that the product lasts for. Includes unit + duration. */
  interval: SubscriptionInterval;
  /** The subscription product's name. */
  name: Scalars['String'];
  /** Available offers for a subscription product. */
  offers?: Maybe<Array<Offer>>;
  /**
   * The Twitch user that is the owner of the channel associated with this subscription product.
   * This is null for SubscriptionProducts like 'turbo' that are not associated with any user.
   */
  owner?: Maybe<User>;
  /**
   * The subscription's USD-formatted price, e.g. "$9.99".
   * @deprecated Transitioning to priceInfo instead to support multi region pricing
   */
  price: Scalars['String'];
  /** PriceInfo holds the products pricing information such as currency, cost, and tax information. */
  priceInfo: PriceInfo;
  /** The subscription product's promotion if it is active. */
  promotion?: Maybe<SubscriptionPromotion>;
  /** The currently active revenue configuration record for the subscription product. */
  revenueConfig?: Maybe<RevenueConfig>;
  /** The connection for user to the subscription product. */
  self?: Maybe<SubscriptionProductSelfConnection>;
  /** The avaliability state of the product. e.g. "active" or "inactive". */
  state: SubscriptionState;
  /**
   * ThirdPartytemplateSKU is used by the frontend to retrieve third party product information such
   * as price. templateSKU is exposed separately from purchaseSKU since retrieving purchaseSKU is a
   * more expensive operation. A user may not be able to purchase the templateSKU. Use purchaseSKU
   * when the user has indiciated they want to purchase.
   * Uses Client-ID to determine platform information and IP address to determine location.
   */
  thirdPartyTemplateSKU?: Maybe<Scalars['String']>;
  /** The tier of the product. */
  tier: Scalars['String'];
  /** The type of subscription, e.g. "chansub" or "teamsub". */
  type: SubscriptionProductType;
  /** The URL for this subscription's purchase page. */
  url: Scalars['String'];
};


/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProductEmoteGroupsArgs = {
  state?: InputMaybe<EmoteStateFilter>;
};


/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProductEmotesArgs = {
  state?: InputMaybe<EmoteStateFilter>;
};


/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProductGiftOffersArgs = {
  platform?: InputMaybe<SubscriptionGiftOfferPlatform>;
  type: SubscriptionGiftType;
};


/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProductPriceInfoArgs = {
  taxCountry?: InputMaybe<Scalars['String']>;
};


/**
 * A subscription that is purchasable by users.
 * Once purchased, the subscription entitles the user to use special emote sets on Twitch.
 */
export type SubscriptionProductThirdPartyTemplateSkuArgs = {
  platform?: InputMaybe<Scalars['String']>;
};

/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnection = {
  __typename?: 'SubscriptionProductSelfConnection';
  /** This user's subscription benefit information for the subscription product. */
  benefit?: Maybe<SubscriptionBenefit>;
  /** True if the user in this connection is allowed to gift the product in this connection. */
  canGiftInChannel: Scalars['Boolean'];
  /** True if the user in this connection can gift the product in this connection to the user with the supplied user ID. */
  canGiftTo: Scalars['Boolean'];
  /**
   * True if the user in this connection can gift the product in this connection to the user with the supplied login.
   * Since this requires an additonal lookup to get the user ID from the login, this is less preferable than canGift.
   */
  canGiftToLogin: Scalars['Boolean'];
  /** Holds configuration necessary to start subscription purchase checkout flow for this product for current user. */
  checkoutConfiguration?: Maybe<SubscriptionCheckoutConfigs>;
  /**
   * The subscription's discount type (e.g. "percent_off").
   * @deprecated Transitioning to promotion field instead
   */
  discountType: DiscountType;
  /**
   * The discount value of the subscription product (e.g. "50").
   * @deprecated Transitioning to promotion field instead
   */
  discountValue: Scalars['String'];
  /**
   * A list of GiftOffers that are available on this subscription product
   * depending on which platform, giftType and user that is authenticated.
   * Exposed on the self connection as well since user based promotions can be given in the future
   * Used by clients to display different gift prices, quantities and user based gift promotion information.
   */
  giftOffers?: Maybe<Array<SubscriptionGiftOffer>>;
  /**
   * If the product is eligible for a discount.
   * @deprecated Transitioning to promotion field instead
   */
  isEligibleForDiscount: Scalars['Boolean'];
  /**
   * The subscription's USD-formatted price after discount (e.g. "$2.49").
   * @deprecated Transitioning to promotion field instead
   */
  newPrice: Scalars['String'];
  /**
   * The subscription's USD-formatted price before discount (e.g. "$4.99").
   * @deprecated Transitioning to promotion field instead
   */
  oldPrice: Scalars['String'];
  /** If the subscription product is eligible for a paid upgrade promotion. */
  paidUpgradePromotion?: Maybe<SubscriptionPromotion>;
  /** Contains information on the final checkout price of this subscription product. */
  productPurchase?: Maybe<ProductPurchase>;
  /** The subscription product's promotion for user if eligible. */
  promotion?: Maybe<SubscriptionPromotion>;
  /**
   * This user's subscription purchase details for the subscription product. If this user is not
   * subscribed to the product, then the result's state is 'inactive'. If a compatible purchase exists,
   * then the result's "compatiblePurchase" field is present.
   */
  purchase?: Maybe<SubscriptionPurchase>;
  /** Subscription tenure data for the user to this subscription product. */
  subscriptionTenure?: Maybe<SubscriptionTenure>;
  /**
   * ThirdPartyPurchaseSKU is different from templateSKU since it represents the SKU of the exact item the
   * user will purchase. It is more expensive to retrieve purchaseSKU than templateSKU, so only
   * use purchaseSKU when the user has indicated they want to checkout. Use templateSKU on channel
   * page load to retrieve product information.
   *
   * Will return an error if the user has no purchasable skus. Will return nil if not on a platform
   * with an external subscription product or if the country is not supported.
   * Uses Client-ID to determine platform information and IP address to determine location.
   */
  thirdPartyPurchaseSKU?: Maybe<Scalars['String']>;
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionCanGiftToArgs = {
  recipientID: Scalars['ID'];
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionCanGiftToLoginArgs = {
  recipientLogin: Scalars['String'];
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionCheckoutConfigurationArgs = {
  config: CheckoutConfigurationInput;
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionGiftOffersArgs = {
  platform?: InputMaybe<SubscriptionGiftOfferPlatform>;
  type: SubscriptionGiftType;
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionProductPurchaseArgs = {
  paymentProvider: PaymentProvider;
  quantity: Scalars['Int'];
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionSubscriptionTenureArgs = {
  tenureMethod: SubscriptionTenureMethod;
};


/** The connection between the user and subscription product. */
export type SubscriptionProductSelfConnectionThirdPartyPurchaseSkuArgs = {
  platform?: InputMaybe<Scalars['String']>;
};

/** The types of subscription products that can be purchased. */
export enum SubscriptionProductType {
  /** Channel sub. */
  Chansub = 'CHANSUB',
  /** Team sub. */
  Teamsub = 'TEAMSUB',
  /** Turbo sub. */
  Turbo = 'TURBO'
}

/** A set of subscription products. */
export type SubscriptionProductsConnection = {
  __typename?: 'SubscriptionProductsConnection';
  /** The resolved subscription products. */
  nodes: Array<SubscriptionProduct>;
};

/** A subscription products error. */
export type SubscriptionProductsError = {
  __typename?: 'SubscriptionProductsError';
  /** A code representing the error state. */
  code: SubscriptionProductsErrorCode;
};

/** Codes representing subscription products error states clients can respond to. */
export enum SubscriptionProductsErrorCode {
  /** Code indicating server error occurred while retrieving subscription products. */
  Error = 'ERROR',
  /** Code indicating subscription products could not be found. */
  Missing = 'MISSING',
  /** Default code. */
  Unknown = 'UNKNOWN'
}

/** The set of results that can occur when resolving a subscription product. */
export type SubscriptionProductsResult = SubscriptionProductsConnection | SubscriptionProductsError;

/** The promotion offer on subscription product. */
export type SubscriptionPromotion = {
  __typename?: 'SubscriptionPromotion';
  /** Contains information on the final checkout price for this promotion. */
  checkoutPrice?: Maybe<ProductPurchase>;
  /**
   * The subscription's discount type (e.g. "PERCENT_OFF").
   * @deprecated No longer supported.
   */
  discountType: SubscriptionPromotionDiscountType;
  /**
   * The discount value of the subscription product (e.g. "50").
   * @deprecated No longer supported.
   */
  discountValue: Scalars['String'];
  /**
   * The subscription's USD-formatted price after discount (e.g. "$2.49").
   * @deprecated Use SubscriptionPromotion.previewPrice instead.
   */
  newPrice: Scalars['String'];
  /**
   * The subscription's USD-formatted price before discount (e.g. "$4.99").
   * @deprecated Use SubscriptionProduct.priceInfo instead.
   */
  oldPrice: Scalars['String'];
  /** The price for the promotion. */
  previewPrice: PriceInfo;
};


/** The promotion offer on subscription product. */
export type SubscriptionPromotionCheckoutPriceArgs = {
  paymentProvider: PaymentProvider;
  quantity: Scalars['Int'];
};

/** Valid discount types for Subscription promotion. */
export enum SubscriptionPromotionDiscountType {
  /** Fixed price discount on subscription product. */
  FixedValueOff = 'FIXED_VALUE_OFF',
  /** No discount on subscription product. */
  None = 'NONE',
  /** Percent off discount on subscription product. */
  PercentOff = 'PERCENT_OFF'
}

/** A user's subscription purchase details, part of the Subscription Checkout workflow. */
export type SubscriptionPurchase = {
  __typename?: 'SubscriptionPurchase';
  /**
   * A compatible purchase exists if this user bought a subscription product of a different tier for the
   * channel in question.
   *
   * i.e. this user doesn't have this subscription purchase for the $4.99 sub but they do have a
   *      compatible purchase for the $9.99 subscription.
   */
  compatiblePurchases?: Maybe<Array<SubscriptionPurchaseDetails>>;
  /** The purchase details for a Twitch purchaser - Subscription product combination. */
  details?: Maybe<SubscriptionPurchaseDetails>;
};

/** The receipt details for a subscription purchase. */
export type SubscriptionPurchaseDetails = {
  __typename?: 'SubscriptionPurchaseDetails';
  /** Date the purchase was cancelled at, if applicable, else null. */
  cancelledAt?: Maybe<Scalars['Time']>;
  /** Currency for the price, e.g. "USD". */
  currency: Scalars['String'];
  /** Divisor for the price based on the currency. e.g. Divisor for USD is 100. */
  divisor: Scalars['Int'];
  /** Purchase's payment provider. */
  paymentProvider: PaymentProvider;
  /** Price in smallest subunit of currency, e.g. "499" cents. */
  price: Scalars['Int'];
  /** The tier of the subscription purchase product. */
  productTier?: Maybe<Scalars['String']>;
  /** The type of subscription purchase. */
  productType: SubscriptionProductType;
  /** Purchase state. */
  state: SubscriptionPurchaseState;
};

/** The various states of the subscription purchase receipt. */
export enum SubscriptionPurchaseState {
  /** Active subscription purchase. It could be non-renewing or renewing. */
  Active = 'ACTIVE',
  /** Cancelled subscription purchase. */
  Cancelled = 'CANCELLED',
  /**
   * Inactive subscription purchase. User's subscription benefit from the original purchase has ended
   * and has not renewed.
   */
  Inactive = 'INACTIVE'
}

/**
 * An Offer for purchasing a Standard (AKA "single" or "targetted") gift subscription for a specific user.
 * This type exists as a futureproofing measure as gifting will evolve over time.
 */
export type SubscriptionStandardGifting = {
  __typename?: 'SubscriptionStandardGifting';
  /** The Offer document for this Standard Gift offer. */
  offer?: Maybe<Offer>;
};

/** The availability state of a subscription product. */
export enum SubscriptionState {
  /** Active state. */
  Active = 'ACTIVE',
  /** Inactive state. */
  Inactive = 'INACTIVE',
  /** Unknown state. */
  Unknown = 'UNKNOWN'
}

/** Simple summary of subscription product. */
export type SubscriptionSummary = {
  __typename?: 'SubscriptionSummary';
  /** Emotes included with subscription. */
  emotes?: Maybe<Array<Maybe<Emote>>>;
  /** Subscription product id, for now is the same as the ticket product id. */
  id: Scalars['ID'];
  /** Emote modifiers available at this tier. */
  modifiers?: Maybe<Array<EmoteModifier>>;
  /** Channel's custom name for their subscription. */
  name: Scalars['String'];
  /** Pricing information about subscription, filtered to what is available for user. */
  offers?: Maybe<Array<SubscriptionOffer>>;
  /** Info specific to the user. */
  self: SubscriptionSummarySelf;
  /** Tier of subscription, either 1, 2, or 3. */
  tier: SubscriptionSummaryTier;
  /** URL for checkout page. */
  url: Scalars['String'];
};

/** Most of the user specific fields for SubscriptionSummary. */
export type SubscriptionSummarySelf = {
  __typename?: 'SubscriptionSummarySelf';
  /** What is the cumulative tenure for this user. */
  cumulativeTenure: Scalars['Int'];
  /** The tier the user is subbed to (if they have a sub). */
  subscribedTier?: Maybe<SubscriptionSummaryTier>;
};

/** Tier of subscription. */
export enum SubscriptionSummaryTier {
  /** First tier, $4.99 for US market. */
  Tier_1 = 'TIER_1',
  /** Second tier, $9.99 for US market. */
  Tier_2 = 'TIER_2',
  /** Third tier, $24.99 for US market. */
  Tier_3 = 'TIER_3'
}

/** Tenure to a subscription product. */
export type SubscriptionTenure = {
  __typename?: 'SubscriptionTenure';
  /** The days remaining in a user's current tenure period. */
  daysRemaining: Scalars['Int'];
  /** The days elapsed in a user's current tenure period. */
  elapsedDays: Scalars['Int'];
  /** The ending date of a user's tenure. */
  end?: Maybe<Scalars['Time']>;
  /** The method used to calculate the user's tenure. */
  method: SubscriptionTenureMethod;
  /** The total duration of a user's tenure. */
  months: Scalars['Int'];
  /** The starting date of a user's tenure. */
  start?: Maybe<Scalars['Time']>;
};

/** A type of tenure to a subscription product. */
export enum SubscriptionTenureMethod {
  /** Tenure data calculated cumulatively. */
  Cumulative = 'CUMULATIVE',
  /** Tenure data calculated streak-based. */
  Streak = 'STREAK'
}

/**
 * A channel could have multiple subscription products at varying tiers.
 * Each value will always map to the respective tier for every channel that has the given tier available as a product.
 *
 * Example:
 * A channel with a "tier 2" subscription product will always have the tier represented as T_2000.
 */
export enum SubscriptionTier {
  /** Custom tier. */
  Custom = 'CUSTOM',
  /** Subscribed with Twitch Prime. */
  Prime = 'PRIME',
  /** Tier "1000". */
  T_1000 = 'T_1000',
  /** Tier "2000". */
  T_2000 = 'T_2000',
  /** Tier "3000". */
  T_3000 = 'T_3000'
}

/** Token that a User uses for redeeming Subscriptions. */
export type SubscriptionToken = {
  __typename?: 'SubscriptionToken';
  /** Current token balance of user. */
  balance?: Maybe<Scalars['Int']>;
};

/**
 * A SubscriptionTokenBundleProduct can contain multiple Offers.
 * ex) A Bundle of size 3 tokens, can have 3 other offers such as:
 *   - Normal offer: "Pay $16.99 for the bundle
 *   - Discounted, one-time buy offer: "Pay $14.99 for the bundle, but a one-time purchase only"
 *   - Bits: Use X amount of Bits to purchase this Bundle.
 */
export type SubscriptionTokenBundleProduct = {
  __typename?: 'SubscriptionTokenBundleProduct';
  /** Assets assocaited with a certain Token Bundle Product. */
  assets?: Maybe<Array<TokenBundleAsset>>;
  /** Subscription token bundle product's identifier. */
  id: Scalars['ID'];
  /**
   * List of available offers for this bundle product.
   * Displays the cheapest offer to the user, if there are promotions to be applied.
   */
  offers?: Maybe<Array<Offer>>;
  /** Quantity of tokens the bundle. */
  quantity: Scalars['Int'];
};

/** Describes configurable values for the token product line. */
export type SubscriptionTokenProductConfig = {
  __typename?: 'SubscriptionTokenProductConfig';
  /** Max token balance a user can have. */
  maxBalance?: Maybe<Scalars['Int']>;
};

/** The individual swap participant input. */
export type SwapCompetitionLobbyParticipantInput = {
  /** The id of the lobby where the lobby participant currently is. */
  lobbyID: Scalars['ID'];
  /** The id of the lobby participant, which can be competition player id or competition team id, we are swapping with. */
  participantID: Scalars['ID'];
};

/** SwapCompetitionLobbyParticipantsInput exchanges the lobby placements of the two participants within the same phase. */
export type SwapCompetitionLobbyParticipantsInput = {
  /** The id of the competition. */
  competitionID: Scalars['ID'];
  /** The participantID and lobbyID of the first lobby participant to be swapped. */
  first: SwapCompetitionLobbyParticipantInput;
  /** The id of the phase. */
  phaseID: Scalars['ID'];
  /** The participantID and lobbyID of the second lobby participant to be swapped. */
  second: SwapCompetitionLobbyParticipantInput;
};

/** SwapCompetitionLobbyParticipantsPayload is the success response for swapping lobby participants. */
export type SwapCompetitionLobbyParticipantsPayload = {
  __typename?: 'SwapCompetitionLobbyParticipantsPayload';
  /** The new state of competition after swapping participants. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** SyncGameOnDropCampaignPayload contains the campaign ID that needs to be synced. */
export type SyncGameOnDropCampaignInput = {
  /** The ID of the campaign to sync. */
  campaignID: Scalars['ID'];
};

/** SyncGameOnDropCampaignPayload returns the result of the sync. */
export type SyncGameOnDropCampaignPayload = {
  __typename?: 'SyncGameOnDropCampaignPayload';
  /** The campaign after the sync. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** GDPR cookie vendors for vendors that support TCF strings, for a user. */
export type TcfCookieVendor = {
  __typename?: 'TCFCookieVendor';
  /** User content status for each vendor. */
  consentStatus: ConsentStatus;
  /** If it’s an advertising, analytics, or essential cookie. */
  cookieVendorType: CookieVendorType;
  /** List of features this vendor uses. */
  features?: Maybe<Array<ConsentFeature>>;
  /** A flag that shows if the consent is given by the user or by consent service as default value. */
  hasUserSetConsent: Scalars['Boolean'];
  /** A flag that shows if the vendor should be visible to management page. */
  isVisible: Scalars['Boolean'];
  /** Vendor name. */
  name: VendorName;
  /** Url to the Vendor's privacy policy. */
  policyURL: Scalars['String'];
  /** List of purposes this vendor uses. */
  purposes?: Maybe<Array<ConsentPurpose>>;
  /** List of special features this vendor uses. */
  specialFeatures?: Maybe<Array<ConsentSpecialFeature>>;
  /** List of special purposes this vendor uses. */
  specialPurposes?: Maybe<Array<ConsentSpecialPurpose>>;
};

/** Tag(s) are used as a discovery and search mechanism for tagged content, including Streams, Clips, and VODs. */
export type Tag = {
  __typename?: 'Tag';
  /** Timestamp of the creation of this tag. */
  createdAt?: Maybe<Scalars['Time']>;
  /** This tag's unique identifier. */
  id: Scalars['ID'];
  /** Whether this tag is auto generated. */
  isAutomated: Scalars['Boolean'];
  /** Whether this tag is a language tag. */
  isLanguageTag: Scalars['Boolean'];
  /** Localized description of this tag. */
  localizedDescription: Scalars['String'];
  /** Localized Name of this tag. */
  localizedName: Scalars['String'];
  /** Scope of the Tag. */
  scope: TagScope;
  /** Official Name of this tag in English. */
  tagName: Scalars['String'];
};

/** The frequency of a tag used as filter for a channel. */
export type TagAnalytic = {
  __typename?: 'TagAnalytic';
  /** A decimal that shows how often a Tag is used. */
  percentage: Scalars['Float'];
  /** The tag for the analytic. */
  tag: Tag;
};

/** A paginated list of tags, and its metadata. */
export type TagConnection = {
  __typename?: 'TagConnection';
  /** The list of tags in this page. */
  edges?: Maybe<Array<TagEdge>>;
  /** Information about this page of tags. */
  pageInfo: PageInfo;
};

/** An element in a paginated tags, and its metadata. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Node represents the extension for the current edge. */
  node?: Maybe<Tag>;
};

/** An enumeration on the different scope of a tag. */
export enum TagScope {
  /** Tags that can be applied to all content types. */
  All = 'ALL',
  /** Tags that can only be applied to the CATEGORY content type. */
  Category = 'CATEGORY'
}

/** An enumeration on the different tag types of a category. */
export enum TagType {
  /** Tags applied to the category. */
  Content = 'CONTENT',
  /** The most popular tags used by other channels streaming this game/category. */
  Top = 'TOP'
}

/** The content that are possibly return for tagging mutation payload. */
export type TaggedContent = Clip | Game | Stream | User | Video;

/** TargetedModerationAction is a ModLogs entry of a chat ban,timeout, or unban. */
export type TargetedModActionDetails = {
  __typename?: 'TargetedModActionDetails';
  /** Timestamp when user was banned/timed-out. */
  bannedAt?: Maybe<Scalars['Time']>;
  /** Duration of the chat timeout (in seconds). */
  durationSeconds?: Maybe<Scalars['Int']>;
  /** Timestamp when the chat timeout expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Reason of the action. */
  reason?: Maybe<Scalars['String']>;
};

/** TaxInterview describes the information for a user's Amazon tax interview during payout onboarding. */
export type TaxInterview = {
  __typename?: 'TaxInterview';
  /**
   * Amazon tax interview account ID.
   * @deprecated Use interview options instead
   */
  accountID: Scalars['ID'];
  /**
   * Amazon tax interview client ID.
   * @deprecated Use interview options
   */
  clientID: Scalars['ID'];
  /**
   * Legal name of the user completing the Amazon tax interview.
   * @deprecated Use interview options
   */
  governmentAlias: Scalars['String'];
  /**
   * The preferred locale for user in the accepted format to initate the Amazon tax interview (e.g. "en_US").
   * @deprecated Use interview options instead
   */
  locale: Scalars['String'];
  /** List of key value pairs that were used to generate the signature. */
  options?: Maybe<Array<TaxInterviewOption>>;
  /** Unique signature to initiate the Amazon tax interview. */
  signature: Scalars['String'];
  /**
   * The type of Amazon tax interview.
   * @deprecated Use interview options instead
   */
  type: TaxInterviewType;
  /** The URL for user to begin their Amazon tax interview. */
  url: Scalars['String'];
};

/**
 * TaxInterviewOption is a key value pair type used by the tax interview.
 * Each option represents a form value that musted be passed to the argon website.
 */
export type TaxInterviewOption = {
  __typename?: 'TaxInterviewOption';
  /** The name of the option. */
  key: Scalars['String'];
  /** The option value. */
  value: Scalars['String'];
};

/** TaxInterviewType enumerates valid Amazon tax interview types. */
export enum TaxInterviewType {
  /** Describes an Amazon tax interview that would allow users to receive royalty income through licensed content. */
  Royalty = 'ROYALTY',
  /** Describes an Amazon tax interview that would allow users to receive income for their goods and services. */
  Service = 'SERVICE'
}

/** TaxMismatchError enumerates valid registration and tax interview field names for payout onboarding. */
export enum TaxMismatchError {
  /** Applied when the user submits a city that does not match the city on their registration. */
  City = 'CITY',
  /** Applied when the user submits a country that does not match the country on their registration. */
  Country = 'COUNTRY',
  /** Applied when the user submits an email that does not match the email on their registration. */
  Email = 'EMAIL',
  /**
   * Applied when the user submits a name that does not match the name on their registration.
   * If provided, the company name will be compared intead of the user's full legal name.
   */
  Name = 'NAME',
  /** Applied when the user submits a postal that does not match the postal on their registration. */
  Postal = 'POSTAL',
  /** Applied when the user submits a state that does not match the state on their registration. */
  State = 'STATE',
  /** Applied when the user submits a street address that does not match the street address on their registration. */
  StreetAddress = 'STREET_ADDRESS',
  /** Applied when the user submits a street address 2 that does not match the street address 2 on their registration. */
  StreetAddress_2 = 'STREET_ADDRESS_2'
}

/** Represents a tax jurisdiction from which a final price was calculated. */
export type TaxRegion = {
  __typename?: 'TaxRegion';
  /** Tax country, required for the TaxRegion object type. */
  countryCode: Scalars['String'];
  /** Tax state if applicable. */
  state?: Maybe<Scalars['String']>;
  /** Tax zip code if applicable. */
  zipCode?: Maybe<Scalars['String']>;
};

/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type Team = {
  __typename?: 'Team';
  /** ID to an image meant to be the background of the Team's landing page. */
  backgroundImageID?: Maybe<Scalars['ID']>;
  /** URL to an image meant to be the background of the Team's landing page. */
  backgroundImageURL?: Maybe<Scalars['String']>;
  /** ID to the Team's banner image. */
  bannerID?: Maybe<Scalars['ID']>;
  /** URL to the Team's banner image. */
  bannerURL?: Maybe<Scalars['String']>;
  /**
   * Retrieves team stats within the start and end time broken down by granularity.
   * Default end time will be the current time (now).
   * Granularity defaults to 5 minutes.
   * ChannelIDs defaults to all team members.
   */
  creatorTimeseriesMetrics?: Maybe<CreatorTimeseriesMetrics>;
  /** Information about the team, formatted in Markdown. */
  description?: Maybe<Scalars['String']>;
  /** Display version of the team name. */
  displayName: Scalars['String'];
  /** The Team's ID. */
  id: Scalars['ID'];
  /**
   * Channels that the Team owner have opted to highlight that are currently live.
   * These channels may or may not also be members of the Team.
   * They will be returned in the order configured by the Team admin.
   */
  liveFeaturedChannels?: Maybe<UserConnection>;
  /**
   * Users that belong to the team that are currently live.
   * They will be returned in the order configured by the Team admin.
   */
  liveMembers?: Maybe<UserConnection>;
  /** ID to the Team's logo image. */
  logoID?: Maybe<Scalars['ID']>;
  /** URL to the Team's logo image. */
  logoURL?: Maybe<Scalars['String']>;
  /**
   * The list of users that belong to this team.
   * They will be returned in the order configured by the Team admin.
   * metricsRevealed allows the client to return all `none`, `statsRevealed`, or `revenueRevealed` members.
   * Defaults to all members to avoid breaking changes.
   */
  members?: Maybe<UserConnection>;
  /** The alphanumeric Twitch name of the team. */
  name: Scalars['String'];
  /** Owner is the User that owns and manages the Team. */
  owner?: Maybe<User>;
  /**
   * Aggregated analytics for several video referral sources, for use in teams dashboard.
   * ChannelIDs defaults to all team members.
   */
  videoPlayReferrals?: Maybe<VideoPlayReferrals>;
};


/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type TeamCreatorTimeseriesMetricsArgs = {
  channelIDs?: InputMaybe<Array<Scalars['ID']>>;
  endAt?: InputMaybe<Scalars['Time']>;
  granularity?: InputMaybe<Granularity>;
  startAt: Scalars['Time'];
  timeZone: Scalars['String'];
};


/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type TeamLiveFeaturedChannelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type TeamLiveMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type TeamMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  metricsRevealedFilter?: InputMaybe<MemberMetricsRevealedParams>;
};


/**
 * Team represents a Twitch Team.
 * Teams are collections of streaming channels, and are owned by a Twitch user.
 * Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
 */
export type TeamVideoPlayReferralsArgs = {
  channelIDs?: InputMaybe<Array<Scalars['ID']>>;
  dimension: ReferralsDimension;
  end: Scalars['Time'];
  filter?: InputMaybe<ReferralsFilter>;
  first?: InputMaybe<Scalars['Int']>;
  start: Scalars['Time'];
};

/** Inputs for terminating a poll. */
export type TerminatePollInChannelInput = {
  /** The id of the channel with the poll to terminate. */
  channelID: Scalars['ID'];
};

/** Outputs from the terminate poll mutation. */
export type TerminatePollInChannelPayload = {
  __typename?: 'TerminatePollInChannelPayload';
  /** The terminated poll. */
  poll?: Maybe<Poll>;
};

/** Inputs for terminating a poll. */
export type TerminatePollInput = {
  /** The id of the poll to terminate. */
  pollID: Scalars['ID'];
};

/** Outputs from the create poll mutation. */
export type TerminatePollPayload = {
  __typename?: 'TerminatePollPayload';
  /** The created poll. */
  poll?: Maybe<Poll>;
};

/** A shelf title token type that contains text with various formatters. */
export type TextToken = {
  __typename?: 'TextToken';
  /** If this title token should be emphasized or not. */
  hasEmphasis: Scalars['Boolean'];
  /** The location that this shelf title token should link to. */
  location: LinkType;
  /** The text to display for this token. */
  text: Scalars['String'];
};

export type ThumbnailOEmbed = {
  __typename?: 'ThumbnailOEmbed';
  height: Scalars['Int'];
  url: Scalars['String'];
  width: Scalars['Int'];
};

/** Possible labels for extra points awarded to resolve ties. */
export enum TiebreakerLabel {
  /** Tiebreaker Points are a generic bonus field determined by the CO. */
  Bonus = 'BONUS',
  /** Tiebreaker Points are awarded for a kill, useful in BR games. */
  Kills = 'KILLS',
  /** An unknown label was provided. */
  Unknown = 'UNKNOWN'
}

/** A drop triggered by accummulating minutes watched. */
export type TimeBasedDrop = DropType & {
  __typename?: 'TimeBasedDrop';
  /** The rewards for this drop and how often those rewards can be awarded. */
  benefitEdges?: Maybe<Array<DropBenefitEdge>>;
  /** The campaign this drop belongs to. */
  campaign: DropCampaign;
  /** The time at which this drop becomes unavailable. */
  endAt: Scalars['Time'];
  /** A unique identifier. */
  id: Scalars['ID'];
  /** The name of this drop. */
  name: Scalars['String'];
  /** The drops that must have been claimed before this drop can be claimed / made progress for. */
  preconditionDrops?: Maybe<Array<TimeBasedDrop>>;
  /** The number of minutes a user has to watch in order to claim the reward. */
  requiredMinutesWatched: Scalars['Int'];
  /** User specific data associated with the TimeBasedDrop. */
  self: TimeBasedDropSelfEdge;
  /** The time at which this drop becomes available. */
  startAt: Scalars['Time'];
};

/** User specific data associated with this drop. */
export type TimeBasedDropSelfEdge = {
  __typename?: 'TimeBasedDropSelfEdge';
  /** The current progress for a given user towards this drop. */
  currentMinutesWatched: Scalars['Int'];
  /** The ID of the drop reward granted to the user if the drop is claimable, returns null otherwise. */
  dropInstanceID?: Maybe<Scalars['ID']>;
  /** Indicates whether or not all preconditions have been met, and the drop is available to get progress. */
  hasPreconditionsMet: Scalars['Boolean'];
  /** Whether the user has already claimed their reward for this drop. */
  isClaimed: Scalars['Boolean'];
};

/** The subcount series is able to display each datapoint according to the following durations. */
export enum TimeSeriesPeriod {
  /** Period of one day per datapoint. */
  Day = 'DAY',
  /** Period of one month per datapoint. */
  Month = 'MONTH'
}

/** Single item of stats for the time series. */
export type TimeseriesItem = {
  __typename?: 'TimeseriesItem';
  /**
   * Deprecated: Number of follows during this timestamp.
   * @deprecated Use user.timeseriesStats.follows instead.
   */
  follows?: Maybe<Scalars['Int']>;
  /** Streamed duration (in minutes). */
  minutesStreamed: Scalars['Int'];
  /** Timestamp of the broken down time series. */
  timestamp: Scalars['Time'];
  /** Value at the timestamp. */
  value: Scalars['Float'];
};

/**
 * Stats within a time frame broken down by granularity.
 * This is used for per channel stats, per team stats use "CreatorTimeseriesMetrics".
 */
export type TimeseriesStats = {
  __typename?: 'TimeseriesStats';
  /** Seconds of ads played per time chunk. */
  adBreaksInSeconds?: Maybe<Array<TimeseriesItem>>;
  /** Ad time (in seconds) per hour per time chunk. */
  adTimePerHour?: Maybe<Array<TimeseriesItem>>;
  /** Average number of viewers per time chunk. */
  averageViewers?: Maybe<Array<TimeseriesItem>>;
  /** Number of chat messages per time chunk. */
  chatMessages?: Maybe<Array<TimeseriesItem>>;
  /** Number of clip views per time chunk. */
  clipViews?: Maybe<Array<TimeseriesItem>>;
  /** Number of clips created per time chunk. */
  clipsCreated?: Maybe<Array<TimeseriesItem>>;
  /** Number of follows during this timestamp. */
  follows?: Maybe<Array<TimeseriesItem>>;
  /** Granularity of the time series, default unit is five minutes. */
  granularity: Granularity;
  /** Host/Raid viewers per time chunk. */
  hostRaidViewers?: Maybe<Array<TimeseriesItem>>;
  /**
   * Deprecated: List of the number of follows within a time period, broken up by granularity.
   * @deprecated Use specific metric from user.timeseriesStats instead.
   */
  items?: Maybe<Array<TimeseriesItem>>;
  /** Live number of views per time chunk. */
  liveViews?: Maybe<Array<TimeseriesItem>>;
  /** Max viewers per time chunk. */
  maxViewers?: Maybe<Array<TimeseriesItem>>;
  /** Minutes watched per time chunk. */
  minutesWatched?: Maybe<Array<TimeseriesItem>>;
  /** Number of subscriptions per time chunk. */
  newSubscriptions?: Maybe<Array<TimeseriesItem>>;
  /** Promotion clicks for the time period. */
  promotionClick?: Maybe<Array<TimeseriesItem>>;
  /** Promotion displays for the time period. */
  promotionDisplay?: Maybe<Array<TimeseriesItem>>;
  /** Time streamed per time chunk. */
  timeStreamed?: Maybe<Array<TimeseriesItem>>;
  /** Number of people chatting per time chunk. */
  uniqueChatters?: Maybe<Array<TimeseriesItem>>;
  /** Number of unique people watching per time chunk. */
  uniqueViewers?: Maybe<Array<TimeseriesItem>>;
};

/** A piece of the shelf title in the form of a token. */
export type TitleTokenEdge = {
  __typename?: 'TitleTokenEdge';
  /** The token. */
  node?: Maybe<TitleTokenNode>;
};

/** The content of a shelf title token. */
export type TitleTokenNode = DateToken | Game | IntegerToken | Tag | TextToken | User;

export type ToggleRitualsEnabledInput = {
  channelID: Scalars['ID'];
  isEnabled: Scalars['Boolean'];
};

export type ToggleRitualsEnabledPayload = {
  __typename?: 'ToggleRitualsEnabledPayload';
  /** Whether the rituals feature is enabled for a channel. */
  isEnabled: Scalars['Boolean'];
  user?: Maybe<User>;
};

/**
 * Assets for a TokenBundleProduct.
 * Each asset will have a 1x, 2x, 3x sizing w/ their respective URLs.
 * Different sizing is required for mobile clients.
 */
export type TokenBundleAsset = {
  __typename?: 'TokenBundleAsset';
  /** URL of asset of size 1x. */
  imageURL1x: Scalars['String'];
  /** URL of asset size 2x. */
  imageURL2x: Scalars['String'];
  /** URL of asset size 3x. */
  imageURL3x: Scalars['String'];
  /**
   * Key identifier for an asset.
   * ex) "bundleImg", "promoImg", etc.
   */
  key: Scalars['String'];
};

/**
 * Tournament is an object that contains all information about a tournament
 * managed within Bits for a specific event tied to cheering.
 * NOTE: Should have been named CheeringTournament.
 */
export type Tournament = {
  __typename?: 'Tournament';
  /**
   * Leaderboard of all users who have cheered in the tournament.
   * @deprecated No longer supported
   */
  globalLeaderboard: BitsLeaderboard;
  /**
   * Event ID of the tournament.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * The list of global milestones that can be claimed in the tournament.
   * For a given threshold, this milestone is reached when cheers from all users on the channel
   * is greater than or equal to the threshold. This unlocks a reward for all users who have cheered.
   * @deprecated No longer supported
   */
  progress: TournamentProgress;
  /**
   * The list of rewards that are a part of the tournament. This is separated out into global, participant, and individual
   * rewards that can be claimed if the user is logged in.
   * @deprecated No longer supported
   */
  rewards?: Maybe<TournamentRewards>;
  /**
   * The list of individual milestones that can be claimed in the tournament.
   * for a given threshold, this milestone is reached when an individual user's total cheers in
   * the channel is greater than or equal to the threshold. This unlocks a reward
   * for the individual user who cheered.
   * @deprecated No longer supported
   */
  self?: Maybe<TournamentSelfEdge>;
  /**
   * Leaderboard of all teams who have been cheered for in the tournament. This leaderboard contains how much each team
   * in the tournament was cheered for.
   * @deprecated No longer supported
   */
  teamLeaderboard: BitsLeaderboard;
  /**
   * The list of teams participating in the tournament.
   * @deprecated No longer supported
   */
  teams: Array<Maybe<TournamentTeam>>;
};

/** Contains all rewards information about the Insider rewards. */
export type TournamentInsiderRewards = {
  __typename?: 'TournamentInsiderRewards';
  /**
   * Twitch chat badge rewards.
   * @deprecated No longer supported
   */
  badges: Array<TournamentReward>;
  /**
   * Bits rewards.
   * @deprecated No longer supported
   */
  bits: Array<TournamentReward>;
  /**
   * Hero skin rewards.
   * @deprecated No longer supported
   */
  heroSkins: Array<TournamentReward>;
  /**
   * In Game Content rewards, like sprays and avatars (non-hero skin rewards).
   * @deprecated No longer supported
   */
  inGameContent: Array<TournamentReward>;
};

/** Describes the amount of progress that has been made in a tournament, with corresponding milestones about said progress. */
export type TournamentProgress = {
  __typename?: 'TournamentProgress';
  /**
   * The amount of progress that has been made in the tournament. This is not exclusive to cheering in the channel.
   * @deprecated No longer supported
   */
  amount: Scalars['Int'];
  /**
   * The milestones associated with the progress made. This is a list of rewards the progress value will unlock.
   * @deprecated No longer supported
   */
  milestones: Array<Milestone>;
};

/** Type containing information about a Reward and claiming information. */
export type TournamentReward = {
  __typename?: 'TournamentReward';
  /**
   * The campaign ID associated with the reward.
   * @deprecated No longer supported
   */
  campaignID: Scalars['ID'];
  /**
   * Can this reward be entitled to the user.
   * @deprecated No longer supported
   */
  canBeFulfilled: Scalars['Boolean'];
  /**
   * Number representing quantity of the reward that user can claim (but not entitled yet) at the time the request is made.
   * @deprecated No longer supported
   */
  canBeFulfilledQuantity: Scalars['Int'];
  /**
   * The reward's description.
   * @deprecated No longer supported
   */
  description: Scalars['String'];
  /**
   * Number representing quantity of the reward that user already claimed and can find in his inventory. If the type is In Game Content, Twitch already handed off to the game through the fulfiller.
   * @deprecated No longer supported
   */
  entitledQuantity: Scalars['Int'];
  /**
   * The ID of the reward.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * The reward's display image URL.
   * @deprecated No longer supported
   */
  imageURL: Scalars['String'];
  /**
   * The state of the reward is entitled to the user.
   * @deprecated No longer supported
   */
  isEntitled: Scalars['Boolean'];
  /**
   * Whether the reward is for prime users only.
   * @deprecated No longer supported
   */
  isPrimeOnly: Scalars['Boolean'];
  /**
   * Whether the reward can be earned multiple times (e.g. in game consumables).
   * @deprecated No longer supported
   */
  isRepeatable: Scalars['Boolean'];
  /**
   * Metadata attached to the reward.
   * @deprecated No longer supported
   */
  metadata?: Maybe<CampaignRewardMetadata>;
  /**
   * The display name of the reward.
   * @deprecated No longer supported
   */
  name: Scalars['String'];
  /**
   * Amount of reward (e.g. amount for bits).
   * @deprecated No longer supported
   */
  quantity: Scalars['Int'];
  /**
   * A number presenting the rarity of this reward (the higher the rarer).
   * @deprecated No longer supported
   */
  rarity: Scalars['Int'];
  /**
   * The type of reward (ex. Twitch Emote, In Game Content).
   * @deprecated No longer supported
   */
  type: Scalars['String'];
};

/**
 * This type holds all information about rewards that are associated with a tournament. The struct parses out
 * which rewards are Global, Team, and Individual, as well as if you're logged in that status if you can claim the reward.
 */
export type TournamentRewards = {
  __typename?: 'TournamentRewards';
  /**
   * The list of Cheerbomb rewards. If the user is logged in, this will also show the claim status of the reward.
   * @deprecated No longer supported
   */
  cheerbomb: Array<TournamentReward>;
  /**
   * The list of Global rewards. If the user is logged in, this will also show the claim status of the reward.
   * @deprecated No longer supported
   */
  global: Array<TournamentReward>;
  /**
   * The list of Individual rewards. If the user is logged in, this will also show the claim status of the reward.
   * @deprecated No longer supported
   */
  individual: Array<TournamentReward>;
  /**
   * The list of Insider rewards, which are granted when one subscribes to the insider pass.
   * @deprecated No longer supported
   */
  insider: TournamentInsiderRewards;
  /**
   * The list of Team rewards. If the user is logged in, this will also show the claim status of the reward.
   * @deprecated No longer supported
   */
  team: Array<TournamentReward>;
};

/** Tournament progress related to a user. */
export type TournamentSelfEdge = {
  __typename?: 'TournamentSelfEdge';
  /**
   * The leaderboard entry of the user. Gives the current position and score.
   * @deprecated No longer supported
   */
  globalLeaderboardItem?: Maybe<BitsLeaderboardItem>;
  /**
   * Amount of progress a user had made towards the tournament personally. This could be a combination of factors,
   * including bits cheered in the channel.
   * @deprecated No longer supported
   */
  progress: TournamentProgress;
  /**
   * A list of the amount of bits a user has cheered for a certain team, as well as the
   * list of milestones that the user could claim with their claim status.
   * @deprecated No longer supported
   */
  teams: Array<TournamentTeam>;
};

/**
 * Team is a construct that contains metadata about a team participating in the tournament,
 * as well as the milestones associated with cheering for them.
 */
export type TournamentTeam = {
  __typename?: 'TournamentTeam';
  /**
   * The division of the team. This string is set by the tournament organizer. (NA, CN, Atlantic League, etc.).
   * @deprecated No longer supported
   */
  division: Scalars['String'];
  /**
   * The ID of the team.
   * @deprecated No longer supported
   */
  id: Scalars['ID'];
  /**
   * The image URL of the team.
   * @deprecated No longer supported
   */
  logoURL: Scalars['String'];
  /**
   * Name of the team.
   * @deprecated No longer supported
   */
  name: Scalars['String'];
};

/** TrackAppealRequestInput the details needs about which track to appeal. */
export type TrackAppealRequestInput = {
  /** audibleMagicResponseID is the ID of the audible magic response. */
  audibleMagicResponseID: Scalars['ID'];
  /** reason is the reason the track is being appealed. */
  reason: Scalars['String'];
};

/** Information used to track recommendation events. */
export type TrackingInfo = {
  __typename?: 'TrackingInfo';
  /** The target object for the shelf, if it exists. */
  reasonTarget?: Maybe<Scalars['String']>;
  /** The type of the target object, if it exists. */
  reasonTargetType?: Maybe<Scalars['String']>;
  /** The reason why this shelf has been recommended. */
  reasonType: Scalars['String'];
  /** The name of the shelf. */
  rowName: Scalars['String'];
};

/** A tracking pixel is used to measure impressions or demographics. */
export type TrackingPixel = {
  __typename?: 'TrackingPixel';
  /** Where this pixel came from. */
  origin?: Maybe<Scalars['String']>;
  /** What service will be using the pixel. */
  service: Scalars['String'];
  /** How long a client needs to view the content before firing the pixel. */
  timeOffsetSeconds?: Maybe<Scalars['Int']>;
  /** The type of tracker. */
  type?: Maybe<TrackingPixelType>;
  /** The URL that is requested when the pixel is fired. */
  url: Scalars['String'];
};

/** The tracking pixel that will be created as part of this campaign. */
export type TrackingPixelInput = {
  /** How long a client needs to view the content before firing the pixel. */
  timeOffsetSeconds?: InputMaybe<Scalars['Int']>;
  /** The type of tracker. */
  type?: InputMaybe<TrackingPixelType>;
  /** The URL that is requested when the pixel is fired. */
  url: Scalars['String'];
};

/** The type of the tracking pixel. */
export enum TrackingPixelType {
  /** Digital Ad Ratings, a Nielsen product that provides demographic data. */
  Dar = 'DAR',
  /** DoubleClick Campaign Manager, a Google product to track ad performance. */
  Dcm = 'DCM',
  /** An impression tracking product. */
  Sizmek = 'SIZMEK'
}

/**
 * A trailer is a video meant to introduce viewers to the creator and the type
 * of content they produce.
 */
export type Trailer = {
  __typename?: 'Trailer';
  /** The trailer video. This may be null if the channel has no trailer. */
  video?: Maybe<Video>;
};

/** TranscodeSession is session metadata related to transcode. */
export type TranscodeSession = {
  __typename?: 'TranscodeSession';
  /** Transcoded audio codecs. */
  audioCodecs: Scalars['String'];
  /** Staff-only field. Hostname of which transcode was processed. */
  host?: Maybe<Scalars['String']>;
  /** Staff-only field. The location of transcode origin. */
  ingestOrigin?: Maybe<Scalars['String']>;
  /** Staff-only field. Profile of transcode. */
  profile?: Maybe<Scalars['String']>;
  /** Transcoded video codecs. */
  videoCodecs: Scalars['String'];
};

/** TransitionExtensionStateError is an error associated with the transitionExtensionState mutation. */
export enum TransitionExtensionStateError {
  /** At least one anchor must be specified. */
  AnchorRequired = 'ANCHOR_REQUIRED',
  /** Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidAuthorEmail = 'INVALID_AUTHOR_EMAIL',
  /** Extension author name length must be > 40. */
  InvalidAuthorNameLength = 'INVALID_AUTHOR_NAME_LENGTH',
  /** Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum. */
  InvalidBitsSupportLevel = 'INVALID_BITS_SUPPORT_LEVEL',
  /** Extension component aspect height must be < 50 or > 1. */
  InvalidComponentAspectHeight = 'INVALID_COMPONENT_ASPECT_HEIGHT',
  /** Aspect Ratio X must be set to a positive integer. */
  InvalidComponentAspectRatioX = 'INVALID_COMPONENT_ASPECT_RATIO_X',
  /** Aspect Ratio Y must be set to a positive integer. */
  InvalidComponentAspectRatioY = 'INVALID_COMPONENT_ASPECT_RATIO_Y',
  /** Extension component aspect width must be < 50 or > 1. */
  InvalidComponentAspectWidth = 'INVALID_COMPONENT_ASPECT_WIDTH',
  /** Target Height must be set to a positve integer. */
  InvalidComponentTargetHeight = 'INVALID_COMPONENT_TARGET_HEIGHT',
  /** Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidComponentViewerPath = 'INVALID_COMPONENT_VIEWER_PATH',
  /** Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidConfigViewerPath = 'INVALID_CONFIG_VIEWER_PATH',
  /** Extension description must be shorter than 1024 characters. */
  InvalidDescriptionLength = 'INVALID_DESCRIPTION_LENGTH',
  /** Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidLiveConfigViewerPath = 'INVALID_LIVE_CONFIG_VIEWER_PATH',
  /** Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidMobileViewerPath = 'INVALID_MOBILE_VIEWER_PATH',
  /** Extension names must be shorter than 40 characters. */
  InvalidNameLength = 'INVALID_NAME_LENGTH',
  /** Extension panel hiehgt must be < 500 or > 100. */
  InvalidPanelHeight = 'INVALID_PANEL_HEIGHT',
  /** Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidPanelViewerPath = 'INVALID_PANEL_VIEWER_PATH',
  /** Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidPrivacyUri = 'INVALID_PRIVACY_URI',
  /** Scale pixels must be set to a positive integer when autoscale is true. */
  InvalidScalingPixels = 'INVALID_SCALING_PIXELS',
  /** Invalid state transition. */
  InvalidStateTransition = 'INVALID_STATE_TRANSITION',
  /** Extension summary must be shorter than 140 characters. */
  InvalidSummaryLength = 'INVALID_SUMMARY_LENGTH',
  /** Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidSupportEmail = 'INVALID_SUPPORT_EMAIL',
  /** Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTermsUri = 'INVALID_TERMS_URI',
  /** Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTestingBaseUri = 'INVALID_TESTING_BASE_URI',
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidVideoOverlayViewerPath = 'INVALID_VIDEO_OVERLAY_VIEWER_PATH',
  /** HasZoom was specified but ZoomPixels is missing. */
  InvalidZoom = 'INVALID_ZOOM',
  /** The number of whitelisted broadcasters exceeds the limit. */
  MaxBroadcasters = 'MAX_BROADCASTERS',
  /** The number of whitelisted testing users exceeds the limit. */
  MaxTesters = 'MAX_TESTERS',
  /** The number of whitelisted config URLs exceeds the limit. */
  MaxWhitelistedConfigUrls = 'MAX_WHITELISTED_CONFIG_URLS',
  /** The number of whitelisted panel URLs exceeds the limit. */
  MaxWhitelistedPanelUrls = 'MAX_WHITELISTED_PANEL_URLS',
  /** The version does not have an asset hash and it must for the transition. */
  MissingAssetHash = 'MISSING_ASSET_HASH',
  /** Review notes were not specified when transitioning an extension to IN_REVIEW. */
  MissingReviewNotes = 'MISSING_REVIEW_NOTES',
  /** Test channel was not specified when transitioning an extension to IN_REVIEW. */
  MissingTestChannel = 'MISSING_TEST_CHANNEL',
  /** Only one version of an Extension can be in a review state (APPROVED, or in IN_REVIEW) at a time. */
  MultipleVersionsInReview = 'MULTIPLE_VERSIONS_IN_REVIEW',
  /** Author email cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingAuthorEmail = 'TRANSITION_MISSING_AUTHOR_EMAIL',
  /** Author name cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingAuthorName = 'TRANSITION_MISSING_AUTHOR_NAME',
  /** Category cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingCategory = 'TRANSITION_MISSING_CATEGORY',
  /** Description cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingDescription = 'TRANSITION_MISSING_DESCRIPTION',
  /** Name cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingName = 'TRANSITION_MISSING_NAME',
  /** Screenshot URLs cannot be empy when transit to READY_FOR_REVIEW. */
  TransitionMissingScreenshotUrls = 'TRANSITION_MISSING_SCREENSHOT_URLS',
  /** Summary cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingSummary = 'TRANSITION_MISSING_SUMMARY',
  /** Support email cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingSupportEmail = 'TRANSITION_MISSING_SUPPORT_EMAIL',
  /** Testing base URI cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingTestingBaseUri = 'TRANSITION_MISSING_TESTING_BASE_URI',
  /** Version cannot be empty when transit to READY_FOR_REVIEW. */
  TransitionMissingVersion = 'TRANSITION_MISSING_VERSION',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** TransitionExtesnsionManifest updates the state of an existing extension. */
export type TransitionExtensionStateInput = {
  /** The extension ID of the extension to update. */
  id: Scalars['ID'];
  /**
   * Notes provided to the moderation team while reviewing the extension.
   * Required when transitioning to READY_FOR_REVIEW.
   */
  reviewNotes?: InputMaybe<Scalars['String']>;
  /** The State to transition the extension to. */
  state: ExtensionState;
  /**
   * URL to a test channel, provided to the moderation team while reviewing the extension.
   * Required when transitioning to READY_FOR_REVIEW.
   */
  testChannel?: InputMaybe<Scalars['String']>;
  /** The extension version to update. */
  version: Scalars['String'];
};

/** TransitionExtensionStatePayload returns any errors that occur during update. */
export type TransitionExtensionStatePayload = {
  __typename?: 'TransitionExtensionStatePayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<TransitionExtensionStateError>;
  /** The updated extension manifest. */
  manifest?: Maybe<ExtensionManifest>;
};

/** A result of a try to trigger a drop on a channel. */
export type TriggerResult = {
  __typename?: 'TriggerResult';
  /** The channel the drop was tried to be triggered on. */
  channel?: Maybe<Channel>;
  /** The drop instance id in case the drop was successfully triggered. */
  dropInstanceID?: Maybe<Scalars['ID']>;
  /** The status result of the try to trigger the drop. */
  status: ManuallyTriggerDropResultStatus;
};

/** Trigger type determines what type of events activate the trigger. */
export enum TriggerType {
  /** CHEER type trigger is activated by cheer events. */
  Cheer = 'CHEER'
}

/**
 * TrueXAd is descriptive information about an engagement that was show for bits.
 * Used as input on the redeem trueXAd mutation.
 */
export type TrueXAd = {
  /** campaignID is the ID of the campaign this ad belongs to. */
  campaignID: Scalars['ID'];
  /** creativeID is the ID of the particular ad experience displayed to the user. */
  creativeID: Scalars['ID'];
  /** currencyAmount is the suggested amount of "currency" to provide to the user based on this ad. */
  currencyAmount: Scalars['String'];
  /** name is the name of the ad campaign. */
  name: Scalars['String'];
};

/** TutorialState represents the possible states of the user's viewing of the mod view tutorial. */
export enum TutorialState {
  /** DISMISSED occurs when a user dismisses the tutorial. */
  Dismissed = 'DISMISSED',
  /** SEEN occurs when a user has seen every step in a tutorial. */
  Seen = 'SEEN',
  /** UNSEEN is the initial state, before a user has either dismissed or viewed the tutorial entirely. */
  Unseen = 'UNSEEN'
}

/** Mosaic layouts for Twitch Studio. */
export type TwitchStudioMosaicLayout = ChannelDashboardLayout & {
  __typename?: 'TwitchStudioMosaicLayout';
  /** The actual Mosaic layout data to be stored or fetched. */
  data: Scalars['MosaicData'];
  /** A unique identifier to uniquely reference this layout. */
  id: Scalars['ID'];
  /** When the layout was last updated */
  lastUpdated?: Maybe<Scalars['Time']>;
  /** The display name for the layout shown to the user. */
  name: Scalars['String'];
  /**
   * A version to identify how the MosaicData was generated,
   * such as for deprecation purposes.
   */
  version: Scalars['String'];
};

/** Two Factor Methods the user can have enabled. */
export enum TwoFactorMethod {
  /** The user has 2fa enabled and has the authy app installed. The 2fa verification code can be retreived from the authy app OR SMS. */
  AuthyApp = 'AUTHY_APP',
  /** The user has 2fa enabled but does not have the authy app installed. Only way for the user to receive the 2fa verification code is SMS. */
  AuthySms = 'AUTHY_SMS',
  /** The user has 2fa enabled and has gone through the totp onboarding process successfully. The 2fa verification code can be retreived from the authenticator app the user chose during onboarding. */
  AuthyTotp = 'AUTHY_TOTP',
  /** unknown 2fa method. */
  Unknown = 'UNKNOWN'
}

/** The url metadata of a twitch webpage. */
export type UrlMetadata = {
  __typename?: 'URLMetadata';
  /** The linked data (JSON format) of the page. */
  jsonld?: Maybe<Scalars['String']>;
  /** The list of metatags of the page. */
  metatags: Array<SeoMetatag>;
  /** The data that power URL sharing. */
  share: UrlMetadataShare;
  /** The title of the page. */
  title: Scalars['String'];
};

/** The data that power URL sharing. */
export type UrlMetadataShare = {
  __typename?: 'URLMetadataShare';
  /** The text to share. */
  text: Scalars['String'];
  /** The title to share. */
  title: Scalars['String'];
  /** The url to share. */
  url: Scalars['String'];
};

/**
 * Used to provide info on the subscription events that might have happened in another device
 * and not acknowledged in the current device.
 */
export type UnacknowledgedSubscriptionEvent = {
  __typename?: 'UnacknowledgedSubscriptionEvent';
  /** The user of the channel the subscription was for. */
  channel?: Maybe<User>;
  /** The time that the subscription benefits will expire. */
  endDate?: Maybe<Scalars['Time']>;
  /** The external product id. */
  externalProductID: Scalars['ID'];
  /** The current status of the subscription. One of "active", "will_not_renew", or "canceled". */
  status: UnacknowledgedSubscriptionEventState;
  /** The UUID of the subscription. */
  subscriptionID: Scalars['ID'];
};

/** Subscrption state of the reported unacknowledged events. */
export enum UnacknowledgedSubscriptionEventState {
  /** The subscription is active. */
  Active = 'ACTIVE',
  /** Subscription will not renew and is not active. */
  Cancelled = 'CANCELLED',
  /** Subscription that is on hold. */
  OnHold = 'ON_HOLD',
  /** Subscription will not renew, but may still be active. */
  WillNotRenew = 'WILL_NOT_RENEW'
}

/**
 * A request from a channel-banned user to the channel moderators to be unbanned
 * from the channel.
 */
export type UnbanRequest = {
  __typename?: 'UnbanRequest';
  /** The channel on which the banned user is appealing a ban. */
  channel?: Maybe<Channel>;
  /** The time at which the unban request was created. */
  createdAt: Scalars['Time'];
  /** UUID of the Unban Request. */
  id: Scalars['ID'];
  /** The banned user appealing the ban. */
  requester?: Maybe<User>;
  /** Custom message provided by the requester. */
  requesterMessage?: Maybe<Scalars['String']>;
  /** The time at which the unban request was resolved (approved or denied). */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** The moderator that has taken action on the user. */
  resolvedBy?: Maybe<User>;
  /** Custom message provided by the resolver. */
  resolverMessage?: Maybe<Scalars['String']>;
  /** The status of the unban request. */
  status: UnbanRequestStatus;
};

/** Paginated list of Unban Requests. */
export type UnbanRequestConnection = {
  __typename?: 'UnbanRequestConnection';
  /** The elements of the list. */
  edges?: Maybe<Array<UnbanRequestEdge>>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Count of all pending unban requests. */
  totalCount?: Maybe<Scalars['Float']>;
};


/** Paginated list of Unban Requests. */
export type UnbanRequestConnectionTotalCountArgs = {
  status?: InputMaybe<UnbanRequestStatus>;
};

/** Element in a list of Unban Requests. */
export type UnbanRequestEdge = {
  __typename?: 'UnbanRequestEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The unban request. */
  node?: Maybe<UnbanRequest>;
};

/** Error returned from an update mutation. */
export type UnbanRequestError = {
  __typename?: 'UnbanRequestError';
  /** The error code returned from an update mutation. */
  code: UnbanRequestErrorCode;
};

/** Possible errors arising from an update unban request mutation. */
export enum UnbanRequestErrorCode {
  /** Attempted status update was not valid. */
  InvalidUpdate = 'INVALID_UPDATE',
  /** Unban Request was not found. */
  RequestNotFound = 'REQUEST_NOT_FOUND',
  /** User does not have the permissions required to update the Unban Request. */
  Unauthorized = 'UNAUTHORIZED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Reasons why a user may be restricted from requesting an unban. */
export enum UnbanRequestRestrictionReason {
  /** User has already created an unban request for the current ban. */
  AlreadyCreated = 'ALREADY_CREATED',
  /** User is not banned on the channel. */
  NotBanned = 'NOT_BANNED',
  /** User is attempting to create a request too since their ban. Must wait for cooldown period to end. */
  TooSoonSinceBan = 'TOO_SOON_SINCE_BAN',
  /** User must be logged in to be able to request an unban. */
  Unauthenticated = 'UNAUTHENTICATED',
  /** Channel is not receiving unban requests. */
  UnbanRequestsDisabled = 'UNBAN_REQUESTS_DISABLED',
  /** Unknown restricted reason. */
  Unknown = 'UNKNOWN'
}

/** Possible statuses of an unban request. */
export enum UnbanRequestStatus {
  /**
   * The user has had their unban request approved, and has acknowledged
   * the rules on the channel.
   */
  Acknowledged = 'ACKNOWLEDGED',
  /** Approved; user is unbanned from the channel. */
  Approved = 'APPROVED',
  /** The user has canceled their unban request. */
  Canceled = 'CANCELED',
  /** User's unban request is denied; user remains banned in the channel. */
  Denied = 'DENIED',
  /** Default status. Is an invalid status state. Used as zero value when no specific status is specified. */
  None = 'NONE',
  /** A moderator decision has not been made on the Unban Request. */
  Pending = 'PENDING'
}

/** Optional filters that can be applied to an unban requests query. */
export type UnbanRequestsOptions = {
  /** The order of the results, either oldest first or newest first. */
  order?: InputMaybe<UnbanRequestsSortOrder>;
  /** Filter results to only requests of this status. */
  status?: InputMaybe<UnbanRequestStatus>;
  /** Filter results to only requests from this user. */
  userID?: InputMaybe<Scalars['ID']>;
};

/** Set of preferences set by the channel owner regarding unban requests. */
export type UnbanRequestsSettings = {
  __typename?: 'UnbanRequestsSettings';
  /** The number of minutes after being banned before users can request an unban. */
  cooldownMinutes: Scalars['Int'];
  /** Whether users can create requests on the channel or not. */
  isEnabled: Scalars['Boolean'];
};

/** Ways to sort Unban Requests. */
export enum UnbanRequestsSortOrder {
  /** The newest request first. */
  Newest = 'NEWEST',
  /** The oldest request first. */
  Oldest = 'OLDEST'
}

export type UnbanUserFromChatRoomError = {
  __typename?: 'UnbanUserFromChatRoomError';
  code: UnbanUserFromChatRoomErrorCode;
};

export enum UnbanUserFromChatRoomErrorCode {
  /** User does not have permission to unban in channel. */
  Forbidden = 'FORBIDDEN',
  /** Target is not banned in channel. */
  TargetNotBanned = 'TARGET_NOT_BANNED',
  /** Target does not exist. */
  TargetNotFound = 'TARGET_NOT_FOUND'
}

export type UnbanUserFromChatRoomInput = {
  bannedUserLogin: Scalars['String'];
  channelID: Scalars['ID'];
};

export type UnbanUserFromChatRoomPayload = {
  __typename?: 'UnbanUserFromChatRoomPayload';
  /** The new ban status of this user regarding the specified channel. */
  ban?: Maybe<ChatRoomBanStatus>;
  /** Mutation error caused by the user input. */
  error?: Maybe<UnbanUserFromChatRoomError>;
};

export type UnblockUserInput = {
  /** ID of user to unblock. */
  targetUserID: Scalars['ID'];
};

export type UnblockUserPayload = {
  __typename?: 'UnblockUserPayload';
  /** User that was unblocked. */
  targetUser: User;
};

/** Data required to undo recommendation feedback. */
export type UndoRecommendationFeedbackInput = {
  /** The id of the feedback. */
  feedbackID: Scalars['ID'];
  /** The page this event was fired from. */
  sourceItemPage: Scalars['String'];
  /** The unique id given to this request. */
  sourceItemRequestID: Scalars['ID'];
  /** The unique tracking id of the shelf / shelf card. */
  sourceItemTrackingID: Scalars['ID'];
};

/** Returns the created feedback item back to the client. */
export type UndoRecommendationFeedbackPayload = {
  __typename?: 'UndoRecommendationFeedbackPayload';
  /** The id of the feedback you just undid. */
  feedbackID: Scalars['ID'];
};

/** UnfollowGameInput contains just the game ID of the game to unfollow. */
export type UnfollowGameInput = {
  gameID: Scalars['ID'];
};

/** UnfollowGamePayload is the response from unfollowing a game. */
export type UnfollowGamePayload = {
  __typename?: 'UnfollowGamePayload';
  /** The deleted follow relationship, if one existed beforehand. */
  follow?: Maybe<GameFollow>;
  /**
   * The game that was unfollowed
   * game.self.follow should now be null.
   */
  game?: Maybe<Game>;
};

export type UnfollowUserInput = {
  targetID: Scalars['ID'];
};

export type UnfollowUserPayload = {
  __typename?: 'UnfollowUserPayload';
  /** The deleted follow relationship. */
  follow?: Maybe<Follow>;
};

export type UnfriendUserInput = {
  /** The authenticated user will no longer be friends with the user whose ID is equal to targetID. */
  targetID: Scalars['ID'];
};

export type UnfriendUserPayload = {
  __typename?: 'UnfriendUserPayload';
  /** The user whose friend relationship was just destroyed by the authenticated user. */
  user?: Maybe<User>;
};

/** UnhostInput contains the necessary inputs to unhost a channel. */
export type UnhostInput = {
  /** Channel ID to unhost from. */
  channelID: Scalars['ID'];
};

/** UnhostPayload is the response after attempting to unhost. */
export type UnhostPayload = {
  __typename?: 'UnhostPayload';
  /** The channel that just unhosted. */
  channel?: Maybe<User>;
};

/** UninstallExtensionError is wrapper for error associated with the uninstallExtension mutation. */
export type UninstallExtensionError = {
  __typename?: 'UninstallExtensionError';
  /** Error code. */
  code: UninstallExtensionErrorCode;
};

/** UninstallExtensionErrorCode is an error code associated with UninstallExtensionError. */
export enum UninstallExtensionErrorCode {
  /** The extension is not installed on the channel. */
  ExtensionNotInstalled = 'EXTENSION_NOT_INSTALLED',
  /** Channel id is invalid, for example, is empty. */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** The required input for an uninstallExtension mutation. */
export type UninstallExtensionInput = {
  /** The composite ID of an extension installation <extensionID:version:channelID>. */
  extensionInstallationID: Scalars['ID'];
};

/** The resulting payload of an uninstallExtension mutation. */
export type UninstallExtensionPayload = {
  __typename?: 'UninstallExtensionPayload';
  /** The error when the mutation fails to set feature flags. */
  error?: Maybe<UninstallExtensionError>;
  /** The id of the extension which was uninstalled. */
  id: Scalars['ID'];
};

/** UnlinkAmazonConnectionInput represent the parameters necessary to unlink an amazon connection. */
export type UnlinkAmazonConnectionInput = {
  /** Id of the user that wishes to unlink his amazon connection. */
  userID?: InputMaybe<Scalars['ID']>;
};

/** UnlinkAmazonConnectionPayload indicates whether the unlinking was successful or not. */
export type UnlinkAmazonConnectionPayload = {
  __typename?: 'UnlinkAmazonConnectionPayload';
  /** Whether or not the unlink operation was successful. Only reports if the underlying call was successful, as such will return true even if no unlinking occured (such as when as user doesn't have a linked amazon account, for instance). */
  isSuccess?: Maybe<Scalars['Boolean']>;
};

/** User ID input of the connection being deleted. */
export type UnlinkRiotConnectionInput = {
  /** Twitch User ID to delete. */
  userID: Scalars['ID'];
};

/** Contains a struct of all current accounts connections. */
export type UnlinkRiotConnectionPayload = {
  __typename?: 'UnlinkRiotConnectionPayload';
  /** The complete account connections list where Riot will be null. */
  connections?: Maybe<AccountConnectionSet>;
};

export type UnlinkSsoInput = {
  /** The single sign-on (SSO) app that should be unlinked from the authenticated user's account. */
  app: Scalars['String'];
  /** The token that identifies the user on the linked SSO app. */
  token?: InputMaybe<Scalars['String']>;
};

export type UnlinkSsoPayload = {
  __typename?: 'UnlinkSSOPayload';
  /** The deleted SSO links. */
  links?: Maybe<Array<SsoLink>>;
};

/** Input for unlocking a chosen modified subscriber emote with Community Points. */
export type UnlockChosenModifiedSubscriberEmoteInput = {
  /** The channel the emote is being redeemed on. */
  channelID: Scalars['ID'];
  /** The client's perception of the reward's cost. */
  cost: Scalars['Int'];
  /** The modified emote to unlock. */
  emoteID: Scalars['ID'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming the unlock a chosen modified subscriber emote reward. */
export type UnlockChosenModifiedSubscriberEmotePayload = {
  __typename?: 'UnlockChosenModifiedSubscriberEmotePayload';
  /** The user's new Community Points balance. */
  balance?: Maybe<Scalars['Int']>;
  /** The error that occurred during redemption, if any. */
  error?: Maybe<CommunityPointsUnlockEmoteError>;
};

/** Input for unlocking a chosen subscriber emote with Community Points. */
export type UnlockChosenSubscriberEmoteInput = {
  /** The channel the emote is being redeemed on. */
  channelID: Scalars['ID'];
  /** The client's perception of the reward's cost. */
  cost: Scalars['Int'];
  /** The emote to unlock. */
  emoteID: Scalars['ID'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming the unlock a chosen subscriber emote reward. */
export type UnlockChosenSubscriberEmotePayload = {
  __typename?: 'UnlockChosenSubscriberEmotePayload';
  /** The user's new Community Points balance. */
  balance?: Maybe<Scalars['Int']>;
  /** The error that occurred during redemption, if any. */
  error?: Maybe<CommunityPointsUnlockEmoteError>;
};

/** Input for unlocking a random subscriber emote with Community Points. */
export type UnlockRandomSubscriberEmoteInput = {
  /** The channel the emote is being redeemed on. */
  channelID: Scalars['ID'];
  /** The client's perception of the reward's cost. */
  cost: Scalars['Int'];
  /** Client-set identifier for the transaction. This ID should be universally unique. */
  transactionID: Scalars['ID'];
};

/** The response from redeeming the unlock a random subscriber emote reward. */
export type UnlockRandomSubscriberEmotePayload = {
  __typename?: 'UnlockRandomSubscriberEmotePayload';
  /** The user's new Community Points balance. */
  balance?: Maybe<Scalars['Int']>;
  /** The random emote that was unlocked. */
  emote?: Maybe<CommunityPointsEmote>;
  /** The error that occurred during redemption, if any. */
  error?: Maybe<CommunityPointsUnlockEmoteError>;
};

/** ModUserError contains details about a client error that occurred. */
export type UnmodUserError = {
  __typename?: 'UnmodUserError';
  /** The enum indicating what error has occurred. */
  code: UnmodUserErrorCode;
};

/** UnmodUserErrorCode defines a client error that occurred while remove a moderator. */
export enum UnmodUserErrorCode {
  /** The channel does not exist. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** The requesting user does not have permission to add a moderator in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The target user does not exist or has a suspended account. */
  TargetNotFound = 'TARGET_NOT_FOUND',
  /** The target user is not a moderator. */
  TargetNotMod = 'TARGET_NOT_MOD'
}

/** UnmodUserInput contains the parameters to remove a user as a moderator to a channel. */
export type UnmodUserInput = {
  /** The channel that the user will be removed as a moderator to. */
  channelID: Scalars['ID'];
  /**
   * The ID of the user that will be removed as a moderator.
   * Either targetID or targetLogin must be provided.
   */
  targetID?: InputMaybe<Scalars['ID']>;
  /**
   * The login of the user that will be removed as a moderator.
   * Either targetID or targetLogin must be provided.
   */
  targetLogin?: InputMaybe<Scalars['String']>;
};

/** UnmodUserPayload is the response when remove a user as a moderator. */
export type UnmodUserPayload = {
  __typename?: 'UnmodUserPayload';
  /** The channel that the user is removed as a moderator to. */
  channel?: Maybe<User>;
  /**
   * The client error that has occurred.
   * Null if the operation is successful.
   */
  error?: Maybe<UnmodUserError>;
  /** The user that is removed as a moderator. */
  target?: Maybe<User>;
};

/** UnsetHypeTrainConfigInput takes series of optional config settings and unsets the custom value for the default.. */
export type UnsetHypeTrainConfigInput = {
  /** Custom emote to be rendered in Hype Train messaging. */
  calloutEmote?: InputMaybe<Scalars['Boolean']>;
  /** Length of the cooldown period after a hype train ends. */
  cooldownPeriodMinutes?: InputMaybe<Scalars['Boolean']>;
  /** The difficulty of hype train levels. */
  difficulty?: InputMaybe<Scalars['Boolean']>;
  /** Hype Train kickoff settings. */
  eventsThreshold?: InputMaybe<Scalars['Boolean']>;
  /** Whether hype train should be enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** A boolean flag that indicates if the hype train settings should be personalized by Twitch. */
  shouldUsePersonalizedSettings?: InputMaybe<Scalars['Boolean']>;
  /** Use creator color as base color of the Hype Train progress bar. */
  willUseCreatorColor?: InputMaybe<Scalars['Boolean']>;
};

/** UnsetHypeTrainConfigPayload is the response that contains the Unsetd config. */
export type UnsetHypeTrainConfigPayload = {
  __typename?: 'UnsetHypeTrainConfigPayload';
  /** The hype train config for the channel. */
  config?: Maybe<HypeTrainConfig>;
};

/** Input to the unsubscribe mutation. One of "channel" or "type" fields must be provided. */
export type UnsubscribeEmailInput = {
  /** The unique ID of the origin email. */
  sourceEmailID: Scalars['String'];
  /** The email type of the origin email. */
  sourceEmailType: Scalars['String'];
  /** ID of the channel whose notifications should be blocked. */
  targetChannelID?: InputMaybe<Scalars['ID']>;
  /** The email type from which the user is unsubscribing. */
  targetEmailType?: InputMaybe<Scalars['String']>;
  /** ID of the user requesting the unsubscribe action. */
  userID: Scalars['ID'];
  /** Server signature to verify authenticity of the link author. */
  validatingHash: Scalars['String'];
};

/** Output from the unsubscribe mutation. */
export type UnsubscribeEmailPayload = {
  __typename?: 'UnsubscribeEmailPayload';
  /** Specifies whether the action was successful. */
  isSuccess: Scalars['Boolean'];
};

/** Inputs to the updateAdProperties mutation. */
export type UpdateAdPropertiesInput = {
  /** Toggle for disable prerolls for midrolls feature. */
  hasDisablePrerollsAbilityEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Toggle for disable prerolls for midrolls notifcations.
   * The "Disable Prerolls" product is a way for streamers to disable preroll ads by running midroll ads.
   * The streamer can choose to enable notifications (ie. "Preroll Ads are now disabled for X minutes") for this product.
   */
  hasDisablePrerollsNotificationsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Toggle for enable multiplayer ads for subs. */
  isMultiplayerAdsForSubsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** User the update belongs to. */
  targetUserID: Scalars['ID'];
};

/** Output from the updateAdProperties mutation. */
export type UpdateAdPropertiesPayload = {
  __typename?: 'UpdateAdPropertiesPayload';
  /** User/channel to update the ad settings. */
  targetUser?: Maybe<User>;
};

/** Inputs for updating all videos viewability by channel id mutation. */
export type UpdateAllChannelVideosViewabilityInput = {
  /** The ID of the channel to update all videos from. */
  channelID: Scalars['ID'];
  /** Determines viewability of all the channels videos. */
  scope: VideoPrivacyScope;
};

/** The returned payload from the UpdateAllChannelVideosViewability mutation. */
export type UpdateAllChannelVideosViewabilityPayload = {
  __typename?: 'UpdateAllChannelVideosViewabilityPayload';
  /** The status for this mutation. */
  status?: Maybe<UpdateAllChannelVideosViewabilityStatus>;
};

/** Status associated with mutation UpdateAllChannelVideosViewability. */
export type UpdateAllChannelVideosViewabilityStatus = {
  __typename?: 'UpdateAllChannelVideosViewabilityStatus';
  /** Error code. */
  code: UpdateAllChannelVideosViewabilityStatusCode;
};

/** The status codes for this mutation. */
export enum UpdateAllChannelVideosViewabilityStatusCode {
  /** User does not have permission to update videos. */
  Forbidden = 'FORBIDDEN',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid Argument. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Update job was successful started. */
  Success = 'SUCCESS',
  /** Unknown Error. */
  Unknown = 'UNKNOWN'
}

export type UpdateAllWhisperThreadsInput = {
  markAllAsRead?: InputMaybe<Scalars['Boolean']>;
};

export type UpdateAllWhisperThreadsPayload = {
  __typename?: 'UpdateAllWhisperThreadsPayload';
  count: Scalars['Int'];
};

/** Defines AutoMod category level settings for a Channel, either overallLevel or detailedAutoModLevels should be non null. */
export type UpdateAutoModLevelsInput = {
  /** String ID of the channel AutoModProperties are being updated for. */
  channelID: Scalars['ID'];
  /** This field represents the detailed AutoMod category settings, which may map to an overallLevel. */
  detailedLevels?: InputMaybe<DetailedAutoModLevelsInput>;
  /** This field will be a value between 0 and 4, inclusive, it is not required. */
  overallLevel?: InputMaybe<Scalars['Int']>;
};

/** Defines the new AutoMod levels of a channel. */
export type UpdateAutoModLevelsPayload = {
  __typename?: 'UpdateAutoModLevelsPayload';
  /** The new levels after applying the mutation. */
  autoModConfiguration?: Maybe<AutoModConfiguration>;
};

export type UpdateAutoModPropertiesInput = {
  /** These fields should be values between 0 and 6 inclusive. */
  aggressiveLevel: Scalars['Int'];
  /** String ID of the channel AutoModProperties are being updated for. */
  channelID: Scalars['String'];
  identityLevel: Scalars['Int'];
  profanityLevel: Scalars['Int'];
  sexualLevel: Scalars['Int'];
};

export type UpdateAutoModPropertiesPayload = {
  __typename?: 'UpdateAutoModPropertiesPayload';
  /** The new properties after applying the mutation. */
  autoModProperties?: Maybe<AutoModProperties>;
};

/** UpdateAutohostSettingsInput update a user's autohost settings. */
export type UpdateAutohostSettingsInput = {
  /** True if this channel has the autohost feature turned on. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The strategy to use when choosing channels to autohost. */
  strategy?: InputMaybe<AutohostSettingsStrategy>;
  /** UserID to update settings for. */
  userID: Scalars['ID'];
  /** True if this user autohosts their team members. */
  willAutohostTeam?: InputMaybe<Scalars['Boolean']>;
  /** True if this channels prefers autohost over vodcast. */
  willPrioritizeAutohost?: InputMaybe<Scalars['Boolean']>;
};

/** UpdateAutohostSettingsPayload returns the user whose settings had been updated. */
export type UpdateAutohostSettingsPayload = {
  __typename?: 'UpdateAutohostSettingsPayload';
  /** User whose autohost settings has been updated. */
  user?: Maybe<User>;
};

/** UpdateBitsBadgeTierNotificationInput is the input required when updating a bits badge tier notification. */
export type UpdateBitsBadgeTierNotificationInput = {
  /** Optional message to send when sharing notification. If supplied, will accompany user notice. */
  message?: InputMaybe<Scalars['String']>;
  /** Unique Identifier for the notification. */
  notificationID: Scalars['ID'];
  /** New state for notification. */
  notificationState: BitsBadgeTierNotificationState;
};

/** UpdateBitsBadgeTierNotificationPayload is the payload returned after updating a bits badge tier notification. */
export type UpdateBitsBadgeTierNotificationPayload = {
  __typename?: 'UpdateBitsBadgeTierNotificationPayload';
  /** The user that updated the bits badge tier notification. */
  user?: Maybe<User>;
};

/** Errors for updating bits badges. */
export type UpdateBitsBadgeTiersError = {
  __typename?: 'UpdateBitsBadgeTiersError';
  /** The associated error code. */
  code: UpdateBitsBadgeTiersErrorCode;
};

/** Possible error codes returned for updating bits badges. */
export enum UpdateBitsBadgeTiersErrorCode {
  /** Badge title is too long. */
  BadgeTitleExceedsCharacterLimit = 'BADGE_TITLE_EXCEEDS_CHARACTER_LIMIT',
  /** Badge title did not pass moderation check. */
  BadgeTitleFailedModeration = 'BADGE_TITLE_FAILED_MODERATION',
  /** The emote code submitted collides with an existing emote code. */
  EmoteCodeAlreadyExists = 'EMOTE_CODE_ALREADY_EXISTS',
  /** The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines). */
  EmoteCodeUnacceptable = 'EMOTE_CODE_UNACCEPTABLE',
  /** Data for least one of the image sizes is not provided. */
  IncompleteBadgeImageData = 'INCOMPLETE_BADGE_IMAGE_DATA',
  /** Invalid parameters in the request. */
  InvalidParameter = 'INVALID_PARAMETER',
  /** Other errors returned from the service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** Settings related to bits badges. */
export type UpdateBitsBadgeTiersInput = {
  /** A list of bits badge tiers to be modified. */
  tiers?: InputMaybe<Array<BitsBadgeTierInput>>;
  /** The owner ID of the channel that the badge tiers belong to. */
  userID: Scalars['ID'];
};

/** Results of bits badge tier updates. */
export type UpdateBitsBadgeTiersPayload = {
  __typename?: 'UpdateBitsBadgeTiersPayload';
  /** Whether or not the broadcaster is enabled to upload bits badge tier emote rewards. */
  canUploadBadgeTierEmoticons?: Maybe<Scalars['Boolean']>;
  /** Service error, if any. */
  error?: Maybe<UpdateBitsBadgeTiersError>;
  /** Updated bits badge tiers. */
  tiers?: Maybe<Array<BitsBadgeTier>>;
};

/** Error code for an error that occurs while updating boost settings. */
export type UpdateBoostSettingsError = {
  __typename?: 'UpdateBoostSettingsError';
  /** Error code for error that occurred while updating boost settings. */
  code: UpdateBoostSettingsErrorCode;
};

/** Error types recognized. */
export enum UpdateBoostSettingsErrorCode {
  /** Internal error being returned from service. */
  InternalError = 'INTERNAL_ERROR',
  /** Invalid parameter in the request. */
  InvalidParameter = 'INVALID_PARAMETER'
}

/** The required input for a updateBoostSettings mutation. */
export type UpdateBoostSettingsInput = {
  /** The Id of the channel where we want to update the boost enable/disable settings. */
  channelID: Scalars['ID'];
  /** Whether the channel has enabled boost challenges. */
  isEarnedEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Whether the channel has enabled boosts. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Whether the channel has enabled boosts paid for by the community. */
  isPaidEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** The result of an updateBoostSettings mutation. */
export type UpdateBoostSettingsPayload = {
  __typename?: 'UpdateBoostSettingsPayload';
  /** The updated channel. */
  channel?: Maybe<Channel>;
  /** The possible error returned from the service. */
  error?: Maybe<UpdateBoostSettingsError>;
};

/** Possible error codes returned from updating broadcast settings. */
export enum UpdateBroadcastSettingsErrorCode {
  /** User is not authorized to update broadcast settings for this channel. */
  AuthFailure = 'AUTH_FAILURE',
  /** Game name is too long. */
  GameNameTooLong = 'GAME_NAME_TOO_LONG',
  /** Language is invalid. */
  LanguageNotValid = 'LANGUAGE_NOT_VALID',
  /** Too many attempts to update broadcast settings. */
  RequestsThrottled = 'REQUESTS_THROTTLED',
  /** Streaming status is too long. */
  StatusTooLong = 'STATUS_TOO_LONG',
  /** Streaming status uses banned words. */
  StatusUsesBannedWords = 'STATUS_USES_BANNED_WORDS',
  /** Unrecognized error returned from the backend service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a updateBroadcastSettings mutation. */
export type UpdateBroadcastSettingsInput = {
  /** Indicate broadcaster's streaming language. */
  broadcasterLanguage?: InputMaybe<Scalars['String']>;
  /** The title of the game that the broadcaster is playing. */
  game?: InputMaybe<Scalars['String']>;
  /** The isMature boolean to set onto the user broadcast. */
  isMature?: InputMaybe<Scalars['Boolean']>;
  /** Channel's streaming Status. */
  status?: InputMaybe<Scalars['String']>;
  /** The Id of the user whose broadcast setting is being updated. */
  userID: Scalars['ID'];
};

/** The result of a updateBroadcastSettings mutation. */
export type UpdateBroadcastSettingsPayload = {
  __typename?: 'UpdateBroadcastSettingsPayload';
  /** The modified broadcast settings. */
  broadcastSettings?: Maybe<BroadcastSettings>;
  /** Error from updating broadcast settings, if any. */
  error?: Maybe<UpdateBroadcastSettingsErrorCode>;
};

/** Inputs for updating the user's celebration config. */
export type UpdateCelebrationConfigInput = {
  /** ID of channel to update the celebration config. */
  channelID: Scalars['ID'];
  /** If turn, celebrations are enabled on the channel. */
  isEnabled: Scalars['Boolean'];
};

/** Outputs from the update celebration config mutation. */
export type UpdateCelebrationConfigPayload = {
  __typename?: 'UpdateCelebrationConfigPayload';
  /** The updated celebration config. */
  celebrationConfig?: Maybe<CelebrationConfig>;
  /** If present, there was an error with the request. */
  error?: Maybe<CelebrationError>;
};

/** Inputs for creating a new celebration. */
export type UpdateCelebrationInput = {
  /** Where on the channel page the celebration will show. */
  area?: InputMaybe<CelebrationArea>;
  /** ID of celebration to update. */
  celebrationID: Scalars['ID'];
  /** ID of channel where the celebration to update exists. */
  channelID: Scalars['ID'];
  /** Length the celebration will play. */
  durationMilliseconds?: InputMaybe<Scalars['Int']>;
  /** Effect which will show when the celebration triggers (ex Fireworks). */
  effect?: InputMaybe<CelebrationEffect>;
  /** Threshold which will trigger the celebration (ex: Cheering 100 Bits). */
  eventThreshold?: InputMaybe<Scalars['Int']>;
  /** Event type which will trigger the celebration (ex: Cheering Bits). */
  eventType?: InputMaybe<CelebrationEventType>;
  /**
   * Intensity of the celebration.
   * Should be bounded (TBA) value which will determine the spectacle of the celebration.
   */
  intensity?: InputMaybe<Scalars['Int']>;
  /** If true, the celebration is enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Outputs from the Update celebration mutation. */
export type UpdateCelebrationPayload = {
  __typename?: 'UpdateCelebrationPayload';
  /** The updated celebration. */
  celebration?: Maybe<Celebration>;
  /** If present, there was an error with the request. */
  error?: Maybe<CelebrationError>;
};

/** Inputs for updating the user's celebration product config. */
export type UpdateCelebrationProductConfigInput = {
  /** List of celebrations products for purchase in the channel. */
  celebrationProducts: Array<CelebrationProductConfigInput>;
  /** ID of channel to update the celebration product config. */
  channelID: Scalars['ID'];
};

/** Outputs from the updated celebration product config mutation. */
export type UpdateCelebrationProductConfigPayload = {
  __typename?: 'UpdateCelebrationProductConfigPayload';
  /** The updated celebration products. */
  celebrationProducts?: Maybe<Array<CelebrationProduct>>;
  /** If present, there was an error with the request. */
  error?: Maybe<CelebrationError>;
};

/** Inputs for updating the user's celebration user settings. */
export type UpdateCelebrationUserSettingsInput = {
  /** If true, celebrations are disabled for the user to see. */
  isOptedOut?: InputMaybe<Scalars['Boolean']>;
};

/** Outputs from the update celebration config mutation. */
export type UpdateCelebrationUserSettingsPayload = {
  __typename?: 'UpdateCelebrationUserSettingsPayload';
  /** The updated logged in user. */
  currentUser?: Maybe<User>;
};

/** The result of a UpdateChangelogReadTimePayload mutation. */
export type UpdateChangelogReadTimePayload = {
  __typename?: 'UpdateChangelogReadTimePayload';
  /** The user whose changelog was marked as read. */
  user?: Maybe<User>;
};

/** Mutation input for updating chanlet content attributes. */
export type UpdateChanletContentAttributesInput = {
  /** Identifier of the chanlet. */
  chanletID: Scalars['ID'];
  /**
   * A list of multi-view content attribute IDs.
   * The provided list will override the list of IDs currently stored.
   */
  contentAttributeIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/** Response payload. */
export type UpdateChanletContentAttributesPayload = {
  __typename?: 'UpdateChanletContentAttributesPayload';
  /** Updated chanlet. */
  chanlet?: Maybe<Channel>;
};

/** The possible error returned. */
export enum UpdateChannelCategoryShelfError {
  /** The same category ID cannot be both shown and hidden. */
  CannotShowAndHideCategory = 'CANNOT_SHOW_AND_HIDE_CATEGORY',
  /** The user making the update is not authorized to do so. */
  Forbidden = 'FORBIDDEN',
  /** One or more of the category IDs in the input are invalid. */
  InvalidCategory = 'INVALID_CATEGORY'
}

/** The required input for a updateChannelClipsSetting mutation. */
export type UpdateChannelClipsSettingInput = {
  /** The Id of the channel where we want to update the clips enable/disable setting. */
  channelID: Scalars['ID'];
  /** If isClipsEnabled is true, allow the following roles to create Clips on the channel. */
  creationRestrictedTo?: InputMaybe<ChannelClipsCreationRestrictedToInput>;
  /** If there are clip creation restrictions, use the following to add options to those restrictions. */
  creationRestrictionOptions?: InputMaybe<ChannelClipsCreationAuthRestrictionOptionsInput>;
  /** Set whether or not users can create Clips on this channel. */
  isClipsEnabled: Scalars['Boolean'];
};

/** The result of a updateChannelClipsSetting mutation. */
export type UpdateChannelClipsSettingPayload = {
  __typename?: 'UpdateChannelClipsSettingPayload';
  /** The updated channel. */
  channel?: Maybe<Channel>;
};

/** The input to update a channel's category shelf content. */
export type UpdateChannelHomePreferencesInput = {
  /** A list of category IDs to hide from the category shelf. */
  categoryIDsToHide?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of category IDs to unhide from the category shelf. */
  categoryIDsToUnhide?: InputMaybe<Array<Scalars['ID']>>;
  /** The ID of the channel whose category shelf is being updated. */
  channelID: Scalars['ID'];
  /** The hero preset. */
  heroPreset?: InputMaybe<HeroPreset>;
  /** The type of streamer shelf to display. */
  streamerShelfType?: InputMaybe<StreamerShelfType>;
};

/** The result of an update to the category shelf. */
export type UpdateChannelHomePreferencesPayload = {
  __typename?: 'UpdateChannelHomePreferencesPayload';
  /** The channel with the modified category shelf. */
  channel?: Maybe<Channel>;
  /** The possible error returned. */
  error?: Maybe<UpdateChannelCategoryShelfError>;
};

/** An error returned from the updateChannelPredictionSettings mutation. */
export type UpdateChannelPredictionSettingsError = {
  __typename?: 'UpdateChannelPredictionSettingsError';
  /** Code describing the error. */
  code: UpdateChannelPredictionSettingsErrorCode;
};

/** Possible error codes from the updateChannelPredictionSettings mutation. */
export enum UpdateChannelPredictionSettingsErrorCode {
  /** The authorized user is not allowed to update prediction settings for this channel. */
  Forbidden = 'FORBIDDEN',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Update a channel's Prediction Settings.
 * All fields other than channelID are nullable; only specify fields that you wish to update.
 */
export type UpdateChannelPredictionSettingsInput = {
  /** Whether channel moderators are allowed to create and resolve Prediction Events. */
  canModeratorsManagePredictions?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the channel to update the settings of. */
  channelID: Scalars['ID'];
};

/** Payload for updating a channel's Prediction Settings. */
export type UpdateChannelPredictionSettingsPayload = {
  __typename?: 'UpdateChannelPredictionSettingsPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<UpdateChannelPredictionSettingsError>;
  /** The updated settings. */
  settings?: Maybe<ChannelPredictionSettings>;
};

export type UpdateChatColorInput = {
  /**
   * Named color for normal users (e.g. "Blue"  or "Coral", see https://help.twitch.tv/customer/portal/articles/659095-twitch-chat-and-moderation-commands)
   * or a hex color for Turbo users (e.g. "#001122").
   */
  color: Scalars['String'];
};

export type UpdateChatColorPayload = {
  __typename?: 'UpdateChatColorPayload';
  /** The user whose chat color was set. */
  user?: Maybe<User>;
};

/**
 * Possible chat settings modifiable for the channel specified via ChannelID.
 *
 * NOTE: Subscribers-only chat mode settings are in the UpdateSubscriptionProduct
 * mutation.
 */
export type UpdateChatSettingsInput = {
  /**
   * autoModLevel is an integer from 0-4 representing the level of automoderation of chat
   * 0 is off, 4 is the highest level of moderation.
   *
   * Deprecated: No longer used.
   */
  autoModLevel?: InputMaybe<Scalars['Int']>;
  /** ID of the channel for which chat settings are being updated. */
  channelID: Scalars['String'];
  /** chatDelayInMs is the delay before non-mods see a message. */
  chatDelayInMs?: InputMaybe<Scalars['Int']>;
  /**
   * followersOnlyDurationMinutes is the number of minutes a user must have
   * followed the broadcaster before being able to chat.
   */
  followersOnlyDurationMinutes?: InputMaybe<Scalars['Int']>;
  /** hideLinks indicates if links should be deleted from non-mod messages. */
  hideLinks?: InputMaybe<Scalars['Boolean']>;
  /**
   * isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
   * match their language.
   *
   * Deprecated: No longer used.
   */
  isBroadcasterLanguageModeEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates whether chat is currently enforcing that messages may only contain
   * emotes.
   */
  isEmoteOnlyModeEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
   * be inserted into automod if the channel has automod enabled.
   *
   * Deprecated: No longer used.
   */
  isOptedOutOfGlobalBannedWordsList?: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates whether chat is currently enforcing that messages must be
   * reasonably unique from recent messages. Previously known as "r9k mode".
   */
  isUniqueChatModeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** requireVerifiedAccount indicates if users must be verified to chat. */
  requireVerifiedAccount?: InputMaybe<Scalars['Boolean']>;
  /** A list of chat rules to display to users when joining a chat channel. */
  rules?: InputMaybe<Array<Scalars['String']>>;
  /**
   * The number of seconds a user must wait in between sending chat messages
   * If value is null, slow mode is not enabled.
   */
  slowModeDurationSeconds?: InputMaybe<Scalars['Int']>;
};

/** Result of mutation is the updated ChatSettings object. */
export type UpdateChatSettingsPayload = {
  __typename?: 'UpdateChatSettingsPayload';
  /** The new chatSettings after applying the mutation. */
  chatSettings?: Maybe<ChatSettings>;
};

/** Partner settings related to chat badges with bits. */
export type UpdateCheerPartnerSettingsBadgesInput = {
  /** A list of tiers to modify. */
  tiers?: InputMaybe<Array<BitsBadgeTierInput>>;
};

/** Partner settings related to chat messages with bits. */
export type UpdateCheerPartnerSettingsChatMessageInput = {
  /** The setting that controls if the user has project v enabled on their channel. */
  isOptedOutOfProjectV?: InputMaybe<Scalars['Boolean']>;
  /** The minimnm setting that controls the minimum bits that must be part of a cheer emote. */
  minBitsPerEmote?: InputMaybe<Scalars['Int']>;
  /** The minimum setting that controls the minimum amount a user must cheer in the channel. */
  minBitsToCheer?: InputMaybe<Scalars['Int']>;
};

/** Settings related to bits cheer bomb events. */
export type UpdateCheerPartnerSettingsCheerBombInput = {
  /** Flag that is true if the user has opted out of the cheer bomb event. */
  isOptedOut?: InputMaybe<Scalars['Boolean']>;
};

/** Partner settings related to the custom cheermote prefix. */
export type UpdateCheerPartnerSettingsCustomPrefixInput = {
  /** Flag that is set if the user has the custom cheermote prefix enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Mutation input for updating Bits partner channel settings. */
export type UpdateCheerPartnerSettingsInput = {
  /** Partner settings related to chat badges with bits. */
  badges?: InputMaybe<UpdateCheerPartnerSettingsBadgesInput>;
  /** Partner settings related to chat messages with bits. */
  chatMessage?: InputMaybe<UpdateCheerPartnerSettingsChatMessageInput>;
  /** Partner settings related to cheer bomb events. */
  cheerBombEvent?: InputMaybe<UpdateCheerPartnerSettingsCheerBombInput>;
  /** Partner settings related to the custom cheermote prefix. */
  customPrefix?: InputMaybe<UpdateCheerPartnerSettingsCustomPrefixInput>;
  /** Whether to onboard or offboard the user with bits. */
  isOnboarded?: InputMaybe<Scalars['Boolean']>;
  /** Partner settings related to the bits leaderboard. */
  leaderboard?: InputMaybe<UpdateCheerPartnerSettingsLeaderboardInput>;
  /** Partner settings related to the recent cheer message. */
  recentCheer?: InputMaybe<UpdateCheerPartnerSettingsRecentCheerInput>;
  /** Partner settings related to sponsored cheermote campaigns. */
  sponsoredCheermote?: InputMaybe<UpdateCheerPartnerSettingsSponsoredCheermoteInput>;
  /** The user ID to update channel settings. */
  userID: Scalars['ID'];
};

/** Partner settings related to the bits leaderboard. */
export type UpdateCheerPartnerSettingsLeaderboardInput = {
  /** Flag that is true if the user has bits leaderboards turned on. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The time period the user wants the leaderboard to be displayed as. */
  timePeriod?: InputMaybe<Scalars['String']>;
};

/** Result of mutation is the updated UserSettings object. */
export type UpdateCheerPartnerSettingsPayload = {
  __typename?: 'UpdateCheerPartnerSettingsPayload';
  /** The updated user settings object. */
  cheer: CheerPartnerSettings;
};

/** Partner settings related to the recent cheer message. */
export type UpdateCheerPartnerSettingsRecentCheerInput = {
  /** Flag that when true pins the recent cheer to their channel. */
  canPin?: InputMaybe<Scalars['Boolean']>;
  /** The minimum bits a user must cheer to show their cheer on the chat header. */
  minimumBits?: InputMaybe<Scalars['Int']>;
  /** The amount of time a recent cheer is shown before being dismissed. */
  timeoutMilliseconds?: InputMaybe<Scalars['Int']>;
};

/** Settings related to sponsored cheermote campaigns. */
export type UpdateCheerPartnerSettingsSponsoredCheermoteInput = {
  /** The campaign ID we are modifying for the user. */
  id: Scalars['ID'];
  /** Flag that is true if the user has opted in of the sponsored cheermote campaign. */
  isOptedIn: Scalars['Boolean'];
};

/** Errors for updating a cheermote tier. */
export type UpdateCheermoteTierError = {
  __typename?: 'UpdateCheermoteTierError';
  /** The associated error code. */
  code: UpdateCheermoteTierErrorCode;
};

/** Possible error codes returned for updating a cheermote tier. */
export enum UpdateCheermoteTierErrorCode {
  /** The uploaded image assets could not be found. */
  EmoteImageNotFound = 'EMOTE_IMAGE_NOT_FOUND',
  /** An animated image asset was not supplied, but is required for the cheermote. */
  EmoteMissingAnimatedAsset = 'EMOTE_MISSING_ANIMATED_ASSET',
  /** A static image asset was not supplied, but is required for the cheermote. */
  EmoteMissingStaticAsset = 'EMOTE_MISSING_STATIC_ASSET',
  /** The uploaded image assets could not be parsed. */
  InvalidImageUpload = 'INVALID_IMAGE_UPLOAD',
  /** Only the cheermote owner is allowed to upload cheermotes. */
  InvalidOwner = 'INVALID_OWNER',
  /** There were not enough image assets supplied for the cheermote. */
  NotEnoughEmoteImageAssets = 'NOT_ENOUGH_EMOTE_IMAGE_ASSETS',
  /** There were more image assets supplied than required for the cheermote. */
  TooManyEmoteImageAssets = 'TOO_MANY_EMOTE_IMAGE_ASSETS',
  /** Other errors returned from the service. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The data needed to update or create a broadcaster's custom cheermotes for a given tier. */
export type UpdateCheermoteTierInput = {
  /** A list containing the image IDs for all assets needed for the cheermote tier. */
  imageAssets: Array<EmoteImageAssetInput>;
  /** The cheermote tier that should be updated. */
  tierThreshold: CheermoteTierThreshold;
  /** The user whose cheermotes are being updated. */
  userID: Scalars['ID'];
};

/** Results of the cheermote tier update. */
export type UpdateCheermoteTierPayload = {
  __typename?: 'UpdateCheermoteTierPayload';
  /** Service error, if any. */
  error?: Maybe<UpdateCheermoteTierError>;
};

/** UpdateClipError is an error associated with the updateClip mutation. */
export type UpdateClipError = {
  __typename?: 'UpdateClipError';
  /** The error when the clip fails to update a clip. */
  message?: Maybe<Scalars['String']>;
};

/** UpdateClipInput updates the title of the clip with the provided slug. */
export type UpdateClipInput = {
  /** The slug of the clip to update. */
  slug: Scalars['ID'];
  /** The new title of the clip. */
  title?: InputMaybe<Scalars['String']>;
};

/** UpdateClipPayload returns the updated clip. */
export type UpdateClipPayload = {
  __typename?: 'UpdateClipPayload';
  /** The clip with its updated properties. */
  clip: Clip;
  /** The error when the clip fails to update a clip. */
  error?: Maybe<UpdateClipError>;
};

/** UpdateClipViewCountInput increments the viewcount of the provided slug. */
export type UpdateClipViewCountInput = {
  /** The slug of the clip to increment viewcount on. */
  slug: Scalars['ID'];
};

/** UpdateClipViewCount returns the clip that was updated. */
export type UpdateClipViewCountPayload = {
  __typename?: 'UpdateClipViewCountPayload';
  /**
   * The clip that was updated.
   * The views field is the only field that is updated, and the change is not reflected immediately.
   */
  clip?: Maybe<Clip>;
};

/** UpdateCollectionInput accepts a collection ID and parameters to update a collection. */
export type UpdateCollectionInput = {
  /** The id of the collection to be updated. */
  collectionID: Scalars['ID'];
  /** The updated description of the collection. */
  description?: InputMaybe<Scalars['String']>;
  /** The itemID of the item whose thumbnail will be collection's thumbnail. */
  thumbnailInput?: InputMaybe<UpdateCollectionThumbnailInput>;
  /** The updated title of the collection. */
  title?: InputMaybe<Scalars['String']>;
  /** The updated type of the collection. */
  type?: InputMaybe<CollectionType>;
};

/** UpdateCollectionPayload resolves the updated collection. */
export type UpdateCollectionPayload = {
  __typename?: 'UpdateCollectionPayload';
  /** The collection that was just updated. */
  collection: Collection;
};

/** UpdateCollectionThumbnailInput accepts a item ID and item Type for the new collection's thumbnail. */
export type UpdateCollectionThumbnailInput = {
  /** The id of the item whose thumbnail will be collection's thumbnail. */
  id: Scalars['ID'];
  /** The type of the item whose thumbnail will be collection's thumbnail. */
  type: Scalars['String'];
};

/** An error from updating an automatic Community Points reward in a channel. */
export type UpdateCommunityPointsAutomaticRewardError = {
  __typename?: 'UpdateCommunityPointsAutomaticRewardError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsAutomaticRewardErrorCode>;
  /** On COST_TOO_LOW, the minimum cost that can be set. */
  minimumCost?: Maybe<Scalars['Int']>;
};

/** The possible reasons updating an automatic Community Points reward in a channel could fail. */
export enum UpdateCommunityPointsAutomaticRewardErrorCode {
  /** The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000". */
  BackgroundColorInvalid = 'BACKGROUND_COLOR_INVALID',
  /** The cost is invalid. Must be a positive integer. */
  CostInvalid = 'COST_INVALID',
  /** The cost is below the minimum. */
  CostTooLow = 'COST_TOO_LOW',
  /** The current user is not allowed to update a reward in this channel. */
  Forbidden = 'FORBIDDEN',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Input for updating an automatic Community Points reward in a channel.
 * Only the channelID and rewardType are required. All other fields are optional.
 * Only set fields that are intended to be updated.
 */
export type UpdateCommunityPointsAutomaticRewardInput = {
  /**
   * The optional custom background color for this reward.
   * Should be a hex color string, for example "FF0000".
   */
  backgroundColor?: InputMaybe<Scalars['String']>;
  /** The channel ID that the reward is being updated in. */
  channelID: Scalars['ID'];
  /** The point cost of this reward. */
  cost?: InputMaybe<Scalars['Int']>;
  /** Whether the reward is enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the reward being updated. */
  rewardType: CommunityPointsAutomaticRewardType;
  /** A flag to reset this automatic reward's background color to default. */
  shouldResetBackgroundColor?: InputMaybe<Scalars['Boolean']>;
  /** A flag to reset this automatic reward's cost to default. */
  shouldResetCost?: InputMaybe<Scalars['Boolean']>;
  /** A flag to reset this automatic reward's image to default. */
  shouldResetImage?: InputMaybe<Scalars['Boolean']>;
};

/** The response from updating an automatic Community Points reward in a channel. */
export type UpdateCommunityPointsAutomaticRewardPayload = {
  __typename?: 'UpdateCommunityPointsAutomaticRewardPayload';
  /** An error that occurred while updating an automatic Community Points reward in a channel. */
  error?: Maybe<UpdateCommunityPointsAutomaticRewardError>;
  /** The newly updated reward. */
  reward?: Maybe<CommunityPointsAutomaticReward>;
};

/** An error from updating a channel's Community Points channel settings. */
export type UpdateCommunityPointsChannelSettingsError = {
  __typename?: 'UpdateCommunityPointsChannelSettingsError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsChannelSettingsErrorCode>;
};

/** The possible reasons updating a channel's Community Points channel settings could fail. */
export enum UpdateCommunityPointsChannelSettingsErrorCode {
  /** The current user is not allowed to update this channel's settings. */
  Forbidden = 'FORBIDDEN',
  /** The custom name failed AutoMod. */
  NameAutomodFailed = 'NAME_AUTOMOD_FAILED',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Input for updating Community Points channel settings..
 * Only the channelID is required. All other fields are optional.
 * Only set fields that are intended to be updated.
 */
export type UpdateCommunityPointsChannelSettingsInput = {
  /** The channel ID to update the settings of. */
  channelID: Scalars['ID'];
  /** Whether the channel has community points turned on. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The channel's custom community points name. */
  name?: InputMaybe<Scalars['String']>;
  /** A flag to reset this channel's community points image to default. */
  shouldResetImage?: InputMaybe<Scalars['Boolean']>;
  /** A flag to reset this channel's community points name to default. */
  shouldResetName?: InputMaybe<Scalars['Boolean']>;
};

/** The response from updating a channel's Community Points channel settings. */
export type UpdateCommunityPointsChannelSettingsPayload = {
  __typename?: 'UpdateCommunityPointsChannelSettingsPayload';
  /** The channel with the newly updated settings. */
  channel?: Maybe<Channel>;
  /** An error that occurred while updating a channel's Community Points channel settings. */
  error?: Maybe<UpdateCommunityPointsChannelSettingsError>;
};

/** Update community goal error. */
export type UpdateCommunityPointsCommunityGoalError = {
  __typename?: 'UpdateCommunityPointsCommunityGoalError';
  /** The error code. */
  code: UpdateCommunityPointsCommunityGoalErrorCode;
};

/** Update community goal error code. */
export enum UpdateCommunityPointsCommunityGoalErrorCode {
  /** Goal background color is invalid. */
  BackgroundColorInvalid = 'BACKGROUND_COLOR_INVALID',
  /** Goal description failed automod. */
  DescriptionAutomodFailed = 'DESCRIPTION_AUTOMOD_FAILED',
  /** Goal description is invalid. */
  DescriptionInvalid = 'DESCRIPTION_INVALID',
  /** Goal already exists. */
  DuplicateGoal = 'DUPLICATE_GOAL',
  /** Goal duration is invalid. */
  DurationInvalid = 'DURATION_INVALID',
  /** The current user is not allowed to update goals for this channel. */
  Forbidden = 'FORBIDDEN',
  /** Goal amount is invalid. */
  GoalAmountInvalid = 'GOAL_AMOUNT_INVALID',
  /** Goal cannot be updated since it has already been started. */
  GoalStarted = 'GOAL_STARTED',
  /** Goal status change invalid. */
  InvalidStatusChange = 'INVALID_STATUS_CHANGE',
  /** Goal was not found. */
  NotFound = 'NOT_FOUND',
  /** Goal title failed automod. */
  TitleAutomodFailed = 'TITLE_AUTOMOD_FAILED',
  /** Goal title is invalid. */
  TitleInvalid = 'TITLE_INVALID',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/** Update community goal input. */
export type UpdateCommunityPointsCommunityGoalInput = {
  /** The amount of community points that this goal needs to succeed. */
  amountNeeded?: InputMaybe<Scalars['Int']>;
  /** The background color of this goal. */
  backgroundColor?: InputMaybe<Scalars['String']>;
  /** The channel. */
  channelID: Scalars['ID'];
  /** The description of this goal. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * The *initial* duration the streamer set for the goal.
   * Only really used during the UNSTARTED state; once the goal is started
   * the endedAt timestamp is populated (and updated for extended deadlines).
   */
  durationDays?: InputMaybe<Scalars['Int']>;
  /** The time the goal is scheduled to end. Used to extend a goal. */
  endsAt?: InputMaybe<Scalars['Time']>;
  /** The id of the goal. */
  goalID: Scalars['ID'];
  /** Reset background color to default if true. */
  resetBackgroundColor?: InputMaybe<Scalars['Boolean']>;
  /** Reset image to default if true. */
  resetImage?: InputMaybe<Scalars['Boolean']>;
  /** Reset max contribution per stream to default if true. */
  resetMaxContributionPerStream?: InputMaybe<Scalars['Boolean']>;
  /** The current status of this goal. */
  status?: InputMaybe<CommunityPointsCommunityGoalStatus>;
  /** The title of this goal. */
  title?: InputMaybe<Scalars['String']>;
};

/** Update community goal payload. */
export type UpdateCommunityPointsCommunityGoalPayload = {
  __typename?: 'UpdateCommunityPointsCommunityGoalPayload';
  /** The error, if any. */
  error?: Maybe<UpdateCommunityPointsCommunityGoalError>;
  /** The community goal. */
  goal?: Maybe<CommunityPointsCommunityGoal>;
};

/** An error from updating a custom Community Points reward in a channel. */
export type UpdateCommunityPointsCustomRewardError = {
  __typename?: 'UpdateCommunityPointsCustomRewardError';
  /** An identifier for the error that occurred. */
  code: UpdateCommunityPointsCustomRewardErrorCode;
};

/** The possible reasons updating a custom Community Points reward in a channel could fail. */
export enum UpdateCommunityPointsCustomRewardErrorCode {
  /** The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000". */
  BackgroundColorInvalid = 'BACKGROUND_COLOR_INVALID',
  /** The cost is invalid. Costs must be greater than 0. */
  CostInvalid = 'COST_INVALID',
  /** A reward with the provided title already exists. Custom reward titles must be unique. */
  DuplicateReward = 'DUPLICATE_REWARD',
  /** The current user is not allowed to update a reward in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The globalCooldown is invalid. globalCooldown must be greater tham 0. */
  GlobalCooldownInvalid = 'GLOBAL_COOLDOWN_INVALID',
  /** The maxPerStream is invalid. maxPerStream must be greater than 0. */
  MaxPerStreamInvalid = 'MAX_PER_STREAM_INVALID',
  /** The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0. */
  MaxPerUserPerStreamInvalid = 'MAX_PER_USER_PER_STREAM_INVALID',
  /** The reward was not found. */
  NotFound = 'NOT_FOUND',
  /** The prompt failed AutoMod. */
  PromptAutomodFailed = 'PROMPT_AUTOMOD_FAILED',
  /** The title failed AutoMod. */
  TitleAutomodFailed = 'TITLE_AUTOMOD_FAILED',
  /** The title is invalid. Titles must not be empty and must be at most 45 characters long. */
  TitleInvalid = 'TITLE_INVALID',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Input for updating a custom Community Points reward in a channel.
 * Only the channelID and rewardID are required. All other fields are optional.
 * Only set fields that are intended to be updated.
 */
export type UpdateCommunityPointsCustomRewardInput = {
  /**
   * The optional custom background color for this reward.
   * Should be a hex color string, for example "FF0000".
   */
  backgroundColor?: InputMaybe<Scalars['String']>;
  /** The channel ID that the reward is being updated in. */
  channelID: Scalars['ID'];
  /** The point cost of this reward. */
  cost?: InputMaybe<Scalars['Int']>;
  /** The length of the global cooldown applied to rewards redeemed of this type. */
  globalCooldownSetting?: InputMaybe<CommunityPointsCustomRewardGlobalCooldownSettingInput>;
  /** Whether this reward has real world value. */
  hasRealWorldValue?: InputMaybe<Scalars['Boolean']>;
  /** Whether the reward is enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Whether the reward is temporarily paused. */
  isPaused?: InputMaybe<Scalars['Boolean']>;
  /** Whether only subscribers are allowed to redeem this reward in this channel. */
  isSubOnly?: InputMaybe<Scalars['Boolean']>;
  /** Whether this reward requires users to enter text input. */
  isUserInputRequired?: InputMaybe<Scalars['Boolean']>;
  /** The most rewards of this type that can be redeemed per stream. */
  maxPerStreamSetting?: InputMaybe<CommunityPointsCustomRewardMaxPerStreamSettingInput>;
  /** The most rewards of this type that can be redeemed per user per stream. */
  maxPerUserPerStreamSetting?: InputMaybe<CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput>;
  /** The optional user-facing prompt for this reward. */
  prompt?: InputMaybe<Scalars['String']>;
  /** The ID of the reward being updated. */
  rewardID: Scalars['ID'];
  /**
   * Whether redemptions for this reward should skip the broadcaster's request queue and get
   * automatically fulfilled.
   */
  shouldRedemptionsSkipRequestQueue?: InputMaybe<Scalars['Boolean']>;
  /** A flag to reset this custom reward's image to the default. */
  shouldResetImage?: InputMaybe<Scalars['Boolean']>;
  /** The short title displayed for this reward. */
  title?: InputMaybe<Scalars['String']>;
};

/** The response from updating a custom Community Points reward in a channel. */
export type UpdateCommunityPointsCustomRewardPayload = {
  __typename?: 'UpdateCommunityPointsCustomRewardPayload';
  /** An error that occurred while updating a custom Community Points reward in a channel. */
  error?: Maybe<UpdateCommunityPointsCustomRewardError>;
  /** The newly updated reward. */
  reward?: Maybe<CommunityPointsCustomReward>;
};

/** An error from acting on a Community Points redemption. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusError = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode>;
};

/** The possible reasons acting on a Community Points redemption could fail. */
export enum UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode {
  /** The current user is not allowed to update the status of this redemption. */
  Forbidden = 'FORBIDDEN',
  /** The redemption was not found. */
  NotFound = 'NOT_FOUND'
}

/** Input for acting on a Community Points redemption. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusInput = {
  /** The channel ID the redemption was made in. */
  channelID: Scalars['ID'];
  /** The new status to set the redemption to. */
  newStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The redemption ID. */
  redemptionID: Scalars['ID'];
};

/** The response from acting on a Community Points redemption. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusPayload = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusPayload';
  /** An error that occurred while updating the redemption status. */
  error?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusError>;
  /** The updated redemption. */
  redemption?: Maybe<CommunityPointsCustomRewardRedemption>;
};

/** Input for acting on all Community Points redemptions for a channel. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput = {
  /** The channel ID the redemptions were made in. */
  channelID: Scalars['ID'];
  /** The new status to set the redemptions to. */
  newStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The old status redemptions are currently set to. */
  oldStatus: CommunityPointsCustomRewardRedemptionStatus;
};

/**
 * The response from acting on all Community Points redemptions for a channel.
 * Most of the work is done as an async task and redemption status changes are pushed over pubsub.
 */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload';
  /** An error that occurred while updating the redemption statuses. */
  error?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesError>;
};

/** Input for acting on the Community Points redemptions from the provided list. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput = {
  /** The channel ID the redemptions were made in. */
  channelID: Scalars['ID'];
  /** The new status to set the redemptions to. */
  newStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The old status redemptions are currently set to. */
  oldStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The redemption IDs to update. */
  redemptionIDs: Array<Scalars['ID']>;
};

/**
 * The response from acting on the Community Points redemptions from the provided list.
 * Most of the work is done as an async task and redemption status changes are pushed over pubsub.
 */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload';
  /** An error that occurred while updating the redemption statuses. */
  error?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesError>;
};

/** Input for acting on all Community Points redemptions for a reward. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput = {
  /** The channel ID the redemptions were made in. */
  channelID: Scalars['ID'];
  /** The new status to set the redemptions to. */
  newStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The old status redemptions are currently set to. */
  oldStatus: CommunityPointsCustomRewardRedemptionStatus;
  /** The reward ID to update all redemptions with oldStatus for. */
  rewardID: Scalars['ID'];
};

/**
 * The response from acting on all Community Points redemptions for a reward.
 * Most of the work is done as an async task and redemption status changes are pushed over pubsub.
 */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload';
  /** An error that occurred while updating the redemption statuses. */
  error?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesError>;
};

/** An error from acting on a Community Points redemption. */
export type UpdateCommunityPointsCustomRewardRedemptionStatusesError = {
  __typename?: 'UpdateCommunityPointsCustomRewardRedemptionStatusesError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode>;
};

/** The possible reasons acting on a Community Points redemption could fail. */
export enum UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode {
  /** The current user is not allowed to update the statuses of these redemptions. */
  Forbidden = 'FORBIDDEN',
  /** There is already a bulk update in progress for this reward / all rewards. Only one can be	processed at a time. */
  InProgress = 'IN_PROGRESS',
  /** An unexpected error occured. */
  Unknown = 'UNKNOWN'
}

/** An error returned when updating a user's enrollment in Community Points early access. */
export type UpdateCommunityPointsEarlyAccessError = {
  __typename?: 'UpdateCommunityPointsEarlyAccessError';
  /** The error code identifying this error. */
  code: UpdateCommunityPointsEarlyAccessErrorCode;
};

/** An error returned when updating a user's enrollment in Community Points early access. */
export enum UpdateCommunityPointsEarlyAccessErrorCode {
  /** The user is not allowed to opt in to the Community Points early access program. */
  Forbidden = 'FORBIDDEN',
  /** There was some other error updating the user's enrollment. */
  Unknown = 'UNKNOWN'
}

/** Requests to change a user's enrollment status in the Community Points early access program. */
export type UpdateCommunityPointsEarlyAccessSettingsInput = {
  /** Sets whether the user is signing up for or removing themself from the early access program. */
  isSignedUp: Scalars['Boolean'];
};

/** Returns updated early access status for Community Points. */
export type UpdateCommunityPointsEarlyAccessSettingsPayload = {
  __typename?: 'UpdateCommunityPointsEarlyAccessSettingsPayload';
  /** The channel whose Early Access preference was updated. */
  channel?: Maybe<Channel>;
  /** Optionally, an error that occurred while attempting to update the user's enrollment status. */
  error?: Maybe<UpdateCommunityPointsEarlyAccessError>;
};

/** An error from updating the last viewed community points content timestamps on a channel. */
export type UpdateCommunityPointsLastViewedContentError = {
  __typename?: 'UpdateCommunityPointsLastViewedContentError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsLastViewedContentErrorCode>;
};

/** The possible reasons updating the last viewed community points content timestamps on a channel could fail. */
export enum UpdateCommunityPointsLastViewedContentErrorCode {
  /** The current user is not allowed to update last viewed timestamps for this channel. */
  Forbidden = 'FORBIDDEN',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Input for updating the last viewed community points content timestamps on a channel.
 * The global content that was viewed on the channel will also have the timestamps updated.
 */
export type UpdateCommunityPointsLastViewedContentInput = {
  /** The channelID where the content was viewed. */
  channelID: Scalars['ID'];
  /** The content types that were viewed. */
  viewedContent: Array<CommunityPointsContentType>;
};

/** The response from updating the last viewed community points content timestamps on a channel. */
export type UpdateCommunityPointsLastViewedContentPayload = {
  __typename?: 'UpdateCommunityPointsLastViewedContentPayload';
  /** An error that occurred while updating the last viewed content timestamps. */
  error?: Maybe<UpdateCommunityPointsLastViewedContentError>;
  /** The updated last viewed timestamps for a channels content. */
  lastViewedChannelContent?: Maybe<Array<CommunityPointsLastViewedContentByType>>;
  /** The updated last viewed timestamps for global content across all of twitch. */
  lastViewedGlobalContent?: Maybe<Array<CommunityPointsLastViewedContentByTypeAndId>>;
};

/** An error from updating a Community Points Smart Costs Acknowledgements in a channel. */
export type UpdateCommunityPointsSmartCostsAcknowledgementsError = {
  __typename?: 'UpdateCommunityPointsSmartCostsAcknowledgementsError';
  /** An identifier for the error that occurred. */
  code?: Maybe<UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode>;
};

/** The possible reasons updating a Community Points Smart Costs Acknowledgement in a channel could fail. */
export enum UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode {
  /** The current user is not allowed to update a smart costs acknowledgement in this channel. */
  Forbidden = 'FORBIDDEN',
  /** The cost is invalid. Must be a positive integer. */
  LastAcknowledgedCostInvalid = 'LAST_ACKNOWLEDGED_COST_INVALID',
  /** An unexpected error occurred. */
  Unknown = 'UNKNOWN'
}

/** Input required for updating community points smart costs acknowledgements. */
export type UpdateCommunityPointsSmartCostsAcknowledgementsInput = {
  /** List of acknowledgements to update. */
  acknowledgements: Array<SmartCostsAcknowledgementInput>;
  /** The channel ID that the reward is being updated in. */
  channelID: Scalars['ID'];
};

/** Payload returned after updating Community Points Smart Costs Acknowledgements. */
export type UpdateCommunityPointsSmartCostsAcknowledgementsPayload = {
  __typename?: 'UpdateCommunityPointsSmartCostsAcknowledgementsPayload';
  /** List of acknowledgements for community points smart costs that were updated. */
  acknowledgements?: Maybe<Array<SmartCostsAcknowledgement>>;
  /** An error that occurred while updating a Community Points Smart Costs Acknowledgements in a channel. */
  error?: Maybe<UpdateCommunityPointsSmartCostsAcknowledgementsError>;
};

/** The competition contact info for updates. */
export type UpdateCompetitionContactInfoInput = {
  /** Link to Discord server for competition contact purposes. */
  discordURL?: InputMaybe<Scalars['String']>;
  /** Email address point of contact for the competition. */
  email?: InputMaybe<Scalars['String']>;
};

/** Update a Competition. */
export type UpdateCompetitionInput = {
  /** Banner image for the competition event page. */
  bannerImageURL?: InputMaybe<Scalars['String']>;
  /** This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed. */
  checkInDurationMinutes?: InputMaybe<Scalars['Int']>;
  /** Long form description of the competition. */
  description?: InputMaybe<Scalars['String']>;
  /** The time the competition is scheduled to end. */
  endAt?: InputMaybe<Scalars['Time']>;
  /** The predefined structure of phases and lobbies. */
  formatType?: InputMaybe<FormatType>;
  /** The game being played in the competition>. */
  gameID?: InputMaybe<Scalars['ID']>;
  /** ID of the Competition we want to update. */
  id: Scalars['ID'];
  /** Primary artwork for the competition. */
  imageURL?: InputMaybe<Scalars['String']>;
  /** Specific format restrictions for a competition. */
  leaderboardDetails?: InputMaybe<UpdateCompetitionLeaderboardDetailsInput>;
  /** The name of the competition. */
  name?: InputMaybe<Scalars['String']>;
  /** The participant-facing points of contact for the competition that only registered participants can see. */
  participantOnlyContactInfo?: InputMaybe<UpdateCompetitionContactInfoInput>;
  /** Long form text block description that explains the prizing for the competition and will be converted to Markdown client-side. */
  prizeDescription?: InputMaybe<Scalars['String']>;
  /** The public points of contact for the competition that anyone can see. */
  publicContactInfo?: InputMaybe<UpdateCompetitionContactInfoInput>;
  /** The time the competition is scheduled to end registration. */
  registrationEndAt?: InputMaybe<Scalars['Time']>;
  /** The maximum number of players in a REGISTERED state. */
  registrationLimit?: InputMaybe<Scalars['Int']>;
  /** Long form text block description that explains the rules for the competition and will be converted to Markdown client-side. */
  rulesDescription?: InputMaybe<Scalars['String']>;
  /** The time the competition is scheduled to start. */
  startAt?: InputMaybe<Scalars['Time']>;
  /** The state of the tournament. */
  state?: InputMaybe<CompetitionState>;
  /** The size of a team when ParticipantType is Team. */
  teamSize?: InputMaybe<Scalars['Int']>;
  /** Link URL to any additional terms and conditions. */
  termsURL?: InputMaybe<Scalars['String']>;
};

/** Editable fields for Leaderboard competition details. */
export type UpdateCompetitionLeaderboardDetailsInput = {
  /** The max participant count for a lobby in phase. */
  lobbyMaxSize?: InputMaybe<Scalars['Int']>;
  /** The number of phases a competition should have. */
  phaseCount?: InputMaybe<Scalars['Int']>;
  /** The way points are assigned to a participant in case of a tie. */
  tiebreakerLabel?: InputMaybe<TiebreakerLabel>;
};

/** Data that was mutated after the competition was updated. */
export type UpdateCompetitionPayload = {
  __typename?: 'UpdateCompetitionPayload';
  /** The competition which was updated. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Update the state of a player in a Competition. */
export type UpdateCompetitionPlayerInput = {
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
  /** The discord username for the player. */
  discordUsername?: InputMaybe<Scalars['String']>;
  /** The in game username for the player. */
  inGameUsername?: InputMaybe<Scalars['String']>;
  /** Indicates whether the player is disqualified. */
  isDisqualified?: InputMaybe<Scalars['Boolean']>;
  /** The state a player has in the competition we want to change. */
  state?: InputMaybe<CompetitionPlayerState>;
  /** Twitch user id of the player. */
  userID: Scalars['ID'];
};

/** Data that was mutated after the player was updated. */
export type UpdateCompetitionPlayerPayload = {
  __typename?: 'UpdateCompetitionPlayerPayload';
  /** The new state of competition after updating a competition player in the competition. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Update a team in a Competition. */
export type UpdateCompetitionTeamInput = {
  /** Twitch user id of the participant to make into the TeamCaptain. */
  captainID?: InputMaybe<Scalars['ID']>;
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
  /** Indicates whether the team is disqualified. */
  isDisqualified?: InputMaybe<Scalars['Boolean']>;
  /** The user ids of the team members. */
  members?: InputMaybe<Array<Scalars['ID']>>;
  /** Unique Team ID for the specified Competition. */
  teamID: Scalars['ID'];
  /** The new name of the team. */
  teamName?: InputMaybe<Scalars['String']>;
};

/** Data that was mutated after the CompetitionTeam was updated. */
export type UpdateCompetitionTeamPayload = {
  __typename?: 'UpdateCompetitionTeamPayload';
  /** The competition that was updated. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Error associated with mutation UpdateConsent. */
export type UpdateConsentError = {
  __typename?: 'UpdateConsentError';
  /** Error code. */
  code?: Maybe<UpdateConsentErrorCode>;
};

/** Client Error Code. */
export enum UpdateConsentErrorCode {
  /** Invalid vendor name or law name or consent status. */
  InvalidVendorLawConsentStatus = 'INVALID_VENDOR_LAW_CONSENT_STATUS'
}

/** UpdateConsentInput updates or creates a consent status for a privacy law. */
export type UpdateConsentInput = {
  /** Consent Session ID. */
  consentSessionID: Scalars['ID'];
  /** Privacy rule set of applicable law, e.g. CCPA or GDPR. */
  privacyLawName: PrivacyLawName;
  /** Consent status for each vendor. */
  vendorStatus: Array<VendorConsentStatusInput>;
};

/** UpdateConsentPayload returns the created or updated consent status. */
export type UpdateConsentPayload = {
  __typename?: 'UpdateConsentPayload';
  /** The full consent status given by the user after the create request. */
  consent?: Maybe<Consent>;
  /** The possible error returned from service. */
  error?: Maybe<UpdateConsentError>;
};

/** Update tags associated with CLIP, STREAM, or VOD with contentID. */
export type UpdateContentTagsInput = {
  /** List of tag IDs to be added from the content. */
  addedTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** ID of the channel owning the content. */
  authorID: Scalars['ID'];
  /** ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs. */
  contentID: Scalars['ID'];
  /** Type of content being returned. Can only be of values CLIP, STREAM, or VOD. */
  contentType: ContentType;
  /** List of tag IDs to be removed from the content. */
  removedTagIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/** Result of mutation is the contentID. */
export type UpdateContentTagsPayload = {
  __typename?: 'UpdateContentTagsPayload';
  /** Content which tags have been updated. */
  content?: Maybe<TaggedContent>;
};

/**
 * Error codes for issues that may occur when trying to update an
 * existing Mosaic layout.
 */
export enum UpdateDashboardViewMosaicLayoutErrorCode {
  /**
   * One or more unspecified aguments are invalid. These are not
   * user-actionable, but might indicate a logic error.
   */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The layout argument is invalid. */
  InvalidArgumentLayout = 'INVALID_ARGUMENT_LAYOUT',
  /** The layoutID argument is required. */
  InvalidArgumentLayoutid = 'INVALID_ARGUMENT_LAYOUTID',
  /** The name argument is invalid. */
  InvalidArgumentName = 'INVALID_ARGUMENT_NAME',
  /** The userID argument is required. */
  InvalidArgumentUserid = 'INVALID_ARGUMENT_USERID',
  /** The version argument is invalid. */
  InvalidArgumentVersion = 'INVALID_ARGUMENT_VERSION',
  /** A layout matching the provided ID was not found. */
  NotFound = 'NOT_FOUND',
  /** An unhandled error. */
  Unknown = 'UNKNOWN'
}

/**
 * Input for updating properties of an existing Mosaic layout.
 * Must specify the id of the layout, which is validated based
 * on the current userID. Must also specify the type of the layout.
 * Other fields are optional; only specified fields are updated,
 * and undefined ones are left unchanged.
 */
export type UpdateDashboardViewMosaicLayoutInput = {
  /**
   * The Mosaic data blob (in string form) representing a Mosaic layout.
   * If left undefined, the data will not be changed.
   */
  data?: InputMaybe<Scalars['MosaicData']>;
  /**
   * The id of the specific mosaic layout to be updated. This identifies
   * a combination of type and channel for this user, and has an additional
   * unique component to distinguish it from other layouts for this type and channel.
   */
  id: Scalars['ID'];
  /**
   * The display name of the layout. This allows the display name to be changed.
   * If left undefined, the display name will not be changed.
   */
  name?: InputMaybe<Scalars['String']>;
  /**
   * The version tag for a Mosaic layout, which can be optionally updated.
   * If left undefined, the value will not be changed.
   */
  version?: InputMaybe<Scalars['String']>;
};

/** Result of the updateDashboardViewMosaicLayout mutation. */
export type UpdateDashboardViewMosaicLayoutPayload = {
  __typename?: 'UpdateDashboardViewMosaicLayoutPayload';
  /** Represents an error when attempting to update a layout, if applicable. */
  errorCode?: Maybe<UpdateDashboardViewMosaicLayoutErrorCode>;
  /** The the layout that was updated. */
  layout?: Maybe<ChannelDashboardLayout>;
};

/** UpdateDropBenefitInput has fields required to update a drop benefit. */
export type UpdateDropBenefitInput = {
  /** The redirect URL where a user can link their account. */
  accountLinkURL: Scalars['String'];
  /** The ID of this benefit object. */
  benefitID: Scalars['ID'];
  /** The global limit of how often this benefit can be entitled to a user. */
  entitlementLimit: Scalars['Int'];
  /** The game that awarded the Drop. */
  gameID: Scalars['ID'];
  /** Specifies if this reward is considered for a game that is available on iOS. */
  isIosAvailable?: InputMaybe<Scalars['Boolean']>;
  /** The display name of this benefit object. */
  name: Scalars['String'];
  /** The RBAC organization ID of the owner. */
  ownerID: Scalars['ID'];
};

/** UpdateDropBenefitOnDropInput has fields required to update a drop's benefit. */
export type UpdateDropBenefitOnDropInput = {
  /** The benefit to add to the drop. */
  benefitID: Scalars['ID'];
  /** How many times the drop can award the benefit. */
  dropEntitlementLimit: Scalars['Int'];
  /** The drop to add the benefit to. */
  dropID: Scalars['ID'];
};

/** UpdateDropBenefitOnDropPayload returns the result of the update. */
export type UpdateDropBenefitOnDropPayload = {
  __typename?: 'UpdateDropBenefitOnDropPayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** UpdateDropBenefitPayload returns the result of the update. */
export type UpdateDropBenefitPayload = {
  __typename?: 'UpdateDropBenefitPayload';
  /** Returns the updated Benefit. */
  dropBenefit?: Maybe<DropBenefit>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** UpdateDropPreconditionsInput has fields required to update multiple drops and their precondition drop. */
export type UpdateDropPreconditionsInput = {
  /** The campaign we want to update drops for. */
  campaignID: Scalars['ID'];
  /** A list of drops and their drop precondition. */
  dropPreconditions: Array<InputMaybe<DropPrecondition>>;
};

/** UpdateDropPreconditionsPayload returns the result of the update. */
export type UpdateDropPreconditionsPayload = {
  __typename?: 'UpdateDropPreconditionsPayload';
  /** Returns the updated Campaign. */
  dropCampaign?: Maybe<DropCampaign>;
  /** A mapped error returned by the drops management service. */
  error?: Maybe<DropsError>;
};

/** The required input for a updateDropsOptOutStatus mutation. */
export type UpdateDropsOptOutStatusInput = {
  /** Channel's drop opt-out Status. */
  isOptedOut: Scalars['Boolean'];
  /** The Id of the user whose broadcast setting is being updated. */
  userID: Scalars['ID'];
};

/** The result of a updateDropsOptOutStatus mutation. */
export type UpdateDropsOptOutStatusPayload = {
  __typename?: 'UpdateDropsOptOutStatusPayload';
  /** Status is the updated status. */
  isOptedOut?: Maybe<Scalars['Boolean']>;
  /** userID is the user who wishes to opt out of drops. */
  userID?: Maybe<Scalars['ID']>;
};

/** Errors for updating emote orders. */
export type UpdateEmoteOrdersError = {
  __typename?: 'UpdateEmoteOrdersError';
  /** The associated error code. */
  code: UpdateEmoteOrdersErrorCode;
};

/** The expected errors that can be returned from the UpdateEmoteOrders mutation. */
export enum UpdateEmoteOrdersErrorCode {
  /** No emote was found with the requested emote ID. */
  BadEmoteRequest = 'BAD_EMOTE_REQUEST',
  /** No group was found with the requested group ID. */
  BadGroupRequest = 'BAD_GROUP_REQUEST',
  /** The orders provided result in an invalid set of orders in a particular group. */
  BadNonUniqueOrdersRequest = 'BAD_NON_UNIQUE_ORDERS_REQUEST',
  /** The user is not permitted to update the orders of the requested emotes or group. */
  Unauthorized = 'UNAUTHORIZED',
  /** An unexpected error occurred. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for an updateEmoteOrders mutation. */
export type UpdateEmoteOrdersInput = {
  /** The list of emotes with their newly requested orders in a particular group. */
  orders: Array<EmoteOrder>;
};

/** The result of an updateEmoteOrders mutation. */
export type UpdateEmoteOrdersPayload = {
  __typename?: 'UpdateEmoteOrdersPayload';
  /** Emotes are the newly reordered emotes. */
  emotes?: Maybe<Array<Emote>>;
  /** Service error, if any. */
  error?: Maybe<UpdateEmoteOrdersError>;
};

/** UpdateExtensionDiscoveryDataError is an error associated with the updateExtensionDiscoveryData mutation. */
export enum UpdateExtensionDiscoveryDataError {
  /** Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidAuthorEmail = 'INVALID_AUTHOR_EMAIL',
  /** Extension author name length must be > 40. */
  InvalidAuthorNameLength = 'INVALID_AUTHOR_NAME_LENGTH',
  /** Extension description must be shorter than 1024 characters. */
  InvalidDescriptionLength = 'INVALID_DESCRIPTION_LENGTH',
  /** Extension names must be shorter than 40 characters. */
  InvalidNameLength = 'INVALID_NAME_LENGTH',
  /** Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidPrivacyUri = 'INVALID_PRIVACY_URI',
  /** Extension summary must be shorter than 140 characters. */
  InvalidSummaryLength = 'INVALID_SUMMARY_LENGTH',
  /** Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidSupportEmail = 'INVALID_SUPPORT_EMAIL',
  /** Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTermsUri = 'INVALID_TERMS_URI',
  /** Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTestingBaseUri = 'INVALID_TESTING_BASE_URI',
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** UpdateExtensionDiscoveryDataInput updates the discovery data of a given extension version. */
export type UpdateExtensionDiscoveryDataInput = {
  /** Extension metadata used for discovery. */
  discoveryManifest: ExtensionDiscoveryManifestInput;
  /** The extension ID of the manifest to update. */
  id: Scalars['ID'];
  /** The extension version to update. */
  version: Scalars['String'];
};

/** UpdateExtensionDiscoveryDataPayload returns the update Extension discovery metadata. */
export type UpdateExtensionDiscoveryDataPayload = {
  __typename?: 'UpdateExtensionDiscoveryDataPayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<UpdateExtensionDiscoveryDataError>;
  /** The updated extension discovery data. */
  manifest?: Maybe<ExtensionVersionDiscoveryManifest>;
};

/** UpdateExtensionManifestError is an error associated with the updateExtensionManifest mutation. */
export enum UpdateExtensionManifestError {
  /** At least one anchor must be specified. */
  AnchorRequired = 'ANCHOR_REQUIRED',
  /** Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidAuthorEmail = 'INVALID_AUTHOR_EMAIL',
  /** Extension author name length must be > 40. */
  InvalidAuthorNameLength = 'INVALID_AUTHOR_NAME_LENGTH',
  /** Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum. */
  InvalidBitsSupportLevel = 'INVALID_BITS_SUPPORT_LEVEL',
  /** Extension component aspect height must be < 50 or > 1. */
  InvalidComponentAspectHeight = 'INVALID_COMPONENT_ASPECT_HEIGHT',
  /** Extension component aspect width must be < 50 or > 1. */
  InvalidComponentAspectWidth = 'INVALID_COMPONENT_ASPECT_WIDTH',
  /** Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidComponentViewerPath = 'INVALID_COMPONENT_VIEWER_PATH',
  /** Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidConfigViewerPath = 'INVALID_CONFIG_VIEWER_PATH',
  /** Extension description must be shorter than 1024 characters. */
  InvalidDescriptionLength = 'INVALID_DESCRIPTION_LENGTH',
  /** Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidLiveConfigViewerPath = 'INVALID_LIVE_CONFIG_VIEWER_PATH',
  /** Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidMobileViewerPath = 'INVALID_MOBILE_VIEWER_PATH',
  /** Extension names must be shorter than 40 characters. */
  InvalidNameLength = 'INVALID_NAME_LENGTH',
  /** Extension panel hiehgt must be < 500 or > 100. */
  InvalidPanelHeight = 'INVALID_PANEL_HEIGHT',
  /** Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidPanelViewerPath = 'INVALID_PANEL_VIEWER_PATH',
  /** Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidPrivacyUri = 'INVALID_PRIVACY_URI',
  /** Extension summary must be shorter than 140 characters. */
  InvalidSummaryLength = 'INVALID_SUMMARY_LENGTH',
  /** Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address. */
  InvalidSupportEmail = 'INVALID_SUPPORT_EMAIL',
  /** Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTermsUri = 'INVALID_TERMS_URI',
  /** Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil. */
  InvalidTestingBaseUri = 'INVALID_TESTING_BASE_URI',
  /** Version specified is invalid. */
  InvalidVersion = 'INVALID_VERSION',
  /** Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path. */
  InvalidVideoOverlayViewerPath = 'INVALID_VIDEO_OVERLAY_VIEWER_PATH',
  /** HasZoom was specified but ZoomPixels is missing. */
  InvalidZoom = 'INVALID_ZOOM',
  /** The number of whitelisted broadcasters exceeds the limit. */
  MaxBroadcasters = 'MAX_BROADCASTERS',
  /** The number of whitelisted testing users exceeds the limit. */
  MaxTesters = 'MAX_TESTERS',
  /** The number of whitelisted config URLs exceeds the limit. */
  MaxWhitelistedConfigUrls = 'MAX_WHITELISTED_CONFIG_URLS',
  /** The number of whitelisted panel URLs exceeds the limit. */
  MaxWhitelistedPanelUrls = 'MAX_WHITELISTED_PANEL_URLS',
  /** User is unable to make modifications to the extension. */
  Unauthorized = 'UNAUTHORIZED'
}

/** UpdateExtensionManifestInput updates the manifest. */
export type UpdateExtensionManifestInput = {
  /** ExtensionAssetManifest is data related to the assets of an extension. */
  assetManifest: ExtensionAssetManifestInput;
  /** Data about what an Extension can do, in general, and at the time of interaction. */
  capabilities: ExtensionCapabilitiesInput;
  /** ExtensionDeveloperManifest is the developer specific extension data. */
  developerManifest: ExtensionDeveloperManifestInput;
  /** Extension metadata used for discovery. */
  discoveryManifest: ExtensionDiscoveryManifestInput;
  /** The extension ID of the manifest to update. */
  id: Scalars['ID'];
  /** The extension version to update. */
  version: Scalars['String'];
  /** Extension views. */
  views: ExtensionViewsInput;
};

/** UpdateExtensionManifestPayload returns the update Extension manifest. */
export type UpdateExtensionManifestPayload = {
  __typename?: 'UpdateExtensionManifestPayload';
  /** The error when the mutation fails to update an extension. */
  error?: Maybe<UpdateExtensionManifestError>;
  /** The updated extension manifest. */
  manifest?: Maybe<ExtensionManifest>;
};

/** UpdateHypeTrainConfigInput takes series of optional config settings. */
export type UpdateHypeTrainConfigInput = {
  /** Custom emote to be rendered in Hype Train messaging. */
  calloutEmoteID?: InputMaybe<Scalars['ID']>;
  /** Length of the cooldown period after a hype train ends. */
  cooldownPeriodMinutes?: InputMaybe<Scalars['Int']>;
  /** The difficulty of hype train levels. */
  difficulty?: InputMaybe<HypeTrainDifficulty>;
  /** Whether hype train should be enabled. */
  isEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Hype Train kickoff settings. */
  kickoff?: InputMaybe<HypeTrainKickoffInput>;
  /** A boolean flag that indicates if the hype train settings should be personalized by Twitch. */
  shouldUsePersonalizedSettings?: InputMaybe<Scalars['Boolean']>;
  /** Use creator color as base color of the Hype Train progress bar. */
  willUseCreatorColor?: InputMaybe<Scalars['Boolean']>;
};

/** UpdateHypeTrainConfigPayload is the response that contains the updated config. */
export type UpdateHypeTrainConfigPayload = {
  __typename?: 'UpdateHypeTrainConfigPayload';
  /** The updated hype train config for the channel. */
  config?: Maybe<HypeTrainConfig>;
};

/**
 * Updates the user's activity sharing setting. This must only be sent in response to a direct action by the user
 * intended to change the setting.
 */
export type UpdateIsSharingActivityInput = {
  /**
   * Determines whether or not to show the user's activity in their shared status. When false, the user will always
   * appear as if they are performing no activity.
   */
  isSharingActivity: Scalars['Boolean'];
};

export type UpdateIsSharingActivityPayload = {
  __typename?: 'UpdateIsSharingActivityPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** Exchanges one of two auth inputs for an AccessToken and RefreshToken. */
export type UpdateLwaTokenInput = {
  /** Either an AuthorizationCode or a RefreshToken. */
  grant: Scalars['String'];
  /** The type of grant provided. */
  grantType: GrantType;
};

/** Returns updated tokens, or an error if a new LWA flow is required. */
export type UpdateLwaTokenPayload = {
  __typename?: 'UpdateLWATokenPayload';
  /** An error in this flow means the client should redo the LWA flow. */
  error?: Maybe<WatchPartyError>;
  /** Contains all token information. */
  token?: Maybe<LwaToken>;
};

/** Mutation input for updating partner leaderboard settings. */
export type UpdateLeaderboardSettingsInput = {
  /** The default leaderboard the user wants to show. */
  defaultLeaderboard?: InputMaybe<LeaderboardType>;
  /** Setting for enabling bits cheering leaderboards. */
  isCheerEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Setting for enabling sub gifting leaderboards. */
  isSubGiftEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The time period the user wants the leaderboard to be displayed as. */
  timePeriod?: InputMaybe<LeaderboardTimePeriodType>;
  /** The user ID to update leaderboard settings. */
  userID: Scalars['ID'];
};

/** Result of mutation is the updated user object. */
export type UpdateLeaderboardSettingsPayload = {
  __typename?: 'UpdateLeaderboardSettingsPayload';
  /** The user whose settings were updated. */
  user?: Maybe<User>;
};

/** The required input for a updateLiveUpNotification mutation. */
export type UpdateLiveUpNotificationInput = {
  /**
   * The text that will be in the notification that sends when the user starts broadcasting.
   * If updated to "", the default value of "<user> went live!" will be used/returned.
   */
  liveUpNotification: Scalars['String'];
  /** The ID of the user whose live up notification is being updated. */
  userID: Scalars['ID'];
};

/** Returned after live up notification state is mutated. */
export type UpdateLiveUpNotificationPayload = {
  __typename?: 'UpdateLiveUpNotificationPayload';
  /** The modified broadcast settings. */
  broadcastSettings?: Maybe<BroadcastSettings>;
  /** If any validation errors occur, this will not be nil. */
  error?: Maybe<UpdateLiveUpNotificationValidationError>;
};

/** Resolver for validation errors that occur on update live up notification. */
export type UpdateLiveUpNotificationValidationError = {
  __typename?: 'UpdateLiveUpNotificationValidationError';
  /** Error code that describes the validation error. */
  code: UpdateLiveUpNotificationValidationErrorCode;
};

/** Validation error status codes. */
export enum UpdateLiveUpNotificationValidationErrorCode {
  /** The notification text sent did not pass auto mod. */
  FailedAutomod = 'FAILED_AUTOMOD',
  /** The notification text sent is too long. */
  TooLong = 'TOO_LONG',
  /** The target user is not found. */
  UserNotFound = 'USER_NOT_FOUND'
}

/** Inputs for updating the score for the lobby participant, who is a competition player or competition team, in a competition. */
export type UpdateLobbyParticipantScoreInput = {
  /** ID of the competition. */
  competitionID: Scalars['ID'];
  /** ID of the competition lobby. */
  lobbyID: Scalars['ID'];
  /** ID of the competition player or competition team. */
  participantID: Scalars['ID'];
  /** ID of the competition phase. */
  phaseID: Scalars['ID'];
  /** The assigned score value. */
  score: Scalars['Int'];
};

/** UpdateLobbyParticipantScorePayload is the success response updating the score for the lobby participant, who is a competition player or competition team, in a competition. */
export type UpdateLobbyParticipantScorePayload = {
  __typename?: 'UpdateLobbyParticipantScorePayload';
  /** The new state of competition after scoring a competition player or competition team for that lobby. */
  competition?: Maybe<Competition>;
  /** Used for competition mutation errors. */
  error?: Maybe<CompetitionError>;
};

/** Contains a list of multi-view content attributes to be updated. */
export type UpdateMultiviewContentAttributesInput = {
  /** List of multi-view content attributes to be updated. */
  params: Array<MultiviewContentAttributeParams>;
};

/** Contains the server response payload. */
export type UpdateMultiviewContentAttributesPayload = {
  __typename?: 'UpdateMultiviewContentAttributesPayload';
  /** Unprocssed content attribute updates. */
  failedUpdates: Array<MultiviewContentAttribute>;
  /** Processed content attribute updates. */
  succeededUpdates: Array<MultiviewContentAttribute>;
};

/** Used for mutating onboarding status. */
export type UpdateOnboardingSkippedChannelsInput = {
  /** List of channels the user skips during the onboarding process. */
  channelIDs: Array<Scalars['ID']>;
  /** ID for the user to update. */
  userID: Scalars['ID'];
};

/** Returned after onboarding state is mutated. */
export type UpdateOnboardingSkippedChannelsPayload = {
  __typename?: 'UpdateOnboardingSkippedChannelsPayload';
  /** Current state of the given user. */
  user?: Maybe<User>;
};

/** Error that may be returned by the UpdateOrganizationMemberRole mutation. */
export type UpdateOrganizationMemberRoleError = {
  __typename?: 'UpdateOrganizationMemberRoleError';
  /** Type of mutation error. */
  code: UpdateOrganizationMemberRoleErrorCode;
};

/** UpdateOrganizationMemberRoleErrorCode is the client error type that occurred during the UpdateOrganizationMemberRole mutation. */
export enum UpdateOrganizationMemberRoleErrorCode {
  /** One of the input parameters is malformed. This should not happen when properly using the UI. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /**
   * The user doesn't meet the requirements to have this role. For example, when trying to assign the
   * "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
   */
  MemberIneligible = 'MEMBER_INELIGIBLE',
  /** The user is not a member of the organization, or the organization does not exist. */
  MemberNotFound = 'MEMBER_NOT_FOUND',
  /**
   * Current user not allowed to update the role.
   * For example, developers can not assign roles, and no one can assign the owner role to another user.
   */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** Inputs to the UpdateOrganizationMemberRole mutation. */
export type UpdateOrganizationMemberRoleInput = {
  /** ID of the organization where the user is a member. */
  organizationID: Scalars['ID'];
  /** New role of the user in the organization. */
  role: OrganizationMemberRole;
  /** User's Twitch ID. */
  userID: Scalars['ID'];
};

/** Outputs from the UpdateOrganizationMemberRole mutation. */
export type UpdateOrganizationMemberRolePayload = {
  __typename?: 'UpdateOrganizationMemberRolePayload';
  /** Logical error that could be returned by the mutation. */
  error?: Maybe<UpdateOrganizationMemberRoleError>;
  /** Updated member with the new role. */
  organizationMember?: Maybe<OrganizationMember>;
};

/** UpdateOwnerChanletAttributesInput updates the owner chanlet attributes. */
export type UpdateOwnerChanletAttributesInput = {
  /** The ID of the owner chanlet (channel that owns chanlets). */
  channelID: Scalars['ID'];
  /** Whether the chanlets should return for the viewers. */
  isChanletFeatureEnabled: Scalars['Boolean'];
};

/** UpdateOwnerChanletAttributesPayload returns the new chanlet that was created. */
export type UpdateOwnerChanletAttributesPayload = {
  __typename?: 'UpdateOwnerChanletAttributesPayload';
  /** Resulted OwnerChanletAttributes from the update. This is expected to match the input. */
  ownerChanletAttributes?: Maybe<OwnerChanletAttributes>;
};

export type UpdatePanelInput = {
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  imageURL?: InputMaybe<Scalars['String']>;
  linkURL?: InputMaybe<Scalars['String']>;
  slotID?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type UpdatePanelPayload = {
  __typename?: 'UpdatePanelPayload';
  panel: Panel;
};

/** Error returned during a invalid user request. */
export type UpdatePhoneNumberConfirmationError = {
  __typename?: 'UpdatePhoneNumberConfirmationError';
  /** Error code returned by the backend. */
  code: UpdatePhoneNumberConfirmationErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to change a users phone number. */
export enum UpdatePhoneNumberConfirmationErrorCode {
  /** The one time password provided is invalid. */
  InvalidOtp = 'INVALID_OTP',
  /** Phone number was not valid. */
  InvalidPhoneNumber = 'INVALID_PHONE_NUMBER',
  /** The phone number provided is used for too many Twitch accounts. */
  LimitReached = 'LIMIT_REACHED',
  /** The one time password provided is missing. A SMS to the phone number will be triggered when this error occurs. */
  MissingOtp = 'MISSING_OTP',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** The phone number has requested checks on too many verification codes. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a updatePhoneNumberConfirmation mutation. */
export type UpdatePhoneNumberConfirmationInput = {
  /** The one time password required to complete phone number registration. This can only be generated from the UpdatePhoneNumber mutation. */
  oneTimePassword: Scalars['String'];
  /** The phone number being added to a twitch user profile. */
  phoneNumber: Scalars['String'];
  /** The ID of the user that is requesting to add or modify their phone number. */
  userID: Scalars['ID'];
};

/** The result of a updatePhoneNumberConfirmationPayload mutation. */
export type UpdatePhoneNumberConfirmationPayload = {
  __typename?: 'UpdatePhoneNumberConfirmationPayload';
  /** error code and localized error. */
  error?: Maybe<UpdatePhoneNumberConfirmationError>;
};

/** Error returned during a invalid user request. */
export type UpdatePhoneNumberError = {
  __typename?: 'UpdatePhoneNumberError';
  /** Error code returned by the backend. */
  code: UpdatePhoneNumberErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to change a users phone number. */
export enum UpdatePhoneNumberErrorCode {
  /** Phone number was not valid. */
  InvalidPhoneNumber = 'INVALID_PHONE_NUMBER',
  /** The phone number provided is used for too many Twitch accounts. */
  LimitReached = 'LIMIT_REACHED',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** The phone number has requested too many verification codes. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a updatePhoneNumber mutation. */
export type UpdatePhoneNumberInput = {
  /** The phone number being added to a twitch user profile. */
  phoneNumber: Scalars['String'];
  /** The ID of the user that is requesting to add or modify their phone number. */
  userID: Scalars['ID'];
};

/** The result of a updatePhoneNumberPayload mutation. */
export type UpdatePhoneNumberPayload = {
  __typename?: 'UpdatePhoneNumberPayload';
  /** error code and localized error. */
  error?: Maybe<UpdatePhoneNumberError>;
};

/** Error code for an error that occurs while updating prime offer status. */
export type UpdatePrimeOfferStatusError = {
  __typename?: 'UpdatePrimeOfferStatusError';
  /** Error code for error that occurred while updating prime offer status. */
  code: UpdatePrimeOfferStatusErrorCode;
};

/** Error types recognized. */
export enum UpdatePrimeOfferStatusErrorCode {
  /** Status when the offers fail to be updated. */
  OffersFailedToUpdate = 'OFFERS_FAILED_TO_UPDATE',
  /** Unknown error being returned from service. */
  Unknown = 'UNKNOWN'
}

/** The offer id you wish to update as well as the status for the update. */
export type UpdatePrimeOfferStatusInput = {
  /** The list of offers and statuses to update. */
  statusChanges: Array<OfferAndStatus>;
  /** The user to update the offer statuses for. */
  userID: Scalars['ID'];
};

/** The returned value for an update prime offer status query. */
export type UpdatePrimeOfferStatusPayload = {
  __typename?: 'UpdatePrimeOfferStatusPayload';
  /** The possible error returned from the service. */
  error?: Maybe<UpdatePrimeOfferStatusError>;
  /** The connection for the status of the offer for the user. */
  self: Array<PrimeOfferSelfConnection>;
};

/**
 * UpdatePrimeSettingsInput contains boolean for setting the users preference on chat notifications,
 * and the users preference on the emoticon set name to be selected.
 */
export type UpdatePrimeSettingsInput = {
  /** The Prime Emoticons Set Name for Prime Emoticons Smilies. */
  primeEmoticonsSetName?: InputMaybe<PrimeEmoticonsSetName>;
  /** True or False for whether the user wants notifications enabled. */
  shouldEnableSubCreditChatNotification?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the user who's settings are being updated. */
  userID: Scalars['ID'];
};

/** Data that was mutated. */
export type UpdatePrimeSettingsPayload = {
  __typename?: 'UpdatePrimeSettingsPayload';
  /** The mutated PrimeSettings. */
  primeSettings?: Maybe<PrimeSettings>;
};

/** UpdateRaidSettingsInput update a user's raid settings. */
export type UpdateRaidSettingsInput = {
  /** Determines what other channels can raid this channel. */
  incomingRaidsPolicy?: InputMaybe<IncomingRaidsPolicy>;
  /** UserID to update settings for. */
  userID: Scalars['ID'];
};

/** UpdateRaidSettingsPayload returns the user whose settings had been updated. */
export type UpdateRaidSettingsPayload = {
  __typename?: 'UpdateRaidSettingsPayload';
  /** User whose raid settings has been updated. */
  user?: Maybe<User>;
};

export type UpdateRoomError = {
  __typename?: 'UpdateRoomError';
  code: UpdateRoomErrorCode;
  /** On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters. */
  maxLength?: Maybe<Scalars['Int']>;
  /** On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters. */
  minLength?: Maybe<Scalars['Int']>;
};

export enum UpdateRoomErrorCode {
  /** User does not have permission to update room. */
  Forbidden = 'FORBIDDEN',
  /** Name contains invalid characters (e.g. spaces). */
  NameContainsInvalidCharacters = 'NAME_CONTAINS_INVALID_CHARACTERS',
  /** Name failed automod check. */
  NameInappropriate = 'NAME_INAPPROPRIATE',
  /** Name too short or too long. */
  NameLengthInvalid = 'NAME_LENGTH_INVALID',
  /** Name was not unique to channel. */
  NameNotUnique = 'NAME_NOT_UNIQUE',
  /** Invalid roles specified (e.g. a more permissive role for send than read). */
  RolesInvalid = 'ROLES_INVALID',
  /** Could not find a room with the given room ID. */
  RoomNotFound = 'ROOM_NOT_FOUND',
  /** Topic failed automod check. */
  TopicInappropriate = 'TOPIC_INAPPROPRIATE',
  /** Topic too short or too long. */
  TopicLengthInvalid = 'TOPIC_LENGTH_INVALID'
}

export type UpdateRoomInput = {
  /** Deprecated. Use minimumReadMessagesRole instead. */
  isPreviewable?: InputMaybe<Scalars['Boolean']>;
  /** Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead. */
  minimumAllowedRole?: InputMaybe<RoomRole>;
  /** Minimum role required to read messages in the room. */
  minimumReadMessagesRole?: InputMaybe<RoomRole>;
  /** Minimum role required to send messages in the room. */
  minimumSendMessagesRole?: InputMaybe<RoomRole>;
  name?: InputMaybe<Scalars['String']>;
  roomID: Scalars['ID'];
  topic?: InputMaybe<Scalars['String']>;
};

export type UpdateRoomModesError = {
  __typename?: 'UpdateRoomModesError';
  code: UpdateRoomModesErrorCode;
  /** On SLOW_MODE_DURATION_INVALID: Maximum number of seconds slow mode can be set to. */
  maximumSlowModeDurationSeconds?: Maybe<Scalars['Int']>;
  /** On SLOW_MODE_DURATION_INVALID: Minimum number of seconds slow mode can be set to. */
  minimumSlowModeDurationSeconds?: Maybe<Scalars['Int']>;
};

export enum UpdateRoomModesErrorCode {
  /** User did not have permission to update room modes. */
  Forbidden = 'FORBIDDEN',
  /** RoomID referred to an invalid or the user does not have permissions to see the room. */
  RoomNotFound = 'ROOM_NOT_FOUND',
  /** Slow mode duration was too short, too long, or not a number. */
  SlowModeDurationInvalid = 'SLOW_MODE_DURATION_INVALID'
}

export type UpdateRoomModesInput = {
  /** Turns emotes only mode on or off. */
  enableEmotesOnlyMode?: InputMaybe<Scalars['Boolean']>;
  /** Turns r9k mode on or off. */
  enableR9KMode?: InputMaybe<Scalars['Boolean']>;
  /** Turns slow mode on or off. */
  enableSlowMode?: InputMaybe<Scalars['Boolean']>;
  roomID: Scalars['ID'];
  /** If slow mode enabled, the number of seconds users must wait between messages. */
  slowModeDurationSeconds?: InputMaybe<Scalars['Int']>;
};

export type UpdateRoomModesPayload = {
  __typename?: 'UpdateRoomModesPayload';
  error?: Maybe<UpdateRoomModesError>;
  room?: Maybe<Room>;
};

export type UpdateRoomPayload = {
  __typename?: 'UpdateRoomPayload';
  error?: Maybe<UpdateRoomError>;
  room?: Maybe<Room>;
};

export type UpdateRoomViewInput = {
  isArchived?: InputMaybe<Scalars['Boolean']>;
  isMuted?: InputMaybe<Scalars['Boolean']>;
  lastReadAt?: InputMaybe<Scalars['Time']>;
  roomID: Scalars['ID'];
};

export type UpdateRoomViewPayload = {
  __typename?: 'UpdateRoomViewPayload';
  roomView?: Maybe<RoomView>;
};

/** UpdateScheduleSegmentError is a wrapper for error associated with the UpdateScheduleSegment mutation. */
export type UpdateScheduleSegmentError = {
  __typename?: 'UpdateScheduleSegmentError';
  /** Error code. */
  code: UpdateScheduleSegmentErrorCode;
  /** If the error is related to overlapping segments, provide the existing segment causing a conflict. */
  conflictingSegment?: Maybe<ScheduleSegment>;
  /** If the error is related to an input out of service-defined bounds, provide the maximum allowed value. */
  maximum?: Maybe<Scalars['Int']>;
  /** If the error is related to an input out of service-defined bounds, provide the miniimum allowed value. */
  minimum?: Maybe<Scalars['Int']>;
};

/** The possible error returned. */
export enum UpdateScheduleSegmentErrorCode {
  /** The segment has already started and can't be edited. */
  AlreadyStarted = 'ALREADY_STARTED',
  /** The segment first occurrence date is set in the past. */
  FirstOccurrenceDateInPast = 'FIRST_OCCURRENCE_DATE_IN_PAST',
  /** Cannot set the first occurrence date on an infinitely recurring segment. */
  FirstOccurrenceDateOnRecurringSegment = 'FIRST_OCCURRENCE_DATE_ON_RECURRING_SEGMENT',
  /** The input is not valid. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** The categories are not valid. */
  InvalidCategories = 'INVALID_CATEGORIES',
  /** The number of categories is invalid. Refer to the error for min and max acceptable values. */
  InvalidCategoryCount = 'INVALID_CATEGORY_COUNT',
  /** The duration is invalid. Refer to the error for min and max acceptable values. */
  InvalidDuration = 'INVALID_DURATION',
  /** The segment is invalid. */
  InvalidSegment = 'INVALID_SEGMENT',
  /** The segment start day is invalid. */
  InvalidStartDay = 'INVALID_START_DAY',
  /** The segment start hour is invalid. */
  InvalidStartHour = 'INVALID_START_HOUR',
  /** The segment start minute is invalid. */
  InvalidStartMinute = 'INVALID_START_MINUTE',
  /** The timezone is not valid. */
  InvalidTimezone = 'INVALID_TIMEZONE',
  /** The title length is invalid. Refer to the error for min and max acceptable values. */
  InvalidTitle = 'INVALID_TITLE',
  /** The specified segment could not be found. */
  NotFound = 'NOT_FOUND',
  /** No update was made because no updated attributes were provided. */
  NoUpdatedAttributesProvided = 'NO_UPDATED_ATTRIBUTES_PROVIDED',
  /** No update was made because the update would cause a segment overlap. */
  OverlappingSegments = 'OVERLAPPING_SEGMENTS',
  /** Not authorized to update this segment. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** The title failed the moderation check. */
  TitleFailedModeration = 'TITLE_FAILED_MODERATION'
}

/** The input to update a schedule segment. */
export type UpdateScheduleSegmentInput = {
  /** The categories of the segment. */
  categories?: InputMaybe<Array<Scalars['ID']>>;
  /** The duration of the segment in minutes. */
  durationMinutes?: InputMaybe<Scalars['Int']>;
  /** The start date and time of the first occurrence of the segment. */
  firstOccurrenceDate?: InputMaybe<Scalars['Time']>;
  /** Whether the segment is cancelled. */
  isCancelled?: InputMaybe<Scalars['Boolean']>;
  /** The schedule id. */
  scheduleID: Scalars['ID'];
  /** The segment id to update. */
  segmentID: Scalars['ID'];
  /** The start time of the segment. */
  start?: InputMaybe<SegmentStartTimeInput>;
  /** The geographic timezone of the segment. */
  timezone?: InputMaybe<Scalars['String']>;
  /** The title of the segment. */
  title?: InputMaybe<Scalars['String']>;
};

/** The returned payload when updating a schedule segment. */
export type UpdateScheduleSegmentPayload = {
  __typename?: 'UpdateScheduleSegmentPayload';
  /** The possible error returned. */
  error?: Maybe<UpdateScheduleSegmentError>;
  /** The updated schedule with the updated segment. */
  schedule?: Maybe<Schedule>;
};

/** Updates the list of streamer onboarding content that a user has seen. */
export type UpdateSeenCreatorOnboardingContentInput = {
  /** A list of content IDs that should be marked as seen. */
  onboardingContentIDs: Array<Scalars['ID']>;
  /** UserID for the user to update seen content. */
  userID: Scalars['ID'];
};

/** The result of an UpdateSeenCreatorOnboardingContent mutation. */
export type UpdateSeenCreatorOnboardingContentPayload = {
  __typename?: 'UpdateSeenCreatorOnboardingContentPayload';
  /** The user who viewed onboarding content. */
  user?: Maybe<User>;
};

/** UpdateSocialMediaError is a user error while creating a social media. */
export enum UpdateSocialMediaError {
  /** The title failed moderation. */
  FailedTitleModeration = 'FAILED_TITLE_MODERATION',
  /** The provided url is invalid. */
  InvalidUrl = 'INVALID_URL',
  /** The social medias does not exist. */
  NotFound = 'NOT_FOUND',
  /** The provided title was too long. */
  TitleTooLong = 'TITLE_TOO_LONG'
}

/** UpdateSocialMediaInput updates existing a social media item under the given channelID. */
export type UpdateSocialMediaInput = {
  /** The unique channel identifier. */
  channelID: Scalars['ID'];
  /** The unique indentifier of the social media item. */
  id: Scalars['ID'];
  /** The visible text of the social media item. */
  title?: InputMaybe<Scalars['String']>;
  /** The web address of the social media item. */
  url?: InputMaybe<Scalars['String']>;
};

/** UpdateSocialMediaPayload returns the updated social media. */
export type UpdateSocialMediaPayload = {
  __typename?: 'UpdateSocialMediaPayload';
  /** The social media channel that was updated. */
  channel?: Maybe<Channel>;
  /** The potential error when updating a social media. */
  error?: Maybe<UpdateSocialMediaError>;
};

/** UpdateSquadInvitePolicyError is the error associated with an updateSquadInvitePolicy. */
export type UpdateSquadInvitePolicyError = {
  __typename?: 'UpdateSquadInvitePolicyError';
  /** The associated error code. */
  code: UpdateSquadInvitePolicyErrorCode;
};

/** UpdateSquadInvitePolicyErrorCode are the possible errors that this mutation returns. */
export enum UpdateSquadInvitePolicyErrorCode {
  /** The caller is not authorized to update the user's squad invite policy. */
  Unauthorized = 'UNAUTHORIZED'
}

/** The required input for an updateSquadInvitePolicy mutation. */
export type UpdateSquadInvitePolicyInput = {
  /** The new invite policy that will replace what is currently set for the user. */
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy;
  /** The ID corresponding to the user whose invite policy should be updated. */
  userID: Scalars['ID'];
};

/** Returns after the invite policy is mutated. */
export type UpdateSquadInvitePolicyPayload = {
  __typename?: 'UpdateSquadInvitePolicyPayload';
  /** The possible error returned from the service. */
  error?: Maybe<UpdateSquadInvitePolicyError>;
  /** The modified user. */
  user?: Maybe<User>;
};

/** UpdateSquadStreamError is the error associated with a updateSquadStream. */
export type UpdateSquadStreamError = {
  __typename?: 'UpdateSquadStreamError';
  /** The associated error code. */
  code: UpdateSquadStreamErrorCode;
};

/** UpdateSquadStreamErrorCode are the possible errors that this mutation returns. */
export enum UpdateSquadStreamErrorCode {
  /** The squad cannot be updated (e.g. squad is not in pending status). */
  SquadCannotBeUpdated = 'SQUAD_CANNOT_BE_UPDATED',
  /** The squad is not found. */
  SquadNotFound = 'SQUAD_NOT_FOUND',
  /** The squad has too few members to be updated to live. */
  SquadTooFewMembers = 'SQUAD_TOO_FEW_MEMBERS',
  /** The user is not authorized to update the squad. */
  Unauthorized = 'UNAUTHORIZED'
}

/** Inputs to the updateSquadStream mutation. */
export type UpdateSquadStreamInput = {
  /** The ID of the squad stream to be updated. */
  squadStreamID: Scalars['ID'];
  /** If specified, the new status of the squad stream. */
  status?: InputMaybe<SquadStreamStatus>;
};

/** Outputs from the updateSquadStream mutation. */
export type UpdateSquadStreamPayload = {
  __typename?: 'UpdateSquadStreamPayload';
  /** The possible error returned from the service. */
  error?: Maybe<UpdateSquadStreamError>;
  /** The updated squad stream. */
  squadStream?: Maybe<SquadStream>;
};

/** Inputs to updating a stucco. */
export type UpdateStuccoInput = {
  /** ID of the channel this stucco belongs to. */
  channelID: Scalars['ID'];
  /** Description representing the stucco, should be the words contained in the stucco, used by screen readers. */
  description: Scalars['String'];
  /** Base64 encoded binary data of the 92x28px stucco ("1x") image asset. */
  imageData1x: Scalars['String'];
  /** Base64 encoded binary data of the 182x56px stucco ("2x") image asset. */
  imageData2x: Scalars['String'];
  /** Base64 encoded binary data of the 368x112px stucco ("4x") image asset. */
  imageData4x: Scalars['String'];
  /** Unique ID of the stucco to update. */
  stuccoID: Scalars['ID'];
  /** Text code representing the stucco without any prefixes (prefixes are added in the backend). */
  suffix: Scalars['String'];
};

/** Inputs for updating a stucco pack (exchanging stuccos contained in the pack). */
export type UpdateStuccoPackInput = {
  /** Id of the channel this pack is part of. */
  channelID: Scalars['ID'];
  /** Id of the stucco pack to update. */
  stuccoPackID: Scalars['ID'];
  /** Updated list of stuccos for this pack. */
  stuccos?: InputMaybe<Array<UpdateStuccoPackItemInput>>;
};

/** Single item in a stuccopack, as part of the update stucco pack call, representing one stucco to be used in a certain slot. */
export type UpdateStuccoPackItemInput = {
  /** Slot index in the pack (used for ordering). */
  slotIndex: Scalars['Int'];
  /** Id of the stucco. */
  stuccoID: Scalars['ID'];
};

/** Outputs from the update stucco pack mutation. */
export type UpdateStuccoPackPayload = {
  __typename?: 'UpdateStuccoPackPayload';
  /** The updated stucco pack. */
  stuccoPack?: Maybe<StuccoPack>;
};

/** The output for the update stucco mutation. */
export type UpdateStuccoPayload = {
  __typename?: 'UpdateStuccoPayload';
  /** The updated stucco. */
  stucco?: Maybe<Stucco>;
};

/** Inputs to the updateSubscriptionProduct mutation. */
export type UpdateSubscriptionProductInput = {
  /** Name of the product. */
  displayName?: InputMaybe<Scalars['String']>;
  /** Toggle to enable add free viewing. */
  hasAdFree?: InputMaybe<Scalars['Boolean']>;
  /** Toggle to enable fast chat (or disable slow mode). */
  hasFastChat?: InputMaybe<Scalars['Boolean']>;
  /** Toggle to enable sub only chat. */
  hasSubOnlyChat?: InputMaybe<Scalars['Boolean']>;
  /** Toggle to enable sub only video. */
  hasSubOnlyVideoArchive?: InputMaybe<Scalars['Boolean']>;
  /** The id of the subscription product. */
  id: Scalars['ID'];
  /** User the update belongs to. */
  targetUserID: Scalars['ID'];
};

/** Output from the updateSubscriptionProduct mutation. */
export type UpdateSubscriptionProductPayload = {
  __typename?: 'UpdateSubscriptionProductPayload';
  /** Subscription product output. */
  product?: Maybe<SubscriptionProduct>;
  /** User/channel to update the subscription product. */
  targetUser?: Maybe<User>;
};

/** The possible error returned. */
export type UpdateUserColorsError = {
  __typename?: 'UpdateUserColorsError';
  /** The error code. */
  code: UpdateUserColorsErrorCode;
};

/** The possible types of error codes returned. */
export enum UpdateUserColorsErrorCode {
  /** Hex string is invalid. */
  InvalidHexColor = 'INVALID_HEX_COLOR'
}

/** The required input for a UpdateUserColorsInput mutation. */
export type UpdateUserColorsInput = {
  /** The user's primary color hex string (e.g. "FFFFFF"). */
  primaryColorHex: Scalars['String'];
  /** The ID of the user whose creator colors are being updated. */
  userID: Scalars['ID'];
};

/** The result of a UpdateUserColorsInput mutation. */
export type UpdateUserColorsPayload = {
  __typename?: 'UpdateUserColorsPayload';
  /** The possible error returned. */
  error?: Maybe<UpdateUserColorsError>;
  /** The modified user. */
  user?: Maybe<User>;
};

/** The required input for a updateUserCreateDateHidden mutation. */
export type UpdateUserCreateDateHiddenInput = {
  /** The hide create date boolean to set onto the user. */
  isCreateDateHidden: Scalars['Boolean'];
  /** The ID of the user whose privacy setting is being updated. */
  userID: Scalars['ID'];
};

/** The result of a updateUserCreateDateHidden mutation. */
export type UpdateUserCreateDateHiddenPayload = {
  __typename?: 'UpdateUserCreateDateHiddenPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The required input for a updateUserDirectoryHidden mutation. */
export type UpdateUserDirectoryHiddenInput = {
  /** The directory hidden boolean to set onto the user. */
  IsDirectoryHidden: Scalars['Boolean'];
};

/** The result of a updateUserDirectoryHidden mutation. */
export type UpdateUserDirectoryHiddenPayload = {
  __typename?: 'UpdateUserDirectoryHiddenPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The required input for a updateUserEmailReuseable mutation. */
export type UpdateUserEmailReusableInput = {
  /** The email reusable boolean to set onto the user. */
  IsEmailReusable: Scalars['Boolean'];
  /** The ID of the user whose broadcast setting is being updated. */
  userID: Scalars['ID'];
};

/** The result of a updateUserEmailReuseable mutation. */
export type UpdateUserEmailReusablePayload = {
  __typename?: 'UpdateUserEmailReusablePayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The possible error returned. */
export type UpdateUserError = {
  __typename?: 'UpdateUserError';
  /** The error code. */
  code: UpdateUserErrorCode;
};

/** The possible error codes returned from updating a user. */
export enum UpdateUserErrorCode {
  /** User is not authorized to update this user. */
  AuthFailure = 'AUTH_FAILURE',
  /** Description contains banned words. */
  DescriptionFailedModeration = 'DESCRIPTION_FAILED_MODERATION',
  /** Description field is too long. */
  DescriptionTooLong = 'DESCRIPTION_TOO_LONG',
  /** User is not allowed to change their display name again. */
  DisplayNameChangeAgain = 'DISPLAY_NAME_CHANGE_AGAIN',
  /** Display name not available. */
  DisplayNameNotAvailable = 'DISPLAY_NAME_NOT_AVAILABLE',
  /** User can only change the capitalization of their display name. */
  DisplayNameOnlyCap = 'DISPLAY_NAME_ONLY_CAP',
  /** Display name is too long. */
  DisplayNameTooLong = 'DISPLAY_NAME_TOO_LONG',
  /** Display name is too short. */
  DisplayNameTooShort = 'DISPLAY_NAME_TOO_SHORT',
  /** Unexpected error during displayname override. */
  DisplayNameUnexpectedErr = 'DISPLAY_NAME_UNEXPECTED_ERR',
  /** Email disabled for reuse. */
  EmailDisabledForReuse = 'EMAIL_DISABLED_FOR_REUSE',
  /** User exists but was excluded by filter criteria. */
  FilteredUserRequested = 'FILTERED_USER_REQUESTED',
  /** Age cannot be under 13 years. */
  InvalidBirthday = 'INVALID_BIRTHDAY',
  /** Display name contains invalid characters. */
  InvalidCharsInDisplayName = 'INVALID_CHARS_IN_DISPLAY_NAME',
  /** The login you selected contains invalid characters. */
  InvalidCharsInLogin = 'INVALID_CHARS_IN_LOGIN',
  /** Email address is not valid. */
  InvalidEmail = 'INVALID_EMAIL',
  /** Email address uses an invalid domain. */
  InvalidEmailDomain = 'INVALID_EMAIL_DOMAIN',
  /** Hex color is not valid. */
  InvalidHexColor = 'INVALID_HEX_COLOR',
  /** Last Login doesn't follow format "%Y-%m-%d %H:%M:%S". */
  InvalidLastLogin = 'INVALID_LAST_LOGIN',
  /** Phone number or email update cannot be combined with delete pohone number. */
  InvalidParameterCombination = 'INVALID_PARAMETER_COMBINATION',
  /** The IP is blocked. */
  IpBlocked = 'IP_BLOCKED',
  /** The specified locale is invalid. */
  LanguageNotValid = 'LANGUAGE_NOT_VALID',
  /** The login you selected is not yet available for re-use. */
  LoginBlocked = 'LOGIN_BLOCKED',
  /** The login you selected is not available. */
  LoginNotAvailable = 'LOGIN_NOT_AVAILABLE',
  /** The login you selected is too long. */
  LoginTooLong = 'LOGIN_TOO_LONG',
  /** The login you selected is too short. */
  LoginTooShort = 'LOGIN_TOO_SHORT',
  /** Login contains banned words. */
  LoginUseBannedWords = 'LOGIN_USE_BANNED_WORDS',
  /** Login contains variations on banned words. */
  LoginUseVariationOnBannedWords = 'LOGIN_USE_VARIATION_ON_BANNED_WORDS',
  /** Email change cooldown. */
  NotAllowedToChangeEmail = 'NOT_ALLOWED_TO_CHANGE_EMAIL',
  /** Login change rate limited. */
  NotAllowedToChangeLogin = 'NOT_ALLOWED_TO_CHANGE_LOGIN',
  /** Phone number can only be removed for an account with a verifed email. */
  NotAllowedToDeletePhoneNumber = 'NOT_ALLOWED_TO_DELETE_PHONE_NUMBER',
  /** No properties found for this user identifier. */
  NoProperties = 'NO_PROPERTIES',
  /** Phone number already exists. */
  PhoneNumberAlreadyExists = 'PHONE_NUMBER_ALREADY_EXISTS',
  /** Phone number cannot contain letters. */
  PhoneNumberHasLetters = 'PHONE_NUMBER_HAS_LETTERS',
  /** Phone number is invalid. */
  PhoneNumberInvalid = 'PHONE_NUMBER_INVALID',
  /** Sudo token expired, prompt the user to log in again. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** Too many attempts to update user. */
  RequestsThrottled = 'REQUESTS_THROTTLED',
  /** Reservation does not exist in db. */
  ReservationNotExits = 'RESERVATION_NOT_EXITS',
  /** Too many users associated with the email. */
  TooManyUsersForEmail = 'TOO_MANY_USERS_FOR_EMAIL',
  /** Unknown error. */
  Unknown = 'UNKNOWN',
  /** User cannot be found. */
  UserNotFound = 'USER_NOT_FOUND',
  /** Admins must use their work email. */
  WorkEmailRequired = 'WORK_EMAIL_REQUIRED'
}

/** The required input for a UpdateUser mutation. */
export type UpdateUserInput = {
  /** If true the phone number associated with this user will be deleted. */
  deletePhoneNumber?: InputMaybe<Scalars['Boolean']>;
  /** The user's personal description. */
  description?: InputMaybe<Scalars['String']>;
  /** The user's display name. */
  displayName?: InputMaybe<Scalars['String']>;
  /** The user's personal email. */
  email?: InputMaybe<Scalars['String']>;
  /** Whether or not to send a mobile verification code if email verification is required. */
  includeVerificationCode?: InputMaybe<Scalars['Boolean']>;
  /** User id of the user being updated. */
  userID: Scalars['ID'];
};

/** The required input for a updateUserIsEmailRevertSuccess mutation. */
export type UpdateUserIsEmailRevertSuccessInput = {
  /** The show email revert success msg boolean to set onto the user. */
  isEmailRevertSuccess: Scalars['Boolean'];
  /** The ID of the user whose email revert success flag is being updated. */
  userID: Scalars['ID'];
};

/** The result of a updateUserIsEmailRevertSuccess mutation. */
export type UpdateUserIsEmailRevertSuccessPayload = {
  __typename?: 'UpdateUserIsEmailRevertSuccessPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The result of an updateUser mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** The possible error returned. */
  error?: Maybe<UpdateUserError>;
  /** The modified user. */
  user?: Maybe<User>;
};

/** An error returned from the updateUserPredictionSettings mutation. */
export type UpdateUserPredictionSettingsError = {
  __typename?: 'UpdateUserPredictionSettingsError';
  /** Code describing the error. */
  code: UpdateUserPredictionSettingsErrorCode;
};

/** Possible error codes from the updateUserPredictionSettings mutation. */
export enum UpdateUserPredictionSettingsErrorCode {
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN'
}

/**
 * Update the current authorized user's Prediction Settings.
 * All fields are nullable; only specify fields that you wish to update.
 */
export type UpdateUserPredictionSettingsInput = {
  /** Whether the user has accepted the latest Predictions Terms of Service. */
  hasAcceptedTOS?: InputMaybe<Scalars['Boolean']>;
  /** Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events. */
  isTemporaryChatBadgeEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Payload for updating a user's Prediction Settings. */
export type UpdateUserPredictionSettingsPayload = {
  __typename?: 'UpdateUserPredictionSettingsPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<UpdateUserPredictionSettingsError>;
  /** The updated settings. */
  settings?: Maybe<UserPredictionSettings>;
};

/** UpdateUserSubscriptionSettingsInput updates the users subscription settings. */
export type UpdateUserSubscriptionSettingsInput = {
  /** Whether the user only wants to receive gifts to channels they follow. */
  giftsInFollowedChannelsOnly?: InputMaybe<Scalars['Boolean']>;
  /** Whether the user wants to hide Badge Modifiers. */
  isBadgeModifierHidden?: InputMaybe<Scalars['Boolean']>;
  /** If the user wants to hide their Founder Badges. */
  isFounderBadgesHidden?: InputMaybe<Scalars['Boolean']>;
  /** Whether the user wants to show how many gifts they've purchased. */
  isGiftCountHidden?: InputMaybe<Scalars['Boolean']>;
  /** Whether the user wants to show their subscription tenure and status in the chat viewer card. */
  isSubscriptionStatusHidden?: InputMaybe<Scalars['Boolean']>;
};

/** UpdateUserSubscriptionGiftSettingsPayload returns the user's current gift settings. */
export type UpdateUserSubscriptionSettingsPayload = {
  __typename?: 'UpdateUserSubscriptionSettingsPayload';
  subscriptionSettings?: Maybe<UserSubscriptionSettings>;
};

/** Inputs to the updateUserTeamMembership mutation. */
export type UpdateUserTeamMembershipInput = {
  /**
   * Whether or not the team should be the user's primary team.
   * Note only True values are effective here. A user must always have one and only one primary team, and setting false would break that invariant.
   * Setting a team as Primary will make all of a user's other team memberships non-primary.
   */
  primary?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not the membership should reveal its revenue. */
  revenueRevealed: Scalars['Boolean'];
  /** Whether or not the membership should reveal its stats. */
  statsRevealed: Scalars['Boolean'];
  /** The team which the membership belongs to. */
  teamID: Scalars['ID'];
  /** The user whose membership is being modified. */
  userID: Scalars['ID'];
};

/** Output from the updateUserTeamMembership mutation. */
export type UpdateUserTeamMembershipPayload = {
  __typename?: 'UpdateUserTeamMembershipPayload';
  /** The user whose membership was modified. */
  user?: Maybe<User>;
};

/** Error information in the update user video shelves response. */
export type UpdateUserVideoShelvesError = {
  __typename?: 'UpdateUserVideoShelvesError';
  /** An http error code to identify the error response. */
  code: Scalars['Int'];
  /** The translated error response message for this given error. */
  message?: Maybe<Scalars['String']>;
};

/** Input information for updating a user's video shelves. Video shelves are added/removed and reordered based on the provided shelfOptions. */
export type UpdateUserVideoShelvesInput = {
  /** Channel for which to update shelves. */
  channelID: Scalars['ID'];
  /** A list of different shelf options to populate the user's video shelves. */
  shelfOptions: Array<ShelvesAvailableOptions>;
};

/** Response to a request to update a user's video shelves. */
export type UpdateUserVideoShelvesPayload = {
  __typename?: 'UpdateUserVideoShelvesPayload';
  /** The error response for this update request. */
  error?: Maybe<UpdateUserVideoShelvesError>;
  /** The list of shelves for this user. */
  shelves?: Maybe<Array<Maybe<VideoShelf>>>;
};

/** Input information for updating a resume watching entry for a specified user and video. */
export type UpdateUserViewedVideoInput = {
  /** Position for where in the video to update for the resume watching entry. */
  position: Scalars['Int'];
  /** User for which to update the resume watching entry. */
  userID: Scalars['ID'];
  /** Video for which to update the resume watching entry. */
  videoID: Scalars['ID'];
  /** Type of the video for which to update the resume watching entry. */
  videoType: VideoType;
};

/** Response to a request to update a resume watching entry for a specified user and video. */
export type UpdateUserViewedVideoPayload = {
  __typename?: 'UpdateUserViewedVideoPayload';
  /** The video returned from the request. */
  video?: Maybe<Video>;
};

export type UpdateVideoCommentInput = {
  /** ID of the comment being updated. */
  commentID: Scalars['ID'];
  /** The state of the comment. */
  state: VideoCommentState;
};

export type UpdateVideoCommentPayload = {
  __typename?: 'UpdateVideoCommentPayload';
  /** The comment that was updated. */
  comment: VideoComment;
};

/** Input information for updating a video. */
export type UpdateVideoInput = {
  /** The description of the video. */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the game presented in the video. */
  game?: InputMaybe<Scalars['String']>;
  /** The language of the video. */
  language?: InputMaybe<Scalars['String']>;
  /** Determines viewability of the video; PUBLIC or PRIVATE. */
  scope?: InputMaybe<VideoPrivacyScope>;
  /** The thumbnail URL of the video. */
  thumbnailPath?: InputMaybe<Scalars['String']>;
  /** The title of the video. */
  title?: InputMaybe<Scalars['String']>;
  /** ID of the video being updated. */
  videoID: Scalars['ID'];
};

/** Response to a request to update a video. */
export type UpdateVideoPayload = {
  __typename?: 'UpdateVideoPayload';
  /** The video with updated fields. */
  video?: Maybe<Video>;
};

/** Error that may be returned by the UpdateVideoStreamSettings mutation. */
export type UpdateVideoStreamSettingsError = {
  __typename?: 'UpdateVideoStreamSettingsError';
  /** Type of mutation error. */
  code: UpdateVideoStreamSettingsErrorCode;
};

/** UpdateVideoStreamSettingsErrorCode is the client error type that occurred during the UpdateVideoStreamSettings mutation. */
export enum UpdateVideoStreamSettingsErrorCode {
  /** The broadcaster is not found. */
  ChannelNotFound = 'CHANNEL_NOT_FOUND',
  /** Invalid argument to add an authorized user. */
  InvalidArgument = 'INVALID_ARGUMENT',
  /** Permission denied to add an authorized user. */
  PermissionDenied = 'PERMISSION_DENIED'
}

/** UpdateVideoStreamSettingsInput updates the broadcaster's stream settings such as stream delay length seconds or stream key. */
export type UpdateVideoStreamSettingsInput = {
  /** ChannelID of the broadcaster. This has to be same as authenticated user's userID. */
  channelID: Scalars['ID'];
  /** The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds. Maximum is set to 900 seconds. */
  delaySeconds?: InputMaybe<Scalars['Int']>;
  /** Whether or not a stream should be started as a low latency stream. */
  isLowLatency?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not the broadcaster prefers to archive the vod for a stream. */
  shouldArchiveVODs?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not to show the disconnect slate. */
  shouldShowDisconnectSlate?: InputMaybe<Scalars['Boolean']>;
};

/** UpdateVideoStreamSettingsPayload returns the updated video stream settings for the broadcaster. */
export type UpdateVideoStreamSettingsPayload = {
  __typename?: 'UpdateVideoStreamSettingsPayload';
  /** The updated Channel for the broadcaster. */
  channel?: Maybe<Channel>;
  /** Error code. */
  error?: Maybe<UpdateVideoStreamSettingsError>;
};

/** Error associated with mutation UpdateVideosViewability. */
export type UpdateVideosViewabilityError = {
  __typename?: 'UpdateVideosViewabilityError';
  /** Error code. */
  code: UpdateVideosViewabilityErrorCode;
};

/** Client error code. */
export enum UpdateVideosViewabilityErrorCode {
  /** The request body was invalid. */
  BadRequest = 'BAD_REQUEST',
  /** Internal error. */
  InternalError = 'INTERNAL_ERROR',
  /** Permission Denied. */
  PermissionDenied = 'PERMISSION_DENIED',
  /** Unknown error. */
  Unknown = 'UNKNOWN'
}

/** Inputs for the updating videos by id mutation. */
export type UpdateVideosViewabilityInput = {
  /** Determines viewability of the videos; PUBLIC or PRIVATE. */
  scope?: InputMaybe<VideoPrivacyScope>;
  /** The IDs of the videos to be updated. */
  videoIDs: Array<Scalars['ID']>;
};

/** The returned payload from the DeleteVideos mutation. */
export type UpdateVideosViewabilityPayload = {
  __typename?: 'UpdateVideosViewabilityPayload';
  /** The possible error returned from service. */
  error?: Maybe<UpdateVideosViewabilityError>;
};

/**
 * The change that will be applied to the user's visibility. See VisibilityInput for details on the effects of each
 * value.
 */
export type UpdateVisibilityInput = {
  visibility: VisibilityInput;
};

export type UpdateVisibilityPayload = {
  __typename?: 'UpdateVisibilityPayload';
  /** The modified user. */
  user?: Maybe<User>;
};

/** The request to the UpdateWhisperSettings mutation. */
export type UpdateWhisperSettingsInput = {
  /** Whether to disallow strangers from iniating a whisper thread to this user. */
  isBlockingWhispersFromStrangers?: InputMaybe<Scalars['Boolean']>;
};

/** The response from the UpdateWhisperSettings mutation. */
export type UpdateWhisperSettingsPayload = {
  __typename?: 'UpdateWhisperSettingsPayload';
  /** The user whose whisper settings were updated. */
  user?: Maybe<User>;
};

export type UpdateWhisperThreadInput = {
  /** Whether to archive the room. */
  isArchived?: InputMaybe<Scalars['Boolean']>;
  /** Whether to mute the room. */
  isMuted?: InputMaybe<Scalars['Boolean']>;
  /** Whether to mark the message as spam. */
  isSpam?: InputMaybe<Scalars['Boolean']>;
  /** ID of last message read by the user. */
  lastReadMessageID?: InputMaybe<Scalars['ID']>;
  /** Whether to revoke temporary send Whisper permission from the other user. */
  removeWhitelist?: InputMaybe<Scalars['Boolean']>;
  /** ID of thread to be marked as read. */
  threadID: Scalars['ID'];
};

export type UpdateWhisperThreadPayload = {
  __typename?: 'UpdateWhisperThreadPayload';
  /** Thread that was updated. */
  thread: WhisperThread;
};

/** Generates an image URL to upload to. */
export type UploadCompetitionImageInput = {
  /** Unique Competition ID. */
  competitionID: Scalars['ID'];
  /** Type of image being uploaded. */
  imageType: CompetitionImageType;
};

/** Data required to upload an image to the competition. */
export type UploadCompetitionImagePayload = {
  __typename?: 'UploadCompetitionImagePayload';
  /** Used for upload competition image errors. */
  error?: Maybe<CompetitionUploadImageError>;
  /** The metadata required to access an image for a competition. */
  image?: Maybe<CompetitionImageUpload>;
};

/** Individual upload config. */
export type UploadConfig = {
  __typename?: 'UploadConfig';
  /** Upload id used when listening to pubsub. */
  ID: Scalars['ID'];
  /** URL to upload images to. */
  URL: Scalars['String'];
  /** The type of asset of the emote image that should be uploaded. */
  assetType: EmoteAssetType;
  /** Images that will result out of the upload. */
  images: Array<UploadImage>;
  /** Size of the image that should be uploaded. */
  size: EmoteImageSize;
};

export type UploadImage = {
  __typename?: 'UploadImage';
  /** Image ID generated by Mako for image. */
  ID: Scalars['ID'];
  /** Size of the image. */
  Size: EmoteImageSize;
  /** The asset type of the image. */
  assetType: EmoteAssetType;
};

/** UseChatNotificationTokenInput is the input required for the UseChatNotificationToken mutation. */
export type UseChatNotificationTokenInput = {
  /** The channel that this token will be used on. */
  channelLogin: Scalars['String'];
  /** Whether or not to include user's streak tenure. */
  includeStreak: Scalars['Boolean'];
  /** An optional message that will be displayed when this chat token is used. */
  message?: InputMaybe<Scalars['String']>;
  /** An optional ID of token to be used. */
  tokenID?: InputMaybe<Scalars['ID']>;
};

/** UseChatNotificationTokenPayload is the return of the UseChatNotificationToken mutation. */
export type UseChatNotificationTokenPayload = {
  __typename?: 'UseChatNotificationTokenPayload';
  /** If the token was successfully used. */
  isSuccess: Scalars['Boolean'];
};

/** Twitch user. */
export type User = {
  __typename?: 'User';
  /** Information about a user's connected accounts. */
  accountConnections: AccountConnectionSet;
  /** Information about a user's account health status. */
  accountHealth?: Maybe<UserAccountHealth>;
  /**
   * Fetch active challenges for the user based on a variety of sorting options.
   * By default returns 10 challenges, sorted by start time.
   */
  activeChallenges?: Maybe<ChannelChallengeConnection>;
  /**
   * An action that a user or session is performing. This field is null if the user is not friends with
   * the authenticated user.
   */
  activity?: Maybe<Activity>;
  /** Ad Properties for the given user. */
  adProperties?: Maybe<AdProperties>;
  /**
   * The user's relationship with Amazon.
   * @deprecated Retail sales discontinued
   */
  amazon?: Maybe<UserAmazonConnection>;
  /** List of authenticated Twitch sessions. */
  authenticatedSessionList?: Maybe<Array<AuthenticatedSession>>;
  /**
   * AutoModProperties is a mapping of automod categories to levels, i.e. a user has indicated they want level 4, or
   * the highest level of moderation for profanity, but level 1 for everything else. (These are based on Sift levels, and will be deprecated).
   */
  autoModProperties?: Maybe<AutoModProperties>;
  /**
   * A user's configured auto refill information, contains all auto refill profiles.
   * Will have an optional filter argument in the future.
   */
  autoRefill?: Maybe<AutoRefill>;
  /**
   * The list of channels that this user has configured to automatically host
   * when their channel is not streaming live. Users can only view their own
   * autohost channels.
   */
  autohostChannels?: Maybe<AutohostChannelConnection>;
  /**
   * Options and preferences for autohost behavior, including whether
   * autohosting is enabled at all and how to choose which channel to host.
   * Users can only view their own autohost settings.
   */
  autohostSettings?: Maybe<AutohostSettings>;
  /**
   * The list of channels that have added this user as a channel to automatically host when their channel is not
   * streaming live. Users can only view their own autohosted by channels.
   */
  autohostedByChannels?: Maybe<AutohostedByChannelConnection>;
  /**
   * An action that a user or session is performing. This field is null if the user is not friends with
   * the authenticated user.
   */
  availability?: Maybe<Availability>;
  /**
   * The badges which are available for the authenticated user to select for use on another user's streams and videos if no channel-specific preference is set.
   * If no domain is not specified, all emote sets will be returned.
   * This is only returned if the request is authenticated by the same user whose email is requested.
   */
  availableBadges?: Maybe<Array<Maybe<Badge>>>;
  /**
   * A list of this user's balances in FIAT currencies
   * If this isn't the `currentUser` this will return null.
   * @deprecated Use walletBalances
   */
  balances?: Maybe<Array<Maybe<Balance>>>;
  /**
   * A list of this user's banned users.
   * A maximum of 100 users by most recent are returned
   * Only resolves for the authenticated user.
   */
  bannedUsers?: Maybe<Array<ChannelBannedUser>>;
  /** A URL to the user's banner image. */
  bannerImageURL?: Maybe<Scalars['String']>;
  /**
   * bitsBalance is the number of bits this user currently has available to spend.
   * If this isn't the `currentUser` or the user has been banned from using bits this will return null.
   * This field can only be requested if an OAuth token is supplied with the request.
   */
  bitsBalance?: Maybe<Scalars['Int']>;
  /**
   * bitsEvents returns a paginated list of this user's bits usage transactions
   * If this isn't the `currentUser` this will return null.
   * This field can only be requested if an OAuth token is supplied with the request.
   */
  bitsEvents?: Maybe<BitsEventConnection>;
  /**
   * bitsOffers is a list of the ways this user can obtain more bits.
   * If this isn't the `currentUser` or the user has been banned from using bits this will return null.
   * This field can only be requested if an OAuth token is supplied with the request.
   */
  bitsOffers?: Maybe<Array<Maybe<BitsOffer>>>;
  /** BitsPaymentMethods has a list of eligible payment methods for a user to transact with. */
  bitsPaymentMethods?: Maybe<BitsPaymentMethods>;
  /**
   * BitsProductEligibility checks for a given user if they are eligible to purchase a given product from the associated
   * provider, quantity, and locale.
   * bitsProduct(id: ID!, provider: BitsProductProvider!, quantity: Int!, locale: String!): BitsProductEligibility!
   * bitsProducts is a list of bits products that a user is able to purchase.
   * Unlike bitsOffers, this does not return any pricing information, only information
   * about the purchasable. A provider must be supplied, which is the payment platform
   * being currently used. An optional list of SKUs can be provided if we are looking up
   * a specific set of products for a user.
   */
  bitsProducts?: Maybe<Array<BitsProduct>>;
  /** Settings tied to a bits user. */
  bitsUserSettings?: Maybe<BitsUserSettings>;
  /**
   * bitsUserState dictates the state of the Bits user (new to Bits, existing Bits user, etc.)
   * If this isn't the `currentUser` or the user has been banned from using bits this will return null.
   * This field can only be requested if an OAuth token is supplied with the request.
   */
  bitsUserState?: Maybe<BitsUserState>;
  /** Resolves account information that Twitch has stored for a user's blizzard account information. */
  blizzardAccount?: Maybe<BlizzardUser>;
  /** Get the blocked terms of a user. */
  blockedTerms: Array<ChannelBlockedTerm>;
  /** blockedUsers returns a list users that are restrained from directly communicating with this user. */
  blockedUsers: Array<Maybe<User>>;
  /**
   * bounties is a list of bounty board bounties for this user.
   * @deprecated Use user.bountiesPage instead
   */
  bounties?: Maybe<Array<Bounty>>;
  /** bountiesPage is a paginated list of bounty board bounties for this user. */
  bountiesPage?: Maybe<BountyConnection>;
  /** bountyBoardSettings are settings and rules around the behavior of bounty boards for this user. */
  bountyBoardSettings?: Maybe<BountyBoardSettings>;
  /** Badges that are displayed in chat during this user's broacasts or videos. */
  broadcastBadges?: Maybe<Array<Maybe<Badge>>>;
  /** A User's broadcast settings that persists between streams. */
  broadcastSettings?: Maybe<BroadcastSettings>;
  /**
   * A User's campaign for their channel.
   * @deprecated campaign events have been deprecated
   */
  campaign?: Maybe<Campaign>;
  /**
   * A User's campaign properties for their channel.
   * @deprecated campaign events have been deprecated
   */
  campaignProperties?: Maybe<CampaignProperties>;
  /** A container for celebration settings for the logged in user. */
  celebrationSettings?: Maybe<CelebrationUserSettings>;
  /**
   * The channel which belongs to the user. This is still deprecated for previous uses.
   * This should only be used for the multi-view experience.
   */
  channel?: Maybe<Channel>;
  /** What other similar content are my viewers watching. */
  channelAnalyticsContentOverlap?: Maybe<ChannelAnalyticsContentOverlap>;
  /**
   * A user's channel feed.
   * No authorization required.  Returns even if channel feed is disabled in the UI.
   */
  channelFeed?: Maybe<Feed>;
  /**
   * Returns the list of chatrooms in the channel visible by the current user.
   * @deprecated The Rooms product has been sunset
   */
  channelRooms: Array<Maybe<Room>>;
  /** Hex color of the user's name in chat, e.g. "#ccaa44". */
  chatColor?: Maybe<Scalars['String']>;
  /** chatSettings are settings and rules for chatting in this user's channel. */
  chatSettings?: Maybe<ChatSettings>;
  /** chatUISettings are settings for the user's chat UI. */
  chatUISettings?: Maybe<ChatUiSettings>;
  /**
   * cheer is the channel-specific cheer settings and current state.
   * Returns null if cheering isn't enabled for this channel.
   */
  cheer?: Maybe<CheerInfo>;
  /** The list of OAuth clients authorized by the current user. */
  clientAuthorizations?: Maybe<Array<ClientAuthorization>>;
  /**
   * A paginated list of clips featuring this user.
   * When criteria is not specified, the default values are used.
   */
  clips?: Maybe<ClipConnection>;
  /** A paginated list of collections (playlists) created by the user. */
  collections?: Maybe<CollectionsConnection>;
  /** Properties relating to the authenticated user's community points on twitch. */
  communityPoints?: Maybe<CommunityPointsUserProperties>;
  /**
   * The company that the user belongs to.
   * Returns null if the user doesn't belong to a company.
   * @deprecated Use organizations instead.
   */
  company?: Maybe<Company>;
  /**
   * The competitions that a user is involved in.
   * Returns null if the user doesn't have any competitions.
   * user and competition state can be null.
   */
  competitions?: Maybe<CompetitionConnection>;
  /** When the user created their account. */
  createdAt: Scalars['Time'];
  /**
   * The container for creator gifts the creator has. This will be null if the creator
   * does not have this feature enabled.
   */
  creatorGifting?: Maybe<CreatorGifting>;
  /** Creator metrics for the given time period. */
  creatorMetricsByInterval?: Maybe<CreatorMetricsByInterval>;
  /** Get the user's referral links sorted by most recently created first. Will be a null CreatorReferralLinkConnection if the user is not eligible. */
  creatorReferralLinks?: Maybe<CreatorReferralLinkConnection>;
  /** Get the user's creator referral link statistics summary. */
  creatorReferralSummary: CreatorReferralSummary;
  /**
   * Paginated past activities for the Dashboard Activity Feed.
   * Always ordered by descending timestamp.
   */
  dashboardActivityFeedActivities?: Maybe<DashboardActivityFeedActivityConnection>;
  /**
   * Paginated past activities for the Dashboard Alert Queue.
   * Always ordered by descending timestamp.
   */
  dashboardAlertQueueActivities?: Maybe<DashboardAlertQueueActivityConnection>;
  /** Preferences that control what alerts are sent to the user for the Dashboard Alert Queue. */
  dashboardAlertQueuePreferences?: Maybe<DashboardAlertQueuePreferences>;
  /** Timestamp when a user's account was deleted/disabled. */
  deletedAt?: Maybe<Scalars['Time']>;
  /**
   * A user-provided blurb describing themselves.
   * Returns null when a description has not been set.
   */
  description?: Maybe<Scalars['String']>;
  /** The directories the user is currently set to broadcast in. */
  directories?: Maybe<UserDirectoryConnection>;
  /**
   * Lists the chat badges that should be displayed by the user's display name in
   * features like chat and whispers. If a channelID is passed in, fetches the
   * display badges that user will have in that channel's context.
   * Includes the following badges:
   * - global authority (staff/admin/global mod)
   * - channel authority (broadcaster/mod, if channelID is set)
   * - subscriber (if channelID is set)
   * - channel selected (bits) or global selected (prime, turbo, ...).
   */
  displayBadges: Array<Maybe<Badge>>;
  /**
   * A user-styled version of their login.
   * For international users, this could be the user's login with localized characters.
   */
  displayName: Scalars['String'];
  /** Number of DMCA violations user has received. */
  dmcaViolationCount?: Maybe<Scalars['Int']>;
  /** A drop 2.0 campaign including personal settings (e.g. account connection status). (Viewer dashboard individual item). */
  dropCampaign?: Maybe<DropCampaign>;
  /** A list of all available Drops 2.0 Campaigns that a user is eligible to participate in. (Viewer dashboard list). */
  dropCampaigns?: Maybe<Array<DropCampaign>>;
  /** Fetch User's current session, which describes the minutes-watched progress towards a drop. */
  dropCurrentSession?: Maybe<DropCurrentSession>;
  /** A list of channels where the user is an editor. */
  editableChannels?: Maybe<EditableChannelConnection>;
  /** A list of channel editors. */
  editors?: Maybe<EditorConnection>;
  /**
   * The user's email address.
   * This is only returned if the request is authenticated by the same user who's email is requested.
   */
  email?: Maybe<Scalars['String']>;
  /**
   * The emote sets this user is entitled to use.
   * If no domains are specified, all emote sets will be returned.
   * If multiple domains are specified, emotes that belong to either domain are returned (OR).
   * If this user is not the current user, it returns nil and a "forbidden" error.
   */
  emoteSets?: Maybe<Array<EmoteSet>>;
  /** The channel's emoticon prefix settings. */
  emoticonPrefix?: Maybe<EmoticonPrefix>;
  /** The list channels that have been endorsed by the user. */
  endorsedChannels?: Maybe<EndorsedChannelConnection>;
  /**
   * A paginated list of user's all expired subscriptions.
   * Only resolves for the current user. Returns a forbidden error if requested for another user.
   */
  expiredSubscriptions?: Maybe<ExpiredSubscriptionConnection>;
  /**
   * Feature flags specific to this user.
   * Always returns nil.
   * @deprecated this functionality has been removed
   */
  featureFlags?: Maybe<FeatureFlags>;
  /**
   * A follow relationship between this user and the one which has the target ID or login.
   * Null if no relationship exists.
   * @deprecated Use user.self.follower instead.
   */
  follow?: Maybe<Follow>;
  /** Retrieves a list of games which the user is following. */
  followedGames?: Maybe<FollowedGameConnection>;
  /**
   * A list of broadcasters this user follows, who are hosting other broadcasters.
   * Only resolves for the authenticated user.
   * @deprecated This field is intended to be replaced as soon as an alternative is available.
   */
  followedHosts?: Maybe<FollowedHostConnection>;
  /**
   * A list of live-streaming broadcasters this user is following.
   * Only resolves for the authenticated user.
   * NOTE: the sort input parameter is not supported and should not be used.
   * @deprecated This field is intended to be replaced as soon as an alternative is available.
   */
  followedLiveUsers?: Maybe<FollowedLiveUserConnection>;
  /**
   * Retrieves recent/popular VODs from the streamers you follow.
   * If this isn't the `currentUser` this will return null.
   */
  followedVideos?: Maybe<VideoConnection>;
  /** A paginated list of users which follow this user. */
  followers?: Maybe<FollowerConnection>;
  /** A paginated list of users this user is following. */
  follows?: Maybe<FollowConnection>;
  /**
   * A list of this user's Twitch friends.
   * A maximum of 500 friends are returned, although most users have less than the maximum.
   * Only accessible if the user is authenticated with the `user_presence_friends_read` scope.
   */
  friends?: Maybe<FriendConnection>;
  /** Notification connection information for a time range. */
  goLiveNotificationConnection?: Maybe<GoLiveNotificationConnection>;
  /** Notification information for a time range. */
  goLiveNotifications?: Maybe<Array<GoLiveNotification>>;
  /** Notifications timeseries analytics for a time range. */
  goLiveNotificationsTimeseries?: Maybe<Array<GoLiveNotificationTimeseries>>;
  /**
   * Always returns false, will be deleted soon.
   * @deprecated this functionality has been removed
   */
  hasBadgesTimedOut: Scalars['Boolean'];
  /** Whether this user has Twitch Presto. */
  hasPresto?: Maybe<Scalars['Boolean']>;
  /** Whether this user has Twitch Prime. */
  hasPrime: Scalars['Boolean'];
  /** Whether this user has streamed before. */
  hasStreamed?: Maybe<Scalars['Boolean']>;
  /** Whether this user has Twitch Turbo. */
  hasTurbo: Scalars['Boolean'];
  /** Whether this user has unread creator changelog items. */
  hasUnreadChangelogItems?: Maybe<Scalars['Boolean']>;
  /** This user's Hero configuration. */
  hero?: Maybe<Hero>;
  /** A curated list of suggested channels to host. */
  hostRecommendations?: Maybe<Array<Maybe<User>>>;
  /**
   * The users hosting this user.
   * This field only resolves for the authenticated user, otherwise resolves to null.
   */
  hostedBy?: Maybe<HostConnection>;
  /** The user who this user is hosting. */
  hosting?: Maybe<User>;
  /** The user's unique identifier. */
  id: Scalars['ID'];
  /** Returns a SHA-1 hash of the id field. */
  idSHA1: Scalars['ID'];
  /**
   * A list of open friend requests sent to this user. Friend requests from non-strangers are always placed in front of
   * friend requests from strangers; `sort` affects how the two components are ordered within themselves. Only accessible
   * if the user is authenticated with the `user_presence_friends_read` scope.
   */
  incomingFriendRequests?: Maybe<IncomingFriendRequestConnection>;
  /**
   * A list of the squad stream invitations that the user has received.
   * Each invitation has a network type of either in-network or out-of-network. The invitations are sorted by creation
   * time, with the latest invitation first.
   * This field only resolves for the authenticated user.
   */
  incomingSquadStreamInvitations?: Maybe<SquadStreamInvitationConnection>;
  /**
   * The list of extensions the user has installed.
   * installedExtensions gives a set of Extension installations, but does not include some of the information required
   * to render extensions.  For this, use extensionsForChannel instead, where you will get more accurate response, and
   * which includes fetched extension configuration and extension permissions.
   */
  installedExtensions?: Maybe<Array<ExtensionInstallation>>;
  /** Items (crates, drops, etc.) the user owns. */
  inventory?: Maybe<Inventory>;
  /**
   * A list of teams that the user has been invited to.
   * Only resolves for the current user.
   */
  invitedTeams?: Maybe<Array<Maybe<Team>>>;
  /**
   * Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
   * @deprecated Game sales discontinued
   */
  isCommerceRevShareEnabled: Scalars['Boolean'];
  /**
   * Whether the user's Twitch account is connected to a Twitter account.
   * Returns nil if there was an error. This field is only accessible on the current user.
   */
  isConnectedToTwitter?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has enabled their email to be reused to create another twitch account. */
  isEmailReusable: Scalars['Boolean'];
  /** Whether or not the user can update their email. */
  isEmailUpdateable: Scalars['Boolean'];
  /** Whether or not the user has verified their email address by clicking a link sent to their email. */
  isEmailVerified: Scalars['Boolean'];
  /**
   * Indicates that the owner of the email on the account did not signup for this account
   * This mainly implies that the account is being deleted and not eligible for self service reactivation.
   */
  isFlaggedToDelete: Scalars['Boolean'];
  /**
   * Whether or not the user can moderate any broadcast chat.
   * @deprecated Use user.roles.isGlobalMod instead.
   */
  isGlobalMod: Scalars['Boolean'];
  /**
   * Whether or not the user is in good standing, granting automatic emote approval.
   * Passes both the authed twitch user who is requesting and the user they are requesting.
   * Applies to both affiliates and partners.
   */
  isInEmoteGoodStanding?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the user is in good standing generally.
   * Authenticated to current user. Will error if not a partner.
   */
  isInGoodStanding: Scalars['Boolean'];
  /** Whether the user meets the GDPR compliance as per his/her country's minimum compliance age. */
  isMinimumGDPRConsentAge: Scalars['Boolean'];
  /** Whether or not the user is moderator of a another user's channel. */
  isModerator: Scalars['Boolean'];
  /**
   * Whether or not the user is a partnered broadcaster with Twitch.
   * @deprecated Use user.roles.isPartner instead.
   */
  isPartner?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the user has verified their phone number.
   * This is currently always true if the user has a phone number.
   * We do not not allow a user to set a phone number without verifying.
   */
  isPhoneNumberVerified: Scalars['Boolean'];
  /**
   * Whether or not the user is a site admininistrator.
   * @deprecated Use user.roles.isSiteAdmin instead.
   */
  isSiteAdmin: Scalars['Boolean'];
  /**
   * Whether or not the user is a Twitch staff member.
   * @deprecated Use user.roles.isStaff instead.
   */
  isStaff: Scalars['Boolean'];
  /** The key pools associated with a user. */
  keyPools?: Maybe<KeyPoolConnection>;
  /**
   * The user's language preference.
   * @deprecated Use user.settings.preferredLanguageTag instead.
   */
  language?: Maybe<Language>;
  /** The user's last broadcast. */
  lastBroadcast?: Maybe<Broadcast>;
  /**
   * When the user last updated their login name.
   * This special field only resolves for the authenticated user.
   */
  lastLoginChangeAt?: Maybe<Scalars['Time']>;
  /**
   * The last time the user's availability or activity changed.
   * This special field only resolves for the authenticated user; use friends.edges.lastStatusChangeAt to retrieve this
   * information about friends..
   * Requires the `user_presence_friends_read` scope.
   */
  lastStatusChangeAt?: Maybe<Scalars['Time']>;
  /** Fetches the latest created Poll for the user. */
  latestPoll?: Maybe<Poll>;
  /** The extensions this user has shared their identity with. */
  linkedExtensions?: Maybe<Array<Extension>>;
  /** The user's standard alphanumeric Twitch name. */
  login: Scalars['String'];
  /**
   * The user's profile image.
   * Valid widths are 28, 50, 70, 150, 300, and 600.
   * The image height will be the same as the given width.
   * @deprecated Replaced by profileImageURL
   */
  logoURL?: Maybe<Scalars['String']>;
  /** Lists a User's Uploaded Loyalty Badge. */
  loyaltyBadges?: Maybe<Array<LoyaltyBadge>>;
  /**
   * Returns the max number of channel rooms that the current user is allowed to
   * create for their channel.
   * @deprecated The Rooms product has been sunset
   */
  maxAllowedChannelRooms: Scalars['Int'];
  /** Returns a resolver to query different subsets of the moderation logs. */
  modLogs?: Maybe<ModLogs>;
  /** Returns all channel roles' access permissions to moderator logs. */
  modLogsAccess?: Maybe<Array<ModLogsAccess>>;
  /** Returns a channel role's access permission to moderator logs. */
  modLogsRoleAccess?: Maybe<ModLogsAccess>;
  /** A user's settings related to the moderation view page. */
  modViewSettings?: Maybe<ModViewSettings>;
  /** Returns a paginated list of channel moderators. */
  mods?: Maybe<ModConnection>;
  /** A user's event notification settings. */
  notificationSettings?: Maybe<Array<EventNotificationSetting>>;
  /**
   * A user's notifications.
   * This is only returned if the request is authenticated by the same user whose onsite notifications are requested.
   * `language` is a letter code for the language the requesting user speaks (ex. "en").
   */
  notifications?: Maybe<OnsiteNotificationConnection>;
  /** OAuth applications developed by the current user. */
  oauthApps?: Maybe<OAuthAppConnection>;
  /** A URL to the image that is displayed when the user is not broadcasting nor hosting another user's broadcast. */
  offlineImageURL?: Maybe<Scalars['String']>;
  /**
   * Information about the current user's onboarding state.
   * @deprecated This feature has been sunset.
   */
  onboarding?: Maybe<Onboarding>;
  /** List of invites to join an organization. */
  organizationInvites?: Maybe<OrganizationInviteUserConnection>;
  /**
   * Returns a list of developer organizations.
   * Returns null if the user doesn't belong to any organizations.
   */
  organizations?: Maybe<Array<Organization>>;
  /**
   * A list of open friend requests sent by this user. Friend requests to non-strangers are always placed in front of
   * friend requests to strangers; `sort` affects how the two components are ordered within themselves. Only accessible
   * if the user is authenticated with the `user_presence_friends_read` scope.
   */
  outgoingFriendRequests?: Maybe<OutgoingFriendRequestConnection>;
  /**
   * A list of teams owned by the user.
   * Only resolves for the current user.
   */
  ownedTeams?: Maybe<Array<Maybe<Team>>>;
  /** panels is a list of `Panel` objects with information related to this channel. */
  panels: Array<Maybe<Panel>>;
  /**
   * Fetch participating challenges for the user based on a variety of sorting options.
   * By default returns 10 challenges, sorted by end time.
   */
  participatingChallenges?: Maybe<ChannelChallengeConnection>;
  /**
   * Non-partnered users can submit a partnership application via createPartnershipApplication mutation.
   * PartnershipApplication includes the status of the most recently submitted application.
   */
  partnershipApplication?: Maybe<PartnershipApplication>;
  /** Whether or not the user is able to be paid. */
  payableStatus?: Maybe<PayableStatus>;
  /**
   * Metrics that are relevant to incentive-based contracts for some partnered
   * streamers. This API returns a year-to-date, rolling list of the past 12
   * months and includes the current (in-progress) month.
   */
  paymentIncentiveMetrics?: Maybe<Array<PaymentIncentiveMetricsRollup>>;
  /**
   * Holds configuration necessary to start payment method management. Only the authenticated user can access their own configs.
   * This is the second step of the payment method management flow.
   * (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
   */
  paymentMethodConfigs?: Maybe<PaymentProviderConfigs>;
  /**
   * List of payment methods that will be used to pay for Twitch subscriptions that renew in the future
   * This is the first step of the payment method management flow.
   * (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
   */
  paymentMethods?: Maybe<Array<PaymentMethod>>;
  /**
   * Get user's list of payment transactions. This currently aggregates subscriptions related transactions but plans
   * to also aggregate other product types such as Bits. The ultimate goal is to record, aggregate, and provide the
   * payment history of Twitch users in a convenient way.
   */
  paymentTransactions?: Maybe<PaymentTransactionConnection>;
  /** Payout Information. */
  payout?: Maybe<Payout>;
  /** Accrued balance since last payout. */
  payoutBalance?: Maybe<PayoutBalance>;
  /** A user's invite into a payout program. */
  payoutInvite?: Maybe<PayoutInvite>;
  /** List of payout plans a user has when enrolled in any payout programs. */
  payoutPlans?: Maybe<Array<PayoutPlan>>;
  /** Get the permitted terms of a user. */
  permittedTerms: Array<ChannelPermittedTerm>;
  /**
   * The user's phone number. Format is always in E.164 format.
   * This is only returned if the request is authenticated by the same user whose phone is requested.
   */
  phoneNumber?: Maybe<Scalars['String']>;
  /**
   * Fetch polls for the user based on a variety of sorting options.
   * By default returns 15 polls, sorted by start time.
   */
  polls?: Maybe<PollConnection>;
  /**
   * Options and preferences for how the user participates in Predictions Events.
   * Users can only view their own Predictions Settings.
   */
  predictionsSettings?: Maybe<UserPredictionSettings>;
  /** The amount of preroll free time in seconds that a user has earned on their channel. */
  prerollFreeTimeSeconds?: Maybe<Scalars['Int']>;
  /**
   * The hex string for the user's primary creator color.
   * Example: "FFFFFF".
   */
  primaryColorHex?: Maybe<Scalars['String']>;
  /**
   * The primary team this user belongs to. A user may belong to more than one team at the same time but must select a single
   * team as the primary. If the user doesn't have a primary team this will be null.
   */
  primaryTeam?: Maybe<Team>;
  /**
   * Always returns null, will be removed soon.
   * @deprecated Use primePayoutHistory, this will be removed soon
   */
  primePayoutDetails?: Maybe<PrimePayoutDetails>;
  /** The prime payout details over a period of time for the user. */
  primePayoutHistory?: Maybe<Array<PrimePayoutDetail>>;
  /** The Twitch Prime settings data for the user. */
  primeSettings?: Maybe<PrimeSettings>;
  /**
   * A URL to the user's profile image.
   * Valid widths are 28, 50, 70, 96, 150, 300, and 600.
   * The image height will be the same as the given width.
   */
  profileImageURL?: Maybe<Scalars['String']>;
  /**
   * The URL to viewing this user's profile.
   * This is typically https://twitch.tv/<login> .
   */
  profileURL: Scalars['String'];
  /** The number of views this user's profile has received since creation. */
  profileViewCount?: Maybe<Scalars['Int']>;
  /** The program agreement for a user enrolled in a payout program. */
  programAgreement?: Maybe<ProgramAgreement>;
  /**
   * A user's pulse feed.
   * This is only returned if the request is authenticated by the same user whose email is requested.
   */
  pulseFeed?: Maybe<Feed>;
  /** PurchaseOrder returns a user's purchase order. */
  purchaseOrder?: Maybe<PurchaseOrder>;
  /** Quests associated with a user. */
  quests?: Maybe<Quests>;
  /** Twitch Radio for the user. */
  radio?: Maybe<Radio>;
  /**
   * Twitch Radio account information.
   * @deprecated Use user.radio.account instead.
   */
  radioAccount?: Maybe<RadioAccount>;
  /**
   * Always returns null.
   * @deprecated this feature has been moved
   */
  raid?: Maybe<Raid>;
  /**
   * Preferences for raid behavior, including whether
   * raids are enabled and from whom can raids orignate.
   * Users can only view their own raid settings.
   */
  raidSettings?: Maybe<RaidSettings>;
  /** An array of recent raids by the broadcaster. */
  recentRaids?: Maybe<Array<Raid>>;
  /** The feedback a user has given about recommended content. */
  recommendationFeedback?: Maybe<RecommendationFeedbackConnection>;
  /**
   * Recommendations for the user. Recommendations can be retrieved only if the request
   * is authenticated and only for the authenticated user.
   */
  recommendations?: Maybe<Recommendations>;
  /** The recommended prefix which is generated based on user name. */
  recommendedEmoticonPrefix: Scalars['String'];
  /** This user's relationship with another user. */
  relationship?: Maybe<UserRelationship>;
  /** User's declared country of residence. */
  residence?: Maybe<UserResidence>;
  /** Info on rewarded video for a user (eligibility). */
  rewardedVideo?: Maybe<RewardedVideo>;
  /** The roles this user fulfills on Twitch. */
  roles?: Maybe<UserRoles>;
  /** Search through a paginated list of public and private videos for this user. */
  searchVideos?: Maybe<VideoConnection>;
  /** A list of streamer onboarding content IDs that that the user has been shown, and when it was first shown. */
  seenCreatorOnboardingContent?: Maybe<Array<CreatorOnboardingContent>>;
  /** The badge this user has selected for global use on Twitch. */
  selectedBadge?: Maybe<Badge>;
  /** The authenticated user's relationship with this user. */
  self?: Maybe<UserSelfConnection>;
  /**
   * Loads the extension installation data for the queried userID's channel that is relevant to the calling user.
   * This includes the extension configuration data & auth tokens for the extension-channel-user combination.
   */
  selfInstalledExtensions?: Maybe<Array<ExtensionInstallationSelfEdge>>;
  /** The settings this user has on Twitch. */
  settings?: Maybe<UserSettings>;
  /**
   * The squad stream that this user is currently a member of, or null if the user is not a member of
   * any squad stream.
   */
  squadStream?: Maybe<SquadStream>;
  /**
   * squadStreamSettings are the user's rules and settings for the squad stream feature.
   * Some fields only resolve for the authenticated user. See schema definition for more detail.
   */
  squadStreamSettings?: Maybe<SquadStreamSettings>;
  /**
   * The relationship between the authenticated user and the single sign-on (SSO) apps they have linked to their Twitch account.
   * @deprecated Service has been shut down
   */
  ssoLinks?: Maybe<Array<SsoLink>>;
  /**
   * The user's live stream.
   * Null if the user is not currently broadcasting.
   */
  stream?: Maybe<Stream>;
  /** A list of the start and end times of stream sessions. */
  streamSessions?: Maybe<Array<StreamSession>>;
  /** A list stream sessions that started and ended during the specified interval. */
  streamSessionsByInterval?: Maybe<Array<StreamSession>>;
  /**
   * A list of stream summaries. Stream summaries provide analytics information
   * for a streaming session. Last started time is for querying sessions from a previous time stamp.
   */
  streamSummaries?: Maybe<Array<StreamSummary>>;
  /** Stucco packs displayed in the user's dashboard stucco settings. */
  stuccoPacksBroadcaster?: Maybe<Array<Maybe<StuccoPack>>>;
  /** stuccos available in the library in the user's dashboard stucco settings. */
  stuccos?: Maybe<Array<Maybe<Stucco>>>;
  /**
   * A list of channels to which the user is subscribed.
   * Only resolves for the authenticated user.
   */
  subscribedChannels?: Maybe<SubscribedChannelConnection>;
  /**
   * The subscription score of the user. Returns both a breakdown of subscriptions and points by tier.
   * Authenticated to the current user. Will be nil if the user is not a partner or affiliate.
   */
  subscriberScore?: Maybe<SubscriberScore>;
  /**
   * A paginated list of user's all active subscriptions.
   * Only resolves for the current user. Returns a forbidden error if requested for another user.
   */
  subscriptionBenefits?: Maybe<SubscriptionBenefitConnection>;
  /** A list of subscription products available for purchase on the user's page. */
  subscriptionProducts?: Maybe<Array<Maybe<SubscriptionProduct>>>;
  /** A list of subscription products available for purchase on the user's page, including handleable errors. */
  subscriptionProductsResult: SubscriptionProductsResult;
  /**
   * Subscription preferences for the current user.
   * Only resolves for the current user. Returns an error if request for another user.
   */
  subscriptionSettings?: Maybe<UserSubscriptionSettings>;
  /**
   * Subtoken information associated with the user.
   * Includes balance of tokens which can be used to redeem Subscriptions.
   */
  subscriptionToken?: Maybe<SubscriptionToken>;
  /** Analytics of the frequency of tags used in discovery. */
  tagAnalytics?: Maybe<Array<TagAnalytic>>;
  /**
   * Tags are used as a discovery and search mechanism for channels.
   * The tag data is from Graffiti directly. Graffiti is not designed to handle huge traffic.
   * Please use Stream.tags instead if know the stream is live and you can accept a 5 min delay in the data.
   * For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
   */
  tags?: Maybe<Array<Tag>>;
  /**
   * A list of UserTeamMemberships which includes all the teams the user is a member of.
   * This includes the primary team.
   * Only resolves for the current user.
   */
  teamMemberships?: Maybe<Array<Maybe<UserTeamMembership>>>;
  /**
   * Retrieves all the statistics within the start and end time broken down by granularity.
   * Default endAt time will be the current time (now).
   * Granularity defaults to 5 minutes.
   */
  timeseriesStats?: Maybe<TimeseriesStats>;
  /**
   * Tournament associated with the user. This is used with the Bits custom cheering experience.
   * @deprecated No longer supported
   */
  tournament?: Maybe<Tournament>;
  /** The user's relationship with Twitch. */
  twitch?: Maybe<UserTwitchConnection>;
  /** Get unacknowledged subscription events. */
  unacknowledgedSubscriptionEvents?: Maybe<Array<UnacknowledgedSubscriptionEvent>>;
  /**
   * When the user last updated their account.
   * Returns null when the user's account has never been updated.
   */
  updatedAt?: Maybe<Scalars['Time']>;
  /**
   * Verification request object for the user and an associated contact address.
   * If no address is provided, the current email address associated with the user account will be used.
   */
  verificationRequest?: Maybe<VerificationRequest>;
  /** Aggregated analytics for several video referral sources, for use in channel analytics. */
  videoPlayReferrals?: Maybe<VideoPlayReferrals>;
  /** A paginated list of video shelves to display on the user's channel. */
  videoShelves?: Maybe<VideoShelfConnection>;
  /**
   * A paginated list of video shelves that are available to be displayed on the
   * user's channel. Only accessible for authorized users (user & editors).
   */
  videoShelvesAvailable?: Maybe<VideoShelfConnection>;
  /** A paginated list of videos for this user. */
  videos?: Maybe<VideoConnection>;
  /**
   * The viewable poll for a channel.
   * Null if no viewable poll is present.
   */
  viewablePoll?: Maybe<Poll>;
  /**
   * A paginated list of viewed videos and their histories for this user.
   * Only resolves for current user.
   */
  viewedVideos?: Maybe<ViewedVideosConnection>;
  /** A paginated list of channel VIPs. */
  vips?: Maybe<VipConnection>;
  /**
   * A user's balances in their Twitch Wallet in different FIAT currencies
   * If this isn't the `currentUser` this will return null.
   */
  walletBalances?: Maybe<WalletBalances>;
  /**
   * A list of restrictions that prevent a user from hosting Watch Parties. A
   * user can only host Watch Parties if there are no restrictions.
   */
  watchPartiesRestrictions?: Maybe<Array<WatchPartiesRestriction>>;
  /** A Watch Party if the User is currently broadcasting one. */
  watchParty?: Maybe<WatchPartyResult>;
  /**
   * Settings related to the Whispers (private user-to-user messaging) feature.
   * Only resolves for the authenticated user.
   */
  whisperSettings?: Maybe<WhisperSettings>;
  /** A paginated list of whisper threads for the current user, sorted by recent first. */
  whisperThreads?: Maybe<WhisperThreadConnection>;
  /** Withholding Tax Detail is the withholding tax rates for the creator. */
  withholdingTaxDetail?: Maybe<WithholdingTaxDetail>;
};


/** Twitch user. */
export type UserActiveChallengesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  direction?: InputMaybe<SortOrder>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ChannelChallengeSort>;
};


/** Twitch user. */
export type UserAvailableBadgesArgs = {
  domains?: InputMaybe<Array<BadgeDomain>>;
};


/** Twitch user. */
export type UserBalancesArgs = {
  walletType?: InputMaybe<WalletType>;
};


/** Twitch user. */
export type UserBitsEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria: BitsEventConnectionCriteriaInput;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserBitsProductsArgs = {
  paymentProvider?: InputMaybe<PaymentProvider>;
  provider: BitsProductProvider;
  skus?: InputMaybe<Array<Scalars['String']>>;
};


/** Twitch user. */
export type UserBountiesArgs = {
  status: Scalars['String'];
};


/** Twitch user. */
export type UserBountiesPageArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  status: Scalars['String'];
};


/** Twitch user. */
export type UserCampaignArgs = {
  campaignID: Scalars['ID'];
};


/** Twitch user. */
export type UserClipsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria?: InputMaybe<UserClipsInput>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserCollectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<CollectionsOptions>;
};


/** Twitch user. */
export type UserCompetitionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  competitionState?: InputMaybe<CompetitionState>;
  first?: InputMaybe<Scalars['Int']>;
  userCompetitionRelationship: UserCompetitionRelationship;
  userState?: InputMaybe<CompetitionPlayerState>;
};


/** Twitch user. */
export type UserCreatorMetricsByIntervalArgs = {
  endAt: Scalars['Time'];
  numberOfIntervals?: InputMaybe<Scalars['Int']>;
  startAt: Scalars['Time'];
  timeZone?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserCreatorReferralLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserCreatorReferralSummaryArgs = {
  endAt: Scalars['Time'];
  startAt: Scalars['Time'];
};


/** Twitch user. */
export type UserDashboardActivityFeedActivitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserDashboardAlertQueueActivitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserDisplayBadgesArgs = {
  channelID?: InputMaybe<Scalars['ID']>;
  channelLogin?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserDropCampaignArgs = {
  id: Scalars['ID'];
};


/** Twitch user. */
export type UserEmoteSetsArgs = {
  domains?: InputMaybe<Array<EmoteSetDomain>>;
};


/** Twitch user. */
export type UserEndorsedChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  recommendationsContext: RecommendationsContext;
};


/** Twitch user. */
export type UserExpiredSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserFollowArgs = {
  targetID?: InputMaybe<Scalars['ID']>;
  targetLogin?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserFollowedGamesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<FollowedGamesType>;
};


/** Twitch user. */
export type UserFollowedHostsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserFollowedLiveUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  includeRestricted?: InputMaybe<Array<StreamRestrictionType>>;
  sort?: InputMaybe<StreamSort>;
};


/** Twitch user. */
export type UserFollowedVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  languages?: InputMaybe<Array<Scalars['String']>>;
  sort?: InputMaybe<VideoSort>;
  types?: InputMaybe<Array<BroadcastType>>;
};


/** Twitch user. */
export type UserFollowersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
};


/** Twitch user. */
export type UserFollowsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<FollowsFilter>;
  first?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
};


/** Twitch user. */
export type UserGoLiveNotificationConnectionArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  endAt: Scalars['Time'];
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<SortOrder>;
  startAt: Scalars['Time'];
};


/** Twitch user. */
export type UserGoLiveNotificationsArgs = {
  endAt: Scalars['Time'];
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<SortOrder>;
  startAt: Scalars['Time'];
};


/** Twitch user. */
export type UserGoLiveNotificationsTimeseriesArgs = {
  endAt: Scalars['Time'];
  granularity: Granularity;
  numberOfIntervals?: InputMaybe<Scalars['Int']>;
  startAt: Scalars['Time'];
  timeZone: Scalars['String'];
};


/** Twitch user. */
export type UserHostedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserIncomingFriendRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<FriendSort>;
};


/** Twitch user. */
export type UserIsModeratorArgs = {
  channelID: Scalars['String'];
};


/** Twitch user. */
export type UserKeyPoolsArgs = {
  after?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserLogoUrlArgs = {
  width: Scalars['Int'];
};


/** Twitch user. */
export type UserModLogsRoleAccessArgs = {
  role: ChannelUserRole;
};


/** Twitch user. */
export type UserModsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  capabilities?: InputMaybe<Array<OnsiteNotificationsCapability>>;
  displayType?: InputMaybe<OnsiteNotificationDisplayType>;
  first?: InputMaybe<Scalars['Int']>;
  language?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserOauthAppsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
};


/** Twitch user. */
export type UserOrganizationInvitesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserOutgoingFriendRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<FriendSort>;
};


/** Twitch user. */
export type UserPanelsArgs = {
  hideExtensions?: InputMaybe<Scalars['Boolean']>;
};


/** Twitch user. */
export type UserParticipatingChallengesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  direction?: InputMaybe<SortOrder>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ChannelChallengeSort>;
  status?: InputMaybe<Array<ChannelChallengeStatus>>;
};


/** Twitch user. */
export type UserPaymentTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria: PaymentTransactionConnectionCriteriaInput;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserPollsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  direction?: InputMaybe<SortOrder>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<PollSort>;
  status?: InputMaybe<Array<PollStatus>>;
};


/** Twitch user. */
export type UserProfileImageUrlArgs = {
  width: Scalars['Int'];
};


/** Twitch user. */
export type UserPurchaseOrderArgs = {
  id: Scalars['ID'];
};


/** Twitch user. */
export type UserRecommendationFeedbackArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['Int']>;
  type: Scalars['String'];
};


/** Twitch user. */
export type UserRelationshipArgs = {
  targetUserID?: InputMaybe<Scalars['ID']>;
};


/** Twitch user. */
export type UserSearchVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<VideoConnectionSearchParams>;
};


/** Twitch user. */
export type UserSelfInstalledExtensionsArgs = {
  isMobile?: InputMaybe<Scalars['Boolean']>;
};


/** Twitch user. */
export type UserSsoLinksArgs = {
  app?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserStreamSessionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  lastStartedAt?: InputMaybe<Scalars['Time']>;
};


/** Twitch user. */
export type UserStreamSessionsByIntervalArgs = {
  endAt: Scalars['Time'];
  startAt: Scalars['Time'];
};


/** Twitch user. */
export type UserStreamSummariesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  lastStartedAt?: InputMaybe<Scalars['Time']>;
};


/** Twitch user. */
export type UserSubscribedChannelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  live?: InputMaybe<Scalars['Boolean']>;
};


/** Twitch user. */
export type UserSubscriptionBenefitsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria: SubscriptionBenefitCriteriaInput;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserTimeseriesStatsArgs = {
  endAt?: InputMaybe<Scalars['Time']>;
  granularity?: InputMaybe<Granularity>;
  startAt: Scalars['Time'];
  timeZone: Scalars['String'];
};


/** Twitch user. */
export type UserUnacknowledgedSubscriptionEventsArgs = {
  platform: Scalars['String'];
};


/** Twitch user. */
export type UserVerificationRequestArgs = {
  address?: InputMaybe<Scalars['String']>;
};


/** Twitch user. */
export type UserVideoPlayReferralsArgs = {
  dimension: ReferralsDimension;
  end: Scalars['Time'];
  filter?: InputMaybe<ReferralsFilter>;
  first?: InputMaybe<Scalars['Int']>;
  start: Scalars['Time'];
};


/** Twitch user. */
export type UserVideoShelvesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<ShelvesOptions>;
};


/** Twitch user. */
export type UserVideoShelvesAvailableArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<ShelvesAvailableOptions>;
};


/** Twitch user. */
export type UserVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  options?: InputMaybe<VideoConnectionOptionsInput>;
  sort?: InputMaybe<VideoSort>;
  type?: InputMaybe<BroadcastType>;
  types?: InputMaybe<Array<BroadcastType>>;
};


/** Twitch user. */
export type UserViewedVideosArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserVipsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** Twitch user. */
export type UserWalletBalancesArgs = {
  bestGuessCountryCode?: InputMaybe<Scalars['String']>;
  walletType?: InputMaybe<WalletType>;
};


/** Twitch user. */
export type UserWatchPartyArgs = {
  accessToken?: InputMaybe<Scalars['String']>;
  decorated?: InputMaybe<Scalars['Boolean']>;
};


/** Twitch user. */
export type UserWhisperThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** Groups users account health information around security of their account. */
export type UserAccountHealth = {
  __typename?: 'UserAccountHealth';
  /** Is the user required to reset their password. */
  isPasswordResetRequired: Scalars['Boolean'];
  /** Is the users email address verified. */
  isVerifiedEmail: Scalars['Boolean'];
  /** Current status of the users password. */
  passwordStatus: PasswordStatus;
  /**
   * The list of Two factor Methods the user has registered with.
   * Empty list means the user does not have two factor.
   */
  twoFactorMethods: Array<TwoFactorMethod>;
};

/** The relationship between the user and Amazon. */
export type UserAmazonConnection = {
  __typename?: 'UserAmazonConnection';
  /** The Amazon associates store linked to this user. */
  associatesStore?: Maybe<AssociatesStore>;
};

/** The edge between a User and a Blizzard connection. */
export type UserBlizzardConnectionLink = {
  __typename?: 'UserBlizzardConnectionLink';
  /** Returns battletag if available. Can be string or nil. */
  battleTag?: Maybe<Scalars['String']>;
};

/** Exactly one of the identifiers must be specified. */
export type UserByAttribute = {
  /**
   * The human-readable identifier for a clip.
   * When specified, returns the broadcaster of the clip.
   */
  broadcasterOfClipSlug?: InputMaybe<Scalars['String']>;
  /** The user's login. */
  login?: InputMaybe<Scalars['String']>;
  /**
   * The identifier for a video collection.
   * When specified, returns the owner of the collection.
   */
  ownsCollectionID?: InputMaybe<Scalars['ID']>;
  /**
   * The identifier for a video.
   * When specified, returns the owner of the video.
   */
  ownsVideoID?: InputMaybe<Scalars['ID']>;
};

/** Filtering criteria for paginated user clips results. */
export type UserClipsInput = {
  /** The ID of the broadcaster to filter results by. */
  broadcasterID?: InputMaybe<Scalars['ID']>;
  /** The ID of the curator to filter results by. */
  curatorID?: InputMaybe<Scalars['ID']>;
  /**
   * DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
   * A filter which restricts results.
   */
  filter?: InputMaybe<ClipsFilter>;
  /** The name of the game to filter results by. */
  gameName?: InputMaybe<Scalars['String']>;
  /** The time period to restrict clips based on creation time. */
  period?: InputMaybe<ClipsPeriod>;
  /** The sort order for the clips results. */
  sort?: InputMaybe<ClipsSort>;
};

/** Enum that specifies which role the user is taking when querying for competitions. */
export enum UserCompetitionRelationship {
  /** Owner of a competition. */
  Owner = 'OWNER',
  /** Player in a competition. */
  Player = 'PLAYER',
  /** Unknown competition role. */
  Unknown = 'UNKNOWN'
}

/**
 * Paginated list of Users, where the relationship between the source type and the User is
 * generic enough that no information needs to be encoded on the edge.
 */
export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<UserEdge>>;
  pageInfo: PageInfo;
  /** The total number of users. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** The connection between a user and the directories they have selected to broadcast in. */
export type UserDirectoryConnection = {
  __typename?: 'UserDirectoryConnection';
  /** The directories selected by this user. */
  nodes: Array<Maybe<Directory>>;
};

/**
 * When resolving a User, the underlying service may claim that
 * no user actually exists for the inputs (i.e. banned, deleted, or
 * there's no record of an account with that login/ID).
 */
export type UserDoesNotExist = {
  __typename?: 'UserDoesNotExist';
  /** Key that was used to resolve the user, could be an ID or login. */
  key: Scalars['String'];
};

/** A list of Drops awarded to the user. // deprecated. */
export type UserDropAwardConnection = {
  __typename?: 'UserDropAwardConnection';
  /**
   * The Drops awarded to the user.
   * @deprecated No longer supported
   */
  nodes: Array<Maybe<DropAward>>;
  /**
   * The number of drop awards a user has received.
   * @deprecated No longer supported
   */
  totalCount?: Maybe<Scalars['Int']>;
};

/** A list of Drops awarded to the user via Drops2.0. */
export type UserDropReward = {
  __typename?: 'UserDropReward';
  /** The DropBenefit that a user is entitled to. */
  benefit: DropBenefit;
  /**
   * The game that awarded the Drop.
   * @deprecated use benefit.Game
   */
  game?: Maybe<Game>;
  /**
   * The assigned ID of the awarded reward.
   * @deprecated use benefit.id
   */
  id: Scalars['ID'];
  /**
   * The image URL of the Benefit. Images are 80x80 pixels.
   * @deprecated use benefit.imageAssetURL
   */
  imageURL: Scalars['String'];
  /** Flag if the user is connected to the game in order to receive the Reward. */
  isConnected: Scalars['Boolean'];
  /**
   * Specifies if this reward is considered for a game that is available on iOS.
   * @deprecated use benefit.isIosAvailable
   */
  isIosAvailable: Scalars['Boolean'];
  /** The timestamp when the Benefit was last awarded to the user. */
  lastAwardedAt: Scalars['Time'];
  /**
   * The developer-provided name of the awarded Benefit.
   * @deprecated use benefit.name
   */
  name: Scalars['String'];
  /**
   * Link where the user can connect their account necessary to receive the reward.
   * @deprecated use benefit.accountLinkURL
   */
  requiredAccountLink: Scalars['String'];
  /** The number of drop awards a user has received. */
  totalCount: Scalars['Int'];
};

/**
 * Generic edge between some type and a User, where there is no information that needs to
 * to be encoded on the edge.
 */
export type UserEdge = {
  __typename?: 'UserEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<User>;
};

/** An attempt to resolve a user has failed due to an error. */
export type UserError = {
  __typename?: 'UserError';
  /** Key that was used to resolve the user, could be an ID or login. */
  key: Scalars['String'];
};

/** The edge between a User and a Facebook connection. */
export type UserFacebookConnectionLink = {
  __typename?: 'UserFacebookConnectionLink';
  /** The user's full name on Facebook. eg. "John Doe". */
  fullName: Scalars['String'];
};

/** UserLeaderboard contains a leaderboard whose entries are Users. */
export type UserLeaderboard = {
  __typename?: 'UserLeaderboard';
  /** id is the id of this leaderboard. */
  id: Scalars['ID'];
  /** items is the list of users in the leaderboard ordered by their score. */
  items: UserLeaderboardItemConnection;
  /** myPosition contains the item representing the authed user's position on this leaderboard. */
  myPosition?: Maybe<UserLeaderboardItem>;
  /** SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time). */
  secondsRemaining: Scalars['Int'];
};

/** UserLeaderboardItem at a specific node in a leaderboard connection. */
export type UserLeaderboardItem = {
  __typename?: 'UserLeaderboardItem';
  /** id the id of this leaderboard item. */
  id: Scalars['ID'];
  /** rank the ordinal rank of this leaderboard item. */
  rank: Scalars['Int'];
  /** score the numerical value by which this leaderboard is sorted. */
  score: Scalars['Int'];
  /** user is the user that holds this position. */
  user?: Maybe<User>;
};

/** UserLeaderboardItemConnection is used to show the various leaderboard items. */
export type UserLeaderboardItemConnection = {
  __typename?: 'UserLeaderboardItemConnection';
  /** edges ... */
  edges: Array<UserLeaderboardItemEdge>;
  /** pageInfo ... */
  pageInfo: PageInfo;
};

/** UserLeaderboardItemEdge describes an edge in a bits leaderboard. */
export type UserLeaderboardItemEdge = {
  __typename?: 'UserLeaderboardItemEdge';
  /** The cursor for this leaderboard edge. */
  cursor: Scalars['Cursor'];
  /** The leaderboard entry at this edge. */
  node?: Maybe<UserLeaderboardItem>;
};

/** The available types of lookups for a user query. */
export enum UserLookupType {
  /** Retrieves only active users without TOS/DMCA violations. */
  Active = 'ACTIVE',
  /** Includes suspended or deleted users in the results. */
  All = 'ALL'
}

/** Restrictions on a user participating in a given Prediction Event. */
export enum UserPredictionEventRestriction {
  /** The user is restricted from participating because they have the ability to manage Predictions on this channel. */
  CanManagePredictions = 'CAN_MANAGE_PREDICTIONS',
  /** The user is restricted from participating because their geographic location has a ban on Predictions for the specific game/category being played. */
  CategoryRegionLocked = 'CATEGORY_REGION_LOCKED',
  /** The user is restricted from participating because their geographic location has a blanket ban on Prediction participation. */
  RegionLocked = 'REGION_LOCKED'
}

/**
 * Options and preferences for how the user participates in Predictions Events.
 * Users can only view their own Predictions Settings.
 */
export type UserPredictionSettings = {
  __typename?: 'UserPredictionSettings';
  /** Whether the user has accepted the latest Predictions Terms of Service. */
  hasAcceptedTOS: Scalars['Boolean'];
  /** Whether the user is in a region that is restricted from participation in making predictions. */
  isInRestrictedRegion?: Maybe<Scalars['Boolean']>;
  /** Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events. */
  isTemporaryChatBadgeEnabled: Scalars['Boolean'];
};

/** Statistics concerning how a user has performed when making Predictions in a given channel. */
export type UserPredictionStatistics = {
  __typename?: 'UserPredictionStatistics';
  /** The total number of events that this user has participated in on this channel. */
  eventsTotal: Scalars['Int'];
  /** The number of events that this user has successfully predicted in this channel. */
  eventsWon: Scalars['Int'];
  /** The most recent prediction made by this user on this channel. Null if they have not made a Prediction recently. */
  mostRecentPrediction?: Maybe<Prediction>;
  /** The total number of points that this user has spent making predictions in this channel. */
  pointsUsed: Scalars['Int'];
  /** The total number of points that this user has won from correct predictions in this channel. */
  pointsWon: Scalars['Int'];
  /** The highest number of points that this user has won from a correct prediction in this channel. */
  pointsWonMax: Scalars['Int'];
  /** The user's current win-streak in Events on this channel. */
  winStreak: Scalars['Int'];
  /** The highest win-streak in Events on this channel the user has ever had. */
  winStreakMax: Scalars['Int'];
};

/** Subjective data on a User (user/channel) for the target user. */
export type UserRelationship = {
  __typename?: 'UserRelationship';
  /** The time when a follower relationship between the user and the target user was established. */
  followedAt?: Maybe<Scalars['Time']>;
  /** Statistics concerning how well the target user has performed in Prediction Events on the user's channel. */
  predictionStatistics?: Maybe<UserPredictionStatistics>;
  /**
   * The subscription benefit relationship between the user and the target user.
   * Null if the user is not subscribed to the other user.
   */
  subscriptionBenefit?: Maybe<SubscriptionBenefit>;
  /** Subscription tenure data for the user to the target user. */
  subscriptionTenure?: Maybe<SubscriptionTenure>;
};


/** Subjective data on a User (user/channel) for the target user. */
export type UserRelationshipSubscriptionTenureArgs = {
  tenureMethod: SubscriptionTenureMethod;
};

/** User's residence. */
export type UserResidence = {
  __typename?: 'UserResidence';
  /** Country in ISO alpha-2. */
  countryCode: Scalars['String'];
  /** Postal code. */
  postalCode?: Maybe<Scalars['String']>;
};

/** The set of results that can occur when resolving a user query. */
export type UserResult = User | UserDoesNotExist | UserError;

/** The edge between a User and a Youtube Connection. */
export type UserRiotConnectionLink = {
  __typename?: 'UserRiotConnectionLink';
  /** The PUUID for the user's Riot account. */
  id: Scalars['ID'];
};

/** Groups site-wide user roles together. */
export type UserRoles = {
  __typename?: 'UserRoles';
  /**
   * Whether or not the user is enrolled in the affiliate program.
   * See https://affiliate.twitch.tv for more information.
   */
  isAffiliate?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the user is allowed to approve extensions on Twitch.
   * @deprecated This role is no longer surfaced through the API
   */
  isExtensionsApprover?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the user is enrolled in the extensions developer program.
   * See https://dev.twitch.tv/docs/extensions/onboarding for more information.
   */
  isExtensionsDeveloper?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user can moderate any broadcast chat. */
  isGlobalMod?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user is a partnered broadcaster with Twitch. */
  isPartner?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user is a site admininistrator. */
  isSiteAdmin?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user is a Twitch staff member. */
  isStaff?: Maybe<Scalars['Boolean']>;
};

/**
 * UserSelfBitsBadge contains the current user's badge tier in a channel and progress toward the next tier.
 * NOTE: should probably have been named CurrentUserBitsBadge.
 */
export type UserSelfBitsBadge = {
  __typename?: 'UserSelfBitsBadge';
  /**
   * current is the highest bits chat badge the authenticated user has achieved in this channel.
   * If a badge tier is disabled after being earned it will still appear here until the next tier is earned.
   * If the user hasn't earned any bits badges yet this will be null.
   */
  current?: Maybe<Badge>;
  id: Scalars['ID'];
  /**
   * next is the next chat badge the authenticated user can earn in this channel.
   * If this is null then there are no higher tiers to earn.
   */
  next?: Maybe<Badge>;
  /**
   * nextBits is the bits value of the next chat badge the authenticated user can earn in this channel.
   * If this is null then there are no higher tiers to earn.
   */
  nextBits?: Maybe<Scalars['Int']>;
  /**
   * progress is the fraction of the way the user is toward the next badge tier [0.0-1.0).
   * If `next` is null this will be zero.
   */
  progress: Scalars['Float'];
  /**
   * tierNotification represents a notification sent to a user when they have achieved
   * a new bits badge in a channel. Used to send a special message.
   * If no notification is pending this will be null.
   */
  tierNotification?: Maybe<BitsBadgeTierNotification>;
  /** totalBits is the number of bits the authenticated user has used in this channel. */
  totalBits: Scalars['Int'];
};

/** Subjective data on another User (user/channel) for the current user. */
export type UserSelfConnection = {
  __typename?: 'UserSelfConnection';
  /** The badges which are available for the authenticated user to select for use on another user's streams and videos. */
  availableBadges?: Maybe<Array<Maybe<Badge>>>;
  /** Ban status of the authenticated user with respect to this user's channel. */
  banStatus?: Maybe<ChatRoomBanStatus>;
  /**
   * bitsBadge contains information about bits badge progression in a channel.
   * This field can only be requested if an OAuth token is supplied with the request.
   */
  bitsBadge?: Maybe<UserSelfBitsBadge>;
  /**
   * The bits leaderboard entry shows the current user's entry in the
   * channel's leaderboard. It does not show context entries around it.
   * @deprecated use user.self.bitsLeaderboardItem instead.
   */
  bitsLeaderboardEntry?: Maybe<BitsLeaderboardEntry>;
  /**
   * The bits leaderboard item shows the current user's entry in the
   * channel's leaderboard. It does not show context entries around it.
   */
  bitsLeaderboardItem?: Maybe<BitsLeaderboardItem>;
  /**
   * The bits leaderboard position shows the curreent users rank
   * and the surrounding users in the current channel.
   */
  bitsLeaderboardPosition?: Maybe<BitsLeaderboard>;
  /** Whether or not the authenticated user can follow this user. */
  canFollow: Scalars['Boolean'];
  /**
   * CanGift relationship between the authenticated user, another user, and a product.
   * True is the authenticated user can gift the product to the other user.
   * @deprecated Transitioning to SubscriptionProductSelfConnection instead
   */
  canGift: Scalars['Boolean'];
  /**
   * CanGiftInChannel relationship between the authenticated user and a product.
   * True is the authenticated user is allowed to send gifts in this channel.
   * @deprecated Transitioning to SubscriptionProductSelfConnection instead
   */
  canGiftInChannel: Scalars['Boolean'];
  /** Checks if the authenticated user can subscribe to this channel via Prime. */
  canPrimeSubscribe: Scalars['Boolean'];
  /**
   * Whether the authenticated user has permission to redeem a subscription to this Channel.
   * Return Values are.
   * 1) Null - The Channel to which the User is subscribed to is not supporting any subscription redemption.
   * 2) False - The User has already utilized their redemption to the channel offering subscription redemption.
   * 2) True - The User can use the subscription redemption offered by the channel.
   */
  canRedeemSubscription?: Maybe<Scalars['Boolean']>;
  /** The list of celebration products available for the authenticated user to purchase in this channel. */
  celebrationProducts?: Maybe<Array<Maybe<CelebrationProduct>>>;
  /**
   * If the authenticated user cannot chat in this channel, a list of reasons.
   * Null if the user can chat.
   */
  chatRestrictedReasons?: Maybe<Array<ChatRestrictedReason>>;
  /**
   * Lists the chat badges that should be displayed by the user's display name in
   * features on a particular user's channel (i.e. chat, feeds).
   * Includes the following badges:
   * - global authority (staff/admin/global mod)
   * - channel authority (broadcaster/mod)
   * - subscriber
   * - channel selected (bits) or global selected (prime, turbo, ...).
   */
  displayBadges: Array<Maybe<Badge>>;
  /**
   * A follower relationship between the authenticated user and another user.
   * Null if the relationship does not exist.
   */
  follower?: Maybe<FollowerEdge>;
  /**
   * The friendship-type relationship (friendship, incoming friend request, outgoing friend request) between the
   * authenticated user and another user. Null if no friendship-type relationship exists.
   */
  friendship?: Maybe<FriendRelationship>;
  /** True if the authenticated user has joined this channel. */
  isChannelMember?: Maybe<Scalars['Boolean']>;
  /** Whether or not the authenticated user is editor of another user's channel. */
  isEditor?: Maybe<Scalars['Boolean']>;
  /** Whether or not the authenticated user is a founder badge owner of another user's channel. */
  isFounder?: Maybe<Scalars['Boolean']>;
  /** Whether or not the authenticated user is a moderator of another user's channel. */
  isModerator?: Maybe<Scalars['Boolean']>;
  /** Whether or not the authenticated user is a VIP of another user's channel. */
  isVIP?: Maybe<Scalars['Boolean']>;
  /**
   * The timestamp of the last time the authenticated user sent a chat message in another user's channel within the last 30 minutes.
   * Null if the authenticated user has not chatted in the channel in the last 30 minutes.
   */
  lastRecentChatMessageAt?: Maybe<Scalars['Time']>;
  /** Information about the authenticated user's Prime subscription credit benefit. */
  primeSubCreditBenefit?: Maybe<PrimeSubCreditBenefit>;
  /**
   * The most recent resub token to use for sending a special message.
   * If no notification is pending this will be null.
   */
  resubNotification?: Maybe<ResubNotification>;
  /** Lists ritual tokens that can be requested or displayed to the user in another user's channel. */
  ritualTokens?: Maybe<Array<RitualToken>>;
  /** The badge the authenticated user selected for use on another user's streams and videos. */
  selectedBadge?: Maybe<Badge>;
  /** Stucco packs that are available to viewers of a broadcaster. */
  stuccoPacksViewer?: Maybe<Array<Maybe<StuccoPack>>>;
  /** The current subscriber badge that a user would have if subscribed & remaining locked subscriber badges with progress. */
  subscriberBadgeProgress?: Maybe<Array<SubscriberBadgeProgress>>;
  /**
   * The subscription benefit relationship between the authenticated user and another user.
   * Null if the authenticated user is not subscribed to the other user.
   */
  subscriptionBenefit?: Maybe<SubscriptionBenefit>;
  /** The number of gift subscriptions that the authenticated user has given to other users in this channel. */
  subscriptionGiftCount?: Maybe<Scalars['Int']>;
  /** Subscription tenure data for the user to this channel. */
  subscriptionTenure?: Maybe<SubscriptionTenure>;
  /** Whether the authenticated user can send or receive Whispers to/from another user. */
  whisperPermissions?: Maybe<WhisperPermissions>;
};


/** Subjective data on another User (user/channel) for the current user. */
export type UserSelfConnectionCanGiftArgs = {
  product: Scalars['String'];
};


/** Subjective data on another User (user/channel) for the current user. */
export type UserSelfConnectionCanGiftInChannelArgs = {
  product: Scalars['String'];
};


/** Subjective data on another User (user/channel) for the current user. */
export type UserSelfConnectionSubscriberBadgeProgressArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};


/** Subjective data on another User (user/channel) for the current user. */
export type UserSelfConnectionSubscriptionTenureArgs = {
  tenureMethod: SubscriptionTenureMethod;
};

/** Groups site-wide user settings together. */
export type UserSettings = {
  __typename?: 'UserSettings';
  /**
   * Whether the user is whitelisted to host Prime Video watch parties. This
   * takes precedence over user.watchPartiesRestrictions.
   */
  canHostWatchParties: Scalars['Boolean'];
  /**
   * The user's channel feed on/off switch.
   * The channel feed is displayed if set to true and is
   * hidden if set to false.
   * @deprecated No longer supported
   */
  channelFeedEnabled: Scalars['Boolean'];
  /** The cheer settings for a user, configured in their partner dashboard. */
  cheer?: Maybe<CheerPartnerSettings>;
  /** Whether or not the user has a second authentication method configured. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the broadcaster is eligible for payout through Amazon retail revenue share.
   * @deprecated Game sales discontinued
   */
  isAmazonRetailRevShareEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
   * @deprecated Game sales discontinued
   */
  isCommerceRevShareEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has requested that their registration date be hidden in the viewer card. */
  isCreateDateHidden?: Maybe<Scalars['Boolean']>;
  /** Whether or not the user has elected to be hidden from search results. */
  isDirectoryHidden?: Maybe<Scalars['Boolean']>;
  /** Whether or not the email was successfully reverted. */
  isEmailRevertSuccess?: Maybe<Scalars['Boolean']>;
  /** Whether the user's channel has rituals enabled. */
  isRitualsEnabled: Scalars['Boolean'];
  /**
   * Whether the user's channel is whitelisted into the rituals experiment.
   * @deprecated Rituals is whitelisted only for launch.
   */
  isRitualsWhitelisted: Scalars['Boolean'];
  /**
   * The user's activity sharing setting.
   * Activity is the part of a user's status that shows what they're currently playing, watching, or streaming.
   * Requires the `user_presence_friends_read` scope.
   */
  isSharingActivity: Scalars['Boolean'];
  /** Partner settings related to leaderboards. */
  leaderboard?: Maybe<LeaderboardSettings>;
  /** The user's preferred language tag for displaying text content. */
  preferredLanguageTag?: Maybe<LanguageTag>;
  /**
   * The user's shared availability while online.
   * A value of ONLINE (typically called "invisibility") additionally means that the user's activity will not be shared
   * regardless of the isSharingActivity setting.
   * Requires the `user_presence_friends_read` scope.
   */
  visibility: Visibility;
};

/** The edge between a User and a Steam connection. */
export type UserSteamConnectionLink = {
  __typename?: 'UserSteamConnectionLink';
  /** A Steam user ID. */
  id: Scalars['ID'];
};

/** UserSubscriptionSettings displays the users subscription settings. */
export type UserSubscriptionSettings = {
  __typename?: 'UserSubscriptionSettings';
  /** If the user only wants to receive gifts to channels they follow. */
  giftsToFollowedChannelsOnly: Scalars['Boolean'];
  /** If the user wants to hide Badge Modifier. */
  isBadgeModifierHidden: Scalars['Boolean'];
  /** If the user wants to hide their Founder Badges. */
  isFounderBadgesHidden: Scalars['Boolean'];
  /** If the user wants to hide the number of gifts they've gifted. */
  isGiftCountHidden: Scalars['Boolean'];
  /** If the user wants to hide their subscription tenure and status in the chat viewer card. */
  isSubscriptionStatusHidden: Scalars['Boolean'];
};

/**
 * UserTeamMembership represents a User's membership to a Twitch Team.
 * UserTeamMemberships are collections of teams that the User is a part of.
 */
export type UserTeamMembership = {
  __typename?: 'UserTeamMembership';
  /** Whether the team is the primary team for the given User. */
  isPrimary: Scalars['Boolean'];
  /** Whether the team is revenue revealed for the given User. */
  isRevenueRevealed: Scalars['Boolean'];
  /** Whether the team is stats revealed for the given User. */
  isStatsRevealed: Scalars['Boolean'];
  /** The Team the user is a member of. */
  team: Team;
};

/** The relationship between the user and Twitch. */
export type UserTwitchConnection = {
  __typename?: 'UserTwitchConnection';
  /** Returns the User's preferred team in Overwatch League. */
  overwatchLeagueTeamPreference?: Maybe<OverwatchLeagueTeamPreference>;
};

/** The edge between a User and a Twitter connection. */
export type UserTwitterConnectionLink = {
  __typename?: 'UserTwitterConnectionLink';
  /** A Twitter username, without the "@" (eg. "Twitch"). */
  username: Scalars['String'];
};

/** The edge between a User and a Youtube Connection. */
export type UserYoutubeConnectionLink = {
  __typename?: 'UserYoutubeConnectionLink';
  /** The URL for the user's Youtube channel. */
  channelURL: Scalars['String'];
};

/** Paginated list of VIP users of a channel. */
export type VipConnection = {
  __typename?: 'VIPConnection';
  /** The elements of the list. */
  edges: Array<VipEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Element in a list of VIP users of a channel. */
export type VipEdge = {
  __typename?: 'VIPEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** Timestamp of when the VIP status was granted. */
  grantedAt: Scalars['Time'];
  /** The user who has the VIP status. */
  node?: Maybe<User>;
};

/** Error that occurred while validating with code. */
export type ValidateVerificationCodeError = {
  __typename?: 'ValidateVerificationCodeError';
  /** Error code for error that occurred while validating with code. */
  code?: Maybe<ValidateVerificationCodeErrorCode>;
};

/** Error types for verification. */
export enum ValidateVerificationCodeErrorCode {
  /** Verification failed because provided code does not match. */
  IncorrectCode = 'INCORRECT_CODE',
  /** Verification failed due to being rate limited. */
  RateLimited = 'RATE_LIMITED',
  /** Validation code was incorrect and the code has been regenerated and resent due to too many failed attempts. */
  TooManyFailedAttempts = 'TOO_MANY_FAILED_ATTEMPTS',
  /** Verification failed due to some unknown, unclassified error. */
  Unknown = 'UNKNOWN'
}

/** ValidateVerificationCodeInput is input required to verify a user contact method in EVS by validating their verification code. */
export type ValidateVerificationCodeInput = {
  /** Address that the user is verifying. This will most likely be an email address or phone number. */
  address: Scalars['String'];
  /** Code used to validate if the verification request is valid. */
  code: Scalars['String'];
  /** Key for the entity associated with the address. This is generally the Twitch ID of the user. */
  key: Scalars['String'];
};

/** ValidateVerificationCodePayload is the VerificationRequest document returned from EVS on success. */
export type ValidateVerificationCodePayload = {
  __typename?: 'ValidateVerificationCodePayload';
  /** Mutation error based on user input. */
  error?: Maybe<ValidateVerificationCodeError>;
  /** The updated verification request. */
  request?: Maybe<VerificationRequest>;
};

/** Vendor consent is a union of different vendors supported based on privacy law. */
export type VendorConsent = CcpaVendorConsent | GdprVendorConsent | RowVendorConsent;

/** VendorConsentStatus is the consent status of each vendor. */
export type VendorConsentStatus = {
  __typename?: 'VendorConsentStatus';
  /** User consentStatus for this vendor. */
  consentStatus: ConsentStatus;
  /** A flag that shows if the consent is given by the user or by consent service as default value. */
  hasUserSetConsent: Scalars['Boolean'];
  /** A flag that shows if the vendor should be visible to the consent settings page. */
  isVisible: Scalars['Boolean'];
  /** Vendor name. */
  name: VendorName;
};

/** VendorConsentStatusInput is the input struct for vendor consent status. */
export type VendorConsentStatusInput = {
  /** Consent status of this vendor. */
  consentStatus: ConsentStatus;
  /** name of the vendor. */
  name: VendorName;
};

/** VendorName is the name of the cookie vendor. */
export enum VendorName {
  /**
   * AMAZON is Amazon.
   * DEPRECATED vendor.
   */
  Amazon = 'AMAZON',
  /** BEESWAX is Beeswax. */
  Beeswax = 'BEESWAX',
  /** BRANCH is Branch. */
  Branch = 'BRANCH',
  /** COMSCORE is ComScore. */
  Comscore = 'COMSCORE',
  /** FLASHTALKING is Flashtalking. */
  Flashtalking = 'FLASHTALKING',
  /** GAMESITE is Gamesite. */
  Gamesite = 'GAMESITE',
  /** GOOGLE is Google. */
  Google = 'GOOGLE',
  /** GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS is Google analytics developer Extensions. */
  GoogleAnalyticsDeveloperExtensions = 'GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS',
  /** KANTAR is Kantar. */
  Kantar = 'KANTAR',
  /** NIELSEN is Nielsen. */
  Nielsen = 'NIELSEN',
  /** SALESFORCE_DMP is Salesforce_DMP. */
  SalesforceDmp = 'SALESFORCE_DMP',
  /** SIZMEK is Sizmek. */
  Sizmek = 'SIZMEK',
  /** SPOTX is Spotx. */
  Spotx = 'SPOTX',
  /** THE_TRADE_DESK is The Trade Desk. */
  TheTradeDesk = 'THE_TRADE_DESK',
  /** BEESWAX is Truex. */
  Truex = 'TRUEX',
  /**
   * TWITCH_AMAZON is a vendor replacement for Amazon.
   * This should be the vendor used to get consent on Amazon.
   */
  TwitchAmazon = 'TWITCH_AMAZON'
}

/** Represents a user's request to verify a given contact method, such as email address or phone number. */
export type VerificationRequest = {
  __typename?: 'VerificationRequest';
  /** Address that the user is verifying. This will most likely be an email address or phone number. */
  address: Scalars['String'];
  /** Key for the entity associated with the address. This is generally the Twitch ID of the user. */
  key: Scalars['String'];
  /** Time at which the verification request was last modified. */
  modified: Scalars['Time'];
  /** Status of the verification request: pending, verified, or rejected. */
  status: VerificationStatus;
};

/** Status of a given verification request. */
export enum VerificationStatus {
  /** Pending indicates not yet successfully verified. */
  Pending = 'PENDING',
  /** Rejected indicates we were unable to send a verification request to the given address, for example if we received a hard bounce from SES. */
  Rejected = 'REJECTED',
  /** Unknown is used as a safe fallback status. */
  Unknown = 'UNKNOWN',
  /** Verified indicates successfully verified. */
  Verified = 'VERIFIED'
}

/** VerifyContactMethodInput is input required to verify a user contact method in EVS by their opaque ID. */
export type VerifyContactMethodInput = {
  /** Used to validate the associated user contact info. */
  opaqueID: Scalars['ID'];
};

/** VerifyContactMethodPayload is the VerificationRequest document returned from EVS on success. */
export type VerifyContactMethodPayload = {
  __typename?: 'VerifyContactMethodPayload';
  /** The success/failure of the verification attempt. */
  isSuccess: Scalars['Boolean'];
  /** The updated verification request. */
  request?: Maybe<VerificationRequest>;
};

/** Error returned during a invalid user request. */
export type VerifyOneTimePasswordError = {
  __typename?: 'VerifyOneTimePasswordError';
  /** Error code returned by the backend. */
  code: VerifyOneTimePasswordErrorCode;
  /** The localized external error message. */
  message: Scalars['String'];
};

/** The possible error enums returned while trying to verify a one time password. */
export enum VerifyOneTimePasswordErrorCode {
  /** The one time password submitted is invalid. */
  InvalidOtp = 'INVALID_OTP',
  /** The user does not have two factor enabled and cannot verify a one time password. */
  NoTwoFactor = 'NO_TWO_FACTOR',
  /** The user needs to re-authenticate to perform this operation. */
  ReauthNeeded = 'REAUTH_NEEDED',
  /** Something unexpected occured. */
  UnknownError = 'UNKNOWN_ERROR'
}

/** The required input for a VerifyOneTimePasswordInput mutation. */
export type VerifyOneTimePasswordInput = {
  /** The one time password that needs to be verified. */
  oneTimePassword: Scalars['String'];
  /** The ID of the user attempting to verify a one time password. */
  userID: Scalars['ID'];
};

/** The result of a verifyOneTimePassword mutation. */
export type VerifyOneTimePasswordPayload = {
  __typename?: 'VerifyOneTimePasswordPayload';
  /** error code and localized error. */
  error?: Maybe<VerifyOneTimePasswordError>;
};

/** Error that occurred while validating with captcha token. */
export type VerifyRewardedVideoEligibilityCaptchaError = {
  __typename?: 'VerifyRewardedVideoEligibilityCaptchaError';
  /** Error code for error that occurred while validating the captcha token. */
  code: VerifyRewardedVideoEligibilityCaptchaErrorCode;
};

/** Error types for captcha verification. */
export enum VerifyRewardedVideoEligibilityCaptchaErrorCode {
  /** The service had an issue unrelated to your input. */
  InternalError = 'INTERNAL_ERROR',
  /** The input provided by the user was rejected. */
  InvalidParameter = 'INVALID_PARAMETER'
}

/** Inputs for registering a Captcha for WATEB. */
export type VerifyRewardedVideoEligibilityCaptchaInput = {
  /** Whether we authenticated with V1 or V2 Arkose endpoint. */
  arkoseEndpointVersion: ArkoseEndpointVersion;
  /** The token response from Arkose to verify. */
  sessionToken: Scalars['String'];
};

/** The response from verifying a captcha with rewarded video systems. */
export type VerifyRewardedVideoEligibilityCaptchaPayload = {
  __typename?: 'VerifyRewardedVideoEligibilityCaptchaPayload';
  /** The error (if one exists) returned from validating the captcha token. */
  error?: Maybe<VerifyRewardedVideoEligibilityCaptchaError>;
};

/** IDs used to determine the context(s) by which content was determined for a given VerticalSubDirectory. */
export type VerticalContentContext = Game | Tag;

/** A container of content for a vertical grouped by shelves. */
export type VerticalDirectory = {
  __typename?: 'VerticalDirectory';
  /** The vertical's unique Twitch identifier. */
  id: Scalars['ID'];
  /** The vertical's backend name. */
  name?: Maybe<Scalars['String']>;
  /** List of shelf groups containing content for this vertical. */
  shelfGroups?: Maybe<Array<VerticalShelfGroup>>;
  /** The human readable slug for the vertical directory, used in the URL. */
  slug?: Maybe<Scalars['String']>;
  /** The subtitle for the shelf group. */
  subtitle: ShelfTitle;
  /** The title for the shelf. */
  title: ShelfTitle;
  /** Used in client tracking. */
  trackingID: Scalars['ID'];
};

/** An ordered list of content to render with metadata on the content. */
export type VerticalShelf = {
  __typename?: 'VerticalShelf';
  /** The ordered content for the shelf. */
  content: ShelfContentConnection;
  /** The one or more contexts for which this shelf contains content for. */
  contentContext?: Maybe<Array<VerticalContentContext>>;
  /** A unique identifier for the shelf. */
  id: Scalars['ID'];
  /** The subtitle for the shelf group. */
  subtitle?: Maybe<ShelfTitle>;
  /** The title for the shelf. */
  title?: Maybe<ShelfTitle>;
  /** Used in client tracking. */
  trackingID: Scalars['ID'];
  /** The type of this shelf. */
  type: VerticalShelfType;
};

/** A grouping of one or more shelves. */
export type VerticalShelfGroup = {
  __typename?: 'VerticalShelfGroup';
  /** The one or more contexts for which this shelf group contains content for. */
  contentContext?: Maybe<Array<VerticalContentContext>>;
  /** A unique identifer for this shelf group. */
  id: Scalars['ID'];
  /** The ordered shelves for this shelf group. */
  shelves?: Maybe<Array<VerticalShelf>>;
  /** The subtitle for the shelf group. */
  subtitle?: Maybe<ShelfTitle>;
  /** The title for the shelf group. */
  title?: Maybe<ShelfTitle>;
  /** Used in client tracking. */
  trackingID: Scalars['ID'];
};

/** The types of vertical shelves supported. */
export enum VerticalShelfType {
  /** A list of categories to be selected. */
  CategorySelector = 'CATEGORY_SELECTOR',
  /** Collection. */
  Collection = 'COLLECTION',
  /** Live matches. */
  LiveMatches = 'LIVE_MATCHES',
  /** Live professionals. */
  LivePros = 'LIVE_PROS',
  /** Replays. */
  Replays = 'REPLAYS'
}

/** A container of content for a vertical by category, grouped by shelves. */
export type VerticalSubDirectory = {
  __typename?: 'VerticalSubDirectory';
  /** The one or more contexts for which this directory contains content for. */
  contentContext?: Maybe<Array<VerticalContentContext>>;
  /** The vertical's unique Twitch identifier. */
  id: Scalars['ID'];
  /** List of shelf groups containing content for this vertical category. */
  shelfGroups?: Maybe<Array<VerticalShelfGroup>>;
  /** The subtitle for the shelf group. */
  subtitle: ShelfTitle;
  /** The title for the shelf. */
  title: ShelfTitle;
  /** Used in client tracking. */
  trackingID: Scalars['ID'];
};

/** The content context of a subdirectory. */
export type VerticalSubDirectoryContentContext = {
  /** The subdirectory content context category ids. */
  categoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** The subdirectory content context tag ids. */
  tagIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type Video = {
  __typename?: 'Video';
  /** A link to an image which contains an animated preview of the video. */
  animatedPreviewURL?: Maybe<Scalars['String']>;
  /** A list of bookmarks for this video. */
  bookmarks?: Maybe<VideoBookmarkConnection>;
  /** The type of broadcast the video originated from. */
  broadcastType?: Maybe<BroadcastType>;
  /**
   * A paginated list of clips for this video.
   * When criteria is not specified, the default values are used.
   */
  clips?: Maybe<ClipConnection>;
  /** A paginated list of comments against this video. */
  comments?: Maybe<VideoCommentConnection>;
  /** A list of tags describing the video. */
  contentTags?: Maybe<Array<Tag>>;
  /** The time the video metadata record was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /**
   * The user who created this video.
   * This will be either the broadcaster or one of their editors.
   */
  creator?: Maybe<User>;
  /** NOTE: named `deleteAt` in Vinyl. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** A description of the video, formatted in markdown. */
  description?: Maybe<Scalars['String']>;
  /**
   * Download information of the video. NOTE: Request this field only when a user is requesting a download
   * since it will go through a process to generate a download URL on the backend.
   */
  download?: Maybe<VideoDownload>;
  /**
   * The length of the video.
   * @deprecated Use length instead, as it's easier to parse.
   */
  duration?: Maybe<Scalars['Duration']>;
  /** The game the video is depicting. */
  game?: Maybe<Game>;
  /** The video's identifier. */
  id: Scalars['ID'];
  /** Whether the video has been soft deleted. */
  isDeleted: Scalars['Boolean'];
  /** Which language the video is in. */
  language?: Maybe<Scalars['String']>;
  /** The length of the video, as an int, in seconds. */
  lengthSeconds?: Maybe<Scalars['Int']>;
  /** A list of moments for this video. */
  moments?: Maybe<VideoMomentConnection>;
  /**
   * Publicly available muted segment info, detailing which parts of the video
   * have had audio removed.
   */
  muteInfo?: Maybe<VideoMuteInfo>;
  /**
   * For highlights, the number of seconds offset from the beginning of the past broadcast the highlight starts.
   * For past broadcasts and uploads, this means nothing.
   */
  offsetSeconds?: Maybe<Scalars['Int']>;
  /** The owner of the video. */
  owner?: Maybe<User>;
  /**
   * The playback access token that determines whether the user can watch the video.
   * Fetched for both authed and unauthed users.
   */
  playbackAccessToken?: Maybe<PlaybackAccessToken>;
  /**
   * The URL to the thumbnail which should be displayed for the video.
   * If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
   */
  previewThumbnailURL: Scalars['String'];
  /**
   * The time when the archive/highlight/upload was first ever available to public,
   * even if it is not currently public.
   */
  publishedAt?: Maybe<Scalars['Time']>;
  /** The reactions associated with this video. */
  reactions?: Maybe<Array<Maybe<Reaction>>>;
  /** The time the video was recorded. */
  recordedAt?: Maybe<Scalars['Time']>;
  /**
   * The reason a video is restricted if the given video is a restricted video.
   * For a video that is not restricted, this field can be null.
   */
  resourceRestriction?: Maybe<ResourceRestriction>;
  /**
   * The reason a video is restricted if the given video is a restricted video.
   * For a video that is not restricted, this field can be null.
   * @deprecated Restriction will be moved over to resourceRestriction instead
   */
  restriction?: Maybe<VideoRestriction>;
  /** Either PRIVATE or PUBLIC. */
  scope?: Maybe<VideoPrivacyScope>;
  /** A link to a sprite sheet image made up of preview thumbnails when seeking the video timeline. */
  seekPreviewsURL?: Maybe<Scalars['String']>;
  /** The authenticated user's relationship with this video. */
  self?: Maybe<VideoSelfEdge>;
  /**
   * When broadcastType is:
   * - ARCHIVE: status goes from RECORDING to RECORDED.
   * - HIGHLIGHT: status goes from UNPROCESSED to RECORDED.
   * - UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong.
   * - PREMIERE_UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong for this legacy broadcast type.
   * - PAST_PREMIERE: status goes from RECORDING to RECORDED for this legacy broadcast type.
   */
  status?: Maybe<VideoStatus>;
  /** The suggested details for creating an automated highlight from this video. */
  suggestedHighlight?: Maybe<VideoSuggestedHighlight>;
  /** An array of tags describing the video. This field will be deprecated soon. Please use `Video.contentTag` instead. */
  tags?: Maybe<Array<Maybe<Scalars['String']>>>;
  /**
   * A list of thumbnail URLs for the video, ordered by descending priority.
   * Owners can insert custom thumbnails into this list.
   * If either `height` or `width` are not given, a templated value (i.e. `{height}`, `{width}`) will be present in the URL instead.
   */
  thumbnailURLs?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The title of the video. */
  title?: Maybe<Scalars['String']>;
  /**
   * A paginated list of clips featuring this vod that is, by default, ordered by view count descending.
   * When criteria is not specified, the default values are used.
   */
  topClips?: Maybe<ClipConnection>;
  /** The most recent time the video data was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** The numer of views this video has. Can be delayed by up to 15 minutes. */
  viewCount?: Maybe<Scalars['Int']>;
  /**
   * For a scheduled video, the time when the video will be made available to the
   * public (the time when the scope will be automatically set to "public").
   * For a video that is public or not scheduled, is null.
   */
  viewableAt?: Maybe<Scalars['Time']>;
};


export type VideoBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type VideoClipsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  curatorIDs?: InputMaybe<Array<Scalars['ID']>>;
  first?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<SortOrder>;
};


export type VideoCommentsArgs = {
  Before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  contentOffsetSeconds?: InputMaybe<Scalars['Int']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type VideoMomentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  momentRequestType?: InputMaybe<VideoMomentRequestType>;
  sort?: InputMaybe<SortOrder>;
  types?: InputMaybe<Array<InputMaybe<VideoMomentType>>>;
};


export type VideoPlaybackAccessTokenArgs = {
  params: PlaybackAccessTokenParams;
};


export type VideoPreviewThumbnailUrlArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


export type VideoThumbnailUrLsArgs = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
};


export type VideoTopClipsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  criteria?: InputMaybe<VideoTopClipsInput>;
  first?: InputMaybe<Scalars['Int']>;
};

/** A video bookmark. */
export type VideoBookmark = {
  __typename?: 'VideoBookmark';
  /** channel the VOD belongs to. */
  channel: User;
  /** Time at which the bookmark was created. */
  createdAt: Scalars['Time'];
  /** Description of the bookmark. */
  description: Scalars['String'];
  /** ID of the bookmark. */
  id: Scalars['ID'];
  /** Relative offset in the video. */
  positionSeconds: Scalars['Int'];
  /** user who created the bookmark. */
  user: User;
};

/** A paginated list of video bookmarks. */
export type VideoBookmarkConnection = {
  __typename?: 'VideoBookmarkConnection';
  /** The elements of the paginated list. */
  edges: Array<Maybe<VideoBookmarkEdge>>;
  /** Error of the get video bookmarks request. */
  error?: Maybe<VideoBookmarkConnectionError>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** VideoBookmarkConnectionError is the error associated with a getVideoBookmarks. */
export type VideoBookmarkConnectionError = {
  __typename?: 'VideoBookmarkConnectionError';
  /** The associated error code. */
  code?: Maybe<VideoBookmarkConnectionErrorCode>;
};

/** VideoBookmarkConnectionErrorCode are the possible errors that this query returns. */
export enum VideoBookmarkConnectionErrorCode {
  /** An unexpected internal server error occurred. */
  InternalServerError = 'INTERNAL_SERVER_ERROR',
  /** The user is unauthorized to fetch bookmarks for the channel. */
  UserUnauthorized = 'USER_UNAUTHORIZED'
}

/** A video bookmark. */
export type VideoBookmarkEdge = {
  __typename?: 'VideoBookmarkEdge';
  /** Uniquely identifies this clip's position in a connection. */
  cursor: Scalars['Cursor'];
  /** The bookmark. */
  node: VideoBookmark;
};

/** Comment on a video. */
export type VideoComment = {
  __typename?: 'VideoComment';
  /** Author of the comment. */
  commenter?: Maybe<User>;
  /** Position of the video where this comment was added. */
  contentOffsetSeconds: Scalars['Int'];
  /** The time the comment was created. */
  createdAt: Scalars['Time'];
  /** The comments's unique identifier. */
  id: Scalars['ID'];
  /** The message of the comment. */
  message?: Maybe<VideoCommentMessage>;
  /**
   * DEPRECATED. List of replies on this comment.
   * @deprecated No longer supported
   */
  replies?: Maybe<VideoCommentConnection>;
  /** Where the comment originated. */
  source: VideoCommentSource;
  /** Current state of the comment. */
  state: VideoCommentState;
  /** The last time this comment was updated. */
  updatedAt: Scalars['Time'];
  /** The video on which this comment was added. */
  video?: Maybe<Video>;
};


/** Comment on a video. */
export type VideoCommentRepliesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** Paginated list of comments. */
export type VideoCommentConnection = {
  __typename?: 'VideoCommentConnection';
  edges?: Maybe<Array<Maybe<VideoCommentEdge>>>;
  pageInfo: PageInfo;
};

/** Video comment edge with cursor and the comment node. */
export type VideoCommentEdge = {
  __typename?: 'VideoCommentEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<VideoComment>;
};

/** Represents the message of a comment. */
export type VideoCommentMessage = {
  __typename?: 'VideoCommentMessage';
  /** Parts of the message body with meta info. */
  fragments?: Maybe<Array<Maybe<VideoCommentMessageFragment>>>;
  /** List of badges the comment author had selected for use at the time of the comment. */
  userBadges?: Maybe<Array<Maybe<Badge>>>;
  /** Text color preferences of comment's author. */
  userColor?: Maybe<Scalars['String']>;
};

/** Represents a part of the message body with meta info. */
export type VideoCommentMessageFragment = {
  __typename?: 'VideoCommentMessageFragment';
  /** Embedded emote info. */
  emote?: Maybe<EmbeddedEmote>;
  /** User which was mentioned. */
  mention?: Maybe<User>;
  /** Raw text of the comment. */
  text: Scalars['String'];
};

/** Where a video comment originated. */
export enum VideoCommentSource {
  /** The comment originated from the live broadcast. */
  Chat = 'CHAT',
  /** The comment was manually created by a commenter. */
  Comment = 'COMMENT',
  /** The comment source is unknown. */
  Unknown = 'UNKNOWN'
}

/** Represents the state of a video comment. */
export enum VideoCommentState {
  /** The comment has been soft-deleted. */
  Deleted = 'DELETED',
  /** The comment was automatically flagged for review (AutoMod). */
  PendingReview = 'PENDING_REVIEW',
  /** The comment is possibly spam and has to be reviewed by a moderator. */
  PendingReviewSpam = 'PENDING_REVIEW_SPAM',
  /** The comment is published. */
  Published = 'PUBLISHED',
  /** The comment was manually unpublished by a mod or the channel owner. */
  Unpublished = 'UNPUBLISHED'
}

/** A paginated list of videos, and its metadata. */
export type VideoConnection = {
  __typename?: 'VideoConnection';
  /** The list of videos in this page. */
  edges?: Maybe<Array<Maybe<VideoEdge>>>;
  /** Information about this page of videos. */
  pageInfo?: Maybe<PageInfo>;
  /** The total number of videos in the larger collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/**
 * Optional input to filter videos.
 * Add any additional optional fields to this input.
 */
export type VideoConnectionOptionsInput = {
  /** The IDs of any categories that should be included in the results. */
  gameIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Whether unpublished (private) videos should be returned. Will only be returned for the currently authenticated user. Defaults to false. */
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  /** The maximum length in seconds of any videos returned. */
  maxLengthSeconds?: InputMaybe<Scalars['Int']>;
  /** The minimum length in seconds of any videos returned. */
  minLengthSeconds?: InputMaybe<Scalars['Int']>;
  /** The ending creation date of any videos returned (not inclusive). */
  searchRangeEndAt?: InputMaybe<Scalars['Time']>;
  /** The starting creation date of any videos returned (not inclusive). */
  searchRangeStartAt?: InputMaybe<Scalars['Time']>;
};

/** A Video Connection Search input to set params to include search term. */
export type VideoConnectionSearchParams = {
  /** The search term to filter video results by. */
  term?: InputMaybe<Scalars['String']>;
};

/** Video download information. */
export type VideoDownload = {
  __typename?: 'VideoDownload';
  /** Status of the download process. */
  status: VideoDownloadStatus;
  /** Generated URL from which to download the video. */
  url: Scalars['String'];
};

/** List of possible video download statuses. */
export enum VideoDownloadStatus {
  /** The video download is completed. */
  Complete = 'COMPLETE',
  /** The video download is created. */
  Created = 'CREATED',
  /** The video download is downloading. */
  Downloading = 'DOWNLOADING',
  /** The video download failed to create. */
  Failed = 'FAILED',
  /** The video download is submitted. */
  Submitted = 'SUBMITTED',
  /** The video download is transmuxing. */
  Transmuxing = 'TRANSMUXING',
  /** The video download status is unknown. */
  Unknown = 'UNKNOWN'
}

/** An element in a paginated list of videos, and its metadata. */
export type VideoEdge = {
  __typename?: 'VideoEdge';
  cursor?: Maybe<Scalars['Cursor']>;
  node?: Maybe<Video>;
};

/** Video Ingest Session Metadata for the current or past broadcasts. */
export type VideoIngestSession = {
  __typename?: 'VideoIngestSession';
  /** Stream session metadata related to broadcaster's backup ingest session. */
  backupIngestSession?: Maybe<BackupIngestSession>;
  /** Bitrates of session by time. Recorded every 3 to 5 seconds. */
  bitrates?: Maybe<Array<StreamBitrate>>;
  /** Broadcaster of the stream. */
  broadcaster?: Maybe<User>;
  /** Recorded framedrop events in stream session. */
  frameDrops?: Maybe<Array<IngestFrameDrop>>;
  /** Framerates of session by time. Recorded every 3 to 5 seconds. */
  framerates?: Maybe<Array<StreamFramerate>>;
  /** The ID of the stream ingest session. */
  id: Scalars['ID'];
  /** Stream session metadata related to broadcaster's ingest session. */
  ingestSession: IngestSession;
  /** Stream session metadata related to broadcaster's RTMP session. */
  rtmpSession: RtmpSession;
  /** Recorded starvation events in stream session. */
  starvationEvents?: Maybe<Array<IngestStarvationEvent>>;
  /** Set of codes to indicate what is wrong with ingested stream. */
  streamHealth?: Maybe<IngestStreamHealth>;
  /** Stream session metadata related to broadcaster's transcode session. */
  transcodeSessions?: Maybe<Array<TranscodeSession>>;
};


/** Video Ingest Session Metadata for the current or past broadcasts. */
export type VideoIngestSessionBitratesArgs = {
  endedAt?: InputMaybe<Scalars['Time']>;
  startedAt?: InputMaybe<Scalars['Time']>;
};


/** Video Ingest Session Metadata for the current or past broadcasts. */
export type VideoIngestSessionFrameratesArgs = {
  endedAt?: InputMaybe<Scalars['Time']>;
  startedAt?: InputMaybe<Scalars['Time']>;
};

/**
 * A video moment represents either a point in time, or a duration of time,
 * during which structured metadata is present.
 */
export type VideoMoment = {
  __typename?: 'VideoMoment';
  /** channel the VOD belongs to. */
  channel: User;
  /** Time at which the moment was created. */
  createdAt: Scalars['Time'];
  /**
   * The displayable context of this moment (translated, where applicable). For
   * instance, the stream marker comment, game name for game change, or “Pack opening”
   * for Hearthstone VCA. Can be null.
   */
  description?: Maybe<Scalars['String']>;
  /**
   * A union of the fields that are specific to individual moments, such as Game Mode
   * inside Hearthstone VCA data.
   */
  details?: Maybe<VideoMomentDetails>;
  /** The duration, in ms, that this moment is applicable, or zero if no duration. */
  durationMilliseconds: Scalars['Int'];
  /** ID of the moment. */
  id: Scalars['ID'];
  /** Moments that cover a time range can also contain moments for that time range. */
  moments?: Maybe<VideoMomentConnection>;
  /** The time, in ms, after the start of the video when this moment occurs. */
  positionMilliseconds: Scalars['Int'];
  /**
   * The additional displayable context of this moment (translated, where applicable).
   * Can be null.
   */
  subDescription?: Maybe<Scalars['String']>;
  /**
   * The url to the thumbnail for this moment.
   * Can be null.
   */
  thumbnailURL?: Maybe<Scalars['String']>;
  /** The underlying moment type. */
  type: VideoMomentType;
  /** The id of the video this moment is contained in. */
  video?: Maybe<Video>;
};

/** A paginated list of video moments. */
export type VideoMomentConnection = {
  __typename?: 'VideoMomentConnection';
  /** The elements of the paginated list. */
  edges: Array<VideoMomentEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/**
 * A union of the fields that are specific to individual moments, such as Game Mode
 * inside Hearthstone VCA data.
 */
export type VideoMomentDetails = GameChangeMomentDetails | HearthstoneMomentDetails | OverwatchMomentDetails | PubgMomentDetails;

/** A video moment. */
export type VideoMomentEdge = {
  __typename?: 'VideoMomentEdge';
  /** Uniquely identifies this moment's position in the connection. */
  cursor: Scalars['Cursor'];
  /** The moment. */
  node: VideoMoment;
};

/**
 * These request types allow the client to request the backend to do
 * some analysis and suggest markers that are relevant.
 */
export enum VideoMomentRequestType {
  /** Moments most likely to be highlighted. Shown to creators. */
  HighlighterSuggestions = 'HIGHLIGHTER_SUGGESTIONS',
  /** Chapter markers shown in the video to viewers. */
  VideoChapterMarkers = 'VIDEO_CHAPTER_MARKERS'
}

/** Marker types present in momentum. */
export enum VideoMomentType {
  /** GAME_CHANGE is when the streamer changes the game during their stream. */
  GameChange = 'GAME_CHANGE',
  /** Hearthstone video content analysis markers. */
  HearthstoneVca = 'HEARTHSTONE_VCA',
  /** Overwatch video content analysis markers. */
  OverwatchVca = 'OVERWATCH_VCA',
  /** PUBG video content analysis markers. */
  PubgVca = 'PUBG_VCA',
  /** Creator/editor selected moment. */
  StreamMarker = 'STREAM_MARKER',
  /** VCA generic VCA analysis markers. */
  Vca = 'VCA'
}

/** Details about automatic mutes applied to this video. */
export type VideoMuteInfo = {
  __typename?: 'VideoMuteInfo';
  /** List of segments muted. */
  mutedSegmentConnection?: Maybe<VideoMutedSegmentConnection>;
  /** List of tracks that are flagged for copyrighted music. */
  tracks?: Maybe<Array<FlaggedTrack>>;
};

/** Information about one contiguous muted portion of video. */
export type VideoMutedSegment = {
  __typename?: 'VideoMutedSegment';
  /** Duration in seconds of the mute. Standard length is 360 (6 mins). */
  duration: Scalars['Int'];
  /** Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted. */
  offset: Scalars['Int'];
};

/**
 * A list of all sections of the video that are muted.
 * If pagination is required at any point in the future, put edges and pageInfo
 * in this type.
 */
export type VideoMutedSegmentConnection = {
  __typename?: 'VideoMutedSegmentConnection';
  /** No pagination functionality. All data returned in initial call. */
  nodes?: Maybe<Array<VideoMutedSegment>>;
};

export type VideoOEmbed = OEmbed & {
  __typename?: 'VideoOEmbed';
  authorName?: Maybe<Scalars['String']>;
  authorURL?: Maybe<Scalars['String']>;
  cacheAge?: Maybe<Scalars['Int']>;
  height: Scalars['Int'];
  html: Scalars['String'];
  inputURL: Scalars['String'];
  providerName?: Maybe<Scalars['String']>;
  providerURL?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<ThumbnailOEmbed>;
  title?: Maybe<Scalars['String']>;
  type: Scalars['String'];
  version: Scalars['String'];
  width: Scalars['Int'];
};

/** Options to include private videos. */
export type VideoOptions = {
  includePrivate?: InputMaybe<Scalars['Boolean']>;
};

/** The required configuration to activate a video overlay extension. */
export type VideoOverlayActivationInput = {
  /** The slot name of where the component extension should be displayed. */
  slot: Scalars['String'];
};

/** VideoOverlayView holds the view configuration of an extension if the videoOverlay anchor is supported. */
export type VideoOverlayView = ExtensionView & {
  __typename?: 'VideoOverlayView';
  /** Specifies whether or not the extension has the ability to link to external websites. */
  canLinkExternalContent: Scalars['Boolean'];
  /** Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets. */
  viewerPath: Scalars['String'];
  /** The URL which should be loaded in for the extension. */
  viewerURL: Scalars['String'];
};

/** VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported. */
export type VideoOverlayViewInput = {
  /** Relative path of the HTML file to load for this view. */
  viewerPath: Scalars['String'];
};

/** Endpoints for different video referral sources, based on channel and time range. */
export type VideoPlayReferrals = {
  __typename?: 'VideoPlayReferrals';
  /** The referral groups and respective counts. */
  items?: Maybe<Array<AggregatedReferrals>>;
  /** Sum of all referrals for a given date range. */
  total: Scalars['Int'];
};

export enum VideoPrivacyScope {
  /** The video is only viewable by the owner. */
  Private = 'PRIVATE',
  /** The video is listed in search and anyone can view the video. */
  Public = 'PUBLIC'
}

/** Restrictions for viewing of a video. Resolves if a video is restricted, null otherwise. */
export type VideoRestriction = {
  __typename?: 'VideoRestriction';
  /** The product "short name" a user needs to purchase to view the video. */
  productName: Scalars['String'];
  /** The name of the product shown to users. */
  productTitle: Scalars['String'];
  /** The reason a video is restricted. */
  reason: Scalars['String'];
  /** The type of restriction the video has. */
  type: Scalars['String'];
};

/** The relationship between the authenticated user and a video. */
export type VideoSelfEdge = {
  __typename?: 'VideoSelfEdge';
  /** Can a user watch a restricted video. */
  isRestricted: Scalars['Boolean'];
  /** User's viewing history against a video. */
  viewingHistory?: Maybe<VideoViewingHistory>;
};

/** A video shelf contains items (clips, videos) from a user to display on their videos page. */
export type VideoShelf = {
  __typename?: 'VideoShelf';
  /** The associated collection if the shelf items are from a specified collection. */
  collection?: Maybe<Collection>;
  /** A description of what the video shelf contains. */
  description?: Maybe<Scalars['String']>;
  /** The associated game with the shelf if the items are from a specified game. */
  game?: Maybe<Game>;
  /** ID of the video shelf. */
  id: Scalars['ID'];
  /** Videos/clips in the video shelf. */
  items?: Maybe<Array<VideoShelfItem>>;
  /** The title of the video shelf. */
  title: Scalars['String'];
  /** The type of items the video shelf contains. */
  type: VideoShelfType;
};

/** A paginated list of video shelves with metadata. */
export type VideoShelfConnection = {
  __typename?: 'VideoShelfConnection';
  /** The list of video shelves available. */
  edges?: Maybe<Array<VideoShelfEdge>>;
  /** The max number of shelves configuration. */
  maxShelfCount?: Maybe<Scalars['Int']>;
  /** Information about this page of video shelves. */
  pageInfo: PageInfo;
  /** The total number of shelves available. */
  totalCount: Scalars['Int'];
};

/** A video shelf. */
export type VideoShelfEdge = {
  __typename?: 'VideoShelfEdge';
  /** Cursor represents the position of the current edge/node. */
  cursor: Scalars['Cursor'];
  /** Uniquely identifies this video shelf's position in a connection. */
  node?: Maybe<VideoShelf>;
};

/** The item to render in a video shelf. */
export type VideoShelfItem = Clip | Video;

/** The type of item returned in the video shelf. */
export enum VideoShelfType {
  /** All videos. */
  AllVideos = 'ALL_VIDEOS',
  /** Videos from a specified collection. */
  Collection = 'COLLECTION',
  /** Videos marked with a specified game sorted by recency. */
  Game = 'GAME',
  /** Broadcasts sorted by recency. */
  LatestBroadcasts = 'LATEST_BROADCASTS',
  /** Non broadcasts sorted by recency. */
  LatestNonBroadcasts = 'LATEST_NON_BROADCASTS',
  /** Videos over 30 minutes sorted by recency. */
  LongVideos = 'LONG_VIDEOS',
  /** Videos under 30 minutes sorted by recency. */
  ShortVideos = 'SHORT_VIDEOS',
  /** Clips created within 30 days sorted by views. */
  TopClips = 'TOP_CLIPS'
}

/** Possible sort orders for lists of videos. */
export enum VideoSort {
  /** Sort the videos descending by time (publishedAt if available or createdAt). */
  Time = 'TIME',
  /** Sort the videos ascending by time (publishedAt if available or createdAt). */
  TimeAsc = 'TIME_ASC',
  /** Sort the videos descending by views. */
  Views = 'VIEWS'
}

export enum VideoStatus {
  /** The upload job is ready to begin. */
  Created = 'CREATED',
  /** Something went wrong. */
  Failed = 'FAILED',
  /** The video is being transcoded. */
  PendingTranscode = 'PENDING_TRANSCODE',
  /** The video is ready to watch. */
  Recorded = 'RECORDED',
  /** The video is being recorded from a live broadcast. */
  Recording = 'RECORDING',
  /** The video is currently transcoding. */
  Transcoding = 'TRANSCODING',
  /** The video needs to be processed. */
  Unprocessed = 'UNPROCESSED',
  /** The video is being uploaded. */
  Uploading = 'UPLOADING'
}

/**
 * Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
 * Represents a user's channel setting when starting a streamm.
 */
export type VideoStreamSettings = {
  __typename?: 'VideoStreamSettings';
  /** A list of Twitch users who are authorized to stream on behalf of a broadcaster. */
  authorizedUsers?: Maybe<Array<User>>;
  /** A list of stream keys to be used for backup redundant stream. */
  backupStreamKeys: Array<StreamKeyResult>;
  /** The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds. */
  delaySeconds: Scalars['Int'];
  /** The number of seconds to display the disconnect slate while the stream is unstable. */
  disconnectSlateDurationSeconds: Scalars['Int'];
  /** When isBackupEnabled is true, streamers can stream a backup stream using the streamkey on backupStreamKeys. */
  isBackupEnabled: Scalars['Boolean'];
  /** When isDelayEnabled is true, streamers can stream with specified delay seconds on delaySeconds. */
  isDelayEnabled: Scalars['Boolean'];
  /** When isDisconnectSlateEnabled is true, streams will show a disconnect slate for the period specified on delaySeconds when a stream disconnects temporarily. */
  isDisconnectSlateEnabled: Scalars['Boolean'];
  /** Whether or not a stream should be started as a low latency stream. */
  isLowLatency: Scalars['Boolean'];
  /** Whether or not the broadcaster prefers to archive the vod for a stream. */
  shouldArchiveVODs: Scalars['Boolean'];
  /** The RTMP stream key for the user's channel. This key is required to stream a video to Twitch. */
  streamKey: StreamKeyResult;
};

/** Details about creating an automated highlight from this video. */
export type VideoSuggestedHighlight = {
  __typename?: 'VideoSuggestedHighlight';
  /** Boolean for whether this set of suggested segments were addressed and dismissed. */
  isDismissed: Scalars['Boolean'];
  /** List of suggested video segments. */
  segments: Array<Maybe<VideoSuggestedSegment>>;
  /** Status of the segments. */
  status?: Maybe<SegmentsStatusType>;
};

/** Information for one suggested video segment. */
export type VideoSuggestedSegment = {
  __typename?: 'VideoSuggestedSegment';
  /** Ending time of the suggested segment in milliseconds. */
  endMS: Scalars['Int'];
  /** Starting time of the suggested segment in milliseconds. */
  startMS: Scalars['Int'];
};

/** Filtering criteria for paginated video top clips results. */
export type VideoTopClipsInput = {
  /** The ID of the curator to filter results by. */
  curatorID?: InputMaybe<Scalars['ID']>;
  /** The time period to restrict clips based on creation time. */
  period?: InputMaybe<ClipsPeriod>;
  /** The sort order for the clips results. */
  sort?: InputMaybe<ClipsSort>;
};

/**
 * Describes what type of content this originated from.
 * NOTE: There is already an enum named BroadcastType which should have been named VideoBroadcastType.
 */
export enum VideoType {
  /** The video type is live. */
  Live = 'LIVE',
  /** The video is a vod. */
  Vod = 'VOD'
}

/** User's viewing history against a video. All fields are null if no viewing history is available. */
export type VideoViewingHistory = {
  __typename?: 'VideoViewingHistory';
  /** Position in seconds since the start of the video. */
  position?: Maybe<Scalars['Int']>;
  /** When the viewing history was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

export type ViewedNotificationsPayload = {
  __typename?: 'ViewedNotificationsPayload';
  /** The modified user which contains an updated OnsiteNotificationsSummary. */
  user?: Maybe<User>;
};

/** A paginated list of viewed videos, their histories, and metadata. */
export type ViewedVideosConnection = {
  __typename?: 'ViewedVideosConnection';
  /** The list of videos and their viewing histories in this page. */
  edges?: Maybe<Array<Maybe<ViewedVideosEdge>>>;
};

/** An element in a paginated list of viewing histories, and its metadata. */
export type ViewedVideosEdge = {
  __typename?: 'ViewedVideosEdge';
  /** Viewing history of user against the video. */
  history: VideoViewingHistory;
  /** Video this viewing history belongs to. */
  node: Video;
};

/**
 * The user's shared availability while online.
 * A value of ONLINE (typically called invisibility) additionally means that the user's activity will not be shared
 * regardless of the isSharingActivity setting.
 * NOTE: Should have been named UserOnlineVisibility.
 */
export enum Visibility {
  Away = 'AWAY',
  Busy = 'BUSY',
  Offline = 'OFFLINE',
  Online = 'ONLINE'
}

/** A visibility type for the user. */
export enum VisibilityInput {
  /**
   * An AWAY visibility will cause the user to appear as Away if they have any sessions, regardless of idleness, or
   * Offline if they have no sessions.
   */
  Away = 'AWAY',
  /**
   * A BUSY visibility will cause the user to appear as Busy if they have any sessions, regardless of idleness, or
   * Offline if they have no sessions.
   */
  Busy = 'BUSY',
  /**
   * An OFFLINE visibility (also called "invisible") will cause the user to appear as Offline always. It will also
   * implicitly turn off activity sharing.
   */
  Offline = 'OFFLINE',
  /**
   * An ONLINE visibility (default) will cause the user's availability to be inherited from their sessions -- Online if
   * they have at least one non-idle session, Away if they have only idle sessions, or Offline if they have no sessions.
   */
  Online = 'ONLINE'
}

/** Input for Visit Stream Manager. */
export type VisitStreamManagerInput = {
  /** The channel ID of the stream manager visited. */
  channelID: Scalars['ID'];
};

/** Payload returned from Visit Stream Manager call. */
export type VisitStreamManagerPayload = {
  __typename?: 'VisitStreamManagerPayload';
  /** The channel ID of the stream manager visited. */
  channelID?: Maybe<Scalars['ID']>;
  /** The success/failure of the client. */
  isSuccess?: Maybe<Scalars['Boolean']>;
  /** The viewer ID trying to view the stream manager. */
  viewerID?: Maybe<Scalars['ID']>;
};

/** Vote in poll error. */
export type VoteInAdPollError = {
  __typename?: 'VoteInAdPollError';
  /** Code describing the error. */
  code: VoteInAdPollErrorCode;
};

/** Vote in poll error code. */
export enum VoteInAdPollErrorCode {
  /** Request is for a choice ID that invalid. */
  InvalidChoiceId = 'INVALID_CHOICE_ID',
  /** Voter is trying to vote more times than the maximum number of times that the poll allows. */
  MaxVoteLimitError = 'MAX_VOTE_LIMIT_ERROR',
  /** User is trying to vote for another choice in a poll that only allows one choice. */
  MultiChoiceVoteForbidden = 'MULTI_CHOICE_VOTE_FORBIDDEN',
  /** User tried to vote in a poll that is not active. */
  PollNotActive = 'POLL_NOT_ACTIVE',
  /** User tried to vote in a poll that doesn't exist i.e. there is no poll running at all). */
  PollNotFound = 'POLL_NOT_FOUND',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** Request has a vote ID that is in progress or has already been submitted. */
  VoteIdConflict = 'VOTE_ID_CONFLICT'
}

/** Inputs for voting on an ad poll. */
export type VoteInAdPollInput = {
  /** The id of the choice the vote is casted on in the poll. */
  choiceID: Scalars['ID'];
  /** The id of the poll that is being voted in. */
  pollID: Scalars['ID'];
  /** The voter id of the voter. */
  userID: Scalars['ID'];
  /** The unique id for this vote action. */
  voteID: Scalars['ID'];
};

/** Output from the vote on poll mutation. */
export type VoteInAdPollPayload = {
  __typename?: 'VoteInAdPollPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<VoteInAdPollError>;
  /** The voter objet returned by the vote operation. */
  vote?: Maybe<AdPollVote>;
};

/**
 * Inputs for voting on a poll by choice index.
 * Poll id and choice id are retrieved from the backend, before sending the vote.
 */
export type VoteInPollByChoiceIndexInput = {
  /** The id of the channel the vote is being cast in. */
  channelID: Scalars['ID'];
  /** Important: The ***ONE INDEXED*** (NOT ZERO INDEXED) position of the choice that is chosen in the poll. */
  choiceIndex: Scalars['Int'];
  /** The tokens used for this vote. */
  tokens?: InputMaybe<PollVoteTokensInput>;
  /** The user id of the voter. */
  userID: Scalars['ID'];
  /** The unique id for this vote action. */
  voteID: Scalars['ID'];
};

/** Output from the vote on poll by choice index mutation. */
export type VoteInPollByChoiceIndexPayload = {
  __typename?: 'VoteInPollByChoiceIndexPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<VoteInPollError>;
  /** The voter objet returned by the vote operation. */
  voter?: Maybe<PollVoter>;
};

/** Vote in poll error. */
export type VoteInPollError = {
  __typename?: 'VoteInPollError';
  /** Code describing the error. */
  code: VoteInPollErrorCode;
};

/** Vote in poll error code. */
export enum VoteInPollErrorCode {
  /** User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100). */
  InsufficientBitsBalance = 'INSUFFICIENT_BITS_BALANCE',
  /** Users's Community Points balance is too low to perform request (e.g. they only have 10 points and they request to spend 100). */
  InsufficientCommunityPointsBalance = 'INSUFFICIENT_COMMUNITY_POINTS_BALANCE',
  /** Request is for an invalid bits amount (e.g. -100 bits, or request is not for a multiple of the Bits cost). */
  InvalidBitsAmount = 'INVALID_BITS_AMOUNT',
  /** Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist). */
  InvalidChannelId = 'INVALID_CHANNEL_ID',
  /** Request is for a choice ID that invalid. */
  InvalidChoiceId = 'INVALID_CHOICE_ID',
  /** Request is for a choice index that is invalid (e.g. there are 3 choices and the request is for index 10). */
  InvalidChoiceIndex = 'INVALID_CHOICE_INDEX',
  /** Request is for an invalid Community Points amount (e.g. -100 Points, or request is not for a multiple of the Points cost). */
  InvalidCommunityPointsAmount = 'INVALID_COMMUNITY_POINTS_AMOUNT',
  /** User is trying to vote for another choice in a poll that only allows one choice. */
  MultiChoiceVoteForbidden = 'MULTI_CHOICE_VOTE_FORBIDDEN',
  /** User tried to vote in a poll that is not active. */
  PollNotActive = 'POLL_NOT_ACTIVE',
  /** User tried to vote in a poll that doesn't exist i.e. there is no poll running at all). */
  PollNotFound = 'POLL_NOT_FOUND',
  /** User cannot vote because they have hit a per-user or per-poll rate limit. The user can try again later. */
  RateLimited = 'RATE_LIMITED',
  /** User is not allowed to vote in their own poll with bits. */
  SelfBitsVoteNotAllowed = 'SELF_BITS_VOTE_NOT_ALLOWED',
  /** User has already used their base votes, so in order to continue voting, they must use tokens (bits or channel points). */
  TokensRequired = 'TOKENS_REQUIRED',
  /** An unknown error occurred. */
  Unknown = 'UNKNOWN',
  /** User is not allowed to vote in poll (e.g. they're banned in the channel). */
  UserForbidden = 'USER_FORBIDDEN',
  /** Request has a vote ID that is in progress or has already been submitted. */
  VoteIdConflict = 'VOTE_ID_CONFLICT'
}

/** Inputs for voting on a poll. */
export type VoteInPollInput = {
  /** The id of the choice the vote is casted on in the poll. */
  choiceID: Scalars['ID'];
  /** The id of the poll that is being voted in. */
  pollID: Scalars['ID'];
  /** The tokens used for this vote. */
  tokens?: InputMaybe<PollVoteTokensInput>;
  /** The user id of the voter. */
  userID: Scalars['ID'];
  /** The unique id for this vote action. */
  voteID: Scalars['ID'];
};

/** Output from the vote on poll mutation. */
export type VoteInPollPayload = {
  __typename?: 'VoteInPollPayload';
  /** If present, there was an error with the request. */
  error?: Maybe<VoteInPollError>;
  /** The voter object returned by the vote operation. */
  voter?: Maybe<PollVoter>;
};

/**
 * Twitch Wallet Balances in multiple FIAT currencies. Can be used to purchase
 * product on the Twitch Platform.
 */
export type WalletBalances = {
  __typename?: 'WalletBalances';
  /** List of all Balances that a Twitch User has on their account. */
  allBalances?: Maybe<Array<Balance>>;
  /** Currencies that an Twitch User is currently eligible to use. */
  eligibleCurrencies?: Maybe<Array<Currency>>;
};

/**
 * User's can have different wallet types based on legal and accounting
 * requirements.
 */
export enum WalletType {
  /** Only supports loading from FIAT currencies from gift card providers. */
  GiftCard = 'GIFT_CARD'
}

/** The possible restrictions for a user trying to host Watch Parties. */
export enum WatchPartiesRestriction {
  /** A user cannot host Watch Parties in their current region. */
  RegionNotSupported = 'REGION_NOT_SUPPORTED',
  /** Unknown restriction. */
  Unknown = 'UNKNOWN'
}

/** Contains all information for Prime Video Watch Parties. */
export type WatchParty = {
  __typename?: 'WatchParty';
  /** Enum representing the restrictions on this Watch Party. */
  contentRestriction: WatchPartyContentRestriction;
  /** Option Watch Party decoration. */
  decoration?: Maybe<WatchPartyDecoration>;
  /**
   * The catalog item id played for this watch party.
   * @deprecated Use decoration.item.id
   */
  gti: Scalars['ID'];
  /** Unique ID of the watch party. */
  id: Scalars['ID'];
  /** Progress of the current state, null for offline watch parties. */
  progress?: Maybe<WatchPartyProgress>;
  /** Current state of the watch party. */
  state: WatchPartyState;
  /** Current title of the watch party. */
  title: Scalars['String'];
  /** CCVs for the watch party. */
  viewersCount: Scalars['Int'];
};

/** Restrictions on a piece of content. */
export enum WatchPartyContentRestriction {
  /** Content is viewable by majority regions. */
  BroadAvailability = 'BROAD_AVAILABILITY',
  /** Content is viewable in a select number of regions. */
  LimitedAvailability = 'LIMITED_AVAILABILITY',
  /** Default type. */
  Unknown = 'UNKNOWN'
}

/** Decoration information for a Watch Party. */
export type WatchPartyDecoration = {
  __typename?: 'WatchPartyDecoration';
  /** Fully decorated item for a watch party. */
  item: WatchPartyItem;
  /** Authenticated: filled in only if the user is authorized to watch the content. */
  player?: Maybe<WatchPartyPlayer>;
};

/** Information to communicate to the user about an error state. */
export type WatchPartyError = {
  __typename?: 'WatchPartyError';
  /** Error code. */
  code: WatchPartyErrorCode;
};

/** Enum for user errors. */
export enum WatchPartyErrorCode {
  /** Used for invalid requests. */
  BadRequest = 'BAD_REQUEST',
  /** Used when the access token is expired. */
  Forbidden = 'FORBIDDEN',
  /** Used when the user is geo restricted. */
  GeoRestricted = 'GEO_RESTRICTED',
  /** Used when the user's request is throttled. */
  RequestThrottled = 'REQUEST_THROTTLED',
  /** Used when the error is unknown. */
  Unknown = 'UNKNOWN'
}

/** Contains all fields needed to render a watch party item. */
export type WatchPartyItem = {
  __typename?: 'WatchPartyItem';
  /** String representing the age rating. */
  contentRating?: Maybe<Scalars['String']>;
  /**
   * Enum representing the restrictions on this item. When available, defer to
   * the Watch Party content restriction.
   */
  contentRestriction: WatchPartyContentRestriction;
  /** Additional details based on the item type. */
  details?: Maybe<WatchPartyItemDetails>;
  /** List of genres. */
  genres: Array<Scalars['String']>;
  /** Whether or not this item has children content. */
  hasChildren: Scalars['Boolean'];
  /** Unique GTI. */
  id: Scalars['ID'];
  /** If the content is mature. */
  isMature: Scalars['Boolean'];
  /** Whether the content has parental control restrictions enabled. */
  isParentalControlRestricted?: Maybe<Scalars['Boolean']>;
  /** If this is a child, ID of the parent. */
  parentID?: Maybe<Scalars['ID']>;
  /** Link to continue watching on PV. */
  primeVideoLink?: Maybe<Scalars['String']>;
  /** Prime video rating. */
  primeVideoRating?: Maybe<PrimeVideoRating>;
  /** Null if user is logged out, contains eligibility information. */
  self?: Maybe<WatchPartyItemSelfEdge>;
  /** List of actors and actresses. */
  starring: Array<Scalars['String']>;
  /** Localized summary. */
  summary?: Maybe<Scalars['String']>;
  /** Localized box art. */
  thumbnailURL: Scalars['String'];
  /** Localized title. */
  title: Scalars['String'];
  /** Video content type, i.e. episode or series. */
  type: WatchPartyItemType;
  /** Publication year. */
  yearPublished?: Maybe<Scalars['Int']>;
};

/** Watch party items, returned in a query. */
export type WatchPartyItemConnection = {
  __typename?: 'WatchPartyItemConnection';
  /** One item per edge. */
  edges: Array<WatchPartyItemEdge>;
  /** Used for user authentication errors. */
  error?: Maybe<WatchPartyError>;
  /** Amazon link. */
  homepageBrowseLink: Scalars['String'];
  /** Pagination info. */
  pageInfo: PageInfo;
};

/** Additional information about content. */
export type WatchPartyItemDetails = EpisodeDetails | MovieDetails | SeasonDetails | SeriesDetails;

/** Represents a single item for a watch party. */
export type WatchPartyItemEdge = {
  __typename?: 'WatchPartyItemEdge';
  /** Cursor to continue querying from here. */
  cursor: Scalars['Cursor'];
  /** Item information. */
  node: WatchPartyItem;
};

/** Contains information about viewer eligibility, likely to change. */
export type WatchPartyItemEligibility = {
  __typename?: 'WatchPartyItemEligibility';
  /** Whether the viewer can watch this content. */
  canView: Scalars['Boolean'];
  /** Localized string explaining why if canView is false. */
  reason?: Maybe<Scalars['String']>;
};

/**
 * Options for querying for catalog items. These fields are mutually exclusive
 * and parentID will take precedent if both are specified.
 */
export type WatchPartyItemSearchOptions = {
  /** Parameter to query for a parent's children items. */
  parentID?: InputMaybe<Scalars['ID']>;
  /** Search for content based on the input string. */
  searchQuery?: InputMaybe<Scalars['String']>;
};

/** Used for upselling Prime, populated from authentication or geotoken. */
export type WatchPartyItemSelfEdge = {
  __typename?: 'WatchPartyItemSelfEdge';
  /** Info about whether or not the user can view this piece of content. */
  eligibility: WatchPartyItemEligibility;
  /** True if the content is PV gated and we will upsell. */
  willShowPrimeUpsell: Scalars['Boolean'];
};

/** Content types for Prime Video. */
export enum WatchPartyItemType {
  /** A leaf node episode in a series/season. */
  Episode = 'EPISODE',
  /** A leaf node movie. */
  Movie = 'MOVIE',
  /** Usually a collection of episodes. */
  Season = 'SEASON',
  /** Usually a collection of seasons. */
  Series = 'SERIES',
  /** Default type. */
  Unknown = 'UNKNOWN'
}

/** Contains information needed to initialize a PV player and play content. */
export type WatchPartyPlayer = {
  __typename?: 'WatchPartyPlayer';
  /** Device Proxy URL to initialize the PV player. */
  deviceProxyBaseURL: Scalars['String'];
  /** Parameters to initialize the PV player. */
  sdkInit: Scalars['String'];
  /** Token to initialize the PV player. */
  token: Scalars['String'];
};

/** Tracks the current state. */
export type WatchPartyProgress = {
  __typename?: 'WatchPartyProgress';
  /** Total duration of the current state. */
  durationSeconds: Scalars['Int'];
  /** Current position in seconds of the state. */
  positionSeconds: Scalars['Int'];
  /** Wall clock time for the start of the current state. */
  start: Scalars['Time'];
};

/** Wrapper to allow passing back errors. */
export type WatchPartyResult = {
  __typename?: 'WatchPartyResult';
  /** Used for user authentication errors. */
  error?: Maybe<WatchPartyError>;
  /** Can be null if the channel is offline or for authentication errors. */
  session?: Maybe<WatchParty>;
};

/** Enum for state. */
export enum WatchPartyState {
  /** Pre-play countdown. */
  HypeIn = 'HYPE_IN',
  /** In progress, video playback. */
  InProgress = 'IN_PROGRESS',
  /** Offline. */
  Offline = 'OFFLINE',
  /** Default value. */
  Unknown = 'UNKNOWN'
}

export type Watching = Activity & {
  __typename?: 'Watching';
  /** This activity's type, i.e. "WATCHING". */
  type?: Maybe<ActivityType>;
  /** The user whose stream is being watched. */
  user?: Maybe<User>;
};

/** A message sent in a whisper thread. */
export type WhisperMessage = {
  __typename?: 'WhisperMessage';
  /** Content of the message. */
  content: MessageBody;
  /** Time the message was deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** Time the message was edited. */
  editedAt?: Maybe<Scalars['Time']>;
  /** User that sent the message. */
  from: User;
  /** UUID of the message. */
  id: Scalars['ID'];
  /** Unique nonce. */
  nonce?: Maybe<Scalars['String']>;
  /** Time the message was sent. */
  sentAt: Scalars['Time'];
  /** The thread the message is a part of. */
  thread: WhisperThread;
};

/** Paginated list of messages in a thread. */
export type WhisperMessageConnection = {
  __typename?: 'WhisperMessageConnection';
  /** The elements of the list. */
  edges: Array<WhisperMessageEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
};

/** Element in a list of messages. */
export type WhisperMessageEdge = {
  __typename?: 'WhisperMessageEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The whisper message. */
  node: WhisperMessage;
};

/** An enumeration of the permissions for one user to Whisper another. */
export enum WhisperPermissionType {
  /** The sender is not allowed to Whisper the recipient. */
  NotPermitted = 'NOT_PERMITTED',
  /** Any sender is able to Whisper the recipient. */
  NotRestricted = 'NOT_RESTRICTED',
  /** The sender is allowed to Whisper the recipient. */
  Permitted = 'PERMITTED',
  /** The sender is temporarily allowed to Whisper the recipient. */
  Temporary = 'TEMPORARY'
}

/** The ability for a Twitch user to send or receive Whispers to/from another Twitch user. */
export type WhisperPermissions = {
  __typename?: 'WhisperPermissions';
  /** If send is NOT_PERMITTED, true if the reason is that the other Twitch user is considered a stranger. */
  isStrangerBlocked: Scalars['Boolean'];
  /** Capability of the user to receive Whispers from the other Twitch user. */
  receive?: Maybe<WhisperPermissionType>;
  /** Capability of the user to send Whispers to the other Twitch user. */
  send?: Maybe<WhisperPermissionType>;
};

/** Settings related to the Whispers (private user-to-user messaging) feature. */
export type WhisperSettings = {
  __typename?: 'WhisperSettings';
  /** If true, disallows strangers from initiating a whisper thread to this user. */
  isBlockingWhispersFromStrangers: Scalars['Boolean'];
  /** If true, this user is disallowed from sending or receiving whisper messages. */
  isWhisperBanned: Scalars['Boolean'];
};

/** Spam classification data for a message. */
export type WhisperSpamInfo = {
  __typename?: 'WhisperSpamInfo';
  /** Time user last marked the thread as not spam. */
  lastMarkedNotSpamAt?: Maybe<Scalars['Time']>;
  /** Spam classification score. */
  likelihood?: Maybe<WhisperSpamLikelihood>;
};

export enum WhisperSpamLikelihood {
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

/** A conversation between two users. */
export type WhisperThread = {
  __typename?: 'WhisperThread';
  /** ID of the whisper thread. */
  id: Scalars['ID'];
  /** Whether the thread has been archived. */
  isArchived: Scalars['Boolean'];
  /** Whether the user has muted the thread. */
  isMuted: Scalars['Boolean'];
  /** The last message sent in this thread. Null if no messages in this thread. */
  lastMessage?: Maybe<WhisperMessage>;
  /** List of messages in the thread. */
  messages?: Maybe<WhisperMessageConnection>;
  /** List of users in the thread. */
  participants: Array<Maybe<User>>;
  /** Spam data about the thread. */
  spamInfo?: Maybe<WhisperSpamInfo>;
  /** Number of whispers that have not been read by the user in the thread. */
  unreadMessagesCount: Scalars['Int'];
  /**
   * Last message read by the user in the thread.
   * @deprecated Not used. Use lastMessage to get the last message.
   */
  userLastMessageRead?: Maybe<WhisperMessage>;
  /** Timestamp of when the other participant may message the user in the thread. */
  whitelistedUntil?: Maybe<Scalars['Time']>;
};


/** A conversation between two users. */
export type WhisperThreadMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};

/** Paginated list of whisper threads. */
export type WhisperThreadConnection = {
  __typename?: 'WhisperThreadConnection';
  /** The elements of the list. */
  edges: Array<WhisperThreadEdge>;
  /** Information about this page. */
  pageInfo: PageInfo;
  /** Total number of whisper threads. */
  totalCount: Scalars['Int'];
  /** Total number of whisper threads containing unread messages for the current user. */
  totalUnreadCount?: Maybe<Scalars['Int']>;
};

/** Element in a list of whisper threads. */
export type WhisperThreadEdge = {
  __typename?: 'WhisperThreadEdge';
  /** Opaque cursor describing this edge's position in the paginated list. */
  cursor: Scalars['Cursor'];
  /** The whisper thread. */
  node: WhisperThread;
};

/** Withholding Tax Detail is the withholding tax rates for the creator. */
export type WithholdingTaxDetail = {
  __typename?: 'WithholdingTaxDetail';
  /** Government royalty tax rate applied to user's earnings. */
  royaltyTaxRate: Scalars['Float'];
  /** Government service tax rate applied to user's earnings. */
  serviceTaxRate: Scalars['Float'];
};

/** Contains configuration used to setup checkout via Xsolla, a payment provider. */
export type Xsolla = {
  __typename?: 'Xsolla';
  /**
   * Iframe URL to allow purchase checkout. This can be an empty string if the URL cannot be generated.
   * @deprecated moving iframe URL generation client-side
   */
  iframeURL: Scalars['String'];
  /** Indicates if the token is for Xsolla's sandbox environment. */
  isSandbox: Scalars['Boolean'];
  /** Access token to allow purchase checkout. This can be an empty string if the token cannot be generated. */
  token: Scalars['String'];
};

export type XsollaConfigs = {
  __typename?: 'XsollaConfigs';
  /**
   * Iframe URL to allow payment method management or purchase checkout
   * There are various cases in which this can be null. One example during
   * subscription purchase checkout flow is if there is an issue with the
   * Xsolla product mapping to the product in Twitch's system.
   * @deprecated Moving iframe URL generation to Twilight
   */
  iframeURL: Scalars['String'];
  /** Indicates if the token is for Xsolla's sandbox environment. */
  isSandbox: Scalars['Boolean'];
  /** Access token to allow purchase checkout. This can be an empty string if the token cannot be generated. */
  token: Scalars['String'];
};

export type ZuoraConfigs = {
  __typename?: 'ZuoraConfigs';
  /** Twitch merchant account ID on Zuora. */
  externalAccountID: Scalars['ID'];
  /** ID of the hosted page we will render. */
  hostedPageID: Scalars['ID'];
  /** URL of the hosted page we will render. */
  hostedPageURL: Scalars['String'];
  /** Used to encrypt sensitive information. */
  publicKey: Scalars['String'];
  /** Need to pass generated signature to access Zuora payment pages. */
  signature: Scalars['String'];
  /** In some cases, when you contact Zuora Support with an issue, the person helping you may ask you to provide the tenant ID. */
  tenantID: Scalars['ID'];
  /** Zuora API uses token as part of authentication. */
  token: Scalars['String'];
};

export type GetRecommendedStreamsQueryVariables = Exact<{
  random: Scalars['ID'];
  limit?: InputMaybe<Scalars['Int']>;
}>;


export type GetRecommendedStreamsQuery = { __typename?: 'Query', personalSections?: Array<{ __typename?: 'PersonalSection', items?: Array<{ __typename?: 'PersonalSectionChannel', user?: { __typename?: 'User', id: string, stream?: { __typename?: 'Stream', broadcastLanguage?: Language | null, createdAt?: any | null, viewersCount?: number | null, previewImageURL?: string | null, broadcaster?: { __typename?: 'User', id: string, login: string, displayName: string, roles?: { __typename?: 'UserRoles', isPartner?: boolean | null } | null, broadcastSettings?: { __typename?: 'BroadcastSettings', title: string, game?: { __typename?: 'Game', displayName: string } | null } | null } | null, playbackAccessToken?: { __typename?: 'PlaybackAccessToken', signature: string, value: string } | null } | null } | null }> | null }> | null, recommendedStreams?: { __typename?: 'RecommendedStreamsConnection', edges?: Array<{ __typename?: 'RecommendedStreamsEdge', node?: { __typename?: 'Stream', broadcaster?: { __typename?: 'User', id: string, stream?: { __typename?: 'Stream', broadcastLanguage?: Language | null, createdAt?: any | null, viewersCount?: number | null, previewImageURL?: string | null, broadcaster?: { __typename?: 'User', id: string, login: string, displayName: string, roles?: { __typename?: 'UserRoles', isPartner?: boolean | null } | null, broadcastSettings?: { __typename?: 'BroadcastSettings', title: string, game?: { __typename?: 'Game', displayName: string } | null } | null } | null, playbackAccessToken?: { __typename?: 'PlaybackAccessToken', signature: string, value: string } | null } | null } | null } | null }> | null } | null };

export type GetUserQueryVariables = Exact<{
  login: Scalars['String'];
}>;


export type GetUserQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: string, stream?: { __typename?: 'Stream', broadcastLanguage?: Language | null, createdAt?: any | null, viewersCount?: number | null, previewImageURL?: string | null, broadcaster?: { __typename?: 'User', id: string, login: string, displayName: string, roles?: { __typename?: 'UserRoles', isPartner?: boolean | null } | null, broadcastSettings?: { __typename?: 'BroadcastSettings', title: string, game?: { __typename?: 'Game', displayName: string } | null } | null } | null, playbackAccessToken?: { __typename?: 'PlaybackAccessToken', signature: string, value: string } | null } | null } | null };

export type GetBadgesQueryVariables = Exact<{
  login: Scalars['String'];
}>;


export type GetBadgesQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: string, broadcastBadges?: Array<{ __typename?: 'Badge', imageURL: string, setID: string, version: string } | null> | null } | null, badges?: Array<{ __typename?: 'Badge', imageURL: string, setID: string, version: string } | null> | null };

export type PersonalSectionChannelePartsFragment = { __typename?: 'PersonalSectionChannel', user?: { __typename?: 'User', id: string, stream?: { __typename?: 'Stream', broadcastLanguage?: Language | null, createdAt?: any | null, viewersCount?: number | null, previewImageURL?: string | null, broadcaster?: { __typename?: 'User', id: string, login: string, displayName: string, roles?: { __typename?: 'UserRoles', isPartner?: boolean | null } | null, broadcastSettings?: { __typename?: 'BroadcastSettings', title: string, game?: { __typename?: 'Game', displayName: string } | null } | null } | null, playbackAccessToken?: { __typename?: 'PlaybackAccessToken', signature: string, value: string } | null } | null } | null };

export type UserPartsFragment = { __typename?: 'User', id: string, stream?: { __typename?: 'Stream', broadcastLanguage?: Language | null, createdAt?: any | null, viewersCount?: number | null, previewImageURL?: string | null, broadcaster?: { __typename?: 'User', id: string, login: string, displayName: string, roles?: { __typename?: 'UserRoles', isPartner?: boolean | null } | null, broadcastSettings?: { __typename?: 'BroadcastSettings', title: string, game?: { __typename?: 'Game', displayName: string } | null } | null } | null, playbackAccessToken?: { __typename?: 'PlaybackAccessToken', signature: string, value: string } | null } | null };

export const UserPartsFragmentDoc = gql`
    fragment UserParts on User {
  id
  stream {
    broadcaster {
      id
      login
      displayName
      roles {
        isPartner
      }
      broadcastSettings {
        title
        game {
          displayName
        }
      }
    }
    broadcastLanguage
    createdAt
    viewersCount
    previewImageURL
    playbackAccessToken(params: {platform: "web", playerType: "site"}) {
      signature
      value
    }
  }
}
    `;
export const PersonalSectionChannelePartsFragmentDoc = gql`
    fragment PersonalSectionChanneleParts on PersonalSectionChannel {
  user {
    ...UserParts
  }
}
    ${UserPartsFragmentDoc}`;
export const GetRecommendedStreamsDocument = gql`
    query GetRecommendedStreams($random: ID!, $limit: Int = 50) {
  personalSections(input: {sectionInputs: [FOLLOWED_SECTION]}) {
    items {
      ...PersonalSectionChanneleParts
    }
  }
  recommendedStreams(
    recRequestID: $random
    location: "LEFT_NAV"
    first: $limit
    context: {}
  ) {
    edges {
      node {
        broadcaster {
          ...UserParts
        }
      }
    }
  }
}
    ${PersonalSectionChannelePartsFragmentDoc}
${UserPartsFragmentDoc}`;

/**
 * __useGetRecommendedStreamsQuery__
 *
 * To run a query within a React component, call `useGetRecommendedStreamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRecommendedStreamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRecommendedStreamsQuery({
 *   variables: {
 *      random: // value for 'random'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetRecommendedStreamsQuery(baseOptions: Apollo.QueryHookOptions<GetRecommendedStreamsQuery, GetRecommendedStreamsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRecommendedStreamsQuery, GetRecommendedStreamsQueryVariables>(GetRecommendedStreamsDocument, options);
      }
export function useGetRecommendedStreamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRecommendedStreamsQuery, GetRecommendedStreamsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRecommendedStreamsQuery, GetRecommendedStreamsQueryVariables>(GetRecommendedStreamsDocument, options);
        }
export type GetRecommendedStreamsQueryHookResult = ReturnType<typeof useGetRecommendedStreamsQuery>;
export type GetRecommendedStreamsLazyQueryHookResult = ReturnType<typeof useGetRecommendedStreamsLazyQuery>;
export type GetRecommendedStreamsQueryResult = Apollo.QueryResult<GetRecommendedStreamsQuery, GetRecommendedStreamsQueryVariables>;
export const GetUserDocument = gql`
    query GetUser($login: String!) {
  user(login: $login) {
    ...UserParts
  }
}
    ${UserPartsFragmentDoc}`;

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      login: // value for 'login'
 *   },
 * });
 */
export function useGetUserQuery(baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, options);
      }
export function useGetUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, options);
        }
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>;
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>;
export type GetUserQueryResult = Apollo.QueryResult<GetUserQuery, GetUserQueryVariables>;
export const GetBadgesDocument = gql`
    query GetBadges($login: String!) {
  user(login: $login) {
    id
    broadcastBadges {
      imageURL
      setID
      version
    }
  }
  badges {
    imageURL
    setID
    version
  }
}
    `;

/**
 * __useGetBadgesQuery__
 *
 * To run a query within a React component, call `useGetBadgesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBadgesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBadgesQuery({
 *   variables: {
 *      login: // value for 'login'
 *   },
 * });
 */
export function useGetBadgesQuery(baseOptions: Apollo.QueryHookOptions<GetBadgesQuery, GetBadgesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBadgesQuery, GetBadgesQueryVariables>(GetBadgesDocument, options);
      }
export function useGetBadgesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBadgesQuery, GetBadgesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBadgesQuery, GetBadgesQueryVariables>(GetBadgesDocument, options);
        }
export type GetBadgesQueryHookResult = ReturnType<typeof useGetBadgesQuery>;
export type GetBadgesLazyQueryHookResult = ReturnType<typeof useGetBadgesLazyQuery>;
export type GetBadgesQueryResult = Apollo.QueryResult<GetBadgesQuery, GetBadgesQueryVariables>;